/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/
  /*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2001
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 * L4C_NW_CMD.C
 *
 * Project:
 * --------
 *   MT6208
 *
 * Description:
 * ------------
 *   This file is intends for ï¿½K.
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/********************************************************************************
*  Copyright Statement:
*  --------------------
*
*  This product has been developed using a protocol stack
*  developed by Sasken Communication Technologies Limited.
*
********************************************************************************/

#define L4C_NW_CMD_C
#ifdef __MOD_RAC__
//#include "kal_non_specific_general_types.h"
//#include "kal_release.h"        /* Basic data type */
//#include "stack_common.h"
#include "kal_public_defs.h" //MSBB change #include "stack_msgs.h"
//#include "stack_ltlcom.h" /* Task message communiction */
//#include "stacklib.h"   /* Basic type for dll, evshed, stacktimer */
//#include "app_buff_alloc.h"     /* Declaration of buffer management API */
//#include "stack_timer.h"
//#include "event_shed.h"
//#include "stack_ltlcom.h"
//#include "ps_trace.h"
#include "kal_trace.h"
//mtk01616_070707
//#include "nvram_editor_data_item.h"
//#include "custom_nvram_editor_data_item.h"

#ifdef __MOD_SMU__
//#include "ps2sim_struct.h"
//#include "ps2sat_struct.h"      
//#include "sim_common_enums.h"
#include "smu_common_enums.h"
#endif /* __MOD_SMU__ */ 
//#include "csmss_common_enums.h"

//#include "mcd_l4_common.h"

#include "l4c_common_enum.h"
//#include "rmmi_common_enum.h"
#include "rmmi_context.h"
#include "l4c_context.h"
#include "layer4_context.h"
//#include "l4c_rspfmttr.h"
#include "l4c_sendmsg.h"
//#include "l4c_ft.h"
#include "l4_trc.h"

#include "mcd_l3_inc_struct.h"

#ifdef __MOD_TCM__
//#include "mcd_l3_inc_gprs_struct.h"
#endif 

#include "l3_inc_enums.h"

#ifdef __MOD_TCM__
//#include "l3_inc_local.h"
#endif 


#ifdef __MOD_TCM__
//#include "mmi_l3_enums.h"
//#include "mmi_sm_enums.h"
//#include "ppp_l4_enums.h"
//#include "tcm_common_enums.h"
//#include "tcm_common.h"
//#include "custom_nvram_editor_data_item.h"
//#include "l4c2abm_struct.h"
//#include "abm2l4c_struct.h"
//#include "l4c2tcm_struct.h"
#include "l4c2tcm_func.h"
//#include "tcm2l4c_struct.h"     /* __SAT__ */
#endif /* __MOD_TCM__ */ 
#include "l4crac_enums.h"
#include "l4crac_func.h"        /* rac header file */
#include "l4c2rac_struct.h"

//#include "l4c_aux_struct.h"
#include "l4c_utility.h"

#include "l4c_nw_cmd.h"

//mtk01616_070707
//#include "l4c2smu_struct.h"
#include "l4c_common_enum.h"
//#include "csmcc_enums.h"
//#include "csmcc_common_enums.h"
//#include "ps2sat_struct.h"
//#include "l4c2csm_cc_struct.h"

//#include "l4c2csm_ss_struct.h"
//#include "l4c2smsal_struct.h"
//#include "smsal_l4c_enum.h"
//#include "l4c_ss_parse.h"
//#include "csmcc_atfunc.h"
#include "rmmi_rsp.h"
#include "rmmi_ind.h"
//#include "l4c2phb_enums.h"   
//#include "l4c2phb_struct.h"
#include "lmmi_rsp.h"

#include "as2l4c_struct.h" //mtk02285, hspa_mmi; mtk02508, for gemini 2.0

//#include "syscomp_config.h"
#include "task_config.h"
#include "kal_general_types.h"
#include "ps_public_enum.h"
#include "ps_public_struct.h"
#include "kal_public_api.h"

#include "ps_em_enum.h"
#include "l4_ps_api.h"

#include "drv_msgid.h"
#include "md_sap.h"
#include "l4_msgid.h"
#include "sim_ps_msgid.h"
#include "rsva_msgid.h"

#ifdef __HSPA_PREFERENCE_SETTING__
    #if defined(__HSDPA_SUPPORT__) && defined(__UMTS_FDD_MODE__) && defined(__MTK_TARGET__)
    #include "hal_ul1_struct.h" //after HAL
    #endif /* defined(__HSDPA_SUPPORT__) && defined(__UMTS_FDD_MODE__) && defined(__MTK_TARGET__) */
#endif /* __HSPA_PREFERENCE_SETTING__ */

#if defined(__GEMINI__)
#include "l4c_root.h"
#endif

#ifdef __MBIM_SUPPORT__
#include "mbci_msg.h"
#include "mbci_ind.h"
#endif

#if defined(__NO_PSDATA_SEND_SCRI__) || defined(__FAST_DORMANCY__)
#include "custom_l4_utility.h"
#endif

#include "ps_public_utility.h"

extern kal_bool l4crac_set_auto_attach(kal_bool auto_attach, kal_bool is_pdp_activate);
extern kal_bool l4crac_get_auto_attach(void);
extern kal_bool l4crac_set_auto_attach_setting(kal_bool auto_attach);
extern kal_bool l4c_eq_load_power_on_data_req(kal_uint8 src_id, kal_bool read_flag, kal_uint8 file_idx);

extern void custom_get_supported_bands(kal_uint32 *gsm_bands, kal_uint32 *umts_bands);

/*****************************************************************************
 * FUNCTION
 *  l4c_nw_get_imei_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 *  imei        [IN]         
 *  svn         [IN]         
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_get_imei_req(kal_uint8 src_id, kal_uint8 *imei, kal_uint8 *svn)
{
    kal_bool result;
    kal_uint8 imei_bcd[8];      //Robin patch
    kal_uint8 svn_bcd;

    result = l4crac_get_imei((kal_uint8*) imei_bcd, (kal_uint8*) & svn_bcd);

    if(result == KAL_TRUE)
    {
        convert_to_digit((kal_uint8*) imei_bcd, imei);

        // mtk01616 070328 :conver bcd to ascii digit 
        *svn = (svn_bcd & 0x0f) + '0';
        *(svn + 1) = (svn_bcd >> 4) + '0';
        *(svn + 2) = '\0';
    }
    
    return result;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_nw_powroff_detach_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_powroff_detach_req(kal_uint8 src_id)
{

    l4crac_dereg_req_struct *param_ptr; //, *param1_ptr; //mtk01616_070707

    /* PWROFF_DETACH don't need to check command conflict */

    //mtk01616_070601: To response MMI if previous RAC action is not finished
    l4c_previous_rac_action_rsp();

    /* Johnny:
       power off detach should be handled specially during set rat mode:
       1. do not send L4CRAC_DEREG_REQ to RAC and set rac_current_action
       2. treat L4CRAC_SET_RAT_MODE_CNF as L4CRAC_DEREG_CNF */
    if (L4C_PTR->rac_current_action != PWRON_SET_RAT_MODE && L4C_PTR->rac_current_action != SET_RAT_MODE)
    {
        param_ptr = (l4crac_dereg_req_struct*)
            construct_local_para((kal_uint16) sizeof(l4crac_dereg_req_struct), TD_RESET);

        param_ptr->src_id = src_id;
        param_ptr->is_poweroff = KAL_TRUE;

        param_ptr->service = CS_PS_DOMAIN;
        l4c_send_msg_to_rac(MSG_ID_L4CRAC_DEREG_REQ, param_ptr);
    }
    l4c_set_user_action(L4C_RAC, src_id, PWROFF_DETACH);
    return KAL_TRUE;
}

/*****************************************************************************
 * FUNCTION
 *  l4c_nw_end_ps_data_session_req (Add by mtk01411)
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_end_ps_data_session_req(kal_uint8 src_id, kal_uint8 force_send_SCRI)
{
#if defined(__NO_PSDATA_SEND_SCRI__) || defined(__FAST_DORMANCY__)
    l4crac_end_ps_data_session_req_struct *param_ptr; 
    end_session_result_enum cause = SCRI_REQ_SENT;

    kal_brief_trace(TRACE_FUNC, FUNC_L4C_NW_END_PS_DATA_SESSION_REQ_ENTRY);

    /***
     * Orange Lab test: 
     * UE does not send the Signalling Connection Release Indication
     *  while sending an SMS
     ***/
    if (has_any_src_in_action(L4C_SMS, CMGS_EXE) == KAL_TRUE
         || has_any_src_in_action(L4C_SMS, CMGS_PDU_EXE) == KAL_TRUE
         #if defined(__MOD_TCM__) && (defined(__FAST_DORMANCY__) || defined(__NO_PSDATA_SEND_SCRI__))
         ||check_if_has_activation_pending_pdp() == KAL_TRUE
         ||check_if_has_deactivation_pending_pdp() == KAL_TRUE
         ||check_if_has_mt_activation_pending_pdp() == KAL_TRUE
         #endif /* defined(__MOD_TCM__) && (defined(__FAST_DORMANCY__) || defined(__NO_PSDATA_SEND_SCRI__)) */
        )
    {
       cause = SCRI_REQ_NOT_SENT;
    }
    else if ((query_ps_conf_test_profile_setting() & GENERAL_BIT_FOR_DISABLE_SCRI_AND_FD)
#if defined(__FAST_DORMANCY__)
            || ((query_ps_conf_test_profile_setting() & GENERAL_BIT_FOR_DISABLE_SCRI_ONLY) 
                && (RRC_NW_R8_FD_Support() == KAL_FALSE))
#endif
            )
    {
        cause = SCRI_NOT_ALLOWED;
    }
    
    if(cause != SCRI_REQ_SENT)
    {
        kal_uint8 temp_src;

        if (src_id == LMMI_SRC)
        {
            l4c_nw_end_ps_data_session_lrsp(cause);
        }
    	else if (src_id >= RMMI_SRC && src_id < RMMI_ALL)
        {
            // TODO
        }
        
        if(src_id != L4C_SRC)
        {
            temp_src = RMMI_PTR->current_src;
            RMMI_PTR->current_src = RMMI_UNSOLICITED;
            l4c_nw_end_ps_data_session_rind(src_id, cause);
            RMMI_PTR->current_src = temp_src;
        }
        
        kal_brief_trace(TRACE_WARNING, WARNING_L4C_SCRI_REQ_NOT_SENT);
        return KAL_FALSE;
    }

    param_ptr = (l4crac_end_ps_data_session_req_struct*)
        construct_local_para((kal_uint16) sizeof(l4crac_end_ps_data_session_req_struct), TD_RESET);
    param_ptr->src_id = src_id;
    param_ptr->force_send_SCRI = (kal_bool)force_send_SCRI;

    l4c_send_msg_to_rac(MSG_ID_L4CRAC_END_PS_DATA_SESSION_REQ, param_ptr);
    return KAL_TRUE;
#endif /* __NO_PSDATA_SEND_SCRI__ */
}

/*****************************************************************************
 * FUNCTION
 *  l4c_nw_exe_att_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id          [IN]        
 *  type            [IN]        
 *  opcode          [IN]        
 *  is_poweroff     [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_exe_att_req(kal_uint8 src_id, kal_uint8 type, kal_uint8 opcode, kal_bool is_poweroff)
{
    if (is_rac_cmd_conflict(src_id, CGATT_EXE) == KAL_TRUE)
    {
        /* we have to check if poweron state but MMI request power off it should not be return 
           conflict */
        if (!(L4C_PTR->cc_current_action[LMMI_SRC] == POWERON_EXE && opcode == RAC_DETACH && is_poweroff == KAL_TRUE))
        {
            return KAL_FALSE;
        }
    }

    if (opcode == RAC_ATTACH)
    {
        l4crac_reg_req_struct *param_ptr, *param1_ptr;

        if (type & RAC_PS)
        {
            param1_ptr = (l4crac_reg_req_struct*)
                construct_local_para((kal_uint16) sizeof(l4crac_reg_req_struct), TD_RESET);

            param1_ptr->src_id = src_id;
            l4c_send_msg_to_rac(MSG_ID_L4CRAC_PS_REG_REQ, param1_ptr);
        }
        if (type & RAC_CS)
        {
            param_ptr = (l4crac_reg_req_struct*)
                construct_local_para((kal_uint16) sizeof(l4crac_reg_req_struct), TD_RESET);

            param_ptr->src_id = src_id;
            param_ptr->search_type = MMI_SEARCH_NORMAL; //mtk01616 070426

	     L4C_PTR->has_deregistered = KAL_FALSE;

            l4c_send_msg_to_rac(MSG_ID_L4CRAC_REG_REQ, param_ptr);
        }
    }
    else
    {
        l4crac_dereg_req_struct *param_ptr, *param1_ptr;

        param_ptr = (l4crac_dereg_req_struct*)
            construct_local_para((kal_uint16) sizeof(l4crac_dereg_req_struct), TD_RESET);

        param_ptr->src_id = src_id;
        param_ptr->is_poweroff = is_poweroff;

        if (type == RAC_CS_AND_PS)
        {
            param1_ptr = (l4crac_dereg_req_struct*)
                construct_local_para((kal_uint16) sizeof(l4crac_dereg_req_struct), TD_RESET);

            param_ptr->service = CS_DOMAIN;
            param1_ptr->src_id = src_id;
            param1_ptr->service = PS_DOMAIN;
            param1_ptr->is_poweroff = is_poweroff;
            l4c_send_msg_to_rac(MSG_ID_L4CRAC_DEREG_REQ, param_ptr);
            l4c_send_msg_to_rac(MSG_ID_L4CRAC_DEREG_REQ, param1_ptr);
        }
        else
        {
            param_ptr->service = type - 1;
            l4c_send_msg_to_rac(MSG_ID_L4CRAC_DEREG_REQ, param_ptr);
        }
    }
    l4c_set_user_action(L4C_RAC, src_id, CGATT_EXE);

    return KAL_TRUE;
}

/*****************************************************************************
 * FUNCTION
 *  l4c_nw_abort_att_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id          [IN]        
 *  type            [IN]        
 *  opcode          [IN]        
 *  is_poweroff     [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_abort_att_req(kal_uint8 src_id, kal_uint8 connect_type, kal_bool ps_detach)
{
#ifndef __MMI_FMI__
    if (l4crac_update_auto_attach(connect_type) == KAL_FALSE)
    {
        return KAL_FALSE;
    }

    if (ps_detach)
    {
        return l4c_nw_exe_att_req(src_id, RAC_PS, RAC_DETACH, KAL_FALSE);
    }
    else
    {
        if (src_id == LMMI_SRC)
        { 
            // TODO
        }
        else if (src_id >= RMMI_SRC && src_id < RMMI_ALL)
        {
            RMMI_PTR->current_src = src_id;
            l4c_general_rrsp(KAL_TRUE, L4C_NO_CAUSE);
        }
    }
#endif
    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_nw_get_attach_status_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 *  type        [IN]        
 *  status      [?]         
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_get_attach_status_req(kal_uint8 src_id, kal_uint8 type, kal_uint8 *status)
{
    kal_uint8 fake, service;

    if (type == RAC_PS)
    {
    #ifdef __PS_SERVICE__
        l4crac_get_attach_status(&fake, status, &service);
    #else 
        *status = REG_STATE_NOT_REGISTERED;
    #endif 
    }
    else
    {
        l4crac_get_attach_status(status, &fake, &service);
    }
    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_nw_set_gprs_connect_type_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 *  type        [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_set_gprs_connect_type_req(kal_uint8 src_id, l4c_gprs_connect_type_enum type)
{
#ifdef __MOD_TCM__
    kal_bool is_context_exist = KAL_FALSE;

    /* Johnny: we use SET_GPRS_CON_TYPE trickly:
       1. we set it but send RSP to MMI without CNF
       2. we clear it when we receive CNF
       3. we will check command conflict in l4c_nw_set_gprs_connect_type_req() */
    if (is_rac_cmd_conflict(src_id, SET_GPRS_CON_TYPE) == KAL_TRUE)
    {
        /* Johnny:
           if SET_GPRS_CON_TYPE command conflict with SET_GPRS_CON_TYPE,
           L4C will return TRUE instead of FALSE but pending the latest auto_attach
           and re-do it when clear SET_GPRS_CON_TYPE */
        if (L4C_PTR->rac_current_action == SET_GPRS_CON_TYPE)
        {
            //mtk01616_070711
            l4crac_set_auto_attach_setting((kal_bool)type);
            kal_trace(TRACE_GROUP_5, INFO_SET_PENDING_ATTACH_SETTING, type);
            L4C_PTR->pending_latest_auto_attach = type;
            return KAL_TRUE;
        }
        else
        {
#ifndef __GEMINI__ //__GPRS_CONN_TYPE_IN_FLIGHT_MODE__
            if (L4C_PTR->cfun_state == 4)
            {
                //kal_prompt_trace(MOD_L4C, "GPRS_CONN_TYPE in flight mode", type);
                l4crac_update_auto_attach((kal_bool)type);
                return KAL_TRUE;
            }
            else
            {
                return KAL_FALSE;
            }
#else
            return KAL_FALSE;
#endif
        }
    }
    /* mtk01616_070711: 
       L4C always call l4crac_set_auto_attach_setting to save setting to NVRAM first. (To prevent issue like #414297.)
       If SET_GPRS_CON_TYPE repeatly,NVRAM setting is sync to L4C_PTR->pending_latest_auto_attach.
       RAC context is sync  to what it RAC was handled currently. */
    l4crac_set_auto_attach_setting((kal_bool)type);

    is_context_exist = check_pdp_context_exist_func();

    //mtk01616_080714: prvent GPRS attach or detach due to ps modules might assert when running modis
#ifdef __MTK_TARGET__
    if (l4crac_set_auto_attach((kal_bool)type, is_context_exist) == KAL_TRUE)
    {
        l4c_set_user_action(L4C_RAC, src_id, SET_GPRS_CON_TYPE);
    }
#endif	
    return KAL_TRUE;
#else /* __MOD_TCM__ */ 
    return KAL_FALSE;
#endif /* __MOD_TCM__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  l4c_nw_exe_gprs_connection_type
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_exe_gprs_connection_type(void)
{
#ifdef __MOD_TCM__
    l4c_gprs_connect_type_enum type;

    if (is_rac_cmd_conflict(LMMI_SRC, CGATT_EXE) == KAL_TRUE)
    {
        if (L4C_PTR->rac_current_action == COPS_EXE || L4C_PTR->rac_current_action == CBND_SET
            || L4C_PTR->rac_current_action == COPS_TEST)
        {
            L4C_PTR->gprs_connection_timeout = KAL_TRUE;
        }
        return KAL_FALSE;
    }

    type = (l4c_gprs_connect_type_enum)l4crac_get_auto_attach();
    if ((type == L4C_WHEN_NEEDED) && (check_pdp_context_exist_func() == KAL_FALSE))
    {

        l4crac_dereg_req_struct *param_ptr;

        param_ptr = (l4crac_dereg_req_struct*)
            construct_local_para((kal_uint16) sizeof(l4crac_dereg_req_struct), TD_RESET);

        param_ptr->src_id = 0;
        param_ptr->is_poweroff = 0;

        param_ptr->service = PS_DOMAIN;
        l4c_send_msg_to_rac(MSG_ID_L4CRAC_DEREG_REQ, param_ptr);
        // hogan: 070209 add action CGATT_EXE for PS AUTO DETACH to prevent cmd conflict
        l4c_set_user_action(L4C_RAC, LMMI_SRC, CGATT_EXE);
    }

#endif /* __MOD_TCM__ */ 
    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_nw_get_gprs_connect_type_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  type        [?]     
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_get_gprs_connect_type_req( /* l4c_gprs_connect_type_enum */ kal_uint8 *type)
{

#ifdef __MOD_TCM__

    /*
     * mtk01616_070725: 
     * MMI will get wrong connection type from RAC context when RAC didn't handle pending_auto_attach yet
     * L4C_PTR->pending_latest_auto_attach will sync with NVRAM setting. since we always set NVRAM first.
     */
    if (L4C_PTR->pending_latest_auto_attach != L4C_GPRS_CONN_TYPE_UNKNOWN)
    {
        *type = L4C_PTR->pending_latest_auto_attach;
    }
    else
    {
        *type = l4crac_get_auto_attach();
    }
    return KAL_TRUE;
#else /* __MOD_TCM__ */ 
    return KAL_FALSE;
#endif /* __MOD_TCM__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  l4c_nw_set_class_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 *  type        [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_set_class_req(kal_uint8 src_id, kal_uint8 type)
{
    l4crac_class_change_req_struct *param_ptr;

    if (is_rac_cmd_conflict(src_id, CGCLASS_SET) == KAL_TRUE)
    {
        return KAL_FALSE;
    }

    param_ptr = (l4crac_class_change_req_struct*)
        construct_local_para((kal_uint16) sizeof(l4crac_class_change_req_struct), TD_RESET);

    param_ptr->src_id = src_id;
    param_ptr->ms_class = type;

    l4c_send_msg_to_rac(MSG_ID_L4CRAC_CLASS_CHANGE_REQ, param_ptr);
    l4c_set_user_action(L4C_RAC, src_id, CGCLASS_SET);

    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_nw_get_class_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 *  type        [?]         
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_get_class_req(kal_uint8 src_id, kal_uint8 *type)
{
    *type = l4crac_get_mobile_class();

    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_nw_set_sel_mode_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 *  mode        [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_set_sel_mode_req(kal_uint8 src_id, kal_uint8 mode)
{
    if (is_current_rac_activated() == KAL_FALSE)
    {
        return KAL_FALSE;
    }

    // Sync with l4c_nw_exe_cops_req()
    // If l4c_nw_exe_cops_req() will be rejected, l4c_nw_set_sel_mode_req() is rejected.
    if (is_rac_cmd_conflict(src_id, COPS_EXE) == KAL_TRUE)
    {
        return KAL_FALSE;
    }
	
    l4crac_set_sel_mode(mode);
    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_nw_get_sel_mode_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 *  mode        [?]         
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_get_sel_mode_req(kal_uint8 src_id, kal_uint8 *mode)
{
    kal_uint8 sel_mode;

    sel_mode = l4crac_get_sel_mode();

    if (src_id == LMMI_SRC)
    {
        *mode = sel_mode;
    }
    else
    {

        if (sel_mode == AUTOMATIC_MODE)
        {
            *mode = AUTO_SELECT;
        }
        else if (sel_mode == MANUAL_MODE)
        {
            *mode = MANUAL_SEL;
        }
    }
    return KAL_TRUE;
}

/*****************************************************************************
 * FUNCTION
 *  l4c_nw_set_gprs_transfer_preference_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 *  mode        [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_set_gprs_transfer_preference_req(kal_uint8 src_id, kal_uint8 prefer)
{
#ifdef __MONITOR_PAGE_DURING_TRANSFER__
    if (is_current_rac_activated() == KAL_FALSE)
    {
        return KAL_FALSE;
    }
	if (l4crac_get_gprs_transfer_preference() != prefer)   
	{
    	l4crac_set_gprs_transfer_preference((gprs_transfer_preference_enum) prefer);
	}
	return KAL_TRUE;
#else
	return KAL_FALSE;
#endif	
    
}


/*****************************************************************************
 * FUNCTION
 *  l4c_nw_get_gprs_transfer_preference_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 *  mode        [?]         
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_get_gprs_transfer_preference_req(kal_uint8 src_id, kal_uint8 *prefer)
{
#ifdef __MONITOR_PAGE_DURING_TRANSFER__
    *prefer = (kal_uint8) l4crac_get_gprs_transfer_preference(); //gprs_transfer_preference_enum
    return KAL_TRUE;
#else
	return KAL_FALSE;
#endif	
}

/*****************************************************************************
 * FUNCTION
 *  l4c_nw_exe_cops_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 *  opcode      [IN]        
 *  oper        [IN]         
 *  rat         [IN]        
 *  factory_mode_arfcn [IN]
 *  preference [IN]: prefer GSM or UMTS
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_exe_cops_req(kal_uint8 src_id, kal_uint8 opcode, kal_uint8 *oper, kal_uint8 rat, kal_uint16 factory_mode_arfcn, kal_uint8 preference)
{
    if (is_rac_cmd_conflict(src_id, COPS_EXE) == KAL_TRUE)
    {
        return KAL_FALSE;
    }

    /*  [MAUI_01704887], mtk02480
      *     When SIM refresh, we should not allow PLMN_SEARCH_REQ before receive mmrr_ready_ind
      *	Otherwise, COPS_EXE might be overwritten by PWRON_ATTACH
      */
    if (L4C_PTR->mmrr_ready_flag == KAL_FALSE)
    {
        return KAL_FALSE;    
    }
	
#if defined(__SP_RIL_SUPPORT__)
    if ((L4C_PTR->rac_current_action == RFON_ATTACH || L4C_PTR->rac_current_action == PWRON_ATTACH) && opcode == AUTO_SELECT)
    {

 	/*    [MAUI_01645864], mtk02480
 	 *		Switch from Flight mode to Noraml mode in WinMo, modem will receive AT+CFUN=1 and AT+COPS=0.
 	 *		AT+COPS=0 perform new search might cost over than 30 seconds, then cause command timed out.
 	 *		So, we bypass AT+COPS=0.
  	 */    
        l4c_result_struct result;    	 
		 
        result.flag = L4C_OK;
        result.cause = L4C_NO_CAUSE;
	 RMMI_PTR->current_src = src_id;
        l4c_nw_exe_cops_rrsp(result, L4C_RAC_OK, NULL);    
     	 return KAL_TRUE;	
    }
#endif	

    l4c_set_user_action(L4C_RAC, src_id, COPS_EXE);

    if (opcode != DEREG)
    {
	/*  [DUMA00116008], [DUMA00115522] mtk02480
	  *    For WM, L4C have to send REG_REQ to RAC  in advance under following condition:
	  *    1. Have been dereg by AT+COPS=2
	  *    2. RFON_ATTACH with limited service(SEARCH_ANY) only
	  *   Currently, we always send REG_REQ before PLMN_SEARCH
	  *   By out test, it supposed be OK.
	  */   
	 if (L4C_PTR->has_deregistered == KAL_TRUE)
	 {
           l4crac_reg_req_struct *param_ptr;	 
		   
           param_ptr = (l4crac_reg_req_struct*) construct_local_para((kal_uint16) sizeof(l4crac_reg_req_struct), TD_RESET);
           param_ptr->src_id = src_id;
   		
           if (L4C_PTR->mmrr_ready_flag == KAL_TRUE)
           {
               param_ptr->search_type = MMI_SEARCH_NORMAL;
	        L4C_PTR->has_deregistered = KAL_FALSE;
           }
           else
           {
               param_ptr->search_type = MMI_SEARCH_ANY;
           }    
           l4c_send_msg_to_rac(MSG_ID_L4CRAC_REG_REQ, param_ptr);		

	    /* mtk02480,  if has_deregistered and receive AT+COPS=0,  we send REG_REQ only,
	                                    and print OK in reg_cnf (COPS_EXE)
	      */
	    if (L4C_PTR->has_deregistered == KAL_FALSE && opcode==AUTO_SELECT)
	    {    
	    	 return KAL_TRUE;
	    }
	 }
    }

    if (opcode == AUTO_SELECT)
    {
        l4crac_plmn_search_req_struct *param_ptr;

        param_ptr = (l4crac_plmn_search_req_struct*)
            construct_local_para((kal_uint16) sizeof(l4crac_plmn_search_req_struct), TD_RESET);

        param_ptr->src_id = src_id;
        param_ptr->factory_mode_arfcn = factory_mode_arfcn; //FastCampOn 20081104

        param_ptr->plmn_reselection_mode = AUTO_RESELECTION;
        param_ptr->plmn_id.rat = rat;
	    param_ptr->preference = preference;		
        l4c_send_msg_to_rac(MSG_ID_L4CRAC_PLMN_SEARCH_REQ, param_ptr);
    }
    else if (opcode == MANUAL_SEL)
    {
        l4crac_plmn_search_req_struct *param_ptr;

        param_ptr = (l4crac_plmn_search_req_struct*)
            construct_local_para((kal_uint16) sizeof(l4crac_plmn_search_req_struct), TD_RESET);
        plmn_convert_to_struct(oper, &param_ptr->plmn_id);

        param_ptr->src_id = src_id;
        param_ptr->factory_mode_arfcn = factory_mode_arfcn; // FastCampOn 20081104    

        param_ptr->plmn_reselection_mode = MANUAL_RESELECTION;
        param_ptr->plmn_id.rat = rat;
	    param_ptr->preference = preference;
        l4c_send_msg_to_rac(MSG_ID_L4CRAC_PLMN_SEARCH_REQ, param_ptr);
    }
    else if (opcode == DEREG)
    {
        l4crac_dereg_req_struct *param_ptr;

        param_ptr = (l4crac_dereg_req_struct*)
            construct_local_para((kal_uint16) sizeof(l4crac_dereg_req_struct), TD_RESET);

        param_ptr->src_id = src_id;
        param_ptr->is_poweroff = KAL_FALSE;

	 /*
	  *	[MAUI_01645864], mtk02480
	  *		Switch from Normal mode to Flight mode in WinMo, modem will receive AT+COPS=2 and AT+CFUN=4
	  *		For AT+COPS=2, we shall dereg both CS and PS service
	  */
#if defined(__CS_SERVICE__) && defined(__PS_SERVICE__)
        param_ptr->service = CS_PS_DOMAIN;
#elif defined (__CS_SERVICE__)
	 param_ptr->service = CS_DOMAIN;
#else
	 param_ptr->service = PS_DOMAIN;	// No such case currently
#endif

        l4c_send_msg_to_rac(MSG_ID_L4CRAC_DEREG_REQ, param_ptr);
    }
    else
    {
        l4c_set_user_action(L4C_RAC, L4C_NO_USER, L4C_NO_ACTION);
        return KAL_FALSE;
    }

    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_nw_get_plmn_list_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_get_plmn_list_req(kal_uint8 src_id)
{
    l4crac_plmn_list_req_struct *param_ptr;

    if (is_rac_cmd_conflict(src_id, COPS_TEST) == KAL_TRUE)
    {

        return KAL_FALSE;
    }

    /*  [MAUI_01724641] mtk02480, 20090323
      *  During PowerOn, COPS_TEST might be overwritten by PWRON_ATTACH (ex: AT+CPIN="1234";+COPS=? , which cause no response for +COPS=? )
      *  To avoid, we not allow COPS_TEST before received MMRR_READY_IND. However, if no SIM inserted(i.e. L4C_SMU_ACTIVATE_FAIL), we allow COPS_TEST
      */
    if (L4C_PTR->mmrr_ready_flag == KAL_FALSE && L4C_PTR->smu_activated != L4C_SMU_ACTIVATE_FAIL)
    {
        return KAL_FALSE;    
    }

    param_ptr = (l4crac_plmn_list_req_struct*)
        construct_local_para((kal_uint16) sizeof(l4crac_plmn_list_req_struct), TD_RESET);

    param_ptr->src_id = src_id;

    l4c_send_msg_to_rac(MSG_ID_L4CRAC_PLMN_LIST_REQ, param_ptr);

    l4c_set_user_action(L4C_RAC, src_id, COPS_TEST);

    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_nw_abort_plmn_list_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_abort_plmn_list_req(kal_uint8 src_id)
{
    l4crac_plmn_list_stop_req_struct *param_ptr;

    if (is_rac_cmd_conflict(src_id, COPS_TEST_STOP) == KAL_TRUE)
    {
        kal_trace(TRACE_WARNING, WARNING_ABORT_PLMN_LIST_REQ_CMD_CONFLICT);
        return KAL_FALSE;
    }

    param_ptr = (l4crac_plmn_list_stop_req_struct*)
        construct_local_para((kal_uint16) sizeof(l4crac_plmn_list_stop_req_struct), TD_RESET);

    param_ptr->src_id = src_id;

    l4c_send_msg_to_rac(MSG_ID_L4CRAC_PLMN_LIST_STOP_REQ, param_ptr);

    //mtk01616_070910: in MONZA , there is plmn_list_stop_cnf , we clear action right after receiving the cnf
    l4c_set_user_action(L4C_RAC, src_id, COPS_TEST_STOP);

    ////      l4c_set_user_action(L4C_RAC, L4C_NO_USER, L4C_NO_ACTION);

    return KAL_TRUE;
}

/* kal_bool l4c_nw_abort_auto_sel_req (kal_uint8 src_id)
   {
   if (L4C_PTR->cc_current_action[src_id] == COPS_EXE)
   {
   l4c_send_msg_to_rac ( MSG_ID_L4CRAC_ABORT_LIST_REQ,
   NULL);
   
   L4C_PTR->cc_sub_state[src_id] = L4C_IDLE_STATE;
   L4C_PTR->cc_current_action[src_id] = L4C_NO_ACTION;
   return KAL_TRUE;
   }
   return KAL_FALSE;
   } */


/*****************************************************************************
 * FUNCTION
 *  l4c_nw_get_current_oper_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 *  oper        [?]         
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_get_current_oper_req(kal_uint8 src_id, kal_uint8 *oper)
{
    plmn_id_rat_struct plmn;

    l4crac_get_current_plmn(&plmn);
    plmn_convert_to_digit(&(plmn.plmn_id), oper);
    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_nw_get_signal_level_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 *  rssi        [?]         
 *  ber         [?]         
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_get_signal_level_req(kal_uint8 src_id, kal_uint8 *rssi, kal_uint8 *ber)
{
    *rssi = L4C_PTR->csq_level; //rx_level, mtk02285
    *ber  = L4C_PTR->ber;
    return KAL_TRUE;
}

kal_bool l4a_nw_set_preferred_band_req (kal_uint8 src_id,
                              kal_uint8 gsm_band, kal_uint8 *umts_fdd_band)
{
   kal_bool ret_val;
   ret_val = l4c_nw_set_preferred_band_req (src_id,
                               KAL_TRUE, gsm_band, KAL_TRUE, umts_fdd_band);
   return ret_val;
}

/*****************************************************************************
 * FUNCTION
 *  l4c_nw_set_preferred_band_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 *  band        [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_set_preferred_band_req(kal_uint8 src_id,
                                       kal_bool is_gsm_band_present, 
                                       kal_uint8 gsm_band, 
                                       kal_bool is_umts_band_present,
                                       kal_uint8 *umts_fdd_band)
{
    kal_uint8 i;
    l4crac_set_preferred_band_req_struct *param_ptr;

    if (is_rac_cmd_conflict(src_id, CBND_SET) == KAL_TRUE)
    {
        return KAL_FALSE;
    }

    param_ptr = (l4crac_set_preferred_band_req_struct*)
        construct_local_para((kal_uint16) sizeof(l4crac_set_preferred_band_req_struct), TD_RESET);

    param_ptr->src_id = src_id;
    param_ptr->gsm_band = gsm_band;
    param_ptr->is_gsm_band_present = is_gsm_band_present;
    for (i=0;i<SIZE_OF_UMTS_BAND;i++)
    {
        param_ptr->umts_fdd_band[i] = umts_fdd_band[i];
    }
    param_ptr->is_umts_band_present = is_umts_band_present;

    // If support dynamic set band and RF is on, RF off -> Set band -> RF on
    // Otherwise, Set band only

#ifdef __DYNAMIC_BAND_SEL__
    if (L4C_PTR->cfun_state == 1)
    {
        L4C_PTR->parameter[src_id].length = sizeof(l4crac_set_preferred_band_req_struct);
        L4C_PTR->parameter[src_id].data = param_ptr;
        l4c_nw_exe_rf_off_req(src_id, CBND_SET);
    }
    else
#endif
    {
        l4c_send_msg_to_rac(MSG_ID_L4CRAC_SET_PREFERRED_BAND_REQ, param_ptr);
        l4c_set_user_action(L4C_RAC, src_id, CBND_SET);
    }

    return KAL_TRUE;	
}


/*****************************************************************************
 * FUNCTION
 *  l4c_nw_get_band_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 *  type        [?]         
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_get_band_req(kal_uint8 src_id,
                             kal_uint8 *gsm_band,
                             kal_uint8 *umts_fdd_band,
                             kal_uint8 *supported_gsm_band,
                             kal_uint8 *supported_umts_fdd_band)
{
    //*type = l4crac_get_preferred_band();
    *gsm_band = l4crac_get_preferred_gsm_band();
    #ifdef __UMTS_RAT__
    l4crac_get_preferred_umts_band (umts_fdd_band);
    #endif


    custom_get_supported_bands(
            (kal_uint32*)supported_gsm_band, 
            (kal_uint32*)supported_umts_fdd_band);

    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_nw_exe_rf_on_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_exe_rf_on_req(kal_uint8 src_id)
{
    l4crac_set_rat_mode_req_struct *param_ptr = (l4crac_set_rat_mode_req_struct*)
        construct_local_para(
            (kal_uint16) sizeof(l4crac_set_rat_mode_req_struct),
            TD_RESET);

    param_ptr->src_id = src_id;
    
#if defined(__ENS_RAT_BALANCING__) && defined(__UMTS_RAT__)
    param_ptr->rat_mode = l4c_nw_check_ef_rat_mode();
#else
    param_ptr->rat_mode = l4crac_get_rat_mode();
#endif

    param_ptr->save_to_nvram = KAL_TRUE; //MAUI_02554068

    l4c_send_msg_to_rac(MSG_ID_L4CRAC_SET_RAT_MODE_REQ, param_ptr);

    l4c_set_user_action(L4C_RAC, src_id, RFON_SET_RAT_MODE);
    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_nw_exe_rf_off_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]
 *  action      [IN]
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_exe_rf_off_req(kal_uint8 src_id, l4c_action_enum action)
{
	
    if ((L4C_PTR->rac_current_action != RFOFF_DETACH) && (L4C_PTR->rac_current_action != PWROFF_DETACH)
    #ifdef __DYNAMIC_BAND_SEL__
        && (L4C_PTR->rac_current_action != CBND_SET)
    #endif
    #ifdef __DYNAMIC_HSPA_PREFERENCE__
        && (L4C_PTR->rac_current_action != SET_HSPA_MODE)
    #endif
        )
    {
        /* Johnny:
           power off detach should be handled specially during set rat mode:
           1. do not send L4CRAC_DEREG_REQ to RAC and set rac_current_action
           2. treat L4CRAC_SET_RAT_MODE_CNF as L4CRAC_DEREG_CNF */
        if (L4C_PTR->rac_current_action != PWRON_SET_RAT_MODE && L4C_PTR->rac_current_action != SET_RAT_MODE)
        {
            l4crac_dereg_req_struct *param_ptr;     //mtk01616_070707 : remove not used param1_ptr

            param_ptr = (l4crac_dereg_req_struct*)
                construct_local_para((kal_uint16) sizeof(l4crac_dereg_req_struct), TD_RESET);

            param_ptr->src_id = src_id;
            param_ptr->is_poweroff = KAL_TRUE;

            param_ptr->service = CS_PS_DOMAIN;

            l4c_send_msg_to_rac(MSG_ID_L4CRAC_DEREG_REQ, param_ptr);
        }

        //mtk01616_070601: To response MMI if previous RAC action is not finished
        l4c_previous_rac_action_rsp();

        l4c_set_user_action(L4C_RAC, src_id, action);
    }
    else
    {
        l4c_send_msg_to_rac(MSG_ID_L4CRAC_RFOFF_REQ, NULL);
    }

return KAL_TRUE;

}

/*****************************************************************************
 * FUNCTION
 *  l4c_nw_cfun_state_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id          [IN]        
 *  cfun_state      [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_cfun_state_req(kal_uint8 src_id, kal_uint8 cfun_state)
{
    l4c_context_struct *l4c_ptr = L4C_PTR;
    kal_bool res;

    if ((l4c_ptr->cfun_state == 0) && ((cfun_state == 1) || (cfun_state == 4)))
    {
        if ((cfun_state == 1) && (is_rac_cmd_conflict(src_id, RFON_SET_RAT_MODE) == KAL_TRUE))
        {
            return KAL_FALSE;
        }
        l4c_ptr->cfun_state = cfun_state;    
        res = l4c_eq_load_power_on_data_req(src_id, KAL_FALSE, 0);
    }
    else if ((l4c_ptr->cfun_state == 1) && (cfun_state == 4))
    {
        if (is_rac_cmd_conflict(src_id, RFOFF_DETACH) == KAL_TRUE)
        {
            return KAL_FALSE;
        }
        res = l4c_nw_exe_rf_off_req(src_id, RFOFF_DETACH);
        l4c_ptr->cfun_state = cfun_state;  //CFUN=4, "OK" will be return when RF OFF.
    }
    else if ((l4c_ptr->cfun_state == 4) && (cfun_state == 1))
    {
        /* For MONZA architecture, we can turn on RF even CS/PS serving in another SIM */
        if (is_rac_cmd_conflict(src_id, RFON_SET_RAT_MODE) == KAL_TRUE)
        {
            return KAL_FALSE;
        }
        res = l4c_nw_exe_rf_on_req(src_id);
        l4c_ptr->cfun_state = cfun_state;
    }
    else if (cfun_state == 0)
    {
    #if 0 // remove in MOLY #ifdef __MMI_FMI__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif

        /* ---------------------------------------------------------
        * [MAUI_02274849] Not allow enter cfun_state=0 if CC has any action
        *  Make sure always power on in cc_current_action=NO_ACTION state
        * ---------------------------------------------------------*/
        if ((l4c_ptr->cc_current_action[src_id] != L4C_NO_ACTION)
            || ((is_rac_cmd_conflict(src_id, RFOFF_DETACH) == KAL_TRUE) && (l4c_ptr->cfun_state == 1)))
        {
            return KAL_FALSE;	 
        }

        if (l4c_ptr->cfun_state != 0)
        {
            l4c_send_msg_to_sim(MSG_ID_SIM_POWEROFF_REQ, NULL, NULL);
        }

        if (l4c_ptr->cfun_state == 1)
        {
            res = l4c_nw_exe_rf_off_req(src_id, RFOFF_DETACH);
        }
        else
        {
            res = KAL_TRUE;

            if (src_id == LMMI_SRC)
            {
                l4c_nw_cfun_state_lrsp(KAL_TRUE);
            }
        #ifdef __MBIM_SUPPORT__
            else if (src_id >= MBCI_SRC && src_id <= MBCI_SRC_END)
            {
                l4c_nw_cfun_state_mrsp(src_id , KAL_TRUE);                
            }
        #endif
            else
            {
                RMMI_PTR->current_src = src_id;
                l4c_cfun_rrsp(KAL_TRUE, L4C_NO_CAUSE);	     
            }

        #ifdef __MBIM_SUPPORT__
            l4c_nw_cfun_state_mind();
        #endif
        }
        l4c_ptr->cfun_state = cfun_state;
        l4c_ptr->smu_activated = L4C_SMU_INACTIVE;
        l4c_ptr->mmrr_ready_flag = KAL_FALSE;
        l4c_clear_poweron_action(src_id);
    }	
    else
    {
        res = KAL_FALSE;
    }

#if defined(__OP01__)
    if (res == KAL_TRUE)
    {
        l4c_op01_rfsw_rind(cfun_state==1?KAL_TRUE:KAL_FALSE);
    }
#endif

    return res;
}

/*****************************************************************************
 * FUNCTION
 *  l4c_nw_set_rat_mode_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id          [IN]        
 *  rat_mode        [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_set_rat_mode_req(kal_uint8 src_id, kal_uint8 rat_mode)
{
#if defined(__NAS_RAT_PREFER__) || defined(__UMTS_FDD_PREFER__)
    return l4c_nw_set_rat_mode_ext_req(src_id, rat_mode, l4crac_get_irat_preference()); // prefer RAT unchanged
#else
    return l4c_nw_set_rat_mode_ext_req(src_id, rat_mode, L4C_PREFER_RAT_INVALID);
#endif
}

/*****************************************************************************
 * FUNCTION
 *  l4c_nw_set_rat_mode_ext_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id          [IN]        
 *  rat_mode        [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_set_rat_mode_ext_req(kal_uint8 src_id, kal_uint8 rat_mode, l4c_prefer_rat_enum prefer_rat)
{
    l4crac_dereg_req_struct *param_ptr;

#if defined(__UMTS_RAT__) && defined(__GEMINI__)
    if ((l4c_current_mod_id != MOD_L4C) && (rat_mode != RAT_GSM))
    {
       return KAL_FALSE;
    }
#endif

    if (is_rac_cmd_conflict(src_id, SET_RAT_MODE_DETACH) == KAL_TRUE) 
    {
        //MAUI_02743658: allow set RAT when GPRS dialup
        if (L4C_PTR->cfun_state == 4)
        {
            l4crac_set_rat_mode(rat_mode);
        #if defined(__NAS_RAT_PREFER__) || defined(__UMTS_FDD_PREFER__)
            l4crac_set_prefer_rat(prefer_rat);
            l4crac_set_irat_preference(prefer_rat);
        #endif
            RMMI_PTR->current_src = src_id;
            l4c_general_rrsp(KAL_TRUE, L4C_NO_CAUSE);
            return KAL_TRUE;
        }
        else
        {
            return KAL_FALSE;
        }
    }

    if (rat_mode == l4crac_get_rat_mode() 
    #if defined(__NAS_RAT_PREFER__) || defined(__UMTS_FDD_PREFER__)
        && prefer_rat == (l4c_prefer_rat_enum)l4crac_get_irat_preference()
    #endif
        )
    {
	    if (src_id == LMMI_SRC)
	    {
        	l4c_nw_set_rat_mode_lrsp(KAL_TRUE);
	    }
	    else
	    {
	 	    RMMI_PTR->current_src = src_id;
	 	    l4c_general_rrsp(KAL_TRUE, L4C_NO_CAUSE);
	    }
        return KAL_TRUE;        
    }

    param_ptr = (l4crac_dereg_req_struct*)construct_local_para((kal_uint16) sizeof(l4crac_dereg_req_struct), TD_RESET);
    param_ptr->src_id = src_id;
    param_ptr->is_poweroff = KAL_TRUE;
    param_ptr->service = CS_PS_DOMAIN;

    l4c_send_msg_to_rac(MSG_ID_L4CRAC_DEREG_REQ, param_ptr);

    //mtk01616_070601: To response MMI if previous RAC action is not finished
    l4c_previous_rac_action_rsp();

    l4c_set_user_action(L4C_RAC, src_id, SET_RAT_MODE_DETACH);

    L4C_PTR->rat_mode = rat_mode;
#if defined(__NAS_RAT_PREFER__) || defined(__UMTS_FDD_PREFER__)
    L4C_PTR->prefer_rat = prefer_rat;
#endif
    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_nw_get_rat_mode_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id          [IN]        
 *  rat_mode        [?]         
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_get_rat_mode_req(kal_uint8 src_id, kal_uint8 *rat_mode)
{
    return l4c_nw_get_rat_mode_ext_req(src_id, rat_mode, NULL);
}

/*****************************************************************************
 * FUNCTION
 *  l4c_nw_get_rat_mode_ext_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id          [IN]        
 *  rat_mode        [?]         
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_get_rat_mode_ext_req(kal_uint8 src_id, kal_uint8 *rat_mode, kal_uint8 *prefer_rat)
{
    if (rat_mode != NULL)
    {
        *rat_mode = l4crac_get_rat_mode();
    }

    if (prefer_rat != NULL)
    {
    #if defined(__NAS_RAT_PREFER__) || defined(__UMTS_FDD_PREFER__)
        *prefer_rat = (kal_uint8)l4crac_get_irat_preference();
    #else
        *prefer_rat = (kal_uint8)L4C_PREFER_RAT_NONE;
    #endif
    }
    return KAL_TRUE;
}

/*****************************************************************************
 * FUNCTION
 *  l4c_nw_get_prefer_rat_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  prefer_rat      [?]     
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_get_prefer_rat_req(kal_uint8 *prefer_rat)
{
    *prefer_rat = l4crac_get_prefer_rat();
    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_nw_set_prefer_rat_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id          [IN]        
 *  prefer_rat      [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_set_prefer_rat_req(kal_uint8 src_id, kal_uint8 prefer_rat)
{
    l4crac_set_prefer_rat_req_struct *param_ptr;

    param_ptr = (l4crac_set_prefer_rat_req_struct*)
        construct_local_para((kal_uint16) sizeof(l4crac_set_prefer_rat_req_struct), TD_RESET);

    param_ptr->src_id = src_id;
    param_ptr->prefer_rat = prefer_rat;

    l4c_send_msg_to_rac(MSG_ID_L4CRAC_SET_PREFER_RAT_REQ, param_ptr);
    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_nw_set_plmn_list_preference_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 *  band        [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_set_plmn_list_preference_req(kal_uint8 src_id, kal_uint8 preference)
{
#ifdef __PLMN_LIST_PREF_SUPPORT__
    l4cas_set_plmn_list_preference_req_struct *param_ptr1;

    l4crac_set_plmn_list_preference((plmn_list_preference_enum)preference);


    param_ptr1 = (l4cas_set_plmn_list_preference_req_struct*)construct_local_para((kal_uint16) sizeof(l4cas_set_plmn_list_preference_req_struct), TD_RESET);    
    param_ptr1->preference = (plmn_list_preference_enum)preference;

    msg_send5(l4c_current_mod_id,
              L4_MODULE(MOD_RRM, l4c_current_mod_id - MOD_L4C), 
              AS_L4C_SAP, 
              MSG_ID_L4CAS_SET_PLMN_LIST_PREFERENCE_REQ, 
              (local_para_struct*)param_ptr1);

#ifdef __UMTS_RAT__
#ifdef __GEMINI__
    if (l4c_current_mod_id == MOD_L4C)
#endif
    {
    l4cas_set_plmn_list_preference_req_struct *param_ptr2; 

    param_ptr2 = (l4cas_set_plmn_list_preference_req_struct*)construct_local_para((kal_uint16) sizeof(l4cas_set_plmn_list_preference_req_struct), TD_RESET);
    param_ptr2->preference = (plmn_list_preference_enum)preference;


    msg_send5(l4c_current_mod_id, MOD_CSE, AS_L4C_SAP, 
            MSG_ID_L4CAS_SET_PLMN_LIST_PREFERENCE_REQ, (local_para_struct*)param_ptr2);
    }	
#endif	
#endif
    return KAL_TRUE;
}

/*****************************************************************************
 * FUNCTION
 *  l4c_nw_get_plmn_list_preference_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 *  band        [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_get_plmn_list_preference_req(kal_uint8 src_id, kal_uint8 *preference)
{
#ifdef __PLMN_LIST_PREF_SUPPORT__
   *preference = l4crac_get_plmn_list_preference();
#endif
   return KAL_TRUE;
}

/*****************************************************************************
 * FUNCTION
 *  l4c_nw_set_hspa_mode_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 *  band        [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_set_hspa_mode_req(kal_uint8 src_id, kal_uint8 hspa_mode, kal_uint8 apply_mode)
{
#ifdef __HSPA_PREFERENCE_SETTING__
    if (KAL_TRUE == is_rac_cmd_conflict(src_id, SET_HSPA_MODE))
    {
        kal_trace(TRACE_WARNING, WARNING_RAC_CMD_CONFLICT);
        return KAL_FALSE;
    }
    else
    {
        if (apply_mode == L4C_APPLY_AFTER_REBOOT) //1
        {
            l4crac_set_hspa_preference((hspa_preference_enum)hspa_mode);
            if (src_id == LMMI_SRC)
            {
                l4c_nw_set_hspa_mode_lrsp(KAL_TRUE);
            }
            else if ((src_id >= RMMI_SRC) && (src_id < RMMI_ALL))
            {
                l4c_general_rrsp(KAL_TRUE, L4C_NO_CAUSE);
            }
            return KAL_TRUE;
        }
    #ifdef __DYNAMIC_HSPA_PREFERENCE__
        else if (apply_mode == L4C_APPLY_AT_RUNTIME) //0, default value for feature phone MMI
        {
            if (L4C_PTR->cfun_state == 1)
            {
                l4cas_set_hspa_preference_req_struct* param_ptr;

                if (L4C_PTR->parameter[src_id].length != 0)
                {
                    return KAL_FALSE;
                }

                param_ptr = (l4cas_set_hspa_preference_req_struct*) construct_local_para((kal_uint16) sizeof(l4cas_set_hspa_preference_req_struct), TD_RESET);
                param_ptr->hspa_preference = (hspa_preference_enum)hspa_mode;

                L4C_PTR->parameter[src_id].length = sizeof(l4cas_set_hspa_preference_req_struct);
                L4C_PTR->parameter[src_id].data = param_ptr;

                l4c_nw_exe_rf_off_req(src_id, SET_HSPA_MODE);
            }
            else
            {
                l4crac_set_hspa_preference((hspa_preference_enum)hspa_mode);
                if (src_id == LMMI_SRC)
                {
                    l4c_nw_set_hspa_mode_lrsp(KAL_TRUE);
                }
                else if ((src_id >= RMMI_SRC) && (src_id < RMMI_ALL))
                {
                    l4c_general_rrsp(KAL_TRUE, L4C_NO_CAUSE);
                }
            }
            return KAL_TRUE;
        }
    #endif
        else
        {
            return KAL_FALSE;
        }
    }
#else
    return KAL_FALSE;
#endif /* __HSPA_PREFERENCE_SETTING__ */
}

#if defined(__UMTS_TDD128_MODE__)
extern hspa_preference_enum usime_Get_HSPA_Category();
#endif
l4c_hspa_preference_enum l4c_nw_get_max_hspa_support_mode(void)
{
    l4c_hspa_preference_enum max_hspa_mode = L4C_HSPA_OFF;
#if defined(__HSDPA_SUPPORT__) && defined(__UMTS_FDD_MODE__) && defined(__MTK_TARGET__)
    FDD_HSDPA_CATEGORY_E dpa_cat;
    FDD_HSUPA_CATEGORY_E upa_cat;
    
    if (KAL_TRUE == UL1D_Get_FDD_HSPA_Phy_Category(&dpa_cat, &upa_cat))
    {
        if (FDD_HSDPA_OFF != dpa_cat)
        {
            max_hspa_mode = L4C_HSDPA_ON;
        }        
        if (FDD_HSUPA_OFF != upa_cat)
        {
            #if defined(__UMTS_R7__)
            max_hspa_mode = L4C_HSPAPLUS_ON;
            #else
            max_hspa_mode = L4C_HSDPA_HSUPA_ON;
            #endif
        }            
    }
    else
    {
        ASSERT(0);
    }

    kal_trace(TRACE_INFO, L4C_PS_GET_MAX_HSPA_SUPPORT_MODE, dpa_cat, upa_cat, max_hspa_mode);    
#elif defined(__UMTS_TDD128_MODE__) && defined(__MTK_TARGET__)
  max_hspa_mode = (l4c_hspa_preference_enum)usime_Get_HSPA_Category();
#endif /* defined(__HSDPA_SUPPORT__) && defined(__UMTS_FDD_MODE__) && defined(__MTK_TARGET__) */    
    return max_hspa_mode;
}

kal_bool l4c_nw_get_hspa_mode_req(kal_uint8 src_id, kal_uint8* hspa_mode)
{
#ifdef __HSPA_PREFERENCE_SETTING__
    *hspa_mode = l4crac_get_hspa_preference();
    if ((*hspa_mode > l4c_nw_get_max_hspa_support_mode())
        && (*hspa_mode < L4C_HSPA_INVLIAD))
    {
        *hspa_mode = l4c_nw_get_max_hspa_support_mode();
    }
	return KAL_TRUE;
#else
    return KAL_FALSE;
#endif //__HSPA_PREFERENCE_SETTING__	
}

kal_bool l4c_nw_get_romaing_status_req(kal_uint8 src_id, kal_bool* is_on_hplmn)
{
    *is_on_hplmn = l4crac_is_on_hplmn();
    return KAL_TRUE;
}

kal_bool l4c_nw_get_romaing_mode_req(kal_uint8 src_id, kal_bool* support_roaming)
{
#if defined(__DYNAMIC_ROAMING_SUPPORT__) && defined(__OP01_3G__)
    *support_roaming = l4crac_get_roaming_mode();
#else
    *support_roaming = KAL_TRUE;
#endif
    return KAL_TRUE;
}

/*****************************************************************************
 * FUNCTION
 *  l4c_nw_sim_mode_switch_stop_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
kal_bool l4c_nw_set_sysconfig_req(kal_uint8 src_id, 
                                                                kal_uint8 rat_mode, 
                                                                kal_uint8 prefer_rat, 
                                                                kal_bool support_roaming, 
                                                                kal_uint8 mobile_class)
{
#if defined(__OP01__)
    l4crac_dereg_req_struct *param_ptr;
    l4c_nw_sysconfig_struct *sysconfig;
    
    if (is_rac_cmd_conflict(src_id, SYS_CONFIG) == KAL_TRUE)
    {
        return KAL_FALSE;
    }

    // Response OK directly if no change
    if (rat_mode == l4crac_get_rat_mode() &&
        prefer_rat == l4crac_get_prefer_rat() &&
    #if defined(__DYNAMIC_ROAMING_SUPPORT__) && defined(__OP01_3G__)
        support_roaming == l4crac_get_roaming_mode() &&
    #endif
        mobile_class == l4crac_get_mobile_class())
    {
        if (src_id == LMMI_SRC)
        {
            // TODO
        }
        else
        {
            RMMI_PTR->current_src = src_id;
            l4c_general_rrsp(KAL_TRUE, L4C_NO_CAUSE);
        }
        return KAL_TRUE;
    }

    sysconfig = (l4c_nw_sysconfig_struct*)get_ctrl_buffer(sizeof(l4c_nw_sysconfig_struct));
    sysconfig->rat_mode = rat_mode;
    sysconfig->prefer_rat = prefer_rat;
    sysconfig->support_roaming = support_roaming;
    sysconfig->mobile_class = mobile_class;
    L4C_PTR->nw_sysconfig = sysconfig;

    param_ptr = (l4crac_dereg_req_struct*)construct_local_para((kal_uint16) sizeof(l4crac_dereg_req_struct), TD_RESET);
    param_ptr->src_id = src_id;
    param_ptr->is_poweroff = KAL_TRUE;
    param_ptr->service = CS_PS_DOMAIN;

    l4c_send_msg_to_rac(MSG_ID_L4CRAC_DEREG_REQ, param_ptr);

    l4c_set_user_action(L4C_RAC, src_id, SYS_CONFIG);
    return KAL_TRUE;
#else
    return KAL_FALSE;
#endif
}


/*****************************************************************************
 * FUNCTION
 *  l4c_nw_set_syssel_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
kal_bool l4c_nw_set_syssel_req(kal_uint8 src_id, 
                               kal_uint8 gsm_band,
                               kal_uint16 umts_band,
                               kal_uint8 rat_mode, 
                               kal_uint8 prefer_rat, 
                               kal_uint8 mobile_class)
{
#if defined(__SYSSEL_SUPPORT__)
    l4crac_dereg_req_struct *param_ptr;
    l4c_nw_syssel_struct *syssel;
    kal_uint8 cur_gsm_band;
    kal_uint16 cur_umts_band;
    kal_bool is_gsm_band_present, is_umts_band_present;
    l4c_context_struct *l4c_ptr = L4C_PTR;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    
    if (is_rac_cmd_conflict(src_id, SYS_SEL) == KAL_TRUE)
    {
        return KAL_FALSE;
    }

    l4c_nw_get_band_req(src_id, &cur_gsm_band, (kal_uint8*)&cur_umts_band);

    // Response OK directly if no change
    if (gsm_band == cur_gsm_band &&
        umts_band == cur_umts_band &&
        rat_mode == l4crac_get_rat_mode() &&
        prefer_rat == l4crac_get_prefer_rat() &&
        mobile_class == l4crac_get_mobile_class())
    {
        if (src_id == LMMI_SRC)
        {
            // TODO
        }
        else
        {
            rmmi_ptr->current_src = src_id;
            l4c_general_rrsp(KAL_TRUE, L4C_NO_CAUSE);
        }
        return KAL_TRUE;
    }

    syssel = (l4c_nw_syssel_struct*)get_ctrl_buffer(sizeof(l4c_nw_syssel_struct));
    syssel->rat_mode = rat_mode;
    syssel->prefer_rat = prefer_rat;
    syssel->mobile_class = mobile_class;
    l4c_ptr->nw_syssel = syssel;

    is_gsm_band_present = (gsm_band != 0)? KAL_TRUE : KAL_FALSE;
    is_umts_band_present = (umts_band != 0)? KAL_TRUE : KAL_FALSE;

    if ((is_gsm_band_present == KAL_TRUE) || (is_umts_band_present == KAL_TRUE))
    {
        /* ideally, if gsm or umts band exists, set both band
         * but currently gsm and umts band can't be set to 0
         */
        if (l4c_nw_set_preferred_band_req(src_id,
                                          is_gsm_band_present, 
                                          gsm_band, 
                                          is_umts_band_present, 
                                          (kal_uint8*)&umts_band) == KAL_FALSE)
        {
            free_ctrl_buffer(syssel);
            l4c_ptr->nw_syssel = NULL;
            return KAL_FALSE;
        }
    }
    else
    {
        param_ptr = (l4crac_dereg_req_struct*)construct_local_para((kal_uint16) sizeof(l4crac_dereg_req_struct), TD_RESET);
        param_ptr->src_id = src_id;
        param_ptr->is_poweroff = KAL_TRUE;
        param_ptr->service = CS_PS_DOMAIN;
        l4c_send_msg_to_rac(MSG_ID_L4CRAC_DEREG_REQ, param_ptr);
        l4c_set_user_action(L4C_RAC, src_id, SYS_SEL);
    }
    
    return KAL_TRUE;
#else
    return KAL_FALSE;
#endif /* __SYSSEL_SUPPORT__ */
}


/*****************************************************************************
 * FUNCTION
 *  l4c_nw_get_csg_list_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
kal_bool l4c_nw_get_csg_list_req(kal_uint8 src_id, kal_uint8 *oper, kal_uint8 rat)
{
#if defined(__CSG_SUPPORT__)
    l4crac_csg_list_req_struct *param_ptr;

    if (is_rac_cmd_conflict(src_id, CSG_TEST) == KAL_TRUE)
    {
        return KAL_FALSE;
    }

    // CSG list only support for 3G
    if (rat == RAT_GSM || l4crac_get_rat_mode() == RAT_GSM)
    {
        return KAL_FALSE;
    }

    param_ptr = (l4crac_csg_list_req_struct*)construct_local_para((kal_uint16) sizeof(l4crac_csg_list_req_struct), TD_RESET);

    if (oper != NULL)
    {
        plmn_convert_to_struct(oper, &param_ptr->plmn_id_rat);
    }
    else
    {
        kal_mem_set(&(param_ptr->plmn_id_rat.plmn_id), 0x0F, 6);
    }

    param_ptr->plmn_id_rat.rat = rat;
    param_ptr->src_id = src_id;

    l4c_send_msg_to_rac(MSG_ID_L4CRAC_CSG_LIST_REQ, param_ptr);

    l4c_set_user_action(L4C_RAC, src_id, CSG_TEST);
    return KAL_TRUE;
#else
    return KAL_FALSE;
#endif
}

/*****************************************************************************
 * FUNCTION
 *  l4c_nw_abort_csg_list_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
kal_bool l4c_nw_abort_csg_list_req(kal_uint8 src_id)
{
#if defined(__CSG_SUPPORT__)
    l4crac_csg_list_stop_req_struct *param_ptr;

    // Only abort CSG list when CSG_TEST is ongoing
    if (L4C_PTR->rac_current_action != CSG_TEST
        || (L4C_PTR->rac_current_action == CSG_TEST && L4C_PTR->rac_user != src_id))
    {
        kal_trace(TRACE_WARNING, WARNING_ABORT_PLMN_LIST_REQ_CMD_CONFLICT);
        return KAL_FALSE;
    }

    param_ptr = (l4crac_csg_list_stop_req_struct*)
        construct_local_para((kal_uint16) sizeof(l4crac_csg_list_stop_req_struct), TD_RESET);

    param_ptr->src_id = src_id;

    l4c_send_msg_to_rac(MSG_ID_L4CRAC_CSG_LIST_STOP_REQ, param_ptr);

    l4c_set_user_action(L4C_RAC, src_id, CSG_TEST_STOP);

    return KAL_TRUE;
#else
    return KAL_FALSE;
#endif

}

/*****************************************************************************
 * FUNCTION
 *  l4c_nw_abort_csg_list_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
kal_bool l4c_nw_csg_attach_req(kal_uint8 src_id, kal_uint8 *oper, kal_uint32 csg_id, kal_uint8 rat)
{
#if defined(__CSG_SUPPORT__)
    l4crac_plmn_search_req_struct *param_ptr;

    if (is_rac_cmd_conflict(src_id, COPS_EXE) == KAL_TRUE)
    {
        return KAL_FALSE;
    }

    // CSG list only support for 3G
    if (rat == RAT_GSM || l4crac_get_rat_mode() == RAT_GSM)
    {
        return KAL_FALSE;
    }

    param_ptr = (l4crac_plmn_search_req_struct*) construct_local_para((kal_uint16) sizeof(l4crac_plmn_search_req_struct), TD_RESET);

    plmn_convert_to_struct(oper, &param_ptr->plmn_id);
    param_ptr->src_id = src_id;
    param_ptr->factory_mode_arfcn = 0xFFFF;
    param_ptr->plmn_reselection_mode = MANUAL_RESELECTION;
    param_ptr->plmn_id.rat = rat;
    param_ptr->preference = 0;
    param_ptr->is_manual_csg_sel = KAL_TRUE;
    param_ptr->csg_id = csg_id;
    
    l4c_send_msg_to_rac(MSG_ID_L4CRAC_PLMN_SEARCH_REQ, param_ptr);

    l4c_set_user_action(L4C_RAC, src_id, COPS_EXE);
    return KAL_TRUE;
#else
    return KAL_FALSE;
#endif
}

/*****************************************************************************
 * FUNCTION
 *  l4c_nw_set_csg_auto_search_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 *  band        [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_set_csg_auto_search_req(kal_uint8 src_id, kal_bool is_enable)
{
#ifdef __CSG_SUPPORT__
    l4cas_csg_auto_search_req_struct *param_ptr1; 

    l4crac_set_csg_auto_search_preference(is_enable);

    param_ptr1 = (l4cas_csg_auto_search_req_struct*)construct_local_para((kal_uint16) sizeof(l4cas_csg_auto_search_req_struct), TD_RESET);    
    param_ptr1->is_enabled = is_enable;

    msg_send5(l4c_current_mod_id, L4_MODULE(MOD_RRM, l4c_current_mod_id - MOD_L4C), 
           AS_L4C_SAP, MSG_ID_L4CAS_CSG_AUTO_SEARCH_REQ, (local_para_struct*) param_ptr1);

#ifdef __UMTS_RAT__
#ifdef __GEMINI__
    if (l4c_current_mod_id == MOD_L4C)
#endif
    {
        l4cas_csg_auto_search_req_struct *param_ptr2; 

        param_ptr2 = (l4cas_csg_auto_search_req_struct*)construct_local_para((kal_uint16) sizeof(l4cas_csg_auto_search_req_struct), TD_RESET);
        param_ptr2->is_enabled = is_enable;

        msg_send5(l4c_current_mod_id, MOD_CSCE, AS_L4C_SAP, 
                MSG_ID_L4CAS_CSG_AUTO_SEARCH_REQ, (local_para_struct*) param_ptr2);
    }	
    #endif

    return KAL_TRUE;
#else
    return KAL_FALSE;
#endif
}

/*****************************************************************************
 * FUNCTION
 *  l4c_nw_get_csg_auto_search_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 *  band        [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_get_csg_auto_search_req(kal_uint8 src_id, kal_bool *is_enable)
{
#ifdef __CSG_SUPPORT__
   *is_enable = l4crac_get_csg_auto_search_preference();
#endif
   return KAL_TRUE;
}

#ifdef __GEMINI__

/*****************************************************************************
 * FUNCTION
 *  l4c_nw_sim_mode_switch_start_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_nw_sim_mode_switch_start_req(kal_uint8 src_id)
{
    L4C_COMM_PTR->during_sim_mode_switch = KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_nw_sim_mode_switch_stop_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_nw_sim_mode_switch_stop_req(kal_uint8 src_id)
{
    L4C_COMM_PTR->during_sim_mode_switch = KAL_FALSE;
}

#endif /* __GEMINI__ */ 

/*****************************************************************************
 * FUNCTION
 *  l4c_nw_set_monitor_peer_pch_req
 * DESCRIPTION
 *
 * PARAMETERS
 *  on_off      [IN]
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_nw_set_monitor_peer_pch_req(kal_bool on_off)
{
#ifdef __GEMINI_MONITOR_PAGE_DURING_TRANSFER__
    rsvas_monitor_peer_pch_switch_req_struct *para_ptr = NULL;

    para_ptr = (rsvas_monitor_peer_pch_switch_req_struct*) construct_local_para(
        (kal_uint16) sizeof(rsvas_monitor_peer_pch_switch_req_struct), TD_RESET);

    para_ptr->is_turn_on = on_off;
    l4c_send_msg_to_rsvas(MSG_ID_RSVAS_MONITOR_PEER_PCH_SWITCH_REQ, para_ptr);

    l4crac_set_peer_gprs_transfer_preference(on_off); //save to NVRAM and RAC context
#endif
    return;
}

/*****************************************************************************
 * FUNCTION
 *  l4c_nw_get_monitor_peer_pch_req
 * DESCRIPTION
 *
 * PARAMETERS
 *  on_off      [OUT]
 * RETURNS
 *  void
 *****************************************************************************/
kal_bool l4c_nw_get_monitor_peer_pch_req(kal_bool *on_off)
{
#ifdef __GEMINI_MONITOR_PAGE_DURING_TRANSFER__
    *on_off = l4crac_get_peer_gprs_transfer_preference();

    return KAL_TRUE;
#else
    return KAL_FALSE;
#endif
}

/*****************************************************************************
 * FUNCTION
 *  l4c_nw_efun_state_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id          [IN]        
 *  cfun_state      [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_efun_state_req(kal_uint8 src_id, kal_uint8 efun_state)
{
#if defined(__GEMINI__)
    return l4c_root_nw_efun_state_req(src_id, efun_state);
#else
    return KAL_FALSE;
#endif
}


#if defined(__ENS_RAT_BALANCING__) && defined(__UMTS_RAT__)
/*****************************************************************************
 * FUNCTION
 *  l4c_nw_check_ef_rat_mode()
 * DESCRIPTION
 *  
 * PARAMETERS
 *  NONE        
 * RETURNS
 *  l4c_rat_enum the target RAT
 *****************************************************************************/
l4c_rat_enum l4c_nw_check_ef_rat_mode(void)
{
    /* according to <CDR-ENS-440> if EF-RAT mode is not present, 
       the terminal shall reset its RAT to "Dual Mode" in 2G/3G UE, 
       and to "Tri-Mode" in 2/G/3G/4G UE
    */
    l4c_rat_enum rat_mode = L4C_RAT_GSM_UMTS;
    l4c_context_struct *l4c_ptr = L4C_PTR;

    if (l4c_ptr->is_valid_ef_rat_mode)
    {
        switch(l4c_ptr->ef_rat_mode)
        {
            case 0x01: // 2G only
                rat_mode = L4C_RAT_GSM;
                break;
            case 0x02: // 3G only
                rat_mode = L4C_RAT_UMTS;
                break;
            case 0x00: // Dual mode
            default:   // All RAT
                rat_mode = L4C_RAT_GSM_UMTS;
                break;
        }
    }

    if (l4c_current_mod_id != MOD_L4C)
    {
        rat_mode = L4C_RAT_GSM;
    }

    return rat_mode;
}
#endif /* __ENS_RAT_BALANCING__ && __UMTS_RAT__ */


#if defined(__NO_PSDATA_SEND_SCRI__) || defined(__FAST_DORMANCY__)
/*****************************************************************************
 * FUNCTION
 *  l4c_nw_set_fd_mode_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]  
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_set_fd_mode_req(kal_uint8 src_id, kal_uint8 mode)
{
    l4c_context_struct *l4c_ptr = L4C_PTR;

    if (mode == l4c_ptr->fast_dormancy_mode)
    {
//        kal_prompt_trace(l4c_current_mod_id, "[FD] mode not changed");
        return KAL_TRUE;
    }
    else if (mode == 0)
    {
        /* stop monitor */
        if (l4c_ptr->fd_event != 0)
        {
            //kal_brief_trace(TRACE_INFO, INFO_CANCEL_EVENT, L4C_PTR->event_id[3]);
            evshed_cancel_event(l4c_ptr->event_scheduler_ptr, &(l4c_ptr->fd_event));
            l4c_ptr->fd_event = 0;
        }
        l4c_ptr->fd_timer_counter = 0;
    }
    else if (mode == 1)
    {
        /* start monitor */
        l4c_fd_start_monitor_timer(L4C_SRC);
    }
    else
    {
        /* unexpected parameter */
        return KAL_FALSE;
    }
    
    l4c_ptr->fast_dormancy_mode = mode;
    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_nw_get_fd_mode_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  kal_uint8
 *****************************************************************************/
kal_uint8 l4c_nw_get_fd_mode_req(void)
{
    return L4C_PTR->fast_dormancy_mode;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_fd_set_screen_status
 * DESCRIPTION
 *  
 * PARAMETERS
 *  status  0: off, 1: on
 * RETURNS
 *  kal_bool
 *****************************************************************************/
kal_bool l4c_fd_set_screen_status(kal_bool is_screen_on)
{
    L4C_PTR->is_screen_on = is_screen_on;
    
    return KAL_TRUE;
}

#endif /* defined(__NO_PSDATA_SEND_SCRI__) || defined(__FAST_DORMANCY__) */


#if defined(__2STAGE_NW_SELECTION__)
/*****************************************************************************
 * FUNCTION
 *  l4c_nw_susp_resum_update_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  mode    [IN]
 *  action  [IN]
 * RETURNS
 *  kal_bool
 *****************************************************************************/
kal_bool l4c_nw_susp_resum_update_req(l4c_source_id_enum src_id, kal_uint8 data, kal_uint8 action)
{
    l4crac_susp_resu_update_req_struct *param_ptr = NULL;
    kal_bool ret_val = KAL_FALSE;

    param_ptr = (l4crac_susp_resu_update_req_struct*) construct_local_para(
               (kal_uint16)sizeof(l4crac_susp_resu_update_req_struct), TD_RESET);

    param_ptr->src_id = src_id;

    if (action == 0)
    {
        param_ptr->action = SUSP_RESU_MODE_CHANGE;
        param_ptr->mode = data;
        l4c_send_msg_to_rac(MSG_ID_L4CRAC_SUSP_RESU_UPDATE_REQ, param_ptr);
        ret_val = KAL_TRUE;
    }
    else if (action == 1)
    {
        param_ptr->action = SUSP_RESU_RESUME_REQ;
        param_ptr->susp_id = data;
        l4c_send_msg_to_rac(MSG_ID_L4CRAC_SUSP_RESU_UPDATE_REQ, param_ptr);
        ret_val = KAL_TRUE;
    }
    else
    {
        free_local_para((local_para_struct*) param_ptr);
    }
    
    return ret_val;
}
#endif /* defined(__2STAGE_NW_SELECTION__) */

#ifdef __UE_EFOPLMN__
/*****************************************************************************
 * FUNCTION
 *  l4c_nw_set_preferred_oper_list_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  no_etnry    [IN]
 *  oper        [IN]         
 *  rat         [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_nw_set_preferred_oper_list_req(kal_uint8 *ver_no, kal_uint8 no_entry, kal_uint8 *oper, kal_uint8 *rat)
{
    l4crac_ue_oplmn_update_req_struct *param_ptr;
    kal_uint8 count = 0;
    kal_uint8 i;
    kal_bool ret_val = KAL_TRUE;

    param_ptr = (l4crac_ue_oplmn_update_req_struct*)
        construct_local_para((kal_uint16) sizeof(l4crac_ue_oplmn_update_req_struct), TD_RESET);

    kal_mem_cpy(param_ptr->ue_oplmn_ver, ver_no, sizeof(param_ptr->ue_oplmn_ver));
    param_ptr->oplmn_data = get_ctrl_buffer(no_entry * 5);
    param_ptr->no_oplmn_entry = no_entry;

    for (i=0; i<no_entry; i++)
    {
        count = plmn_convert_to_bcd((oper + (i*7)), (param_ptr->oplmn_data + (i*5)));
        if (count > MAX_PLMN_BCD_LEN)
        {
            ret_val = KAL_FALSE;
            break;
        }

        if (rat[i] == L4C_RAT_GSM)
        {
            *(param_ptr->oplmn_data + (i*5) + 3) = 0;
            *(param_ptr->oplmn_data + (i*5) + 4) = 0x80;
        }
        else if (rat[i] == L4C_RAT_UMTS)
        {
            *(param_ptr->oplmn_data + (i*5) + 3) = 0x80;
            *(param_ptr->oplmn_data + (i*5) + 4) = 0;
        }
        else if (rat[i] == L4C_RAT_GSM_UMTS)
        {
            *(param_ptr->oplmn_data + (i*5) + 3) = 0x80;
            *(param_ptr->oplmn_data + (i*5) + 4) = 0x80;
        }
        else
        {
            *(param_ptr->oplmn_data + (i*5) + 3) = 0;
            *(param_ptr->oplmn_data + (i*5) + 4) = 0;
        }
    }

    if (ret_val == KAL_TRUE)
    {
        l4c_send_msg_to_rac(MSG_ID_L4CRAC_UE_OPLMN_UPDATE_REQ, param_ptr);
    }
    
    return ret_val;
}
#endif /* #ifdef __UE_EFOPLMN__ */

#endif /* __MOD_RAC__ */ 

