/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 * L4C_SIM_CMD.C
 *
 * Project:
 * --------
 *   MT6208
 *
 * Description:
 * ------------
 *   This file is intends for ...
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/********************************************************************************
*  Copyright Statement:
*  --------------------
*
*  This product has been developed using a protocol stack
*  developed by Sasken Communication Technologies Limited.
*
********************************************************************************/

#define L4C_SIM_CMD_C
#ifdef __MOD_SMU__
#include "kal_public_defs.h" //MSBB change #include "stack_msgs.h"
//#include "app_ltlcom.h" /* Task message communiction */
#include "ps2sim_struct.h"
#include "sim_common_enums.h"
#include "smu_common_enums.h"
#include "mcd_l4_common.h"
#include "l4c_common_enum.h"
#include "l4c_context.h"
#include "layer4_context.h"
#include "l4c_sendmsg.h"
#include "mcd_l3_inc_struct.h"
#if defined(__MMI_FMI__)
#include "mmi_msgid.h"
#endif
#include "l4_msgid.h"
#include "sim_ps_msgid.h"
#include "sim_public_msgid.h"
#ifdef __MOD_SMU__
#include "ps2sat_struct.h"
#endif 
#include "l4c2smu_struct.h"
#include "l4c_common_enum.h"
#include "ps2sat_struct.h"
#include "l4c2csm_cc_struct.h"
#include "l4c2smsal_struct.h"
#include "ps2sat_struct.h"
#include "mcd_ps2sat_peer.h"
#include "l3_inc_enums.h"
#include "l4c_utility.h"
#include "l4c_sim_cmd.h"
#include "mcd.h"
#include "l4a.h"
#ifdef __RSAT__
#include "l4c_rsat_msg_struct.h"
#endif
#include "l4c2rac_struct.h"
#include "l4_trc.h"
#include "smsal_l4c_enum.h"
#include "kal_public_defs.h" //MSBB change #include "stack_config.h"
#include "l4crac_enums.h"
#include "kal_trace.h"
#include "ps_public_struct.h"
#include "kal_general_types.h"
#include "ps_public_enum.h"
#include "kal_public_api.h"
#include "l4c_ciss_cmd.h"

#include "custom_nvram_extra.h"
#include "sim_ps_enum.h"

#if defined(__GEMINI__) && defined(__SIM_ME_LOCK__)
#include "l4c_root.h"
#endif

#include "nvram_struct.h"
#include "nvram_msgid.h"

extern void l4csmu_get_chv_info_status(sim_chv_info_struct *chv_info, sim_chv_status_struct *chv_status);
extern void smsal_decode_cbsdcs(
                kal_uint8 dcs,
                kal_uint8 *lang_type,
                smsal_dcs_enum *alphabet_type,
                smsal_msg_class_enum *msg_class,
                kal_bool *is_compress,
                kal_bool *is_reserved);


/*****************************************************************************
 * FUNCTION
 *  l4c_smu_get_iccid_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id          [IN]        
 *  iccid_string     [?]         
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_smu_get_iccid_req(kal_uint8 src_id, kal_uint8 *iccid_str)
{
    if (L4C_PTR->sim_detected == KAL_TRUE)
    {
        kal_uint8 iccid[11];
        kal_uint8 i,j=0;
        kal_uint8 ch1, ch2;

        (*pSmuSecurityInfog->query_a)(SMU_ICCID_A, iccid, NUM_OF_BYTE_ICCID, (l4c_current_mod_id - MOD_L4C));

        iccid[10] = 0xFF;
        
        for (i=0; i<10; i++)
        {
            ch1 = iccid[i] & 0x0f;
            ch2 = (iccid[i] & 0xf0) >> 4;
        
            iccid_str[j] = get_ch_byte_raw(ch1, CONVERT_TO_DIGIT_NORMAL);
            iccid_str[j+1] = get_ch_byte_raw(ch2, CONVERT_TO_DIGIT_NORMAL);
        
            j += 2;
        }
        iccid_str[20] = '\0';

        return KAL_TRUE;
    }
    else
    {
        return KAL_FALSE;
    }
}

/*****************************************************************************
 * FUNCTION
 *  l4c_smu_get_imsi_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id          [IN]        
 *  imsi_string     [?]         
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_smu_get_imsi_req(kal_uint8 src_id, kal_uint8 *imsi_string)
{
    if (L4C_PTR->sim_detected == KAL_TRUE)
    {
        kal_uint8 imsi[9];

        l4csmu_get_imsi((kal_uint8*) imsi);
        imsi[8] = 0xff;

        convert_to_digit((kal_uint8*) imsi, imsi_string);

        return KAL_TRUE;
    }
    else
    {
        return KAL_FALSE;
    }
}


/*****************************************************************************
 * FUNCTION
 *  l4c_smu_exe_lock_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 *  opcode      [IN]        
 *  type        [IN]        
 *  passwd      [?]         
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_smu_exe_lock_req(kal_uint8 src_id, kal_uint8 opcode, kal_uint8 type, kal_uint8 *passwd)
{
    l4csmu_security_req_struct *param_ptr;

    if (is_smu_cmd_conflict(src_id, CLCK_EXE) == KAL_TRUE)
    {
        //return KAL_FALSE;
        if (src_id == LMMI_SRC)
        {
            /* Johnny: special case for SIM refresh, L4C do not send msg to MMI by L4A, MMI will display "Please Try Later" */
        #if defined(__MMI_FMI__)
            mmi_smu_lock_rsp_struct *p = construct_local_para(sizeof(mmi_smu_lock_rsp_struct), 0);

            p->result = KAL_FALSE;
            p->cause = TYPE_UNSPECIFIED;
            l4a_sendmsg_ilm(l4c_current_mod_id, MOD_MMI, MSG_ID_MMI_SMU_LOCK_RSP, p);
        #endif /* defined(__MMI_FMI__) */ 
            return KAL_TRUE;
        }
        else
        {
            return KAL_FALSE;
        }
    }


    param_ptr = (l4csmu_security_req_struct*)
        construct_local_para((kal_uint16) sizeof(l4csmu_security_req_struct), TD_RESET);

    param_ptr->src_id = src_id;
    param_ptr->type = type;
    param_ptr->op = opcode;

    if (type == TYPE_CHV1 || type == TYPE_CHV2)
    {
        l4c_sim_pin_convert((kal_uint8*) param_ptr->key1, (kal_uint8*) passwd);
    }
    else
    {
        convert_to_bcd(passwd, (kal_uint8*) param_ptr->key1, SML_MAX_SUPPORT_KEY_LEN);
    }

    /* only allow lock/unlock operation, no query */
    l4c_send_msg_to_smu(MSG_ID_L4CSMU_SECURITY_REQ, param_ptr);

   l4c_set_user_action(L4C_SMU, src_id, CLCK_EXE);
    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_smu_exe_master_reset_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 *  pin         [?]         
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_smu_exe_master_reset_req(kal_uint8 src_id, kal_uint8 *pin)
{
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif	
    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_smu_exe_dial_mode_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 *  type        [IN]        
 *  on_off      [IN]        
 *  pin         [?]         
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_smu_exe_dial_mode_req(kal_uint8 src_id, kal_uint8 type, kal_uint8 on_off, kal_uint8 *pin)
{
    l4csmu_security_req_struct *param_ptr;
    l4csmu_dial_mode_req_struct *param1_ptr;

    if (is_smu_cmd_conflict(src_id, XDN_EXE) == KAL_TRUE)
    {
        return KAL_FALSE;
    }


    param1_ptr = (l4csmu_dial_mode_req_struct*)
        construct_local_para((kal_uint16) sizeof(l4csmu_dial_mode_req_struct), TD_RESET);

    param1_ptr->src_id = src_id;
    param1_ptr->dn_type = type;
    param1_ptr->switch_on = on_off;

    if (src_id == LMMI_SRC)
    {
        l4c_send_msg_to_smu(MSG_ID_L4CSMU_DIAL_MODE_REQ, param1_ptr);
    }
    else
    {
        param_ptr = (l4csmu_security_req_struct*)
            construct_local_para((kal_uint16) sizeof(l4csmu_security_req_struct), TD_RESET);

        param_ptr->src_id = src_id;
        param_ptr->type = TYPE_CHV2;
        param_ptr->op = VERIFY;

        l4c_sim_pin_convert((kal_uint8*) param_ptr->key1, (kal_uint8*) pin);

        l4c_send_msg_to_smu(MSG_ID_L4CSMU_SECURITY_REQ, param_ptr);

        L4C_PTR->parameter[src_id].length = sizeof(l4csmu_dial_mode_req_struct);
        L4C_PTR->parameter[src_id].data = param1_ptr;
    }

    l4c_set_user_action(L4C_SMU, src_id, XDN_EXE);    
    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_smu_get_dial_mode_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  dial_mode       [?]     
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_smu_get_dial_mode_req( /* sim_dn_enum */ kal_uint8 *dial_mode)
{
    *dial_mode = l4csmu_get_dial_mode();
    return KAL_TRUE;

}


/*****************************************************************************
 * FUNCTION
 *  l4c_smu_exe_verify_pin_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id          [IN]        
 *  pin_type        [IN]        
 *  pin             [?]         
 *  new_pin         [?]         
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_smu_exe_verify_pin_req(kal_uint8 src_id, kal_uint8 pin_type, kal_uint8 *pin, kal_uint8 *new_pin)
{
    l4csmu_security_req_struct *param_ptr;
    kal_uint8 type, opcode = VERIFY;
    kal_bool sim_type = KAL_FALSE;
    smu_pending_password_id_enum pending_password_id;

    if (is_smu_cmd_conflict(src_id, CPIN_EXE) == KAL_TRUE)
    {
        /* Johnny: special case for SIM refresh, L4C do not send msg to MMI by L4A, MMI will display "Please Try Later" */
    #if defined(__MMI_FMI__)
        if (src_id == LMMI_SRC)
        {
            mmi_smu_verify_pin_rsp_struct *p = construct_local_para(sizeof(mmi_smu_verify_pin_rsp_struct), 0);

            p->result = KAL_FALSE;
            p->next_type = TYPE_UNSPECIFIED;
            l4a_sendmsg_ilm(l4c_current_mod_id, MOD_MMI, MSG_ID_MMI_SMU_VERIFY_PIN_RSP, p);
            return KAL_TRUE;
        }
    #endif /* defined(__MMI_FMI__) */ 
    
        return KAL_FALSE;
    }

    pending_password_id = l4csmu_get_pending_password_id();

    if (pin_type == TYPE_UNSPECIFIED)
    {
        if (l4csmu_get_pending_lock(pending_password_id, &type) == KAL_FALSE)
        {
            return KAL_FALSE;
        }
        else
        {
            if ((pending_password_id == ID_SIM_PIN1) || (pending_password_id == ID_SIM_PUK1))
            {
                sim_type = KAL_TRUE;
                if (pending_password_id == ID_SIM_PUK1)
                {
                    opcode = UNBLOCK;
                }
            }
        }
    }
    else
    {
        L4C_PTR->power_on_pin_check = KAL_FALSE;
	
        if (pin_type==TYPE_CHV1 || pin_type==TYPE_UBCHV1)
        {
            if (pending_password_id==ID_SIM_PIN1 || pending_password_id==ID_SIM_PUK1)
            {
                L4C_PTR->power_on_pin_check = KAL_TRUE;	 
            }
        }

        if (pin_type == TYPE_UBCHV1)
        {
            opcode = UNBLOCK;
            type = TYPE_CHV1;
            sim_type = KAL_TRUE;
        }
        else if (pin_type == TYPE_UBCHV2)
        {
            opcode = UNBLOCK;
            type = TYPE_CHV2;
            sim_type = KAL_TRUE;
        }
        else if (pin_type == TYPE_CHV1 || pin_type == TYPE_CHV2)
        {
            type = pin_type;
            sim_type = KAL_TRUE;
        }
        else
        {
            type = pin_type;
        }
    }

    if ((opcode==VERIFY || opcode==UNBLOCK)  && type == TYPE_CHV1)
    {
        if (L4C_PTR->sub_modules_ready == KAL_FALSE)
        {
            kal_uint8 id;
            for (id = LMMI_SRC; id < RMMI_ALL + 1; id++)
            {
                if (L4C_PTR->cc_current_action[id] != L4C_NO_ACTION && L4C_PTR->cc_current_action[id] != POWERON_EXE)
                {
                    return KAL_FALSE;
                }
            }
        }
    }

    param_ptr = (l4csmu_security_req_struct*)
        construct_local_para((kal_uint16) sizeof(l4csmu_security_req_struct), TD_RESET);

    param_ptr->src_id = src_id;
    param_ptr->type = type;
    param_ptr->op = opcode;

    if (sim_type == KAL_FALSE)
    {
        convert_to_bcd(pin, (kal_uint8*) param_ptr->key1, SML_MAX_SUPPORT_KEY_LEN);
    }
    else
    {
        l4c_sim_pin_convert((kal_uint8*) param_ptr->key1, (kal_uint8*) pin);
    }

    if (opcode == UNBLOCK)
    {
        if (sim_type == KAL_FALSE)
        {
            convert_to_bcd(new_pin, (kal_uint8*) param_ptr->key2, SML_MAX_SUPPORT_KEY_LEN);
        }
        else
        {
            l4c_sim_pin_convert((kal_uint8*) param_ptr->key2, (kal_uint8*) new_pin);

        }
    }

    l4c_send_msg_to_smu(MSG_ID_L4CSMU_SECURITY_REQ, param_ptr);

    if (type == TYPE_CHV2)
    {
        l4c_set_user_action(L4C_SMU, src_id, CPIN2_EXE);     /* MAUI_02388637 */
    }
    else
    {
        l4c_set_user_action(L4C_SMU, src_id, CPIN_EXE); 
    }
    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_smu_get_pin_type_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 *  name        [?]         
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_smu_get_pin_type_req(kal_uint8 src_id, kal_uint8 *name)
{
    if (L4C_PTR->sim_detected == KAL_FALSE)
    {
        return KAL_FALSE;
    }

    *name = l4csmu_get_pending_password_id();
#if defined(__GEMINI__) && defined(__SIM_ME_LOCK__)
    if ((*name == ID_PH_FSIM_PIN) || 
        (*name == ID_PH_NET_PIN) || 
        (*name == ID_PH_NETSUB_PIN) ||
        (*name == ID_PH_SP_PIN) || 
        (*name == ID_PH_CORP_PIN) || 
        (*name == ID_PH_LINK_NS_SP_PIN) || 
        (*name == ID_PH_LINK_SIM_C_PIN))
    {
        /* link_SML cheat AP by l4c root */
        *name = l4c_root_get_pending_password_id(l4c_current_mod_id - MOD_L4C);
    }
#endif

    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_smu_file_idx_for_preferred_oper_list
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
sim_file_index_enum l4c_smu_file_idx_for_preferred_oper_list(sim_file_index_enum selected_file)
{
    kal_bool is_ef_plmn = KAL_FALSE;
    kal_bool is_ef_uplmn = KAL_FALSE;
    kal_bool is_ef_oplmn = KAL_FALSE;
    kal_bool is_ef_hplmn = KAL_FALSE;
    kal_uint16 number;

    if (selected_file == FILE_NONE)  // get any file if avaliable
    {
        is_ef_plmn = l4csmu_read_plmn_sel(FILE_PLMNSEL_IDX, 0, &number, NULL);
        is_ef_uplmn = l4csmu_read_plmn_sel(FILE_PLMNWACT_IDX, 0, &number, NULL);
        is_ef_oplmn = l4csmu_read_plmn_sel(FILE_OPLMNWACT_IDX, 0, &number, NULL);
        is_ef_hplmn = l4csmu_read_plmn_sel(FILE_HPLMNACT_IDX, 0, &number, NULL);

        if (is_ef_uplmn == KAL_TRUE)
        {
            return FILE_PLMNWACT_IDX;
        }
        else if (is_ef_plmn == KAL_TRUE)
        {
            return FILE_PLMNSEL_IDX;
        }
        else if (is_ef_oplmn == KAL_TRUE)
        {
            return FILE_OPLMNWACT_IDX;
        }
        else if (is_ef_hplmn == KAL_TRUE)
        {
            return FILE_HPLMNACT_IDX;
        }
    }
    else    // check specific file available or not
    {
        if (l4csmu_read_plmn_sel(selected_file, 0, &number, NULL) == KAL_TRUE)
        {
            return selected_file;
        }
    }

    return FILE_NONE;
}

/*****************************************************************************
 * FUNCTION
 *  l4c_smu_set_preferred_oper_list_req_ext
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 *  index       [IN]        
 *  opcode      [IN]        
 *  oper        [?]         
 *  rat         [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_smu_set_preferred_oper_list_req_ext(
            kal_uint8 src_id,
            sim_file_index_enum file_idx,
            kal_uint8 index,
            kal_uint8 opcode,
            kal_uint8 *oper,
            kal_uint8 rat)
{
    l4csmu_plmn_sel_write_req_struct *param_ptr;
    kal_uint8 count = 0;

    kal_brief_trace(TRACE_INFO, INFO_L4C_PREFER_PLMN_FILE, file_idx);

    if (file_idx == FILE_NONE)
    {
        file_idx = l4c_smu_file_idx_for_preferred_oper_list(FILE_NONE);
    }

    if (file_idx == FILE_NONE || file_idx == FILE_OPLMNWACT_IDX || file_idx == FILE_HPLMNACT_IDX)
    {
        kal_brief_trace(TRACE_WARNING, WARNING_WRITE_FILE_FAIL);
        kal_brief_trace(TRACE_INFO, INFO_L4C_PREFER_PLMN_FILE, file_idx);
        return KAL_FALSE;
    }
    else if (file_idx == FILE_PLMNWACT_IDX)
    {
        if (rat == L4C_RAT_NONE)
        {
            if (src_id == LMMI_SRC)
            {
                rat = L4C_RAT_NONE;
            }
            else
            {
                rat = L4C_RAT_GSM_UMTS; /* default value for AT */
            }
        }
    }

    if (is_smu_cmd_conflict(src_id, CPOL_EXE) == KAL_TRUE)
    {
        return KAL_FALSE;
    }

    param_ptr = (l4csmu_plmn_sel_write_req_struct*)
        construct_local_para((kal_uint16) sizeof(l4csmu_plmn_sel_write_req_struct), TD_RESET);

    param_ptr->src_id = src_id;
    param_ptr->idx = index;
    param_ptr->op = opcode;
    param_ptr->file_idx = file_idx;

    if (oper != NULL)
    {
        count = plmn_convert_to_bcd(oper, (kal_uint8*) param_ptr->plmn_data);
        if (count > MAX_PLMN_BCD_LEN)
        {
            ASSERT(0);
        }

        if (file_idx == FILE_PLMNWACT_IDX)
        {
            if (rat == L4C_RAT_GSM)
            {
                param_ptr->plmn_data[3] = 0;
                param_ptr->plmn_data[4] = 0x80;
            }
            else if (rat == L4C_RAT_UMTS)
            {
                param_ptr->plmn_data[3] = 0x80;
                param_ptr->plmn_data[4] = 0;
            }
            else if (rat == L4C_RAT_GSM_UMTS)
            {
                param_ptr->plmn_data[3] = 0x80;
                param_ptr->plmn_data[4] = 0x80;
            }
	     else
	     {
                param_ptr->plmn_data[3] = 0;
                param_ptr->plmn_data[4] = 0;	     
	     }
        }
    }
    else
    {
        if (file_idx == FILE_PLMNWACT_IDX)
        {
            kal_mem_set(param_ptr->plmn_data, 0xff, 3);
            kal_mem_set(&(param_ptr->plmn_data[3]), 0x00, 2);
        }
        else
        {
            kal_mem_set(param_ptr->plmn_data, 0xff, 3);
        }
    }

    l4c_send_msg_to_smu(MSG_ID_L4CSMU_PLMN_SEL_WRITE_REQ, param_ptr);

    l4c_set_user_action(L4C_SMU, src_id, CPOL_EXE);    
    return KAL_TRUE;
}

/*****************************************************************************
 * FUNCTION
 *  l4c_smu_set_preferred_oper_list_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 *  index       [IN]        
 *  opcode      [IN]        
 *  oper        [?]         
 *  rat         [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_smu_set_preferred_oper_list_req(
            kal_uint8 src_id,
            kal_uint8 index,
            kal_uint8 opcode,
            kal_uint8 *oper,
            kal_uint8 rat)
{
    return l4c_smu_set_preferred_oper_list_req_ext(
                        src_id,
                        FILE_NONE,
                        index,
                        opcode,
                        oper,
                        rat);
}


/*****************************************************************************
 * FUNCTION
 *  l4c_smu_get_preferred_oper_list_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id              [IN]        
 *  index               [IN]        
 *  file_idx_req        [IN]        
 *  num                 [?]         
 *  oper_list           [?]         
 *  rat_list            [?]         
 *  file_idx_rsp        [?]         
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_smu_get_preferred_oper_list_req(
            kal_uint8 src_id,
            kal_uint8 index,
            kal_uint16 file_idx_req,
            kal_uint16 *num,
            kal_uint8 *oper_list,
            kal_uint8 *rat_list,
            kal_uint16 *file_idx_rsp)
{
    smu_plmn_id_struct *list;
    plmn_id_rat_struct plmn_id;
    kal_uint16 i;
    kal_bool ret_val;

    kal_brief_trace(TRACE_INFO, INFO_L4C_PREFER_PLMN_FILE, file_idx_req);

    if ((kal_uint16) (sizeof(smu_plmn_id_struct) * (*num)) >= 2048)
    {
        ASSERT(0);
    }

    if (file_idx_req == FILE_NONE)
    {
        file_idx_req = l4c_smu_file_idx_for_preferred_oper_list(FILE_NONE);
        kal_brief_trace(TRACE_INFO, INFO_L4C_PREFER_PLMN_FILE, file_idx_req);

        *file_idx_rsp = file_idx_req;

        if (file_idx_req == FILE_NONE)
        {
            return KAL_TRUE;
        }
    }
    else
    {
        *file_idx_rsp = file_idx_req;
    }

    if ((oper_list == NULL) || (rat_list == NULL))
    {
        list = NULL;
    }
    else
    {
        list = (smu_plmn_id_struct*) get_ctrl_buffer((kal_uint16) (sizeof(smu_plmn_id_struct) * (*num)));
    }

    ret_val = l4csmu_read_plmn_sel((sim_file_index_enum)file_idx_req, index, num, (smu_plmn_id_struct*) list);

    if (src_id < RMMI_SRC)
    {
        if (*num > MAX_SUPPORT_EF_PLMNSEL_REC)
        {
            *num = MAX_SUPPORT_EF_PLMNSEL_REC;
        }
    }

    if ((oper_list != NULL) && (rat_list != NULL))
    {
        /* convert bcd back to string */
        for (i = 0; i < *num; i++)
        {
            plmn_id.plmn_id.mcc1 = list[i].mcc1;
            plmn_id.plmn_id.mcc2 = list[i].mcc2;
            plmn_id.plmn_id.mcc3 = list[i].mcc3;
            plmn_id.plmn_id.mnc1 = list[i].mnc1;
            plmn_id.plmn_id.mnc2 = list[i].mnc2;
            plmn_id.plmn_id.mnc3 = list[i].mnc3;

            plmn_convert_to_digit(&(plmn_id.plmn_id), oper_list);
            oper_list[6] = 0;
            oper_list += 7;
            rat_list[2 * i] = list[i].access_tech[0];
            rat_list[2 * i + 1] = list[i].access_tech[1];
        }
        free_ctrl_buffer(list);
    }

    return ret_val;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_smu_set_puc_params_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id          [IN]        
 *  pin             [?]         
 *  currency        [?]         
 *  ppu             [?]         
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_smu_set_puc_params_req(kal_uint8 src_id, kal_uint8 *pin, kal_uint8 *currency, kal_uint8 *ppu)
{
#ifdef __AOC_SUPPORT__
    l4csmu_puct_write_req_struct *param1_ptr;

    if (is_smu_cmd_conflict(src_id, CPUC_EXE) == KAL_TRUE)
    {
        return KAL_FALSE;
    }

    param1_ptr = (l4csmu_puct_write_req_struct*)
        construct_local_para((kal_uint16) sizeof(l4csmu_puct_write_req_struct), TD_RESET);

    param1_ptr->src_id = src_id;

    kal_mem_cpy((kal_uint8*) param1_ptr->currency_code, currency, 3);
    kal_mem_cpy((kal_uint8*) param1_ptr->puct_data, ppu, 18);

    if ((src_id == LMMI_SRC) || (pin == NULL))
    {
        l4c_send_msg_to_smu(MSG_ID_L4CSMU_PUCT_WRITE_REQ, param1_ptr);
    }
    else
    {
        l4csmu_security_req_struct *param_ptr;

        param_ptr = (l4csmu_security_req_struct*)
            construct_local_para((kal_uint16) sizeof(l4csmu_security_req_struct), TD_RESET);

        param_ptr->src_id = src_id;
        param_ptr->type = TYPE_CHV2;
        param_ptr->op = VERIFY;

        l4c_sim_pin_convert((kal_uint8*) param_ptr->key1, (kal_uint8*) pin);


        l4c_send_msg_to_smu(MSG_ID_L4CSMU_SECURITY_REQ, param_ptr);

        L4C_PTR->parameter[src_id].length = sizeof(l4csmu_puct_write_req_struct);
        L4C_PTR->parameter[src_id].data = param1_ptr;
    }

    l4c_set_user_action(L4C_SMU, src_id, CPUC_EXE);
    return KAL_TRUE;
#else
    return KAL_FALSE;
#endif
}


/*****************************************************************************
 * FUNCTION
 *  l4c_smu_get_puc_params_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id          [IN]        
 *  currency        [?]         
 *  ppu             [?]         
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_smu_get_puc_params_req(kal_uint8 src_id, kal_uint8 *currency, kal_uint8 *ppu)
{
#ifdef __AOC_SUPPORT__
    kal_bool ret_val;

    ret_val = l4csmu_get_puct_value(currency, ppu);
    if (ret_val == KAL_FALSE)
    {
        kal_trace(TRACE_WARNING, WARNING_EFPUCT_IS_NOT_VALID);
        return KAL_FALSE;
    }

    if (currency[0] == 0xff && currency[1] == 0xff  && currency[2] == 0xff )//kitty
    {
        currency[0] = 0x00;
        currency[1] = 0x00;
        currency[2] = 0x00;
    }

    return KAL_TRUE;
#else
    return KAL_FALSE;
#endif    
}


/*****************************************************************************
 * FUNCTION
 *  l4c_smu_exe_change_password_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 *  type        [IN]        
 *  old         [?]         
 *  new1        [?]         
 *  new2        [?]         
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_smu_exe_change_password_req(
            kal_uint8 src_id,
            kal_uint8 type,
            kal_uint8 *old,
            kal_uint8 *new1,
            kal_uint8 *new2)
{
    l4csmu_security_req_struct *param_ptr;
    kal_uint8 count = 0;

    if (is_smu_cmd_conflict(src_id, CPWD_EXE) == KAL_TRUE)
    {
        return KAL_FALSE;
    }

    param_ptr = (l4csmu_security_req_struct*)
        construct_local_para((kal_uint16) sizeof(l4csmu_security_req_struct), TD_RESET);

    param_ptr->src_id = src_id;
    param_ptr->type = type;
    param_ptr->op = CHANGE;

    if (type == TYPE_CHV1 || type == TYPE_CHV2)
    {
        l4c_sim_pin_convert((kal_uint8*) param_ptr->key1, (kal_uint8*) old);
    }
    else
    {
        count = convert_to_bcd(old, (kal_uint8*) param_ptr->key1, SML_MAX_SUPPORT_KEY_LEN);
    }

    if (count >= MAX_SIM_PASSWD_BCD_LEN)
    {
        /* error */
    }

    if (type == TYPE_CHV1 || type == TYPE_CHV2)
    {
        l4c_sim_pin_convert((kal_uint8*) param_ptr->key2, (kal_uint8*) new1);
    }
    else
    {
        count = convert_to_bcd(new1, (kal_uint8*) param_ptr->key2, SML_MAX_SUPPORT_KEY_LEN);
    }

    l4c_send_msg_to_smu(MSG_ID_L4CSMU_SECURITY_REQ, param_ptr);

    l4c_set_user_action(L4C_SMU, src_id, CPWD_EXE);
    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_smu_exe_restricted_access_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 *  cmd         [IN]        
 *  file_id     [IN]        
 *  channel     [IN]
 *  p1          [IN]        
 *  p2          [IN]        
 *  p3          [IN]        
 *  data        [?]         
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_smu_exe_restricted_access_req(
            kal_uint8 src_id,
            kal_uint8 cmd,
            kal_uint16 file_id,
            kal_uint8 channel,
            kal_uint8 p1,
            kal_uint8 p2,
            kal_uint8 p3,
            kal_uint8 *data,
            kal_uint8 *pathid,
            kal_uint8 pathid_length)
{
    l4csmu_sim_access_req_struct *param_ptr;

//    if (is_smu_cmd_conflict(src_id, CRSM_EXE) == KAL_TRUE)
//    {
//        return KAL_FALSE;
//    }

    param_ptr = (l4csmu_sim_access_req_struct*)
        construct_local_para((kal_uint16) sizeof(l4csmu_sim_access_req_struct), TD_RESET);

    param_ptr->src_id = src_id;
    param_ptr->cmd = cmd;
    param_ptr->fileid = file_id;
    param_ptr->channel_id = channel; 
    param_ptr->p1 = p1;
    param_ptr->p2 = p2;
    param_ptr->p3 = p3;

    kal_mem_cpy(param_ptr->data, data, 256);
    kal_mem_cpy(param_ptr->pathid, pathid, 4);
    param_ptr->pathid_length = pathid_length;

    l4c_send_msg_to_smu(MSG_ID_L4CSMU_SIM_ACCESS_REQ, param_ptr);

//    l4c_set_user_action(L4C_SMU, src_id, CRSM_EXE);
    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_smu_write_sim_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id          [IN]        
 *  file_idx        [IN]        
 *  para            [IN]        
 *  data            [?]         
 *  length          [IN]        
 *  path            [?]         
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_smu_write_sim_req(
            kal_uint8 src_id,
            kal_uint16 file_idx,
            kal_uint8 para,
            kal_uint8 *data,
            kal_uint16 length,
            kal_uint8 *path,
            kal_uint8 access_id)  
{
    sim_write_req_struct *param_ptr;

    param_ptr = (sim_write_req_struct*) construct_local_para((kal_uint16) sizeof(sim_write_req_struct), TD_RESET);

    param_ptr->file_idx = file_idx;
    param_ptr->para = para;
    //param_ptr->access_id = src_id; 
    param_ptr->access_id = access_id; 
    param_ptr->src_id = src_id; 
    param_ptr->length = length;

    if (length>255) //mtk02480 add		
    {
        ASSERT(0);  
    }
    kal_mem_cpy(param_ptr->data + 5, data, length); /* Johnny: the first 5 bytes of data in MSG_ID_SIM_WRITE_REQ should be padded */
    if (param_ptr->path != NULL)
    {
        kal_mem_cpy(param_ptr->path, path, 6);
    }

    l4c_send_msg_to_sim(MSG_ID_SIM_WRITE_REQ, param_ptr, NULL);
    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_smu_read_sim_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id          [IN]        
 *  file_idx        [IN]        
 *  para            [IN]        
 *  length          [IN]        
 *  path            [?]         
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_smu_read_sim_req(
            kal_uint8 src_id,
            kal_uint16 file_idx,
            kal_uint16 para,
            kal_uint16 length,
            kal_uint8 *path,
            kal_uint8 access_id)  
{
    sim_read_req_struct *param_ptr;

    param_ptr = (sim_read_req_struct*) construct_local_para((kal_uint16) sizeof(sim_read_req_struct), TD_RESET);

    param_ptr->file_idx = file_idx;
    param_ptr->para = para;
    param_ptr->length = length;
    //param_ptr->access_id = src_id;  
    param_ptr->access_id = access_id; 
    param_ptr->src_id = src_id; 
    if (path != NULL)
    {
        kal_mem_cpy(param_ptr->path, path, 6);
    }

    l4c_send_msg_to_sim(MSG_ID_SIM_READ_REQ, param_ptr, NULL);
    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_smu_read_file_info_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id          [IN]        
 *  file_idx        [IN]        
 *  path            [?]         
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_smu_read_file_info_req(kal_uint8 src_id, kal_uint16 file_idx, kal_uint8 *path, kal_uint8 access_id) 
{
    sim_file_info_req_struct *param_ptr;

    param_ptr = (sim_file_info_req_struct*)
        construct_local_para((kal_uint16) sizeof(sim_file_info_req_struct), TD_RESET);

    param_ptr->file_idx = file_idx;
    param_ptr->access_id = access_id;  
    param_ptr->src_id = src_id; 
    if (param_ptr->path != NULL)
    {
        kal_mem_cpy(param_ptr->path, path, 6);
    }

#if defined(__OP01__)
    if (src_id >= RMMI_SRC)
    {
        if (is_smu_cmd_conflict(src_id, SPN_EXE) == KAL_TRUE)
        {
            return KAL_FALSE;
        }

        l4c_set_user_action(L4C_SMU, src_id, SPN_EXE);
    }
#endif

    l4c_send_msg_to_sim(MSG_ID_SIM_FILE_INFO_REQ, param_ptr, NULL);
    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_smu_set_personalization_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id          [IN]        
 *  category        [IN]        
 *  op              [IN]        
 *  key             [?]         
 *  len             [IN]        
 *  data            [?]         
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_smu_set_personalization_req(
            kal_uint8 src_id,
            kal_uint8 category,
            kal_uint8 op,
            kal_uint8 key[SML_MAX_SUPPORT_KEY_LEN*2+1],
            kal_uint8 len,
            kal_uint8 data[10])
{
#ifdef __SIM_ME_LOCK__
    l4csmu_set_personalization_req_struct *param_ptr;
    kal_uint8 null_teminated_key[SML_MAX_SUPPORT_KEY_LEN*2+1];

    //kal_uint8 valid_bcd_imsi;

    param_ptr = (l4csmu_set_personalization_req_struct*)
        construct_local_para((kal_uint16) sizeof(l4csmu_set_personalization_req_struct), TD_RESET);

    param_ptr->category = category;
    param_ptr->op = op;

    kal_mem_set(null_teminated_key, 0, SML_MAX_SUPPORT_KEY_LEN*2+1);
    kal_mem_cpy(null_teminated_key, key, SML_MAX_SUPPORT_KEY_LEN*2);

    kal_mem_set(param_ptr->key, 0xff, SML_MAX_SUPPORT_KEY_LEN);

    convert_to_bcd(null_teminated_key, param_ptr->key, SML_MAX_SUPPORT_KEY_LEN);

    param_ptr->len = len;
    param_ptr->src_id = src_id;
    kal_mem_cpy(param_ptr->data, data, 10);

    l4c_send_msg_to_smu(MSG_ID_L4CSMU_SET_PERSONALIZATION_REQ, param_ptr);
    return KAL_TRUE;
#else
    return KAL_FALSE;
#endif
}


/*****************************************************************************
 * FUNCTION
 *  l4c_smu_sml_status_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_smu_sml_status_req(kal_uint8 src_id)
{
#ifdef __SIM_ME_LOCK__
    l4csmu_sml_status_req_struct *param_ptr;

    param_ptr = (l4csmu_sml_status_req_struct*)
        construct_local_para((kal_uint16) sizeof(l4csmu_sml_status_req_struct), TD_RESET);

    param_ptr->src_id = src_id;

    l4c_send_msg_to_smu(MSG_ID_L4CSMU_SML_STATUS_REQ, param_ptr);

    return KAL_TRUE;
#else    
    return KAL_FALSE;
#endif
}


/*****************************************************************************
 * FUNCTION
 *  l4c_sim_power_off_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_sim_power_off_req(kal_uint8 src_id)
{
    l4c_send_msg_to_sim(MSG_ID_SIM_POWEROFF_REQ, NULL, NULL);
    return KAL_TRUE;
}

#if defined(__SIM_UT__)
/*****************************************************************************
 * FUNCTION
 *  l4c_sim_remove_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 *  mode        [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_sim_remove_req(kal_uint8 src_id, kal_uint8 mode)
{
    sim_error_test_req_struct *param_ptr;

    param_ptr = (sim_error_test_req_struct*)
        construct_local_para((kal_uint16) sizeof(sim_error_test_req_struct), TD_RESET);

    param_ptr->switch_mode = mode;

    l4c_send_msg_to_sim(MSG_ID_SIM_ERROR_TEST_REQ, param_ptr, NULL);
    return KAL_TRUE;
}
#endif

/*****************************************************************************
 * FUNCTION
 *  l4c_sim_get_gsmcdma_dualsim_info_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id        [IN]     
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_sim_get_gsmcdma_dualsim_info_req (kal_uint8 src_id)
{
#ifdef __GSMCDMA_DUALSIM__    
    l4c_sim_get_gsmcdma_dualsim_info_req_struct*param_ptr;

    param_ptr = (l4c_sim_get_gsmcdma_dualsim_info_req_struct *)
                        construct_local_para(
                        (kal_uint16)sizeof(l4c_sim_get_gsmcdma_dualsim_info_req_struct), TD_RESET);
    
    param_ptr->src_id = src_id;

    l4c_send_msg_to_sim (MSG_ID_L4C_SIM_GET_GSMCDMA_DUALSIM_INFO_REQ,
                        param_ptr, NULL);    
#endif   
		return KAL_TRUE;
}
/*****************************************************************************
 * FUNCTION
 *  l4c_sim_set_gsmcdma_dualsim_mode_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id        [IN]     
 *  op             [IN]     
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_sim_set_gsmcdma_dualsim_mode_req ( kal_uint8 src_id, kal_uint8 op)
{
#ifdef __GSMCDMA_DUALSIM__
    l4c_sim_set_gsmcdma_dualsim_mode_req_struct*param_ptr;

    param_ptr = (l4c_sim_set_gsmcdma_dualsim_mode_req_struct *)
                        construct_local_para(
                        (kal_uint16)sizeof(l4c_sim_set_gsmcdma_dualsim_mode_req_struct), TD_RESET);
    
    param_ptr->op = op;
    param_ptr->src_id = src_id;
    
    l4c_send_msg_to_sim (MSG_ID_L4C_SIM_SET_GSMCDMA_DUALSIM_MODE_REQ,
                        param_ptr, NULL);
#endif
    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_sim_check_pin_status_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  chv_info        [?]     
 *  chv_status      [?]     
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_sim_check_pin_status_req(sim_chv_info_struct *chv_info, sim_chv_status_struct *chv_status)
{
    if (L4C_PTR->sim_detected == KAL_FALSE)
    {
        return KAL_FALSE;
    }

    l4csmu_get_chv_info_status(chv_info, chv_status);
    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_sim_pin_convert
 * DESCRIPTION
 *  
 * PARAMETERS
 *  dest        [?]     
 *  src         [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_sim_pin_convert(kal_uint8 *dest, kal_uint8 *src)
{
    kal_uint8 idx = 0;

    for (idx = 0; idx < (MAX_SIM_PASSWD_LEN - 1); idx++)
    {
        if (src[idx] == 0x00)
        {
            while (idx < (MAX_SIM_PASSWD_LEN - 1))
            {
                dest[idx] = 0xFF;
                idx++;
            }
            break;
        }
        else
        {
            dest[idx] = src[idx];
        }
    }

}

/*****************************************************************************
 * FUNCTION
 *  l4c_sim_reset_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *    
 * RETURNS
 *  void
 *****************************************************************************/
kal_bool l4c_sim_reset_req(kal_uint8 src_id)
{
    sim_reset_req_struct*param_ptr;

    param_ptr = (sim_reset_req_struct *)construct_local_para((kal_uint16)sizeof(sim_reset_req_struct), TD_RESET);

    param_ptr->src_id = src_id;

    l4c_send_msg_to_sim(MSG_ID_SIM_RESET_REQ, param_ptr, NULL);
    return KAL_TRUE;
}

/*****************************************************************************
 * FUNCTION
 *  l4c_sim_read_plmn_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_sim_read_plmn_req(kal_uint8 src_id, kal_uint8 access_id, kal_uint16 file_idx)
{
   sim_read_plmn_req_struct *param_ptr;

   param_ptr = (sim_read_plmn_req_struct*)construct_local_para((kal_uint16) sizeof(sim_read_plmn_req_struct), TD_RESET);

   param_ptr->file_idx = file_idx;
   param_ptr->access_id = access_id;
   param_ptr->state= 0; /* Not read after update */
   param_ptr->src_id = src_id;  
   
   l4c_send_msg_to_sim(MSG_ID_SIM_READ_PLMN_REQ, param_ptr, NULL);
}

/*****************************************************************************
 * FUNCTION
 *  l4c_sim_write_plmn_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_sim_write_plmn_req(kal_uint8 src_id, kal_uint8 access_id, kal_uint16 file_idx, kal_uint16 file_size, kal_uint8 *file)
{
   sim_write_plmn_req_struct *param_ptr;

   param_ptr = (sim_write_plmn_req_struct*)construct_local_para((kal_uint16) sizeof(sim_write_plmn_req_struct), TD_RESET);

   param_ptr->file_idx = file_idx;
   param_ptr->file_size = file_size;
   param_ptr->access_id = access_id;
   param_ptr->src_id = src_id;  

  if (file_size > MAX_SUPPORT_PLMN_DATA_SIZE)
  {
      ASSERT(0); /* should not exceed than max plmn file size */ 
  }
  
  kal_mem_cpy(param_ptr->file,file,file_size);

  l4c_send_msg_to_sim(MSG_ID_SIM_WRITE_PLMN_REQ, param_ptr, NULL);
}


/*****************************************************************************
 * FUNCTION
 *  l4c_sim_search_record_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_sim_search_record_req(kal_uint8 src_id,kal_uint16 file_idx, kal_uint16 para, kal_uint8 access_id,  kal_uint8 *path,kal_uint8 pattern_len,kal_uint8 *data)
{
#if defined(__SIM_SEARCH_RECORD_SUPPORT__)/* MAUI_02953154 */
    sim_search_record_req_struct *param_ptr;

    param_ptr = (sim_search_record_req_struct*)construct_local_para((kal_uint16) sizeof(sim_search_record_req_struct), TD_RESET);

    param_ptr->file_idx = file_idx;
    param_ptr->para = para;
    param_ptr->access_id = access_id;
    param_ptr->src_id = src_id;  
    param_ptr->pattern_len = pattern_len;
	
    kal_mem_cpy(param_ptr->path,path,6);
    kal_mem_cpy(param_ptr->data,data,MAX_SUPPORT_RECORD_SIZE+6);

    l4c_send_msg_to_sim(MSG_ID_SIM_SEARCH_RECORD_REQ, param_ptr, NULL);
#endif    
}

//mtk02514_nfc
#if defined(__CSIM__) || defined(__CGLA__)
/*****************************************************************************
 * FUNCTION
 *  l4c_sim_apdu_access_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
 kal_bool l4c_sim_apdu_access_req(kal_uint8 src_id,l4c_action_enum action, kal_uint16 length, kal_uint8 *command,kal_uint8 channel_id)
{
/* MAUI_03082391 */
    sim_apdu_access_req_struct *param_ptr;

    if (is_smu_cmd_conflict(src_id, action) == KAL_TRUE)
   {
   	return KAL_FALSE;
   }

    l4c_set_user_action(L4C_SMU, src_id, action);

    param_ptr = (sim_apdu_access_req_struct*)
            construct_local_para((kal_uint16) sizeof(sim_apdu_access_req_struct), TD_RESET);
   
   param_ptr->src_id = src_id;  
   param_ptr->req_len = length;   
    param_ptr->channel_id = channel_id;    
   kal_mem_cpy(param_ptr->req, command, length);
   
    l4c_send_msg_to_sim(MSG_ID_SIM_APDU_ACCESS_REQ, param_ptr, NULL);

   return KAL_TRUE;
}
#endif

#ifdef __UICC_CHANNEL_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  l4c_sim_manage_channel_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
 kal_bool l4c_sim_manage_channel_req(
        kal_uint8 src_id,
        l4c_action_enum action,
        sim_manage_channel_mode_enum op,
        kal_uint8 req_len, kal_uint8 *req)
{
    sim_manage_channel_req_struct *param_ptr;

    if (is_smu_cmd_conflict(src_id, action) == KAL_TRUE)
    {
        return KAL_FALSE;
    }

    l4c_set_user_action(L4C_SMU, src_id, action);

    param_ptr = (sim_manage_channel_req_struct*)
            construct_local_para((kal_uint16) sizeof(sim_manage_channel_req_struct), TD_RESET);

    param_ptr->src_id = src_id;
    param_ptr->op = op;
    param_ptr->req_len = req_len;
    kal_mem_cpy(param_ptr->req, req, req_len);
   
    l4c_send_msg_to_sim(MSG_ID_SIM_MANAGE_CHANNEL_REQ, param_ptr, NULL);

   return KAL_TRUE;
}

#endif

/*****************************************************************************
 * FUNCTION
 *  l4c_bt_sim_profile_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *    
 * RETURNS
 *  void
 *****************************************************************************/
kal_bool l4c_bt_sim_profile_req(kal_uint8 src_id, kal_uint8 action, kal_uint8 transport_protocol_type, kal_uint8 *apdu, kal_uint16 length)
{
#if !defined(__MMI_FMI__) && defined(__BT_SIM_PROFILE__)
    switch (action)
    {
    	case 0:  /* Connect */
		{
		    bt_sim_connect_req_struct *param_ptr;

		    param_ptr = (bt_sim_connect_req_struct *)construct_local_para((kal_uint16)sizeof(bt_sim_connect_req_struct), TD_RESET);
		    param_ptr->src_id = src_id;

		    l4c_send_msg_to_sim(MSG_ID_BT_SIM_CONNECT_REQ, param_ptr, NULL);	
		    break;
		}
    	case 1:  /* Disconnect */
		{
		    bt_sim_disconnect_req_struct *param_ptr;

		    param_ptr = (bt_sim_disconnect_req_struct *)construct_local_para((kal_uint16)sizeof(bt_sim_disconnect_req_struct), TD_RESET);
		    param_ptr->src_id = src_id;

		    l4c_send_msg_to_sim(MSG_ID_BT_SIM_DISCONNECT_REQ, param_ptr, NULL);	
		    break;
		}		
    	case 2:  /* PowerOn */
		{
		    bt_sim_power_on_req_struct *param_ptr;

		    param_ptr = (bt_sim_power_on_req_struct *)construct_local_para((kal_uint16)sizeof(bt_sim_power_on_req_struct), TD_RESET);
		    param_ptr->src_id = src_id;
		    param_ptr->transport_protocol_type = transport_protocol_type;

		    l4c_send_msg_to_sim(MSG_ID_BT_SIM_POWER_ON_REQ, param_ptr, NULL);	
		    break;
		}	
    	case 3:  /* PowerOff */
		{
		    bt_sim_power_off_req_struct *param_ptr;

		    param_ptr = (bt_sim_power_off_req_struct *)construct_local_para((kal_uint16)sizeof(bt_sim_power_off_req_struct), TD_RESET);
		    param_ptr->src_id = src_id;

		    l4c_send_msg_to_sim(MSG_ID_BT_SIM_POWER_OFF_REQ, param_ptr, NULL);	
		    break;
		}	
    	case 4:  /* Reset */
		{
		    bt_sim_reset_req_struct *param_ptr;

		    param_ptr = (bt_sim_reset_req_struct *)construct_local_para((kal_uint16)sizeof(bt_sim_reset_req_struct), TD_RESET);
		    param_ptr->src_id = src_id;
		    param_ptr->transport_protocol_type = transport_protocol_type;

		    l4c_send_msg_to_sim(MSG_ID_BT_SIM_RESET_REQ, param_ptr, NULL);	
		    break;
		}
    	case 5:  /* APDU */
		{
		    bt_sim_apdu_req_struct *param_ptr;

		    param_ptr = (bt_sim_apdu_req_struct *)construct_local_para((kal_uint16)sizeof(bt_sim_apdu_req_struct), TD_RESET);
		    param_ptr->src_id = src_id;
		    param_ptr->transport_protocol_type = transport_protocol_type;

	           param_ptr->apdu_req_len = length;
	           if (param_ptr->apdu_req_len > APDU_REQ_MAX_LEN*2)
	           {
	           		kal_trace(TRACE_WARNING, WARNING_L4C_ERROR);
	           		return KAL_FALSE;
	           }
		    kal_mem_cpy(param_ptr->apdu_req, apdu, param_ptr->apdu_req_len);
			
		    l4c_send_msg_to_sim(MSG_ID_BT_SIM_APDU_REQ, param_ptr, NULL);	
		    break;
		}		
	default:
		return KAL_FALSE;
    }
#endif
    return KAL_TRUE;	
}


#ifdef __VSIM__ 
/*****************************************************************************
 * FUNCTION
 *  l4c_sim_vsim_req
 * DESCRIPTION
 *   Enable/Disable Virtual SIM mode
 * PARAMETERS
 *  dest        [?]     
 *  src         [?]     
 * RETURNS
 *  void
 *****************************************************************************/
kal_bool l4c_sim_vsim_req(kal_uint8 src_id, kal_uint8 switch_on)
{
    l4c_sim_set_vsim_mode_req_struct *param_ptr;

    if (is_current_rac_activated() != KAL_TRUE)
    {
        return KAL_FALSE;
    }

    param_ptr = (l4c_sim_set_vsim_mode_req_struct*)
        construct_local_para((kal_uint16) sizeof(l4c_sim_set_vsim_mode_req_struct), TD_RESET);

    param_ptr->src_id= src_id;
    param_ptr->switch_on= switch_on;
	
    l4c_send_msg_to_sim(MSG_ID_L4C_SIM_SET_VSIM_MODE_REQ, param_ptr, NULL);	
    return KAL_TRUE;
}
#endif

/*****************************************************************************
 * FUNCTION
 *  l4c_sim_authenticate_req
 * DESCRIPTION
 * PARAMETERS
 *  dest        [?]     
 *  src         [?]     
 * RETURNS
 *  void
 *****************************************************************************/
kal_bool l4c_sim_authenticate_req(kal_uint8 src_id, kal_uint8 rand_len, kal_uint8 *rand, kal_uint8 auth_len, kal_uint8 *auth)
{   
#if !defined(__MMI_FMI__) || defined(__EAUTH_SUPPORT__)
    sim_authenticate_req_struct *param_ptr;

    param_ptr = (sim_authenticate_req_struct*)
        construct_local_para((kal_uint16) sizeof(sim_authenticate_req_struct), TD_RESET);

    if (rand_len > 16 || auth_len > 16)
    {
        ASSERT(0);
    }

    param_ptr->src_id = src_id;
    kal_mem_cpy(param_ptr->rand, rand, rand_len);

    if (auth_len > 0)
    {
        param_ptr->is_auth_present = KAL_TRUE;
        kal_mem_cpy(param_ptr->auth, auth, auth_len);
    }
    else
    {
        param_ptr->is_auth_present = KAL_FALSE;
    }

    l4c_send_msg_to_sim(MSG_ID_SIM_AUTHENTICATE_REQ, param_ptr, NULL);
    return KAL_TRUE;
#else
    return KAL_FALSE;
#endif
}

/*****************************************************************************
 * FUNCTION
 *  l4c_smu_sml_ready_notify_req
 * DESCRIPTION
 * PARAMETERS
 *  dest        [?]     
 *  src         [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_smu_sml_ready_notify_req(void)
{   
#ifdef WISDOM_MMI
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #ifdef __MOD_RAC__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #endif /* __MOD_RAC__ */ 
/* under construction !*/
/* under construction !*/
#endif
    return;
}

#ifdef __SAT__


/*****************************************************************************
 * FUNCTION
 *  l4c_sat_dspl_text_res
 * DESCRIPTION
 *  
 * PARAMETERS
 *  local_ptr       [?]     
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_sat_dspl_text_res(sat_dspl_text_res_struct *local_ptr)
{
    sat_dspl_text_res_struct *param_ptr;

    param_ptr = (sat_dspl_text_res_struct*)
        construct_local_para((kal_uint16) sizeof(sat_dspl_text_res_struct), TD_RESET);

    kal_mem_cpy(param_ptr->cmd_detail, local_ptr->cmd_detail, 5);
    param_ptr->res = local_ptr->res;
    param_ptr->additional_info = local_ptr->additional_info;

    l4c_send_msg_to_sim(MSG_ID_SAT_DSPL_TEXT_RES, param_ptr, NULL);
    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_sat_get_inkey_res
 * DESCRIPTION
 *  
 * PARAMETERS
 *  local_ptr       [?]     
 *  peer_ptr        [?]     
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_sat_get_inkey_res(sat_get_inkey_res_struct *local_ptr, sat_get_inkey_res_peer_struct *peer_ptr)
{
    sat_get_inkey_res_struct *param_ptr;
    sat_get_inkey_res_peer_struct *param1 = NULL;

    param_ptr = (sat_get_inkey_res_struct*)
        construct_local_para((kal_uint16) sizeof(sat_get_inkey_res_struct), TD_RESET);

    kal_mem_cpy(param_ptr->cmd_detail, local_ptr->cmd_detail, 5);
    param_ptr->res = local_ptr->res;
    param_ptr->is_yes_selected = local_ptr->is_yes_selected;

    L4C_PACK_ALLOC(
        sat_get_inkey_res_peer_struct_alloc,
        MCD_SAT_GET_INKEY_RES_PEER_STRUCT,
        sat_get_inkey_res_peer_struct,
        param1);

    param1->no_text_string = peer_ptr->no_text_string;
    param1->dcs_of_text_string = peer_ptr->dcs_of_text_string;
    if (peer_ptr->no_text_string > 0)
    {
        kal_mem_cpy(param1->text_string, peer_ptr->text_string, param1->no_text_string);
    }

    l4c_send_msg_to_sim(MSG_ID_SAT_GET_INKEY_RES, param_ptr, (kal_uint8*) param1);

    L4C_PACK_DEALLOC(sat_get_inkey_res_peer_struct_dealloc, param1);

    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_sat_get_input_res
 * DESCRIPTION
 *  
 * PARAMETERS
 *  local_ptr       [?]     
 *  peer_ptr        [?]     
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_sat_get_input_res(sat_get_input_res_struct *local_ptr, sat_get_input_res_peer_struct *peer_ptr)
{
    sat_get_input_res_struct *param_ptr;
    sat_get_input_res_peer_struct *param1 = NULL;

    param_ptr = (sat_get_input_res_struct*)
        construct_local_para((kal_uint16) sizeof(sat_get_input_res_struct), TD_RESET);

    kal_mem_cpy(param_ptr->cmd_detail, local_ptr->cmd_detail, 5);
    param_ptr->res = local_ptr->res;

    L4C_PACK_ALLOC(
        sat_get_input_res_peer_struct_alloc,
        MCD_SAT_GET_INPUT_RES_PEER_STRUCT,
        sat_get_input_res_peer_struct,
        param1);

    param1->no_text_string = peer_ptr->no_text_string;
    param1->dcs_of_text_string = peer_ptr->dcs_of_text_string;
    if (peer_ptr->no_text_string > 0)
    {
        kal_mem_cpy(param1->text_string, peer_ptr->text_string, param1->no_text_string);
    }

    l4c_send_msg_to_sim(MSG_ID_SAT_GET_INPUT_RES, param_ptr, (kal_uint8*) param1);

    L4C_PACK_DEALLOC(sat_get_input_res_peer_struct_dealloc, param1);

    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_sat_setup_menu_res
 * DESCRIPTION
 *  
 * PARAMETERS
 *  local_ptr       [?]     
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_sat_setup_menu_res(sat_setup_menu_res_struct *local_ptr)
{
    sat_setup_menu_res_struct *param_ptr;

    param_ptr = (sat_setup_menu_res_struct*)
        construct_local_para((kal_uint16) sizeof(sat_setup_menu_res_struct), TD_RESET);

    kal_mem_cpy(param_ptr->cmd_detail, local_ptr->cmd_detail, 5);
    param_ptr->res = local_ptr->res;

    l4c_send_msg_to_sim(MSG_ID_SAT_SETUP_MENU_RES, param_ptr, NULL);
    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_sat_select_item_res
 * DESCRIPTION
 *  
 * PARAMETERS
 *  local_ptr       [?]     
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_sat_select_item_res(sat_select_item_res_struct *local_ptr)
{
    sat_select_item_res_struct *param_ptr;

    param_ptr = (sat_select_item_res_struct*)
        construct_local_para((kal_uint16) sizeof(sat_select_item_res_struct), TD_RESET);

    kal_mem_cpy(param_ptr->cmd_detail, local_ptr->cmd_detail, 5);
    param_ptr->res = local_ptr->res;
    param_ptr->item_id = local_ptr->item_id;

    l4c_send_msg_to_sim(MSG_ID_SAT_SELECT_ITEM_RES, param_ptr, NULL);
    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_sat_play_tone_res
 * DESCRIPTION
 *  
 * PARAMETERS
 *  local_ptr       [?]     
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_sat_play_tone_res(sat_play_tone_res_struct *local_ptr)
{
    sat_play_tone_res_struct *param_ptr;

    param_ptr = (sat_play_tone_res_struct*)
        construct_local_para((kal_uint16) sizeof(sat_play_tone_res_struct), TD_RESET);

    kal_mem_cpy(param_ptr->cmd_detail, local_ptr->cmd_detail, 5);
    param_ptr->res = local_ptr->res;

    l4c_send_msg_to_sim(MSG_ID_SAT_PLAY_TONE_RES, param_ptr, NULL);
    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_sat_setup_call_res
 * DESCRIPTION
 *  
 * PARAMETERS
 *  local_ptr       [?]     
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_sat_setup_call_res(sat_setup_call_res_struct *local_ptr)
{

    if (L4C_PTR->cc_current_action[SAT_SRC] == SAT_ATD_EXE)

    {
        L4C_PTR->cc_current_action[SAT_SRC] = L4C_NO_ACTION;
    }

    l4c_clear_sat_redial_duration_timer_hdlr();    
    L4C_PTR->sat_redial_flag = KAL_FALSE; 
    L4C_PTR->sat_redial_duration = 0;
	
#ifdef __RSAT__
    if (L4C_PTR->parameter_sat.length != 0)
    {
        local_para_struct *local_ptr;

        local_ptr = (local_para_struct*) L4C_PTR->parameter_sat.data;
        local_ptr->ref_count = 1;       /* make sure the reference count is 1 so that when 
                                           call free locl para that pare will be freed successfull */
        free_local_para(local_ptr);
        L4C_PTR->parameter_sat.length = 0;
        L4C_PTR->parameter_sat.data = NULL;
    }
#endif
	
    l4c_send_msg_to_sim(MSG_ID_SAT_SETUP_CALL_RES, local_ptr, NULL);
    
    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_sat_send_sms_res
 * DESCRIPTION
 *  
 * PARAMETERS
 *  local_ptr       [?]     
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_sat_send_sms_res(sat_send_sms_res_struct *local_ptr)
{
    l4c_send_msg_to_sim(MSG_ID_SAT_SEND_SMS_RES, local_ptr, NULL);

#ifdef __RSAT__
    if (L4C_PTR->parameter_sat.length != 0)
    {
        local_para_struct *local_ptr;

        local_ptr = (local_para_struct*) L4C_PTR->parameter_sat.data;
        local_ptr->ref_count = 1;       /* make sure the reference count is 1 so that when 
                                           call free locl para that pare will be freed successfull */
        free_local_para(local_ptr);
        L4C_PTR->parameter_sat.length = 0;
        L4C_PTR->parameter_sat.data = NULL;
    }
#endif

    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_sat_send_ss_res
 * DESCRIPTION
 *  
 * PARAMETERS
 *  local_ptr       [?]     
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_sat_send_ss_res(sat_send_ss_res_struct *local_ptr)
{
    l4c_send_msg_to_sim(MSG_ID_SAT_SEND_SS_RES, local_ptr, NULL);

#ifdef __RSAT__
    if (L4C_PTR->parameter_sat.length != 0)
    {
        local_para_struct *local_ptr;

        local_ptr = (local_para_struct*) L4C_PTR->parameter_sat.data;
        local_ptr->ref_count = 1;       /* make sure the reference count is 1 so that when 
                                           call free locl para that pare will be freed successfull */
        free_local_para(local_ptr);
        L4C_PTR->parameter_sat.length = 0;
        L4C_PTR->parameter_sat.data = NULL;
    }
#endif

    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_sat_send_ussd_res
 * DESCRIPTION
 *  
 * PARAMETERS
 *  local_ptr       [?]     
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_sat_send_ussd_res(sat_send_ussd_res_struct *local_ptr)
{
    l4c_send_msg_to_sim(MSG_ID_SAT_SEND_USSD_RES, local_ptr, NULL);

#ifdef __RSAT__
    if (L4C_PTR->parameter_sat.length != 0)
    {
        local_para_struct *local_ptr;

        local_ptr = (local_para_struct*) L4C_PTR->parameter_sat.data;
        local_ptr->ref_count = 1;       /* make sure the reference count is 1 so that when 
                                           call free locl para that pare will be freed successfull */
        free_local_para(local_ptr);
        L4C_PTR->parameter_sat.length = 0;
        L4C_PTR->parameter_sat.data = NULL;
    }
#endif
    
    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_sat_setup_idle_dspl_res
 * DESCRIPTION
 *  
 * PARAMETERS
 *  local_ptr       [?]     
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_sat_setup_idle_dspl_res(sat_setup_idle_dspl_res_struct *local_ptr)
{
    l4c_send_msg_to_sim(MSG_ID_SAT_SETUP_IDLE_DSPL_RES, local_ptr, NULL);
    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_sat_run_at_command_res
 * DESCRIPTION
 *  
 * PARAMETERS
 *  local_ptr       [?]     
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_sat_run_at_command_res(sat_run_at_command_res_struct *local_ptr)
{
    l4c_send_msg_to_sim(MSG_ID_SAT_RUN_AT_COMMAND_RES, local_ptr, NULL);
    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_sat_send_dtmf_res
 * DESCRIPTION
 *  
 * PARAMETERS
 *  cmd_detail          [?]         
 *  res                 [IN]        
 *  additional_info     [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_sat_send_dtmf_res(kal_uint8 cmd_detail[5], kal_uint8 res, kal_uint8 additional_info)
{
    sat_send_dtmf_res_struct *local_ptr = construct_local_para((kal_uint16) sizeof(sat_send_dtmf_res_struct), 0);

    kal_mem_cpy(local_ptr->cmd_detail, cmd_detail, 5);
    local_ptr->res = res;
    local_ptr->additional_info = additional_info;

    l4c_send_msg_to_sim(MSG_ID_SAT_SEND_DTMF_RES, local_ptr, NULL);
    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_sat_lang_notify_res
 * DESCRIPTION
 *  
 * PARAMETERS
 *  local_ptr       [?]     
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_sat_lang_notify_res(sat_lang_notify_res_struct *local_ptr)
{
#ifndef __SAT_LOWCOST_UI_DISABLE__
    l4c_send_msg_to_sim(MSG_ID_SAT_LANG_NOTIFY_RES, local_ptr, NULL);
    return KAL_TRUE;
#else
    return KAL_FALSE; // temp fix to compile warning 
#endif
}


/*****************************************************************************
 * FUNCTION
 *  l4c_sat_launch_browser_res
 * DESCRIPTION
 *  
 * PARAMETERS
 *  cmd_detail                  [?]         
 *  res                         [IN]        
 *  size_of_additional_info     [IN]        
 *  additional_info             [?]         
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_sat_launch_browser_res(
            kal_uint8 cmd_detail[5],
            kal_uint8 res,
            kal_uint8 additional_res)
{
#ifndef __SAT_LOWCOST_UI_DISABLE__
    sat_launch_browser_res_struct *local_ptr = construct_local_para(
                                                (kal_uint16) sizeof(sat_launch_browser_res_struct),
                                                TD_RESET);

    kal_mem_cpy(local_ptr->cmd_detail, cmd_detail, 5);
    local_ptr->res = res;
    local_ptr->additional_res = additional_res;     /* MAUI_02888481 additional_info interface change */

    l4c_send_msg_to_sim(MSG_ID_SAT_LAUNCH_BROWSER_RES, local_ptr, NULL);
    return KAL_TRUE;
#else
    return KAL_FALSE; // temp fix to compile warning 
#endif    
}


/*****************************************************************************
 * FUNCTION
 *  l4c_sat_exe_menu_select_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  local_ptr       [?]     
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_sat_exe_menu_select_req(sat_menu_select_req_struct *local_ptr)
{
    sat_menu_select_req_struct *param_ptr;

    L4C_PTR->cc_current_action[SAT_SRC] = MENU_SEL_EXE;

    param_ptr = (sat_menu_select_req_struct*)
        construct_local_para((kal_uint16) sizeof(sat_menu_select_req_struct), TD_RESET);

    param_ptr->item_id = local_ptr->item_id;
    param_ptr->is_help_info_requested = local_ptr->is_help_info_requested;

    l4c_send_msg_to_sim(MSG_ID_SAT_MENU_SELECT_REQ, param_ptr, NULL);

    return KAL_TRUE;

}


/*****************************************************************************
 * FUNCTION
 *  l4c_sat_evdl_idle_screen_available_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_sat_evdl_idle_screen_available_req(void)
{
#ifndef __SAT_LOWCOST_UI_DISABLE__
    sat_evdl_idle_screen_available_req_struct *param_ptr;

    param_ptr = (sat_evdl_idle_screen_available_req_struct*)
        construct_local_para((kal_uint16) sizeof(sat_evdl_idle_screen_available_req_struct), TD_RESET);

    l4c_send_msg_to_sim(MSG_ID_SAT_EVDL_IDLE_SCREEN_AVAILABLE_REQ, param_ptr, NULL);
    return KAL_TRUE;
#else
    return KAL_FALSE; // temp fix to compile warning 
#endif /* __SAT_LOWCOST_UI_DISABLE__ */       
}


/*****************************************************************************
 * FUNCTION
 *  l4c_sat_evdl_language_selection_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  iso639_language     [?]     
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_sat_evdl_language_selection_req(kal_uint8 iso639_language[2])
{
#ifndef __SAT_LOWCOST_UI_DISABLE__
    sat_evdl_language_selection_req_struct *param_ptr;

    param_ptr = (sat_evdl_language_selection_req_struct*)
        construct_local_para((kal_uint16) sizeof(sat_evdl_language_selection_req_struct), TD_RESET);

    kal_mem_cpy(param_ptr->iso639_language, iso639_language, 2);
    l4c_send_msg_to_sim(MSG_ID_SAT_EVDL_LANGUAGE_SELECTION_REQ, param_ptr, NULL);
    return KAL_TRUE;
#else  
    return KAL_FALSE; // temp fix to compile warning 
#endif /* __SAT_LOWCOST_UI_DISABLE__ */     
}


/*****************************************************************************
 * FUNCTION
 *  l4c_sat_evdl_browser_termination_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  browser_termination_cause       [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_sat_evdl_browser_termination_req(kal_uint8 browser_termination_cause)
{
#ifndef __SAT_LOWCOST_UI_DISABLE__
    sat_evdl_browser_termination_req_struct *param_ptr;

    param_ptr = (sat_evdl_browser_termination_req_struct*)
        construct_local_para((kal_uint16) sizeof(sat_evdl_browser_termination_req_struct), TD_RESET);

    param_ptr->browser_termination_cause = browser_termination_cause;
    l4c_send_msg_to_sim(MSG_ID_SAT_EVDL_BROWSER_TERMINATION_REQ, param_ptr, NULL);
    return KAL_TRUE;
#else   
    return KAL_FALSE; // temp fix to compile warning 
#endif /* __SAT_LOWCOST_UI_DISABLE__ */       
}

/*****************************************************************************
 * FUNCTION
 *  l4c_sat_provide_lang_info_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  send lang info to SIM 
 * RETURNS
 *  
 *****************************************************************************/
//lexel
kal_bool l4c_sat_provide_lang_info_req(kal_uint8 *lang)
{
    sat_language_cnf_struct*param_ptr;

    param_ptr = (sat_language_cnf_struct*)construct_local_para((kal_uint16) sizeof(sat_language_cnf_struct), TD_RESET);

    kal_mem_cpy(param_ptr->language,lang,2);

    l4c_send_msg_to_sim(MSG_ID_SAT_LANGUAGE_CNF, param_ptr, NULL);

   return KAL_TRUE;	
}

/*****************************************************************************
 * FUNCTION
 *  l4c_sat_file_change_res_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  send lang info to SIM 
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_sat_file_change_res_req(kal_uint8 src_id, kal_uint8 is_successful)
{
#if defined(__SIM_FILE_CHANGE_WITH_MMI_ACK__)
    sat_file_change_res_struct *param_ptr;

    param_ptr = (sat_file_change_res_struct*)construct_local_para((kal_uint16) sizeof(sat_file_change_res_struct), TD_RESET);
    param_ptr->src_id = 2;  // 2 means response from MMI
    param_ptr->is_successful = is_successful;

    l4c_send_msg_to_sim(MSG_ID_SAT_FILE_CHANGE_RES, param_ptr, NULL);
#endif

   return KAL_TRUE;	
}

#ifdef __SATCE__


/*****************************************************************************
 * FUNCTION
 *  l4c_sat_open_channel_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  cmd_detail          [?]         
 *  res                 [IN]        
 *  additional_info     [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_sat_open_channel_req(kal_uint8 cmd_detail[5], kal_uint8 res, kal_uint8 additional_info)
{
    l4csmu_sat_open_channel_req_struct *param_ptr;

    param_ptr = (l4csmu_sat_open_channel_req_struct*)
        construct_local_para((kal_uint16) sizeof(l4csmu_sat_open_channel_req_struct), TD_RESET);

    kal_mem_cpy(param_ptr->cmd_detail, cmd_detail, 5);
    param_ptr->res = res;
    param_ptr->additional_info = additional_info;

    l4c_send_msg_to_smu(MSG_ID_L4CSMU_SAT_OPEN_CHANNEL_REQ, param_ptr);

    return KAL_TRUE;

}


/*****************************************************************************
 * FUNCTION
 *  l4c_sat_close_channel_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  cmd_detail      [?]         
 *  res             [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_sat_close_channel_req(kal_uint8 cmd_detail[5], kal_uint8 res)
{
    // abot close channel , not supported currently
    return KAL_TRUE;

}


/*****************************************************************************
 * FUNCTION
 *  l4c_sat_send_data_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  cmd_detail      [?]         
 *  res             [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_sat_send_data_req(kal_uint8 cmd_detail[5], kal_uint8 res)
{
    l4csmu_sat_send_data_req_struct *param_ptr;

    L4C_PTR->cc_current_action[SAT_SRC] = SAT_SEND_DATA_EXE;

    param_ptr = (l4csmu_sat_send_data_req_struct*)
        construct_local_para((kal_uint16) sizeof(l4csmu_sat_send_data_req_struct), TD_RESET);

    param_ptr->res = res;

    l4c_send_msg_to_smu(MSG_ID_L4CSMU_SAT_SEND_DATA_REQ, param_ptr);

    return KAL_TRUE;

}


/*****************************************************************************
 * FUNCTION
 *  l4c_sat_recv_data_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  cmd_detail      [?]         
 *  res             [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_sat_recv_data_req(kal_uint8 cmd_detail[5], kal_uint8 res)
{
    l4csmu_sat_recv_data_req_struct *param_ptr;

    L4C_PTR->cc_current_action[SAT_SRC] = SAT_RECV_DATA_EXE;

    param_ptr = (l4csmu_sat_recv_data_req_struct*)
        construct_local_para((kal_uint16) sizeof(l4csmu_sat_recv_data_req_struct), TD_RESET);
    param_ptr->res = res;

    l4c_send_msg_to_smu(MSG_ID_L4CSMU_SAT_RECV_DATA_REQ, param_ptr);

    return KAL_TRUE;

}


/*****************************************************************************
 * FUNCTION
 *  l4c_rsat_evdl_data_available_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  cmd_detail      [?]         
 *  res             [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_rsat_evdl_data_available_req(kal_uint8 channel_status[2], kal_uint8 channel_data_length)
{
    sat_evdl_data_available_req_struct *param_ptr;

    param_ptr = (sat_evdl_data_available_req_struct*)
        construct_local_para((kal_uint16) sizeof(sat_evdl_data_available_req_struct), TD_RESET);

    kal_mem_cpy(param_ptr->channel_status, channel_status, 2);
    param_ptr->channel_data_length = channel_data_length;

    l4c_send_msg_to_sim(MSG_ID_SAT_EVDL_DATA_AVAILABLE_REQ, param_ptr, NULL);
    return KAL_TRUE;
}

/*****************************************************************************
 * FUNCTION
 *  l4c_rsat_evdl_channel_status_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  cmd_detail      [?]         
 *  res             [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_rsat_evdl_channel_status_req(kal_uint8 channel_status[2])
{
    sat_evdl_channel_status_req_struct *param_ptr;

    param_ptr = (sat_evdl_channel_status_req_struct*)
        construct_local_para((kal_uint16) sizeof(sat_evdl_channel_status_req_struct), TD_RESET);

    kal_mem_cpy(param_ptr->channel_status, channel_status, 2);

    l4c_send_msg_to_sim(MSG_ID_SAT_EVDL_CHANNEL_STATUS_REQ, param_ptr, NULL);
    return KAL_TRUE;
}

/*****************************************************************************
 * FUNCTION
 *  l4c_rsat_open_gprs_channel_res
 * DESCRIPTION
 *  
 * PARAMETERS
 *  cmd_detail      [?]         
 *  res             [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_rsat_open_gprs_channel_res(kal_uint8 cmd_detail[5], 
											kal_uint8 res, 
											kal_uint8 cause, 
											kal_uint8 ch_status[2], 
											kal_uint8 bearer, 
											sat_gprs_bearer_para_struct bearer_para, 
											kal_uint16 buffer_size)
{
    sat_open_gprs_channel_res_struct *param_ptr;

    param_ptr = (sat_open_gprs_channel_res_struct*)
        construct_local_para((kal_uint16) sizeof(sat_open_gprs_channel_res_struct), TD_RESET);

    kal_mem_cpy(param_ptr->cmd_detail, cmd_detail, 5);
    param_ptr->res = res;
    param_ptr->cause = cause;
    kal_mem_cpy(param_ptr->ch_status, ch_status, 2);
    param_ptr->bearer = bearer;
    kal_mem_cpy(&param_ptr->bearer_para, &bearer_para, sizeof(sat_gprs_bearer_para_struct));	
    param_ptr->buffer_size = buffer_size;	

    l4c_send_msg_to_sim(MSG_ID_SAT_OPEN_GPRS_CHANNEL_RES, param_ptr, NULL);
    return KAL_TRUE;
}

/*****************************************************************************
 * FUNCTION
 *  l4c_rsat_open_csd_channel_res
 * DESCRIPTION
 *  
 * PARAMETERS
 *  cmd_detail      [?]         
 *  res             [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_rsat_open_csd_channel_res(kal_uint8 cmd_detail[5], 
											kal_uint8 res, 
											kal_uint8 cause, 
											kal_uint8 ch_status[2], 
											kal_uint8 bearer, 
											sat_csd_bearer_para_struct bearer_para, 
											kal_uint16 buffer_size)
{
    sat_open_csd_channel_res_struct *param_ptr;

    param_ptr = (sat_open_csd_channel_res_struct*)
        construct_local_para((kal_uint16) sizeof(sat_open_csd_channel_res_struct), TD_RESET);

    kal_mem_cpy(param_ptr->cmd_detail, cmd_detail, 5);
    param_ptr->res = res;
    param_ptr->cause = cause;
    kal_mem_cpy(param_ptr->ch_status, ch_status, 2);
    param_ptr->bearer = bearer;
    kal_mem_cpy(&param_ptr->bearer_para, &bearer_para, sizeof(sat_csd_bearer_para_struct));	
    param_ptr->buffer_size = buffer_size;	

    l4c_send_msg_to_sim(MSG_ID_SAT_OPEN_CSD_CHANNEL_RES, param_ptr, NULL);
    return KAL_TRUE;
}

/*****************************************************************************
 * FUNCTION
 *  l4c_rsat_open_server_mode_channel_res
 * DESCRIPTION
 *  
 * PARAMETERS
 *  cmd_detail      [?]         
 *  res             [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_rsat_open_server_mode_channel_res(kal_uint8 cmd_detail[5], 
											kal_uint8 res, 
											kal_uint8 cause, 
											kal_uint8 ch_status[2], 
											kal_uint8 bearer, 
											kal_uint16 buffer_size)
{
    sat_open_server_mode_channel_res_struct *param_ptr;

    param_ptr = (sat_open_server_mode_channel_res_struct*)
        construct_local_para((kal_uint16) sizeof(sat_open_server_mode_channel_res_struct), TD_RESET);

    kal_mem_cpy(param_ptr->cmd_detail, cmd_detail, 5);
    param_ptr->res = res;
    param_ptr->cause = cause;
    kal_mem_cpy(param_ptr->ch_status, ch_status, 2);
    param_ptr->bearer = bearer;	
    param_ptr->buffer_size = buffer_size;	

    l4c_send_msg_to_sim(MSG_ID_SAT_OPEN_SERVER_MODE_CHANNEL_RES, param_ptr, NULL);
    return KAL_TRUE;
}

/*****************************************************************************
 * FUNCTION
 *  l4c_rsat_close_channel_res
 * DESCRIPTION
 *  
 * PARAMETERS
 *  cmd_detail      [?]         
 *  res             [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_rsat_close_channel_res(kal_uint8 cmd_detail[5], 
											kal_uint8 res, 
											kal_uint8 cause)
{
    sat_close_channel_res_struct *param_ptr;

    param_ptr = (sat_close_channel_res_struct*)
        construct_local_para((kal_uint16) sizeof(sat_close_channel_res_struct), TD_RESET);

    kal_mem_cpy(param_ptr->cmd_detail, cmd_detail, 5);
    param_ptr->res = res;
    param_ptr->cause = cause;

    l4c_send_msg_to_sim(MSG_ID_SAT_CLOSE_CHANNEL_RES, param_ptr, NULL);
    return KAL_TRUE;
}

/*****************************************************************************
 * FUNCTION
 *  l4c_rsat_send_data_res
 * DESCRIPTION
 *  
 * PARAMETERS
 *  cmd_detail      [?]         
 *  res             [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_rsat_send_data_res(kal_uint8 cmd_detail[5], 
									kal_uint8 ch_type, 
									kal_uint8 res,
									kal_uint8 cause,
									kal_uint8 ch_data_length)						
{
    sat_send_data_res_struct *param_ptr;

    param_ptr = (sat_send_data_res_struct*)
        construct_local_para((kal_uint16) sizeof(sat_send_data_res_struct), TD_RESET);

    kal_mem_cpy(param_ptr->cmd_detail, cmd_detail, 5);
    param_ptr->ch_type = ch_type;
    param_ptr->res = res;
    param_ptr->cause = cause;
    param_ptr->ch_data_length = ch_data_length;

    l4c_send_msg_to_sim(MSG_ID_SAT_SEND_DATA_RES, param_ptr, NULL);
    return KAL_TRUE;
}

/*****************************************************************************
 * FUNCTION
 *  l4c_rsat_recv_data_res
 * DESCRIPTION
 *  
 * PARAMETERS
 *  cmd_detail      [?]         
 *  res             [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_rsat_recv_data_res(kal_uint8 cmd_detail[5], 
									kal_uint8 ch_type, 
									kal_uint8 res,
									kal_uint8 cause,
									kal_uint8 ch_data_length,
									kal_uint8 no_data,
									kal_uint8 *data)						
{
    sat_recv_data_res_struct *param_ptr;
    sat_recv_data_res_peer_struct *peer_ptr = NULL;

    param_ptr = (sat_recv_data_res_struct*)
        construct_local_para((kal_uint16) sizeof(sat_recv_data_res_struct), TD_RESET);

    kal_mem_cpy(param_ptr->cmd_detail, cmd_detail, 5);
    param_ptr->ch_type = ch_type;
    param_ptr->res = res;
    param_ptr->cause = cause;
    param_ptr->ch_data_length = ch_data_length;

    L4C_PACK_ALLOC(
        sat_recv_data_res_peer_struct_alloc,
        MCD_SAT_RECV_DATA_RES_PEER_STRUCT,
        sat_recv_data_res_peer_struct,
        peer_ptr);

    peer_ptr->no_data = no_data;
    if (peer_ptr->no_data > 0)
    {
        kal_mem_cpy(peer_ptr->data, data, peer_ptr->no_data);
    }
   
    l4c_send_msg_to_sim(MSG_ID_SAT_RECV_DATA_RES, param_ptr, (kal_uint8 *)peer_ptr);

    L4C_PACK_DEALLOC(sat_recv_data_res_peer_struct_dealloc, peer_ptr);
	
    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_rsat_ch_status_res
 * DESCRIPTION
 *  
 * PARAMETERS
 *  cmd_detail      [?]         
 *  res             [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_rsat_ch_status_res(kal_uint8 cmd_detail[5], 
									kal_uint8 res,
									kal_uint8 cause,
									kal_uint8 channel_status[2])
{
    sat_ch_status_res_struct *param_ptr;

    param_ptr = (sat_ch_status_res_struct*)
        construct_local_para((kal_uint16) sizeof(sat_ch_status_res_struct), TD_RESET);

    kal_mem_cpy(param_ptr->cmd_detail, cmd_detail, 5);
    param_ptr->res = res;
    param_ptr->cause = cause;
    kal_mem_cpy(param_ptr->channel_status, channel_status, 2);

    l4c_send_msg_to_sim(MSG_ID_SAT_CH_STATUS_RES, param_ptr, NULL);
    return KAL_TRUE;
}


#endif /* __SATCE__ */ 

#if defined(__RSAT__) || defined(__SAT_PROPRIETARY_ENVELOPE__) || defined(__SAT_PROPRIETARY_COMMAND__) 
/*****************************************************************************
 * FUNCTION
 *  l4c_sat_terminal_response_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  length              [IN]        
 *  terminal_rsp        [?]         
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_sat_terminal_response_req(kal_uint8 length, kal_uint8 *terminal_rsp)
{
    sat_terminal_rsp_struct *param_ptr;

    param_ptr = (sat_terminal_rsp_struct*) construct_local_para((kal_uint16) sizeof(sat_terminal_rsp_struct), TD_RESET);
    param_ptr->length = length;
    kal_mem_cpy(&(param_ptr->terminal_rsp[5]), terminal_rsp, length);
    l4c_send_msg_to_sim(MSG_ID_SAT_TERMINAL_RSP, param_ptr, NULL);

#ifdef __RSAT__
    if (L4C_PTR->cc_current_action[SAT_SRC] != L4C_NO_ACTION)
    {
        L4C_PTR->cc_current_action[SAT_SRC] = L4C_NO_ACTION;
    }
    if (L4C_PTR->parameter_sat.length != 0)
    {
        local_para_struct *local_ptr;

        local_ptr = (local_para_struct*) L4C_PTR->parameter_sat.data;
        local_ptr->ref_count = 1;       /* make sure the reference count is 1 so that when 
                                           call free locl para that pare will be freed successfull */
        free_local_para(local_ptr);
        L4C_PTR->parameter_sat.length = 0;
        L4C_PTR->parameter_sat.data = NULL;
    }
#endif

    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_sat_envelope_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  length          [IN]        
 *  envelope        [?]         
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_sat_envelope_req(kal_uint8 src_id, kal_uint8 length, kal_uint8 *envelope_data)
{
    sat_envelope_req_struct *param_ptr;

    param_ptr = (sat_envelope_req_struct*) construct_local_para((kal_uint16) sizeof(sat_envelope_req_struct), TD_RESET);
    param_ptr->src_id = src_id;
    param_ptr->length = length;
    kal_mem_cpy(&(param_ptr->envelope[5]), envelope_data, length);
    l4c_send_msg_to_sim(MSG_ID_SAT_ENVELOPE_REQ, param_ptr, NULL);
    return KAL_TRUE;
}

#endif

#ifdef __RSAT__
/*****************************************************************************
 * FUNCTION
 *  l4c_sat_setup_sms
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_sat_setup_sms(kal_uint8 src_id)
{
    mmi_sat_send_sms_stage1_req_struct *param_ptr;
    #if defined(__MOD_L4A__) || defined(__RSAT__) 
    kal_bool ret_val = KAL_FALSE;
    #endif /* __RSAT__ */ 

    if (L4C_PTR->parameter_sat.length == 0)
    {
        return KAL_FALSE;
    }
    else
    {
    #if defined(__MOD_L4A__) && !defined(__RSAT__) 
        param_ptr = (mmi_sat_send_sms_stage1_req_struct*) L4C_PTR->parameter_sat.data;

        ret_val = l4a_sat_send_sms_req( 
            param_ptr->is_sms_packed_required,
            param_ptr->no_addr,
            param_ptr->addr,
            param_ptr->tpdu_length,
            param_ptr->tpdu);
    #endif /* __MOD_L4A__ */ 
    #ifdef __RSAT__
        {
            l4csmsal_sat_send_req_struct *l = (l4csmsal_sat_send_req_struct*)
                construct_local_para(
                    (kal_uint16) sizeof(l4csmsal_sat_send_req_struct),
                    TD_RESET);

            param_ptr = (mmi_sat_send_sms_stage1_req_struct*) L4C_PTR->parameter_sat.data;

            l->src_id = src_id;
            l->is_sms_packed_required = param_ptr->is_sms_packed_required;
            l->sc_addr.addr_length = param_ptr->no_addr;
            kal_mem_cpy(l->sc_addr.addr_bcd, param_ptr->addr, param_ptr->no_addr);

            l->tpdu_length = param_ptr->tpdu_length;
            kal_mem_cpy(l->tpdu, param_ptr->tpdu, 175);

            ret_val = l4c_sat_send_sms_req(l);
        }
    #endif /* __RSAT__ */ 

        if (L4C_PTR->parameter_sat.length != 0)
        {
            local_para_struct *local_ptr;

            local_ptr = (local_para_struct*) L4C_PTR->parameter_sat.data;
            local_ptr->ref_count = 1;   /* make sure the reference count is 1 so that when 
                                           call free locl para that pare will be freed successfull */
            free_local_para(local_ptr);
            L4C_PTR->parameter_sat.length = 0;
            L4C_PTR->parameter_sat.data = NULL;
        }
    }
    return ret_val;
}

/*****************************************************************************
 * FUNCTION
 *  l4c_sat_setup_ss
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_sat_setup_ss()
{
    mmi_sat_send_ss_stage1_req_struct *param_ptr;
    kal_bool ret_val = KAL_FALSE;

    if (L4C_PTR->parameter_sat.length == 0)
    {
        return KAL_FALSE;
    }
    else
    {
        param_ptr = (mmi_sat_send_ss_stage1_req_struct*) L4C_PTR->parameter_sat.data;

        ret_val = l4c_sat_send_ss_req(param_ptr->input, 0x01, param_ptr->length, param_ptr->type_of_modification);

        if (L4C_PTR->parameter_sat.length != 0)
        {
            local_para_struct *local_ptr;

            local_ptr = (local_para_struct*) L4C_PTR->parameter_sat.data;
            local_ptr->ref_count = 1;   /* make sure the reference count is 1 so that when 
                                           call free locl para that pare will be freed successfull */
            free_local_para(local_ptr);
            L4C_PTR->parameter_sat.length = 0;
            L4C_PTR->parameter_sat.data = NULL;
        }
    }
    return ret_val;
}

/*****************************************************************************
 * FUNCTION
 *  l4c_sat_setup_ussd
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_sat_setup_ussd()
{
    mmi_sat_send_ussd_stage1_req_struct *param_ptr;
    kal_bool ret_val = KAL_FALSE;

    if (L4C_PTR->parameter_sat.length == 0)
    {
        return KAL_FALSE;
    }
    else
    {
        param_ptr = (mmi_sat_send_ussd_stage1_req_struct*) L4C_PTR->parameter_sat.data;
        ret_val = l4c_sat_send_ussd_req(param_ptr->input, param_ptr->dcs, param_ptr->length, param_ptr->type_of_modification);

        if (L4C_PTR->parameter_sat.length != 0)
        {
            local_para_struct *local_ptr;

            local_ptr = (local_para_struct*) L4C_PTR->parameter_sat.data;
            local_ptr->ref_count = 1;   /* make sure the reference count is 1 so that when 
                                           call free locl para that pare will be freed successfull */
            free_local_para(local_ptr);
            L4C_PTR->parameter_sat.length = 0;
            L4C_PTR->parameter_sat.data = NULL;
        }
    }
    return ret_val;
}

/*****************************************************************************
 * FUNCTION
 *  l4c_sat_setup_call
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_sat_setup_call()
{
    mmi_sat_call_setup_stage1_req_struct *param_ptr;

    if (L4C_PTR->parameter_sat.length == 0)
    {
        return KAL_FALSE;
    }
    else
    {
    #if defined(__MOD_L4A__) && !defined(__RSAT__) 
        param_ptr = (mmi_sat_call_setup_stage1_req_struct*) L4C_PTR->parameter_sat.data;
        l4a_sat_call_setup_req(param_ptr->sat_call_type,
                               param_ptr->no_addr,
                               param_ptr->addr,
                               param_ptr->no_sub_addr, param_ptr->sub_addr, param_ptr->no_ccp, param_ptr->ccp,
                               param_ptr->type_of_modification);        //mtk01616_070521
    #endif /* __MOD_L4A__ */ 
    #ifdef __RSAT__
        {
            l4ccsm_cc_sat_setup_req_struct *l = NULL;

            param_ptr = (mmi_sat_call_setup_stage1_req_struct*) L4C_PTR->parameter_sat.data;

            l = get_ctrl_buffer((kal_uint16) sizeof(l4ccsm_cc_sat_setup_req_struct));

            l->src_id = SAT_SRC;
            l->sat_call_type = param_ptr->sat_call_type;

            l->called_sub_addr_present = (param_ptr->no_sub_addr) ? 1 : 0;

            l->called_sub_addr.sub_addr_len = param_ptr->no_sub_addr;
            kal_mem_cpy(l->called_sub_addr.sub_addr, param_ptr->sub_addr, 21);

            l->ccp_present = (param_ptr->no_ccp) ? 1 : 0;
            kal_mem_cpy(l->ccp, param_ptr->ccp, MAX_SAT_SIZE_OF_CCP); //MAUI_02863694
            l->size_of_ccp = param_ptr->no_ccp;

            ////l->is_changed_from_ss = param_ptr->is_changed_from_ss;
            l->type_of_modification = param_ptr->type_of_modification;  //mtk01616_070521
            l->l4c_retry = KAL_FALSE;

            l4c_sat_call_setup_req(l, param_ptr->addr, param_ptr->no_addr);
            free_ctrl_buffer(l);
        }
    #endif /* __RSAT__ */ 

        if (L4C_PTR->parameter_sat.length != 0)
        {
            local_para_struct *local_ptr;

            local_ptr = (local_para_struct*) L4C_PTR->parameter_sat.data;
            local_ptr->ref_count = 1;   /* make sure the reference count is 1 so that when 
                                           call free locl para that pare will be freed successfull */
            free_local_para(local_ptr);
            L4C_PTR->parameter_sat.length = 0;
            L4C_PTR->parameter_sat.data = NULL;
        }
    }
    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_sat_dtmf
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
kal_bool l4c_sat_dtmf()
{
    mmi_sat_send_dtmf_stage1_req_struct *param_ptr;

    if (L4C_PTR->parameter_sat.length == 0)
    {
        return KAL_FALSE;
    }
    else
    {
        param_ptr = (mmi_sat_send_dtmf_stage1_req_struct*) L4C_PTR->parameter_sat.data;
        l4c_sat_send_dtmf_req(2,        //SAT_SRC
                              param_ptr->dtmf_digit, param_ptr->no_digit);

        if (L4C_PTR->parameter_sat.length != 0)
        {
            local_para_struct *local_ptr;

            local_ptr = (local_para_struct*) L4C_PTR->parameter_sat.data;
            local_ptr->ref_count = 1;   /* make sure the reference count is 1 so that when 
                                           call free locl para that pare will be freed successfull */
            free_local_para(local_ptr);
            L4C_PTR->parameter_sat.length = 0;
            L4C_PTR->parameter_sat.data = NULL;
        }
    }
    return KAL_TRUE;
}
#endif /* __RSAT__ */ 

#endif /* __SAT__ */ 

#ifdef __GEMINI__


/*****************************************************************************
 * FUNCTION
 *  l4c_smu_sim_status_update_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  new_sim_config      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_smu_sim_status_update_req(kal_uint8 new_sim_config)
{
    l4crac_sim_status_update_req_struct *param_ptr;

    param_ptr = (l4crac_sim_status_update_req_struct*)
        construct_local_para((kal_uint16) sizeof(l4crac_sim_status_update_req_struct), TD_RESET);

    L4C_COMM_PTR->dual_sim_mode_setting = new_sim_config;

    param_ptr->sim_insert_status = L4C_COMM_PTR->dual_sim_inserted_status;
    param_ptr->sim_config_status = L4C_COMM_PTR->dual_sim_mode_setting;

    l4c_send_msg_to_rac(MSG_ID_L4CRAC_SIM_STATUS_UPDATE_REQ, param_ptr);
}


/*****************************************************************************
 * FUNCTION
 *  l4c_smu_dual_sim_to_flight_mode_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_smu_dual_sim_to_flight_mode_req()
{

}
#endif /* __GEMINI__ */ 


/*****************************************************************************
 * FUNCTION
 *  l4c_sim_recovery_enhancement_switch_req
 * DESCRIPTION
 *  
 * PARAMETERS
 *  kal_bool
 * RETURNS
 *  mode
 *****************************************************************************/
kal_bool l4c_sim_recovery_enhancement_switch_req(kal_bool mode)
{
#if defined(__SIM_RECOVERY_ENHANCEMENT__)
    sim_recovery_enhancement_switch_req_struct *param_ptr;
    
    param_ptr = (sim_recovery_enhancement_switch_req_struct*) construct_local_para(
        (kal_uint16) sizeof(sim_recovery_enhancement_switch_req_struct), TD_RESET);
    
    param_ptr->switch_on = mode;
    l4c_send_msg_to_sim(MSG_ID_SIM_RECOVERY_ENHANCEMENT_SWITCH_REQ, param_ptr, NULL);

    return KAL_TRUE;
#else
    return KAL_FALSE;
#endif /* defined(__SIM_RECOVERY_ENHANCEMENT__) */
}

/*****************************************************************************
 * FUNCTION
 *  l4c_sim_query_info_req
 * DESCRIPTION
 *  to get SIM related information using MSG_ID_SIM_QUERY_INFO_REQ
 *
 * PARAMETERS
 *  kal_bool
 * RETURNS
 *  mode
 *****************************************************************************/
kal_bool l4c_sim_query_info_req(kal_uint8 src_id, sim_query_info_enum info_id)
{
    
    sim_query_info_req_struct *param_ptr;
    
    param_ptr = (sim_query_info_req_struct*) construct_local_para(
        (kal_uint16) sizeof(sim_query_info_req_struct), TD_RESET);
    
    param_ptr->src_id = src_id;
    param_ptr->info_id = info_id;
    
    l4c_send_msg_to_sim(MSG_ID_SIM_QUERY_INFO_REQ, param_ptr, NULL);

    return KAL_TRUE;
}

/*****************************************************************************
 * FUNCTION
 *  l4c_sim_terminal_capability_setting_req
 * DESCRIPTION
 *  to set SIM terminal capability parameters using MSG_ID_SIM_TERMINAL_CAPABILITY_SETTING_REQ
 *
 * PARAMETERS
 *  kal_bool
 * RETURNS
 *  mode
 *****************************************************************************/
kal_bool l4c_sim_terminal_capability_setting_req(kal_uint8 additional_interface)
{
    sim_terminal_capability_setting_req_struct *param_ptr;
    
    param_ptr = (sim_terminal_capability_setting_req_struct*) construct_local_para(
        (kal_uint16) sizeof(sim_terminal_capability_setting_req_struct), TD_RESET);

    param_ptr->support_additional_interface = KAL_TRUE;
    param_ptr->additional_interface = additional_interface;
    
    l4c_send_msg_to_sim(MSG_ID_SIM_TERMINAL_CAPABILITY_SETTING_REQ, param_ptr, NULL);

    return KAL_TRUE;
}


#if defined(__REGIONAL_PHONE__)
/*****************************************************************************
 * FUNCTION
 *  l4c_regional_phone_mode_req
 * DESCRIPTION
 *  to set the mode of early read IMSI
 *
 * PARAMETERS
 *  kal_bool
 * RETURNS
 *  mode
 *****************************************************************************/
kal_bool l4c_regional_phone_mode_req(kal_uint32 mode)
{
    nvram_write_req_struct *param_ptr = NULL;
    nvram_ef_regional_phone_mode_struct regional_phone_mode;

    kal_brief_trace(TRACE_INFO, INFO_REGIONAL_PHONE_MODE, mode);
    param_ptr = (nvram_write_req_struct*)l4c_construct_nvram_write_local_para(L4C_SRC,
                                                                              NVRAM_EF_REGIONAL_PHONE_MODE_LID,
                                                                              1);

    regional_phone_mode.mode = (mode == 0)? 0:1;
    l4c_send_msg_to_nvm(MSG_ID_NVRAM_WRITE_REQ, param_ptr, (kal_uint8*)&regional_phone_mode, sizeof(nvram_ef_regional_phone_mode_struct));
    
    return KAL_TRUE;
}
#endif /* __REGIONAL_PHONE__ */

#endif /* __MOD_SMU__ */ 

