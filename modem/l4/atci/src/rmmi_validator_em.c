/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 * RMMI_VALIDATOR_EM.C
 *
 * Project:
 * --------
 *   MAUI
 *
 * Description:
 * ------------
 *   This file is intends for ...
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
#include <stdio.h>
#include <string.h>
//#include "kal_non_specific_general_types.h"
#include "kal_public_defs.h" //MSBB change #include "stack_config.h"
#if defined(NEPTUNE_MMI)
#include "nvram_common_defs.h" /*for +ETEST*/
#endif
//#include "ps_trace.h"
#include "kal_trace.h"
//#include "kal_common_defs.h"
#include "drvpdn.h"
//#include "kal_release.h"
//#include "stack_common.h"
#include "kal_public_defs.h" //MSBB change #include "stack_msgs.h"
//#include "app_ltlcom.h" /* Task message communiction */
//#include "stacklib.h"   /* Basic type for dll, evshed, stacktimer */
//#include "app_buff_alloc.h"
//#include "stack_timer.h"
//#include "event_shed.h"
//#include "nvram_editor_data_item.h"
//#include "custom_nvram_editor_data_item.h"
//#include "syscomp_config.h"
//#include "task_config.h"


#ifdef __MOD_SMU__
//#include "ps2sim_struct.h"
//#include "sim_common_enums.h"
//#include "smu_common_enums.h"
#endif /* __MOD_SMU__ */ 
#include "device.h"
//#include "csmss_common_enums.h"

//#include "mcd_l3_inc_struct.h"
//#include "mcd_l3_inc_gprs_struct.h"
//#include "l3_inc_enums.h"

//#include "mcd_l4_common.h"

#include "l4c_common_enum.h"
#include "rmmi_common_enum.h"
#include "rmmi_context.h"
#include "l4c_context.h"
#include "layer4_context.h"
//#include "l4c_rspfmttr.h"
//#include "l4c_msghdlr.h"
#include "l4_trc.h"
#include "atci_trc.h"

//#include "uart_sw.h"
#include "dcl.h"
//#include "l4_defs.h"
//#include "csmcc_atfunc.h"
//#include "csmss_atfunc.h"
//#include "l4c_aux_struct.h"
//#include "l4c_ss_parse.h"

#ifdef __MOD_CSM__
//#include "mcd_ss_parameters.h"
//#include "mcd_ss_tcapmessages.h"
#include "l4c_common_enum.h"
//#include "csmcc_enums.h"
//#include "csmcc_common_enums.h"
//#include "ps2sat_struct.h"
//#include "l4c2csm_cc_struct.h"

//#include "l4c_ciss_cmd.h"
//#include "l4c2csm_ss_struct.h"
//#include "l4c_cc_cmd.h"
#endif /* __MOD_CSM__ */ 
#include "med_struct.h"

#ifdef __MOD_UEM__
#include "device.h"
//#include "l4c2uem_struct.h"
//#include "uem_at_cmd.h"
#include "custom_em.h"
#include "l4c_eq_cmd.h"
#endif /* __MOD_UEM__ */ 
#ifdef __MOD_RAC__
//#include "l4crac_func.h"
//#include "l4c_nw_cmd.h"
//#include "l4crac_enums.h"
#endif /* __MOD_RAC__ */ 
#ifdef __MOD_PHB__
//#include "sim_common_enums.h"
//#include "l4c2phb_enums.h"
//#include "l4c2phb_struct.h"
//#include "phb_sap.h"
//#include "l4c_phb_cmd.h"
//#include "phb_defs.h"
//#include "phb_config.h"
#endif /* __MOD_PHB__ */ 
#ifdef __MOD_SMSAL__
//#include "l4c2smsal_struct.h"
//#include "smsal_l4c_defs.h"
//#include "smsal_l4c_funcs.h"
//#include "smsal_l4c_enum.h"
//#include "smsal_defs.h"
//#include "l4c_sms_cmd.h"
#endif /* __MOD_SMSAL__ */ 
#ifdef __MOD_SMU__
//#include "ps2sat_struct.h"
//#include "mcd_ps2sat_peer.h"
//#include "l4c_sim_cmd.h"
#endif /* __MOD_SMU__ */ 
#ifdef __MOD_TCM__
//#include "mmi_l3_enums.h"
//#include "mmi_sm_enums.h"
//#include "ppp_l4_enums.h"
//#include "tcm_common_enums.h"
//#include "tcm_common.h"
//#include "custom_nvram_editor_data_item.h"
//#include "l4c2abm_struct.h"
//#include "abm2l4c_struct.h"
//#include "l4c2tcm_struct.h"
//#include "l4c2tcm_func.h"
//#ifdef __TCPIP__
//#include "l4c2abm_struct.h"
//#endif /* __TCPIP__ */
//#include "l4c_gprs_cmd.h"
#endif /* __MOD_TCM__ */ 

#include "l4c_utility.h"
#include "rmmi_rspfmttr.h"
#include "rmmi_utility.h"
//#include "rmmi_rsp.h"
//#include "rmmi_validator.h"
#include "nvram_data_items.h"
//#include "custom_hw_default.h"
//#include "l4c_table.h"
#include "rmmi_parser.h"
//#include "resource_verno.h"     // for +EGMR read MMI resource version
//#include "mba_resource.h" // for +EGMR read MMI resource version

#ifdef __CSD_FAX__
//#include "csm_data_enums.h"
//#include "l4c2t30_struct.h"
//#include "l4c_t30_cmd.h"
//#include "l4c2t30_enums.h"
#endif /* __CSD_FAX__ */ 
#include "rmmi_parser.h"
//#ifdef __J2ME__
//#include "jam_msg_handler.h"
//#endif 

#if defined(__BT_SUPPORT__)
#include "bluetooth_struct.h"
#endif 

#if defined(__DT_SUPPORT__) || defined(__GEMINI__)
//#include "l4c2dt_struct.h"
#endif /* __DT_SUPPORT__ */ 

#include "l4c_sendmsg.h"

#ifdef __CUST_NEW__
//#include "gpio_sw.h"
#include "dcl.h"
#endif 

/* for data item NVRAM_EF_IMEI_IMEISV_LID move */
//#include "nvram_user_defs.h"
//#include "csmcc_defs.h"

//#include "nvram_enums.h"
#include "nvram_interface.h" //mtk02508_090310 for new NVRAM API: nvram_get_imei_value()

//#include "keypad_sw.h"
//#include "l4c2smu_struct.h"
#include "lmmi_ind.h"

//#include "csmcc_common_enums.h"

//#include "mncc_struct.h"
//#include "csmcc_bc_types.h"
//#include "csmcc_types.h"
#include "custom_em.h"
//#include "L4c_ctm_cmd.h"
//#include "csmcc_utility.h"

#if defined(__AT_RRC_TRACE_SUPPORT__)
#include "as2l4c_struct.h"
#endif

//#include "sat_def.h"

//#include "uem_proc_cmd.h"

//#include "rmmi_msghdlr.h"

#include "kal_general_types.h"
#include "kal_public_api.h"
#include "ps_public_struct.h"
#include "kal_public_defs.h"

#if defined(__NFC_SUPPORT__)
/*Add header files for NFC related feature*/
#include "mtk_nfc_ext_msg.h"
#endif


#ifdef __TC02__
#include "uem_proc_cmd.h"
#endif

#ifdef LQT_SUPPORT
//#include "lcd_lqt.h"
extern void lcd_config_lqt(kal_uint8 mode,kal_uint8 level, kal_uint8 color);//kitty
extern void lcm_config_lqt(kal_uint8 mode, kal_uint16 cmd, kal_uint16 num, kal_uint16 *ptr);
#endif 

#ifdef __AT_ESWM_SUPPORT__ 
#include "init.h"
#include "uem_at_cmd.h"
#endif

#include "ps_public_utility.h"

#include "swla_public.h"
#include "ps_em_enum.h"
#if defined(__AT_ETSTLP_SUPPORT__) || !defined(__MMI_FMI__)
#include "l4c_tst.h"
#endif

#include "l4c_em.h"

extern UART_PORT PS_UART_PORT;

extern kal_uint8 rmmi_aux_PDNhandle;
extern kal_uint8 PhnsetGetATDisplayBound(void);
extern kal_bool custom_uem_gpio_set_level(kal_uint8 gpio_dev_type, kal_uint8 gpio_dev_level);
extern kal_bool rmmi_general_command_parsing(kal_uint32 op, kal_uint32 data_len, kal_uint8 *data_str);


#if defined(MT6318) && defined(PLUTO_MMI)
/*****************************************************************************
 * FUNCTION
 *  rmmi_ereg_hdlr
 * DESCRIPTION
 *  This is rmmi function handler to read/write specific register index
 *  add by mtk00924 05/12/05
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_ereg_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 error_cause;
    kal_uint16 param2, reg_index;
    pmic_config_param_struct request;
    kal_uint8 param1[7];
    kal_uint8 result;

    kal_trace(TRACE_FUNC, FUNC_RMMI_EREG_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {

        case RMMI_SET_OR_EXECUTE_MODE:
        {

            result = rmmi_string_validator_ext(
                        &error_cause,
                        source_string_ptr,
                        (kal_uint8) RMMI_COMMA,
                        7,
                        (kal_uint8*) param1);

            if (result == RMMI_VALIDATOR_ERROR)
            {
                break;
            }

            toUpper(param1);
            if (strcmp((char*)param1, "0X0000") == 0)
            {
                reg_index = 0X0000;
            }
            else if (strcmp((char*)param1, "0X1000") == 0)
            {
                reg_index = 0X1000;
            }
            else if (strcmp((char*)param1, "0X2000") == 0)
            {
                reg_index = 0X2000;
            }
            else if (strcmp((char*)param1, "0X3000") == 0)
            {
                reg_index = 0X3000;
            }
            else if (strcmp((char*)param1, "0X4000") == 0)
            {
                reg_index = 0X4000;
            }
            else if (strcmp((char*)param1, "0X5000") == 0)
            {
                reg_index = 0X5000;
            }
            else if (strcmp((char*)param1, "0X6000") == 0)
            {
                reg_index = 0X6000;
            }
            else if (strcmp((char*)param1, "0X7000") == 0)
            {
                reg_index = 0X7000;
            }
            else if (strcmp((char*)param1, "0X8000") == 0)
            {
                reg_index = 0X8000;
            }
            else if (strcmp((char*)param1, "0X9000") == 0)
            {
                reg_index = 0X9000;
            }
            else if (strcmp((char*)param1, "0XA000") == 0)
            {
                reg_index = 0XA000;
            }
            else if (strcmp((char*)param1, "0XE000") == 0)
            {
                reg_index = 0XE000;
            }
            else if (strcmp((char*)param1, "0XF000") == 0)
            {
                reg_index = 0XF000;
            }
            else
            {
                break;
            }

            // read value set to register index when "WRITE"
            param2 = (kal_uint16) rmmi_int_validator_range_check(&error_cause,
                                                                 source_string_ptr,
                                                                 RMMI_PTR->s_reg.s3,
                                                                 0xff);
            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }
            if (param2 != RMMI_VALIDATOR_ERROR) //there is some value set to data, so "WRITE"
            {
                request.write_reg.register_index = (kal_uint16) reg_index;
                request.write_reg.data = (kal_uint8) param2;

                l4c_eq_pmic_config_req(RMMI_SRC, PMIC_WRITE_REG, request);
                ret_val = KAL_TRUE;
                return;
            }
            else
            {
                if (error_cause == RMMI_PARSE_NOT_FOUND)        //there is only register index given, so "READ"
                {
                    request.read_reg.register_index = (kal_uint16) reg_index;

                    l4c_eq_pmic_config_req(RMMI_SRC, PMIC_READ_REG, request);

                    ret_val = KAL_TRUE;
                    return;
                }
                else if (error_cause == RMMI_PARSE_OK)  //the setting value for data is 255, so "WRITE"
                {
                    request.write_reg.register_index = (kal_uint16) reg_index;
                    request.write_reg.data = (kal_uint8) param2;

                    l4c_eq_pmic_config_req(RMMI_SRC, PMIC_WRITE_REG, request);
                    ret_val = KAL_TRUE;
                    return;
                }
                else
                {
                    break;
                }
            }
            break;
        }

        default:
        {
            break;
        }
    }
    if (ret_val == KAL_FALSE)
    {
        rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    }
}

/*****************************************************************************
 * FUNCTION
 *  rmmi_epmic_hdlr
 * DESCRIPTION
 *  This is rmmi function handler to read PM IC related information from driver
 *  add by mtk00924 05/12/05
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_epmic_hdlr(rmmi_string_struct *source_string_ptr)
{
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    kal_bool ret_val = KAL_FALSE;
    kal_uint16 param1, category;
    pmic_config_param_struct request;

    kal_trace(TRACE_FUNC, FUNC_RMMI_EPMIC_HDLR_ENTRY);

    kal_mem_set(&request, 0, sizeof(pmic_config_param_struct));

    switch (source_string_ptr->cmd_mode)
    {

        case RMMI_SET_OR_EXECUTE_MODE:
        {
            category = (kal_uint16) rmmi_int_validator_range_check(NULL,
                                                                   source_string_ptr,
                                                                   (kal_uint8) RMMI_COMMA,
                                                                   7);

            if (category == RMMI_VALIDATOR_ERROR)
            {
                break;
            }

            switch (category)
            {
                case 0:
                    param1 = (kal_uint16) rmmi_int_validator_range_check(NULL,
                                                                         source_string_ptr,
                                                                         rmmi_ptr->s_reg.s3,
                                                                         6);
                    if (param1 == RMMI_VALIDATOR_ERROR)
                    {
                        break;
                    }
                    else
                    {
                        request.chr_state.status = (kal_uint8) param1;
                        l4c_eq_pmic_config_req(RMMI_SRC, PMIC_GET_CHR_STATE, request);

                        ret_val = KAL_TRUE;

                        break;
                    }
                case 1:
                    param1 = (kal_uint16) rmmi_int_validator_range_check(NULL,
                                                                         source_string_ptr,
                                                                         rmmi_ptr->s_reg.s3,
                                                                         1);
                    if (param1 == RMMI_VALIDATOR_ERROR)
                    {
                        break;
                    }
                    else
                    {
                        request.ac_usb_status.type = (kal_uint8) param1;
                        l4c_eq_pmic_config_req(RMMI_SRC, PMIC_GET_AC_USB, request);

                        ret_val = KAL_TRUE;

                        break;
                    }
                case 2:
                    param1 = (kal_uint16) rmmi_int_validator_range_check(NULL,
                                                                         source_string_ptr,
                                                                         rmmi_ptr->s_reg.s3,
                                                                         4);
                    if (param1 == RMMI_VALIDATOR_ERROR)
                    {
                        break;
                    }
                    else
                    {
                        request.led_config.type = (kal_uint8) param1;
                        l4c_eq_pmic_config_req(RMMI_SRC, PMIC_GET_LED_CONFIG, request);

                        ret_val = KAL_TRUE;

                        break;
                    }
                case 3:
                    param1 = (kal_uint16) rmmi_int_validator_range_check(NULL,
                                                                         source_string_ptr,
                                                                         rmmi_ptr->s_reg.s3,
                                                                         8);
                    if (param1 == RMMI_VALIDATOR_ERROR)
                    {
                        break;
                    }
                    else
                    {
                        request.misc_ldo_state.type = (kal_uint8) param1;
                        l4c_eq_pmic_config_req(RMMI_SRC, PMIC_GET_MISC_LDO_STATE, request);

                        ret_val = KAL_TRUE;

                        break;
                    }

                case 4:
                {
                    l4c_eq_pmic_config_req(RMMI_SRC, PMIC_GET_RGB_DIM, request);

                    ret_val = KAL_TRUE;

                    break;
                }
                case 5:
                {
                    l4c_eq_pmic_config_req(RMMI_SRC, PMIC_GET_BL_DIM, request);

                    ret_val = KAL_TRUE;

                    break;
                }
                case 6:
                {
                    l4c_eq_pmic_config_req(RMMI_SRC, PMIC_GET_SPEAKER_STATE, request);

                    ret_val = KAL_TRUE;

                    break;
                }
                case 7:
                {
                    l4c_eq_pmic_config_req(RMMI_SRC, PMIC_GET_SPEAKER_GAIN, request);

                    ret_val = KAL_TRUE;

                    break;
                }
                default:
                {
                    break;
                }
            }
        }
        default:
        {
            break;
        }
    }
    if (ret_val == KAL_FALSE)
    {
        rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    }
}

#endif /* defined(MT6318) && defined(PLUTO_MMI) */

#ifdef __MMI_FMI__
#if !defined(__ULC_AT__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_evcld_hdlr
 * DESCRIPTION
 *  This is for phonesuite to access Vcalendar
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_evcld_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint8 string_length = 0;
    kal_uint16 index = 255; 
    kal_uint8 filepath[50];
    kal_uint8 inputFilename[100];
    kal_uint8 result;
    kal_uint8 mode, error_cause;
    kal_uint16 vcal_type = 255; 
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    kal_mem_set(filepath, 0, sizeof(filepath));

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            /* <mode>:0=add,  1=update, 2=delete, 3=read, 4=query, 5=query Vcalendar 1.0 is supported or not */
            mode = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                              source_string_ptr,
                                                              RMMI_COMMA,
                                                              6);
            if (mode == RMMI_VALIDATOR_ERROR)
            {
                break;
            }

         /***************************************
         *<index>:
         *index should be 0xFF(default value) when <mode> = 0
         *index should be given when <mode> = 1,2,3
         *index does not have meaning when <mode> = 4,5
         ****************************************/
            if (mode == 1 || mode == 2 || mode == 3)    /* "update", "delete", "read" need <index> */
            {
                index = rmmi_int_validator_u16_check(&error_cause,
                                                     source_string_ptr,
                                                     RMMI_COMMA);

                if (error_cause != RMMI_PARSE_OK)
                {
                    break;
                }
            }

            if (mode == 0 || mode == 1) /* "add" and "update" operation need <path> */
            {
                result = rmmi_string_validator_ext(
                            &error_cause,
                            source_string_ptr,
                            rmmi_ptr->s_reg.s3,
                            100,
                            (kal_uint8*) inputFilename);

                if (result == RMMI_VALIDATOR_ERROR)
                {
                    rmmi_ptr->cmee_err = RMMI_ERR_SYNTEX_ERROR;
                    break;
                }
                check_hex_value_ext(inputFilename, (kal_uint8*) filepath);
                rmmi_byte_order_reverse((kal_uint8*) filepath, 50);
		
                l4c_eq_vcalendar_req_lind(mode, vcal_type, index, filepath); 
                return;
           }
	    else if (mode == 2 || mode == 3 ||mode == 4)/* "delete", "read", and "query" operation need no <path> */
           {
                vcal_type = rmmi_int_validator_range_check(&error_cause,
                                                           source_string_ptr,
                                                           rmmi_ptr->s_reg.s3,
                                                           1);
                if (error_cause != RMMI_PARSE_OK)
                {
                    break;
                }
			  
                l4c_eq_vcalendar_req_lind(mode, vcal_type, index, filepath); 
                return;
	     }
            else 
            {
                l4c_eq_vcalendar_req_lind(mode, vcal_type, index, filepath); 
                return;
            }
        }
        default:
            break;
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, buffer, string_length);
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_elsm_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for LCM Sleep Mode turn on/off  .
 *  mtk00468 add on 09/17
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_elsm_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 op;
    kal_uint8 const *rsp_str = NULL;    /* response string and initialization */
    kal_uint16 string_length = 0;       /* string length variable */

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
            /* checking the command mode */
        case RMMI_TEST_MODE:    /* at+elsm=? */
        {
            rsp_str = (kal_uint8 const*)"+ELSM: (0,1)"; /* prepare the response string */
            string_length = strlen((char*)rsp_str);     /* type casting */
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_SET_OR_EXECUTE_MODE:  /* at+ealt = 0  loop back test mode acivate */
        {
            /* Get the seed from the command line and validate it */
            op = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                            source_string_ptr,
                                                            RMMI_PTR->s_reg.s3,
                                                            1);
            if (op == RMMI_VALIDATOR_ERROR)
            {
                break;  //error handling
            }
            l4c_em_lcm_sleep_mode_req_ind(source_string_ptr->src_id, op);
            ret_val = KAL_TRUE;
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}

#endif /* !defined(__ULC_AT__) */


/*****************************************************************************
 * FUNCTION
 *  rmmi_ekpd_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for de/activate keypad enevt report.
 *  mtk00468 add on 07/16
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_ekpd_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 op;                           /* variable for en-/disable */
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];   /* temp buffer for response format usage */
    kal_uint8 const *rsp_str = NULL;        /* response string and initialization */
    kal_uint16 string_length = 0;           /* string length variable */
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    l4c_context_struct *l4c_ptr = L4C_PTR;

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
            /* checking the command mode */
        case RMMI_TEST_MODE:    /* at+ekpd=? */
        {
            rsp_str = (kal_uint8 const*)"+EKPD: (0,1)"; /* prepare the response string */
            string_length = strlen((char*)rsp_str);     /* type casting */
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_READ_MODE:    /* at+ekpd? */
        {

            rmmi_ptr->arg_list[0] = (void*)&l4c_ptr->keypad_event_flag;        /* save the value into rmmi context para array */
            string_length = rmmi_fast_string_print(
                                /* using this macro to format the string quickly */ buffer,
                                (kal_uint8*) "+EKPD: %d",
                                rmmi_ptr->arg_list,
                                1);
            rsp_str = &buffer[0];
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:  /* at+ekpd = 0  EM mode acivate */
        {
            /* Get the seed from the command line and validate it */
            op = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                            source_string_ptr,
                                                            rmmi_ptr->s_reg.s3,
                                                            1);
            if (op == RMMI_VALIDATOR_ERROR)
            {
                break;  //error handling
            }
            if (op)
            {
                l4c_em_keypad_event_act_ind(source_string_ptr->src_id, (kal_bool) op);
                l4c_ptr->keypad_event_flag = KAL_TRUE;
            }
            else
            {
                if (l4c_ptr->keypad_event_flag == KAL_TRUE) /* error handle if never active we dont sent stop to uem */
                {
                    l4c_em_keypad_event_act_ind(source_string_ptr->src_id, (kal_bool) op);
                    l4c_ptr->keypad_event_flag = KAL_FALSE;
                }
            }
            ret_val = KAL_TRUE;
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}

/*****************************************************************************
 * FUNCTION
 *  rmmi_elcm_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for set LCM for factory test.
 *  mtk00468 add on 07/16
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_elcm_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 type;                     /* variable for en-/disable */
    kal_uint8 const *rsp_str = NULL;    /* response string and initialization */
    kal_uint16 string_length = 0;       /* string length variable */

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
            /* checking the command mode */
        case RMMI_TEST_MODE:    /* at+elcm=? */
        {
            rsp_str = (kal_uint8 const*)"+ELCM: (0-6)"; /* prepare the response string */
            string_length = strlen((char*)rsp_str);     /* type casting */
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_SET_OR_EXECUTE_MODE:  /* at+elcm = 4  back to normal idle screen */
        {
            /* Get the seed from the command line and validate it */
            type = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                              source_string_ptr,
                                                              (kal_uint8) RMMI_COMMA,
                                                              6);
            if (type == RMMI_VALIDATOR_ERROR)
            {
                break;  //error handling
            }
            if (type < 5)
            {
                l4c_em_lcm_test_ind(source_string_ptr->src_id, type);
                ret_val = KAL_TRUE;
                break;
            }
            #if defined(PLUTO_MMI)
            else if (type == 5)
            {
                kal_uint16 red, green, blue;
                kal_uint8 error_cause;

                red = (kal_uint16) rmmi_int_validator_u16_check((kal_uint8*)&error_cause,
                                                                source_string_ptr,
                                                                (kal_uint8) RMMI_COMMA);

                if (error_cause != RMMI_PARSE_OK)
                {
                    break;
                }

                green = (kal_uint16) rmmi_int_validator_u16_check((kal_uint8*)&error_cause,
                                                                  source_string_ptr,
                                                                  (kal_uint8) RMMI_COMMA);

                if (error_cause != RMMI_PARSE_OK)
                {
                    break;
                }

                blue = (kal_uint16) rmmi_int_validator_u16_check((kal_uint8*)&error_cause,
                                                                 source_string_ptr,
                                                                 RMMI_PTR->s_reg.s3);

                if (error_cause != RMMI_PARSE_OK)
                {
                    break;
                }

                type = 1;   /* start test LCM R/G/B */

                l4c_em_rgb_test_req_lind(type, red, green, blue);
                return;
            }
            else if (type == 6)
            {
                type = 0;   /* stop test LCM R/G/B */
                l4c_em_rgb_test_req_lind(type, 0xffff, 0xffff, 0xffff);
                return;
            }
            #else
            break;
            #endif
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_etest_hdlr
 * DESCRIPTION
 *  This is rmmi function handler to read autotest report
 *  add by mtk00714 04/05/21
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_etest_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_ACTIVE_MODE:
        {
        #if defined(NEPTUNE_MMI)
            l4c_eq_read_autotest_report_req(source_string_ptr->src_id, NVRAM_EF_AUTOTEST_LID, 2);
        #else
            l4c_em_quick_test_report_lind();
            L4C_PTR->route_thru_lmmi = KAL_TRUE;
            L4C_PTR->route_thru_lmmi_user = source_string_ptr->src_id;
        #endif
            return;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 result, error_cause;
            kal_uint8 password[16];

            result = rmmi_string_validator_ext(&error_cause, source_string_ptr, (kal_uint8) RMMI_PTR->s_reg.s3, 9, (kal_uint8*) password);     //MMI's limit to Phone lock code is 8 byte
            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }

            if (L4C_PTR->cc_current_action[LMMI_SRC] == POWERON_EXE)
            {
                break;
            }

            // factory reset
            l4c_mmi_factory_restore_req_lind(password);
            return;
        }
        default:
        {
            break;
        }
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
}


#if !defined(__ULC_AT__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_ekey_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_ekey_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_uint8 n;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    kal_bool ret_val = KAL_FALSE;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    l4c_context_struct *l4c_ptr = L4C_PTR;

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            rsp_str = (kal_uint8 const*)"+EKEY: (0, 1)";    /* prepare the response string */
            string_length = strlen((char*)rsp_str);         /* type casting */
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_READ_MODE:
        {
            rmmi_ptr->arg_list[0] = (void*)&l4c_ptr->ekey_mode;
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+EKEY: %d", rmmi_ptr->arg_list, 1);
            rsp_str = &buffer[0];
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            n = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                           source_string_ptr,
                                                           (kal_uint8) RMMI_COMMA,
                                                           1);
            if (n == RMMI_VALIDATOR_ERROR)
            {
                rmmi_ptr->cmee_err = RMMI_ERR_SYNTEX_ERROR;
                break;
            }
            l4c_ptr->ekey_mode = n;
            ret_val = KAL_TRUE;
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            rmmi_ptr->cmee_err = RMMI_ERR_UNSPECIFIED;
            break;
        }
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
}
#endif /*!defined(__ULC_AT__) */


#ifdef LQT_SUPPORT

/*****************************************************************************
 * FUNCTION
 *  rmmi_elqt_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for LCM Qualification Tool.
 *  mtk02088 add on 06/16
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_elqt_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 mode, op, i;
    kal_uint16 cmd = 0; 
    kal_uint16 level = 0; 
    kal_uint8 const *rsp_str = NULL;   
    kal_uint16 string_length = 0;      
    kal_uint16 reg_buf[16];
    kal_uint8 buf[MAX_UART_LENGTH];    /* maximum charactor 90 */
    kal_uint8 buffer[MAX_UART_LENGTH];  /*maximum charator 104*/
    kal_uint16 len = 0;
    kal_uint8 color = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;


    /* checking the command mode */
    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:    /* at+clqt=? */
        {
            rsp_str = (kal_uint8 const*)"+ELQT: (0-6)"; 
            string_length = strlen((char*)rsp_str);     
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_SET_OR_EXECUTE_MODE: 
        {
            mode = rmmi_int_validator_range_check(NULL,
                                                  source_string_ptr,
                                                  (kal_uint8) RMMI_COMMA,
                                                  6);

            if (mode == RMMI_VALIDATOR_ERROR)
            {
                break;
            }           

            if (mode == 0 || mode == 1)
            {
                level = rmmi_int_validator_range_check(NULL,
                                                       source_string_ptr, 
                                                       (kal_uint8) RMMI_COMMA,
                                                       63);
                if (level == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }

                color = rmmi_int_validator_range_check(NULL,
                                                       source_string_ptr, 
                                                       rmmi_ptr->s_reg.s3,
                                                       3);
                if (color == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }

                lcd_config_lqt(mode, level, color);
            }
            else if (mode == 2)
            {
                lcd_config_lqt(mode, level, color);              
            }
            else if (mode == 3)
            {
                level = rmmi_int_validator_range_check(NULL,
                                                       source_string_ptr, 
                                                       (kal_uint8) RMMI_COMMA,
                                                       3);
                if (level == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }

                op = rmmi_int_validator_range_check(NULL,
                                                    source_string_ptr, 
                                                    rmmi_ptr->s_reg.s3,
                                                    1);
                if (op == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }

                lcd_config_lqt(mode, op, level);
            }
            else if (mode == 4)
            {
                kal_uint8 error_cause;
                level = rmmi_int_validator_range_check(NULL,
                                                       source_string_ptr, 
                                                       (kal_uint8) RMMI_COMMA,
                                                       16);
                if ((level == RMMI_VALIDATOR_ERROR) || (level == 0))
                {
                    break;
                }
		
                cmd = rmmi_int_validator_u16_check(&error_cause,
                                                   source_string_ptr, 
                                                   rmmi_ptr->s_reg.s3);
                if (error_cause != RMMI_PARSE_OK)
                {
                    break;
                }

                lcm_config_lqt(mode, cmd, level, reg_buf);

                for (i = 0; i < level; i++)
                {
                    kal_sprintf((char*)buf + len, "0x%2x", reg_buf[i]);
                    if(i != (level -1))
                    {
                        strcat((kal_char*) buf, ",");
                    }
                    len = strlen((kal_char*) buf);
                }
			 		
                rmmi_ptr->arg_list[0] = (void*)&cmd;  
                rmmi_ptr->arg_list[1] = (void*)buf; 
                string_length = rmmi_fast_string_print(
                                			buffer,
                                			(kal_uint8*) "+ELQT: %d, %s",
                                			rmmi_ptr->arg_list,
                                			2);
                rsp_str = &buffer[0];

	     	}
	     	else if (mode == 5)
	     	{
                lcm_config_lqt(mode, cmd, level, reg_buf);
	     	}
	     	else if (mode == 6)
	     	{
	     	    kal_uint8 error_cause;
                level = rmmi_int_validator_u16_check(&error_cause,
                                                     source_string_ptr, 
                                                     (kal_uint8) RMMI_COMMA);
                if (error_cause != RMMI_PARSE_OK)
                {
                		break;
                }

                cmd = rmmi_int_validator_u16_check(&error_cause,
                                                   source_string_ptr, 
                                                   rmmi_ptr->s_reg.s3);
                if (error_cause != RMMI_PARSE_OK)
                {
                    break;
                }

                lcm_config_lqt(mode, cmd, level, reg_buf);
	     	}

            ret_val = KAL_TRUE;
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;

}
#endif /* LQT_SUPPORT */ 

#ifdef __BT_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  rmmi_embt_hdlr
 * DESCRIPTION
 *  This function allows Tool to request the target to enter Test mode for Bluetooth.
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_embt_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_uint8 op, error_cause;
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 name[32];
    kal_uint8 addr[6];
    kal_uint8 dcs = L4_ASCII;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 string_length = 0;
    rmmi_common_context_struct *rmmi_comm_ptr = RMMI_COMM_PTR;

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
    #if defined(__BT_SUPPORT__)
        case RMMI_TEST_MODE:
        {
            rsp_str = (kal_uint8 const*)"+EMBT: (1)";
            string_length = strlen((char*)rsp_str);
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* defined(__BT_SUPPORT__) */ 
    #endif /* __test_mode__ */ 
    #if defined(__BT_SUPPORT__)
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            op = (kal_uint8) rmmi_int_validator_range_check(&error_cause,
                                                            source_string_ptr,
                                                            RMMI_COMMA,
                                                            5);
            if(error_cause != RMMI_PARSE_OK)
            {
                break;
            }

            if (op == 1)        //enter BT test mode
            {
                bt_test_mode_req_struct *param_ptr;

                param_ptr = (bt_test_mode_req_struct*) construct_local_para(
                                                        (kal_uint16) sizeof(bt_test_mode_req_struct),
                                                        TD_CTRL);
                param_ptr->mode = 1;
            #ifdef __GEMINI__
                param_ptr->dual_sim_uart_setting = rmmi_comm_ptr->sim_uart_setting;
            #endif 
                rmmi_send_msg_to_bt(MSG_ID_BT_TEST_MODE_REQ, param_ptr);
                ret_val = KAL_TRUE;
            }
            else if (op == 2)   //leave BT test mode
            {
                bt_test_mode_req_struct *param_ptr;

                param_ptr = (bt_test_mode_req_struct*) construct_local_para(
                                                        (kal_uint16) sizeof(bt_test_mode_req_struct),
                                                        TD_CTRL);
                param_ptr->mode = 2;
            #ifdef __GEMINI__
                param_ptr->dual_sim_uart_setting = rmmi_comm_ptr->sim_uart_setting;
            #endif 
                rmmi_send_msg_to_bt(MSG_ID_BT_TEST_MODE_REQ, param_ptr);
                ret_val = KAL_TRUE;
            }
            else if (op == 0)
            {
                bt_set_bd_param_req_struct *param_ptr;
                /* parse friendly name */
                if (RMMI_PTR->char_set == RMMI_CHSET_UCS2)
                {
                    kal_uint8 string[65];
                    kal_uint8 result;

                    dcs = L4_UCS2;
                    kal_mem_set(name, 0, 32);
                    result = rmmi_string_validator_ext(
                                &error_cause,
                                source_string_ptr,
                                RMMI_COMMA,
                                65,
                                (kal_uint8*) string);
                    if (error_cause == RMMI_PARSE_OK)
                    {
                        check_hex_value(string, name);
                        rmmi_byte_order_reverse(name, (kal_uint16) (strlen((char*)string) / 2));
                    }
                    else
                        break;
                }
                else
                {
                    ret_val = rmmi_bt_str_validator(source_string_ptr, RMMI_COMMA, 32, name, KAL_FALSE);
                    if (ret_val == KAL_FALSE)
                    {
                        break;
                    }
                }
                /* parser bd_addr */
                ret_val = rmmi_bt_hex_validator(source_string_ptr, RMMI_COMMA, 6, addr);
                if (ret_val == KAL_TRUE)
                {
                    param_ptr = (bt_set_bd_param_req_struct*) construct_local_para(
                                                                (kal_uint16) sizeof(bt_set_bd_param_req_struct),
                                                                TD_CTRL);

                    kal_mem_cpy(param_ptr->name, name, sizeof(name));
                    kal_mem_cpy(param_ptr->bd_addr, addr, sizeof(addr));
                    param_ptr->dcs = dcs;

                    rmmi_send_msg_to_bt(MSG_ID_BT_SET_BD_ADDR_REQ, param_ptr);
                    return;
                }
                //else will be break (ERROR)
            }
            else if (op == 5)
            {
                bt_read_bd_addr_req_struct *param_ptr;

                param_ptr = (bt_read_bd_addr_req_struct*) construct_local_para(
                                                            (kal_uint16) sizeof(bt_read_bd_addr_req_struct),
                                                            TD_CTRL);
            #ifdef __GEMINI__
                param_ptr->dual_sim_uart_setting = rmmi_comm_ptr->sim_uart_setting;
            #endif 
                rmmi_send_msg_to_bt(MSG_ID_BT_GET_BD_ADDR_REQ, param_ptr);
                return;
            }
            else
            {
                break;
            }
            break;

        }
    #endif /* defined(__BT_SUPPORT__) */ 
        default:
        {
            break;
        }
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
}

/*****************************************************************************
 * FUNCTION
 *  rmmi_ebtlb_hdlr
 * DESCRIPTION
 *  This function allows Tool to request the target to enter Test mode for Bluetooth.
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_ebtlb_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_uint8 mode, error_cause;
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 bd_addr[6], pin_code[17];
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 string_length = 0;
    kal_uint8 result;

    kal_trace(TRACE_FUNC, FUNC_RMMI_EBTLB_HDLR_ENTRY);

    kal_mem_set(pin_code, 0, sizeof(pin_code));
    kal_mem_set(bd_addr, 0, sizeof(bd_addr));

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            mode = (kal_uint8) rmmi_int_validator_range_check(&error_cause,
                                                              source_string_ptr,
                                                              RMMI_COMMA,
                                                              2);
            if(error_cause != RMMI_PARSE_OK)
            {
                break;
            }
            if (mode == 1)      //loopback 1 test 
            {
            #if defined(__BT_SUPPORT__)
                rmmi_send_msg_to_bt(MSG_ID_BT_PCM_LB_REQ, NULL);
                return;
            #endif /* defined(__BT_SUPPORT__) */ 
                break;

            }
            else if (mode == 2) //loopback 2 test 
            {
            #ifdef __MMI_FMI__
                /* get bd_addr */
                ret_val = rmmi_bt_hex_validator(source_string_ptr, RMMI_COMMA, 6, bd_addr);
                if (ret_val == KAL_FALSE)
                {
                    break;
                }

                /* get pin_code */
                result = rmmi_string_validator(
                            source_string_ptr,
                            RMMI_PTR->s_reg.s3, /* separator */
                            10,
                            (kal_uint8*) pin_code);

                if (result == RMMI_VALIDATOR_ERROR)
                {
                    ret_val = KAL_FALSE;
                    break;
                }

                l4c_bt_loopback_test_req_lind(bd_addr, pin_code);
                L4C_PTR->route_thru_lmmi = KAL_TRUE;						
		   L4C_PTR->route_thru_lmmi_user= source_string_ptr->src_id;		   
                return;
            #endif /* __MMI_FMI__ */ 
                break;  //no MMI then return ERROR
            }
            else
            {
                break;
            }
            break;
        }
        default:
        {
            break;
        }
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
}


#endif /* __BT_SUPPORT__ */


#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #ifdef __test_mode__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif /* __test_mode__ */ 
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif 


#endif /* __MMI_FMI__ */

#if defined(__USB_MULTIPLE_COMPORT_SUPPORT__) && defined(__USB_ENABLE__)
/*
 AT%DIAG
     - used to get/set the function of diag port
     - after set command, this cmd will trigger UE to reset automatically
     - only for test purpose
     - hash1=232529, hash2=0

     [test] Get the configuration in NVRAM
     AT%DIAG=?
         +DIAG: config=<func>
         OK

     [read] Get the current setting in use
     AT%DIAG?
         +DIAG: setting=<func>
         OK

     [set]  Set new configuration to NVRAM
     AT%DIAG=<func>
         OK/ERROR

     <func>
         0, diag port for TST
         1, diag port for AT
         255, unknown state

     rmmi_diag_func_enum
         RMMI_DIAG_FOR_TST = 0,
         RMMI_DIAG_FOR_AT = 1,
         RMMI_DIAG_FOR_UNKNOWN = 0xFF,
 */
extern UART_PORT TST_PORT;
extern UART_PORT TST_PORT_L1;
void rmmi_diag_hdlr(rmmi_string_struct *source_string_ptr) 
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_INFO, FUNC_RMMI_DIAG_HDLR_ENTRY);
    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_ACTIVE_MODE:
        {
            rmmi_diag_func_enum func = RMMI_DIAG_FOR_UNKNOWN;
            if ((TST_PORT == uart_port_usb2) || (TST_PORT_L1 == uart_port_usb2))
            {
                func = RMMI_DIAG_FOR_TST;
            }
            else
            {
                kal_uint8 cid = RMMI_MAX_CHANNEL_NUMBER;
                for (cid=0; cid<RMMI_MAX_CHANNEL_NUMBER; cid++) //MAUI_02169290, mtk02285
                {
                    if (RMMI_COMM_PTR->port[cid] == uart_port_usb2)
                    {
                        break;
                    }
                }
                if (cid < RMMI_MAX_CHANNEL_NUMBER)
                {
                    func = RMMI_DIAG_FOR_AT;
                }
                kal_trace(TRACE_INFO, INFO_L4C_USBUART2_IS_FOUND_OR_NOT, func == RMMI_DIAG_FOR_AT, cid);
            }
            ret_val = KAL_TRUE;
            rmmi_ptr->arg_list[0] = (void*)&func;			
			if (func == RMMI_DIAG_FOR_AT)
			{
			    string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+DIAG: SETTING = AT(%d)", RMMI_PTR->arg_list, 1);
			}
			else if (func == RMMI_DIAG_FOR_TST)
			{
			    string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+DIAG: SETTING = TST(%d)", RMMI_PTR->arg_list, 1);
			}
			else
			{
			    string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+DIAG: SETTING = UNKNOWN(%d)", RMMI_PTR->arg_list, 1);
			}
            break;
        }
        case  RMMI_READ_MODE:
        {
            ret_val = l4c_eq_read_nvm_uart_port_req(source_string_ptr->src_id, DIAG_NVM_READ);
            if (ret_val == KAL_TRUE)
            {
                return;
            }            
            break;
        }		
        case RMMI_SET_OR_EXECUTE_MODE:
        {
			kal_uint8 error_cause;
			kal_uint8 func;
			l4c_action_enum action; //MAUI_02304946, mtk02285
			
			func = rmmi_int_validator_u8_check(&error_cause,
			                                   source_string_ptr,
			                                   rmmi_ptr->s_reg.s3 /* separator */);	

            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }
            else
            {
                if (func > RMMI_DIAG_FOR_AT)
                {
                    break;
                }
            }

            action = (func == RMMI_DIAG_FOR_AT)?(DIAG_NVM_SET_AT_READ):(DIAG_NVM_SET_TST_READ);
            ret_val = l4c_eq_read_nvm_uart_port_req(source_string_ptr->src_id, (kal_uint16) action);
            if (ret_val == KAL_TRUE)
            {
                return;
            }		
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*)buffer, string_length);
    return;
} /* end of rmmi_diag_hdlr */
#endif /* __USB_MULTIPLE_COMPORT_SUPPORT__ && __USB_ENABLE__, mtk02285_usb2 */


/*****************************************************************************
 * FUNCTION
 *  rmmi_egcmd_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for bypass general command request
 *  add by mtk00924 06/06/26
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_egcmd_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
    kal_uint16 string_length = 0;
    kal_uint8 error_cause;
    kal_uint32 op, data_len;
    kal_uint8 temp_data_str[401], data_str[202];

    kal_mem_set(temp_data_str, 0, 401);
    kal_mem_set(data_str, 0, 202);

    switch (source_string_ptr->cmd_mode)
    {

        case RMMI_SET_OR_EXECUTE_MODE:
        {
            op = rmmi_int_validator_u32_check(&error_cause,
                                              source_string_ptr,
                                              (kal_uint8) RMMI_COMMA /* separator */ );
            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }

            data_len = rmmi_int_validator_u32_check(&error_cause,
                                                    source_string_ptr,
                                                    (kal_uint8) RMMI_COMMA /* separator */ );
            if (error_cause != RMMI_PARSE_OK && error_cause != RMMI_PARSE_NOT_FOUND)
            {
                break;
            }

            ret_val = rmmi_string_validator_ext(
                        &error_cause,
                        source_string_ptr,
                        (kal_uint8) RMMI_PTR->s_reg.s3,
                        401,
                        (kal_uint8*) temp_data_str);
            if (ret_val == RMMI_VALIDATOR_ERROR && error_cause != RMMI_PARSE_NOT_FOUND)
            {
                break;
            }

            if (ret_val != RMMI_VALIDATOR_ERROR)
            {
                ret_val = check_hex_value_ext(temp_data_str, data_str);
            
                if (ret_val == KAL_FALSE)
                {
                    break;
                }
            }

            kal_trace(TRACE_INFO, RMMI_PARAM_UU, op, data_len);

            ret_val = rmmi_general_command_parsing(op, data_len, data_str);
        }
        default:
        {
            break;
        }
    }

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_casp_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for de/activate sound play .
 *  mtk00468 add on 03/30
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
/* Begin: mtk00714 +CASP */
void rmmi_casp_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 mode;                     /* active or deactive for audio play */
    kal_uint8 timer = 0xff;   
    kal_uint8 sound_style;              /* variable for sound style */
    kal_uint8 volume;                   /* sound volume */
    kal_uint8 out_path;                 /* sound output equipment, earphone or loudspeaker etc */
    kal_uint8 error_cause;
    kal_uint8 sound_ID;                /* variable for sound ID */
    kal_uint16 string_length = 0;       /* string length variable */
    kal_uint8 const *rsp_str = NULL;    /* response string and initialization */
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    l4c_context_struct *l4c_ptr = L4C_PTR;


    kal_trace(TRACE_FUNC, FUNC_RMMI_CASP_HDLR_ENTRY);

    /* checking the command mode */
    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE:  /* at+casp = 1,1,1 to play sound 1 and style 1 or +casp=0,1 to stop sound 1 */
        {
            /* Get the seed from the command line and validate it */
            mode = rmmi_int_validator_u8_check(&error_cause,
                                               source_string_ptr,
                                               (kal_uint8) RMMI_COMMA);
            if(error_cause != RMMI_PARSE_OK)
            {
                break;
            }
            
            switch (mode)
            {
                case RMMI_STOP:
                {
                    sound_ID = (kal_uint8) rmmi_int_validator_range_check(&error_cause,
                                                                           source_string_ptr,
                                                                           (kal_uint8) rmmi_ptr->s_reg.s3,
                                                                           0xffff);

                    if(error_cause != RMMI_PARSE_OK)
                    {
                        break;
                    }
                    if(sound_ID > 80)
                    {
                        /* Notify MMI to stop play ringtone */
                        l4c_eq_ringtone_play_req_lind(mode, 0, 0, 0, (sound_ID-80));
                        l4c_ptr->route_thru_lmmi = KAL_TRUE;
                        l4c_ptr->route_thru_lmmi_user = source_string_ptr->src_id;
                        return;
                    }
                    else
                    {
                        /* clear event schedule */
                        if ((l4c_ptr->event_id[2] != 0) && (rmmi_ptr->casp_soundID == sound_ID))
                        {
                            kal_trace(TRACE_INFO, INFO_RMMI_CANCEL_EVENT, l4c_ptr->event_id[2]);
                            evshed_cancel_event(l4c_ptr->event_scheduler_ptr, &(l4c_ptr->event_id[2]));
                            l4c_ptr->event_id[2] = 0;
                        }
                        ret_val = l4c_eq_audio_stop_req(source_string_ptr->src_id, (kal_uint8)sound_ID);
                    }
                    break;
                }
                case RMMI_PLAY:
                {
                    sound_ID = (kal_uint8) rmmi_int_validator_range_check(&error_cause,
                                                                           source_string_ptr,
                                                                           (kal_uint8) RMMI_COMMA,
                                                                           0xffff);

                    if(error_cause != RMMI_PARSE_OK)
                    {
                        break;
                    }

                    sound_style = (kal_uint8) rmmi_int_validator_range_check((kal_uint8*) & error_cause,
                                                                             source_string_ptr,
                                                                             (kal_uint8) RMMI_COMMA,
                                                                             3);
                    if (error_cause != RMMI_PARSE_OK)        //check if the style exist
                    {
                        break;
                    }
                    else        // if(sound_style<=3) 
                    {
                        timer = (kal_uint8) rmmi_int_validator_range_check((kal_uint8*) & error_cause,
                                                                           source_string_ptr,
                                                                           (kal_uint8) RMMI_COMMA,
                                                                           25);
                        if(sound_ID > 80)
                        {
                            /* If ringtone play, must keep this parameter empty!
                               To simplify Ringtone play design, decided to not support timer feature! 
                            */
                            if(error_cause != RMMI_PARSE_NOT_FOUND)
                            {
                                /* RMMI_PARSE_OK also disallow*/
                                break;
                            }
                        }
                        else
                        {
                            if (error_cause == RMMI_PARSE_OK)
                            {
                                if(timer == 0)
                                {
                                    break;
                                }
                            }
                            else    // (timer==RMMI_VALIDATOR_ERROR)
                            {
                                if (error_cause == RMMI_PARSE_ERROR)
                                {
                                    break;
                                }
                            }

                            /* add by mtk00714, in case last timer was not expired */
                            if (l4c_ptr->event_id[2] != 0)
                            {
                                break;
                            }
                        }
                        
                        volume = (kal_uint8)rmmi_int_validator_range_check(&error_cause,
                                                                           source_string_ptr,
                                                                           (kal_uint8) RMMI_COMMA,
                                                                           6);
                        if(error_cause != RMMI_PARSE_OK)
                        {
                            if(error_cause == RMMI_PARSE_NOT_FOUND)
                            {
                                volume = 3; /* give default volume value*/
                            }
                            else
                            {
                                break;
                            }
                        }
                        

                        out_path = (kal_uint8)rmmi_int_validator_range_check(&error_cause,
                                                                             source_string_ptr,
                                                                             (kal_uint8)rmmi_ptr->s_reg.s3,
                                                                             (kal_uint32)MAX_AUDIO_DEVICE_NUM);
                        if(error_cause != RMMI_PARSE_OK)
                        {
                            if(error_cause == RMMI_PARSE_NOT_FOUND)
                            {
                                out_path = (kal_uint8)AUDIO_DEVICE_SPEAKER2; /* default path, MED auto detect output device*/
                            }
                            else
                            {
                                break;
                            }
                        }

                        if(sound_ID > 80)
                        {
                            /* Notify MMI to play ringtone */
                            l4c_eq_ringtone_play_req_lind(mode, sound_style, volume, out_path, (sound_ID-80));
                            l4c_ptr->route_thru_lmmi = KAL_TRUE;
                            l4c_ptr->route_thru_lmmi_user = source_string_ptr->src_id;
                            return;
                        }
                        else
                        {
                            ret_val = l4c_eq_full_para_audio_play_req(source_string_ptr->src_id,
                                                                      sound_ID,
                                                                      sound_style,
                                                                      0,
                                                                      volume,
                                                                      out_path);

                            if (timer <= 25)/* When timer omitted, it will be 0xff */
                            {
                                rmmi_ptr->casp_soundID = sound_ID;
                                l4c_ptr->event_id[2] = evshed_set_event(
                                                        l4c_ptr->event_scheduler_ptr,
                                                        (kal_timer_func_ptr) rmmi_casp_playaudio_timeout_hdlr,
                                                        (void*)&(rmmi_ptr->casp_soundID),
                                                        (timer * 10 * KAL_TICKS_100_MSEC));

                            }
                            break;
                        }
                        
                    }
                    break;
                }
                default:
                {
                    rmmi_ptr->cmee_err = RMMI_ERR_OPERATION_NOT_SUPPORTED;
                }
            }
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}

/* End: mtk00714 +CASP */


/*****************************************************************************
 * FUNCTION
 *  rmmi_esam_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for set LCM for factory test.
 *  mtk00468 add on 07/28
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_esam_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 mode;                     /* variable for en-/disable */
    kal_uint8 const *rsp_str = NULL;    /* response string and initialization */
    kal_uint16 string_length = 0;       /* string length variable */

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
            /* checking the command mode */
        case RMMI_TEST_MODE:    /* at+esam=? */
        {
            rsp_str = (kal_uint8 const*)"+ESAM: (0-2)"; /* prepare the response string */
            string_length = strlen((char*)rsp_str);     /* type casting */
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_SET_OR_EXECUTE_MODE:  /* at+elcm = 4  back to normal idle screen */
        {
            /* Get the seed from the command line and validate it */
            mode = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                              source_string_ptr,
                                                              RMMI_PTR->s_reg.s3,
                                                              2);
            if (mode == RMMI_VALIDATOR_ERROR)
            {
                break;  //error handling
            }
            l4c_eq_set_audio_mode_req(mode);
            ret_val = KAL_TRUE;
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;

}


/*****************************************************************************
 * FUNCTION
 *  rmmi_egmr_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for retrive revision.
 *  mtk00468 add on 08/04
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_egmr_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 op, type;                     /* variable for en-/disable */
    kal_uint8 eq_id[NVRAM_EF_BARCODE_NUM_SIZE + 1];
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];   /* temp buffer for response format usage */
    kal_uint8 const *rsp_str = NULL;        /* response string and initialization */
    kal_uint16 string_length = 0;           /* string length variable */
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;


    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE:  /* at+ealt = 0  loop back test mode acivate */
        {
            /* Get the seed from the command line and validate it */
            op = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                            source_string_ptr,
                                                            RMMI_COMMA,
                                                            1);
            if (op == RMMI_VALIDATOR_ERROR)
            {
                break;  //error handling
            }

            if (op == 0)
            {
                type = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                                  source_string_ptr,
                                                                  rmmi_ptr->s_reg.s3,
                                                                  13);
            }
            else
            {
                type = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                                  source_string_ptr,
                                                                  RMMI_COMMA,
                                                                  12);
            }
            if (type == RMMI_VALIDATOR_ERROR)
            {
                break;
            }
            if (op == 0)        // get operation
            {
                switch (type)
                {
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 13:    // release_flavor
                        ret_val = get_ms_revision(type, (kal_uint8*) eq_id);
                        break;
                    case 5:
                    {
                        ret_val = l4c_eq_read_ms_sn_req(source_string_ptr->src_id, NVRAM_EF_BARCODE_NUM_LID, 1);
                        if(ret_val == KAL_TRUE)
                        {
                            return;
                        }
                        break;
                    }
                    case 6:
                        ret_val = KAL_FALSE;
                        break;
                    case 7:
                #ifdef __GEMINI__
                    case 10:
                #if (L4_MAX_SIM_NUM > 2)
                    case 11: //for SIM3
                #if (L4_MAX_SIM_NUM > 3)
                    case 12: //for SIM4
                #endif
                #endif
                #endif
                    {
                        //mtk02508_090310 use new IMEI Blocking API
                        kal_uint8 imei_bcd[8];
                        kal_uint8 imei_str[16];
                        kal_uint8 result;
                        kal_uint8 rec_idx;

                        if (type == 7)
                        {
                            rec_idx = 1;
                        }
                    #ifdef __GEMINI__
                        else
                        {
                            rec_idx = 2 + (type - 10);
                        }
                    #endif /* __GEMINI__ */
                        rec_idx = l4c_gemini_get_actual_sim_id(rec_idx-1);
                        rec_idx ++;
                        result = nvram_get_imei_value(8, imei_bcd, rec_idx);
                        if (result == KAL_TRUE)
                        {
                            imei_bcd[7] = imei_bcd[7] | 0xf0;
                            convert_to_digit((kal_uint8*) imei_bcd, imei_str);
                            rmmi_ptr->arg_list[0] = (void*)imei_str;
                            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+EGMR: \"%s\"", RMMI_PTR->arg_list, 1);
                            rsp_str = &buffer[0];
                            ret_val = KAL_TRUE;
                        }
                        break;
                    }
                    #if defined(__MMI_FMI__)
                    case 8:
                        kal_sprintf(
                            (kal_char*) buffer,
                            "+AUDIO: \"%u\"\r\n+IMAGE: \"%u\"\r\n+FONT: \"%u\"\r\n+STR: \"%u\"",
                            CURRENT_AUDIO_RES_VERSION,
                            CURRENT_IMAGE_RES_VERSION,
                            CURRENT_FONT_RES_VERSION,
                            CURRENT_STR_RES_VERSION);
                        string_length = strlen((char*)buffer);
                        rsp_str = &buffer[0];
                        ret_val = KAL_TRUE;
                        break;
                    #endif
                    case 9:
                    {
                        ret_val = l4c_eq_read_ms_sv_req(source_string_ptr->src_id, NVRAM_EF_SYS_CACHE_OCTET_LID, NVRAM_SYS_SVN);
                        if(ret_val == KAL_TRUE)
                        {
                            return;
                        }
                        break;
                    }
                    default:
                        break;
                }

                if ((ret_val == KAL_TRUE) && (type != 8) && (type != 7)
                #ifdef __GEMINI__
                    && ((type < 10) || (type > 12)) //type != 10, 11, 12
                #endif /* __GEMINI__ */
                )
                {
                    rmmi_ptr->arg_list[0] = (void*)eq_id;
                    string_length = rmmi_fast_string_print(
                                        buffer,
                                        (kal_uint8*) "+EGMR: \"%s\"",
                                        rmmi_ptr->arg_list,
                                        1);
                    rsp_str = &buffer[0];
                }
                break;
            }
            else        //set operation and only for type 5 and 7 and 9
            {
                kal_uint8 length;
                kal_uint8 nvram_data[NVRAM_EF_BARCODE_NUM_SIZE+1];
                kal_uint8 result;
                kal_uint8 i;

                if ((type != 5) && (type != 7) && (type != 9)
            #ifdef __GEMINI__
                    && ((type < 10) || (type > 12)) //type != 10, 11, 12
            #endif 
                    )
                    break;

                result = (kal_uint8) rmmi_string_validator(
                                        source_string_ptr,
                                        rmmi_ptr->s_reg.s3, /* separator */
                                        (NVRAM_EF_BARCODE_NUM_SIZE + 1),
                                        (kal_uint8*) eq_id);
                if (result == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }
                length = (kal_uint8)strlen((kal_char*) eq_id);

                if (type == 5)
                {
                    kal_mem_cpy((kal_uint8*) nvram_data, (kal_uint8*) eq_id, length + 1);
                    ret_val = l4c_eq_set_ms_sn_req(source_string_ptr->src_id, nvram_data, NVRAM_EF_BARCODE_NUM_SIZE);
                }
                else if (type == 7
                #ifdef __GEMINI__
                         || ((type >= 10) && (type <= 12)) //type == 10, 11, or 12
                #endif /* __GEMINI__ */
                    )
                {
                    kal_uint8 imei_string[NVRAM_EF_IMEI_IMEISV_SIZE];

                    kal_mem_set(imei_string, 0, NVRAM_EF_IMEI_IMEISV_SIZE);
                    
                    /* IMEI: 15 digits */
                    if (length != 15)
                    {
                        break;
                    }
                    for (i = 0; i < 15; i++)
                    {
                        if (!(RMMI_IS_NUMBER(eq_id[i])))
                        {
                            rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNSPECIFIED);
                            return;
                        }
                    }
                    convert_to_bcd((kal_uint8*) eq_id, (kal_uint8*) imei_string, 8);
                    imei_string[7] &= 0x0f;

                    if (type == 7)
                    {
                        rmmi_ptr->imei_action = RMMI_IMEI_WRITE;
                    }
                #ifdef __GEMINI__
                    else //type == 10, 11, or 12
                    {
                        rmmi_ptr->imei_action = RMMI_IMEI_2_WRITE + (type - 10);
                    }
                #endif
                    ret_val = l4c_eq_set_ms_imei_req(source_string_ptr->src_id, imei_string, NVRAM_EF_IMEI_IMEISV_SIZE); //mtk02508_090310
                }
                else if (type == 9)
                {
                    kal_uint8 sv_bcd[NVRAM_EF_SYS_CACHE_OCTET_SIZE];

                    kal_mem_set(sv_bcd, 0, NVRAM_EF_SYS_CACHE_OCTET_SIZE);
                    
                    /* SVN: 2 digits */
                    if (length != 2)
                    {
                        break;
                    }
                    for (i = 0; i < 2; i++)
                    {
                        if (!(RMMI_IS_NUMBER(eq_id[i])))
                        {
                            rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNSPECIFIED);
                            return;
                        }
                    }
                    convert_to_bcd((kal_uint8*) eq_id, (kal_uint8*) sv_bcd, 1);
                    ret_val = l4c_eq_set_ms_sv_req(source_string_ptr->src_id, sv_bcd, NVRAM_EF_SYS_CACHE_OCTET_SIZE);
                }
                if (ret_val == KAL_TRUE)
                {
                    return;
                }

            }
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_eslp_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for enable sleep mpde or disable it.
 *  mtk00468 add on 09/05
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_eslp_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 op;
    kal_uint8 const *rsp_str = NULL;    /* response string and initialization */
    kal_uint16 string_length = 0;       /* string length variable */

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
            /* checking the command mode */
        case RMMI_TEST_MODE:    /* at+eslp=? */
        {
            rsp_str = (kal_uint8 const*)"+ESLP: (0,1)"; /* prepare the response string */
            string_length = strlen((char*)rsp_str);     /* type casting */
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_SET_OR_EXECUTE_MODE:  /* at+ealt = 0  loop back test mode acivate */
        {
            /* Get the seed from the command line and validate it */
            op = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                            source_string_ptr,
                                                            RMMI_PTR->s_reg.s3,
                                                            1);
            if (op == RMMI_VALIDATOR_ERROR)
            {
                break;  //error handling
            }
            ret_val = l4c_em_sleep_mode_req((kal_bool)op);
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}

/*****************************************************************************
 * FUNCTION
 *  rmmi_elnvrm_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for GPO setting for factory test.
 *  mtk00468 add on 09/17
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_elnvrm_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 mode;                     /* variable for en-/disable */
    kal_uint8 const *rsp_str = NULL;    /* response string and initialization */
    kal_uint16 string_length = 0;       /* string length variable */

    /* checking the command mode */
    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:    /* at+envrm=? */
        {
            rsp_str = (kal_uint8 const*)"+ELNVRM: (1)"; /* prepare the response string */
            string_length = strlen((char*)rsp_str);     /* type casting */
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            mode = (kal_uint8) rmmi_int_validator_u8_check(NULL,
                                source_string_ptr,
                                RMMI_PTR->s_reg.s3 /* separator */ );

            if (
        #ifdef ELNVRM_UNLOCK_SUPPORT
                   mode != 0 &&
        #endif 
                   mode != 1 && mode != 3)  /* 1: lock, 3: OTP lock, (0: unlock) */
                break;

            ret_val = l4c_eq_lock_nvram_req(source_string_ptr->src_id, mode);
            if (ret_val != KAL_TRUE)
            {
                break;
            }
            return;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_erftx_hdlr
 * DESCRIPTION
 *  This is the AT handler function for 3G RF TX power setting
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_erftx_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 error_cause; 
    kal_uint8 op;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_ACTIVE_MODE:
        {
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {

            op = (kal_uint8)rmmi_int_validator_range_check(
                                &error_cause,
                                source_string_ptr,
                                RMMI_COMMA, //RMMI_PTR->s_reg.s3,
                                5);

            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }

            if(op == 0)
            {
                #if defined(__UMTS_FDD_MODE__)
                kal_uint8 func;
                kal_uint8 band;
                kal_int8  power;
                kal_uint16 freq;

                func = (kal_uint8)rmmi_int_validator_ext(&error_cause, source_string_ptr, (kal_uint8)RMMI_COMMA);

                /*
                                func = 0: UE WCDMA TX output power setting
                                        = 1: Stop WCDMA TX power output
                            */
                if(func > 1)
                {
                    break;
                }
                else if(func == 0)
                {
                    band = (kal_uint8)rmmi_int_validator_ext(&error_cause, source_string_ptr, (kal_uint8)RMMI_COMMA);
                    
                    if(error_cause != RMMI_PARSE_OK)
                    {
                        break;
                    }
                    
                    freq = (kal_uint16)rmmi_int_validator_ext(&error_cause, source_string_ptr, (kal_uint8)RMMI_COMMA);
                    if(error_cause != RMMI_PARSE_OK)
                    {
                        break;
                    }
                    
                    power = (kal_int8)rmmi_signed_int_validator(&error_cause, source_string_ptr, RMMI_PTR->s_reg.s3);
                    if(error_cause != RMMI_PARSE_OK)
                    {
                        break;
                    }
                    
                    ret_val = l4c_eq_3g_rf_test_req(source_string_ptr->src_id, func, band, freq, power);
                }
                else if(func == 1)
                {
                    ret_val = l4c_eq_3g_rf_test_req(source_string_ptr->src_id, func, 0, 0, 0);
                }
                
                if(ret_val == KAL_TRUE)
                {
                    return;
                }
                else
                {
                    break;
                }
            #endif
            }
            else if(op == 1)
            {
                kal_uint8 para1, para2;
                kal_bool gsm_tbl_valid = KAL_TRUE, umts_tbl_valid = KAL_TRUE;
                
                para1 = (kal_uint8)rmmi_int_validator_range_check(
                                    &error_cause,
                                    source_string_ptr,
                                    RMMI_COMMA, //RMMI_PTR->s_reg.s3,
                                    255);
    
                if (error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    gsm_tbl_valid = KAL_FALSE;
                }
                else if (error_cause != RMMI_PARSE_OK)
                {
                    break;
                }
                else
                {
                    kal_mem_set((void*)RMMI_COMM_PTR->gsm_tx_pwr_reduction_tbl, para1, 4*2*4);
                }
    
                para2 = (kal_uint8)rmmi_int_validator_range_check(
                                    &error_cause,
                                    source_string_ptr,
                                    RMMI_COMMA, //RMMI_PTR->s_reg.s3,
                                    255);            
    
                if (error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    umts_tbl_valid = KAL_FALSE;
                }
                else if (error_cause != RMMI_PARSE_OK)
                {
                    break;
                }
                else
                {
                    kal_mem_set((void*)RMMI_COMM_PTR->umts_tx_pwr_reduction_tbl, para2, 20*2);
                }

                ret_val = l4c_l1_max_tx_pwr_red_req(source_string_ptr->src_id, 
                                                    op, 
                                                    gsm_tbl_valid, 
                                                    (kal_uint8***)(RMMI_COMM_PTR->gsm_tx_pwr_reduction_tbl),
                                                    umts_tbl_valid,
                                                    (kal_uint8**)(RMMI_COMM_PTR->umts_tx_pwr_reduction_tbl));
                break;
            }
            else if (op == 2)
            {
                kal_uint8 type;
                rf_test_gsm_param_struct request;
                kal_mem_set(&request, 0, sizeof(rf_test_gsm_param_struct));

                type = (kal_uint8)rmmi_int_validator_range_check(
                                    &error_cause,
                                    source_string_ptr,
                                    RMMI_COMMA, //RMMI_PTR->s_reg.s3,
                                    3);

                if (error_cause != RMMI_PARSE_OK)
                {
                    break;
                }

                if (type == 0) // RF test GSM stop
                {
                    //l4c_eq_rf_test_gsm_req(source_string_ptr->src_id, type, request);
                }
                else if (type == 1) // RF test GSM TX
                {
                    request.gsm_tx_test.arfcn = (kal_uint16)rmmi_int_validator_range_check(&error_cause, source_string_ptr, RMMI_COMMA, 0xFFFF);
                    request.gsm_tx_test.afc = (kal_int16)rmmi_signed_int_validator(&error_cause, source_string_ptr, RMMI_COMMA);
                    request.gsm_tx_test.band= (kal_uint8)rmmi_int_validator_range_check(&error_cause, source_string_ptr, RMMI_COMMA, 0xFF);
                    request.gsm_tx_test.tsc = (kal_int8)rmmi_signed_int_validator(&error_cause, source_string_ptr, RMMI_COMMA);
                    request.gsm_tx_test.pcl = (kal_int8)rmmi_signed_int_validator(&error_cause, source_string_ptr, RMMI_COMMA);
                    request.gsm_tx_test.pattern= (kal_uint8)rmmi_int_validator_range_check(&error_cause, source_string_ptr, RMMI_PTR->s_reg.s3, 0xFF);
                }
                else if (type == 2) // RF test GSM RX
                {
                    request.gsm_rx_test.arfcn = (kal_int16)rmmi_signed_int_validator(&error_cause, source_string_ptr, RMMI_COMMA);
                    request.gsm_rx_test.gain = (kal_int16)rmmi_signed_int_validator(&error_cause, source_string_ptr, RMMI_COMMA);
                    request.gsm_rx_test.band = (kal_uint8)rmmi_int_validator_range_check(&error_cause, source_string_ptr, RMMI_COMMA, 0xFF);
                    request.gsm_rx_test.pattern = (kal_uint8)rmmi_int_validator_range_check(&error_cause, source_string_ptr, RMMI_PTR->s_reg.s3, 0xFF);
                }
                else if (type == 3) // RF test GSM power scan
                {
                    request.gsm_power_scan.band = (kal_uint8)rmmi_int_validator_range_check(&error_cause, source_string_ptr, RMMI_COMMA, 0xFF);
                    request.gsm_power_scan.arfcn_in = (kal_int16)rmmi_signed_int_validator(&error_cause, source_string_ptr, RMMI_PTR->s_reg.s3);
                }

                l4c_eq_rf_test_gsm_req(source_string_ptr->src_id, type, request);

                if (type == 3)
                {
                    ;//return; // wait for power scan result
                }

                ret_val = KAL_TRUE;
            }
            else if (op == 3 || op == 5)
            {
                kal_uint8 rat;
                kal_bool gsm_tbl_valid = KAL_FALSE, umts_tbl_valid = KAL_FALSE;
                kal_uint8 para;
                kal_uint8 i,j,k;

                rat = (kal_uint8)rmmi_int_validator_range_check(
                                    &error_cause,
                                    source_string_ptr,
                                    RMMI_COMMA,
                                    2);

                if (error_cause != RMMI_PARSE_OK)
                {
                    break;
                }

                if (rat == 1) // GSM
                {
                    gsm_tbl_valid = KAL_TRUE;

                    for (i=0; i<4; i++)
                        for (j=0; j<2; j++)
                            for (k=0; k<4; k++)
                            {
                                kal_uint8 symbol;

                                if (i==3 && j==1 && k==3)
                                {
                                    symbol = RMMI_PTR->s_reg.s3; // The last one
                                }
                                else
                                {
                                    symbol = RMMI_COMMA;
                                }
                                
                                para = (kal_uint8)rmmi_int_validator_range_check(
                                                    &error_cause,
                                                    source_string_ptr,
                                                    symbol,
                                                    255);

                                if (error_cause == RMMI_PARSE_OK)
                                {
                                    RMMI_COMM_PTR->gsm_tx_pwr_reduction_tbl[i][j][k] = para;
                                }
                            }
                }
                else if (rat == 2) // UMTS
                {
                    umts_tbl_valid = KAL_TRUE;

                    for (i=0; i<20; i++)
                        for (j=0; j<2; j++)
                            {
                                kal_uint8 symbol;
                    
                                if (i==19 && j==1)
                                {
                                    symbol = RMMI_PTR->s_reg.s3; // The last one
                                }
                                else
                                {
                                    symbol = RMMI_COMMA;
                                }
                                
                                para = (kal_uint8)rmmi_int_validator_range_check(
                                                    &error_cause,
                                                    source_string_ptr,
                                                    symbol,
                                                    255);
                    
                                if (error_cause == RMMI_PARSE_OK)
                                {
                                    RMMI_COMM_PTR->umts_tx_pwr_reduction_tbl[i][j] = para;
                                }
                            }
                }

                ret_val = l4c_l1_max_tx_pwr_red_req(source_string_ptr->src_id, 
                                                    op, 
                                                    gsm_tbl_valid, 
                                                    (kal_uint8***)(RMMI_COMM_PTR->gsm_tx_pwr_reduction_tbl),
                                                    umts_tbl_valid,
                                                    (kal_uint8**)(RMMI_COMM_PTR->umts_tx_pwr_reduction_tbl));
            }
            else if (op == 4)
            {
                kal_mem_set((void*)(RMMI_COMM_PTR->gsm_tx_pwr_reduction_tbl), 0, 4*2*4);
                kal_mem_set((void*)(RMMI_COMM_PTR->umts_tx_pwr_reduction_tbl), 0, 20*2);

                ret_val = l4c_l1_max_tx_pwr_red_req(source_string_ptr->src_id, 
                                                    op, 
                                                    KAL_TRUE, 
                                                    (kal_uint8***)(RMMI_COMM_PTR->gsm_tx_pwr_reduction_tbl),
                                                    KAL_TRUE,
                                                    (kal_uint8**)(RMMI_COMM_PTR->umts_tx_pwr_reduction_tbl));
            }

            break;
        }
        default:
        {
            ret_val = KAL_FALSE;
            break;
        }
    }

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}

/*****************************************************************************
 * FUNCTION
 *  rmmi_epct_hdlr
 * DESCRIPTION
 *  This is for Protocol Stack Conformance Test profile setting, Enable Get/Set Conformance test profile by
 *  AT Command.
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_epct_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 error_cause;
    kal_uint8 conf_test_mode;
    kal_uint32 test_profile;
    
    switch(source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:
        {
            l4c_em_get_conftest_para_req(source_string_ptr->src_id);
            return;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            conf_test_mode = (kal_uint8)rmmi_int_validator_range_check(&error_cause,
                                                                       source_string_ptr,
                                                                       RMMI_COMMA,
                                                                       (kal_uint8)PS_CONF_TEST_END);
            if(error_cause != RMMI_PARSE_OK)
            {
                break;
            }
            test_profile = rmmi_int_validator_range_check(&error_cause,
                                                          source_string_ptr,
                                                          RMMI_PTR->s_reg.s3,
                                                          0x00FFFFFF);
            if(error_cause != RMMI_PARSE_OK)
            {
                if(error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    test_profile = 0;
                }
                else
                {
                    break;
                }
            }
            ret_val = l4c_em_set_conftest_para_req(source_string_ptr->src_id,
                                                      conf_test_mode,
                                                      test_profile);
            if(ret_val == KAL_TRUE)
            {
                /*Response will be given in NVRAM WRITE CNF handler*/
                /* We can save user input here to L4 context, thus will not require 
                            to manualy reboot handset. But there is a risk that NVRAM write fail case. */
                return;
            }
            break;
            
        }
        default:
        {
            /* Un-supported AT command mode */
            break;
        }
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_eswla_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for Enable SWLA and assert target
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_eswla_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_uint32 op;
    
    switch(source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            op = rmmi_int_validator_range_check(NULL,
                                                source_string_ptr,
                                                RMMI_PTR->s_reg.s3,
                                                1);
            if(op == RMMI_VALIDATOR_ERROR)
            {
                break;
            }
            
            if(op == 0)
            {
                /* Print OK first */
                rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
                ASSERT(0);
            }
            else if(op == 1)
            {
                #if defined(__MTK_TARGET__) && defined(__MTK_INTERNAL__) && !defined(__MAUI_BASIC__)
/* under construction !*/
                #endif
                rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
            }
            return;
        }
        default:
            /* unrecd format of AT command */
            break;
    }
    
    rmmi_final_rsp_generator(source_string_ptr->src_id, KAL_FALSE, NULL, 0);
    return;
}


#if defined(__AT_BACKUP_DATA_SUPPORT__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_esds_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for SDS backup and restore
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_esds_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_TRUE;
	kal_uint8 op;

	
	/* checking the command mode */
	switch (source_string_ptr->cmd_mode)
	{
		case RMMI_SET_OR_EXECUTE_MODE:
		{
			op = (kal_uint8)rmmi_int_validator_range_check(NULL,
														   source_string_ptr,
                                                           RMMI_PTR->s_reg.s3,
                                                           1);
			if(op == RMMI_VALIDATOR_ERROR)
		    {
		    	ret_val = KAL_FALSE;
				break;
		    }

			ret_val = l4c_em_set_sds_req(source_string_ptr->src_id, op);
            if(ret_val == KAL_TRUE)
            {
                return;
            }
			break;
		}
		default:
		{
			/* unrecognized format of AT command line */
			break;
		}
	}	/* end of the switch */
    
    rmmi_final_rsp_generator(source_string_ptr->src_id, KAL_FALSE, NULL, 0);
}
#endif


#ifdef __TC02__
/*****************************************************************************
 * FUNCTION
 *  rmmi_rbti_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for RBTI setting. If this command is executed,
 *  handset will reboot and not enter charging mode.
 *  mtk02508 add on 2010/09/23
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_rbti_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    
    /* checking the command mode */
    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_ACTIVE_MODE:
        {
            ret_val = l4cuem_power_reset(NORMAL_RESET);
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);

    return;
}
#endif /* __TC02__ */


#if defined(__AT_RRC_TRACE_SUPPORT__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_trace_hdlr
 * DESCRIPTION
 *  This command is used to turn on/off RRC Trace function.
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_trace_hdlr(rmmi_string_struct *source_string_ptr)
{
    l4cas_set_rrc_peer_trace_req_struct *param_ptr;
    kal_uint8 trace_on;

    kal_trace(TRACE_FUNC, FUNC_RMMI_TRACE_HDLR_ENTRY);

    switch(source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            trace_on = rmmi_int_validator_range_check(NULL,
                                                      source_string_ptr,
                                                      RMMI_PTR->s_reg.s3,
                                                      1);
            if(trace_on == RMMI_VALIDATOR_ERROR)
            {
                rmmi_result_code_fmttr(RMMI_RCODE_ERROR, L4C_NO_CAUSE);
                return;
            }
            /* send message to ADR */
            param_ptr = (l4cas_set_rrc_peer_trace_req_struct*)
                         construct_local_para((kal_uint16) sizeof(l4cas_set_rrc_peer_trace_req_struct), TD_RESET);
            param_ptr->trace_on = (kal_bool)trace_on;

            msg_send5(l4c_current_mod_id, MOD_ADR, AS_L4C_SAP, 
                    MSG_ID_L4CAS_SET_RRC_PEER_TRACE_REQ, (local_para_struct *)param_ptr);
            /* There is no response from ADR, we suppose set request will be success */
            rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
            break;
        }
        default:
        {
            /* Un-support AT command mode*/
            rmmi_result_code_fmttr(RMMI_RCODE_ERROR, L4C_NO_CAUSE);
            break;
        }
    }
    return;
}

#endif /* defined(__AT_RRC_TRACE_SUPPORT__) */


#if defined(__AT_ESWM_SUPPORT__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_eswm_hdlr
 * DESCRIPTION
 *  This command is used to switch mode.
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_eswm_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 op, mode = 0;
    kal_uint8 const *rsp_str = NULL;
    kal_uint16 string_length = 0;

    kal_trace(TRACE_FUNC, FUNC_RMMI_ESWM_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;

            op = (kal_uint8) rmmi_int_validator_range_check(
                                &error_cause,
                                source_string_ptr,
                                (kal_uint8) RMMI_COMMA,
                                3);          

            if (op == RMMI_VALIDATOR_ERROR)
	        {
	         break;
	        }

            if (op == 1 || op == 2 || op == 3)
            {
                mode = (kal_uint8) rmmi_int_validator_range_check(
                                &error_cause,
                                source_string_ptr,
                                RMMI_PTR->s_reg.s3,
                                1);
                if (mode == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }
            }

            if (op == 0)
            {
            #ifdef __MTK_TARGET__
                rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
                INT_SetCmdToSys (SYS_CMD_SET_BL_DL);
                l4c_target_reset(3);
                return;
            #else
                ret_val = KAL_TRUE;
                break;
            #endif
            }
            else if (op == 1)
            {
                if (mode == 0)
                {
                    l4cuem_at_ef_port_setting(L4CUEM_EF_PORT_MS, NULL);
                }
                else 
                {
                    l4cuem_at_ef_port_setting(L4CUEM_EF_PORT_COM_SWITCH, NULL);
                }
                return;
            }
            else if (op == 2)
            {
                if (mode == 0)
                {
                    l4cuem_at_ef_port_setting(L4CUEM_EF_PORT_SD_LOGGING, (void *)KAL_TRUE);
                }
                else 
                {
                    l4cuem_at_ef_port_setting(L4CUEM_EF_PORT_SD_LOGGING, (void *)KAL_FALSE);
                }
                return;
            }
            else if (op == 3) // 0:CD-ROM , 1: COM port
            {
                l4cuem_at_ef_port_setting(L4CUEM_EF_PORT_CDROM_CONFIG, (void *)(kal_uint32)mode);
                return;
            }
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_sms_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}
#endif /* defined(__AT_ESWM_SUPPORT__) */


#if defined(__UMTS_TDD128_MODE__)
extern void CSCE_SetIsInterRatOpt(kal_bool isInterRatOpt);
extern void meme_update_is3G2HandoverOpt(kal_bool is3G2HandoverOpt);
/*****************************************************************************
 * FUNCTION
 *  rmmi_ecro_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for TDD 23G cell reselection optimization on/off
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_ecro_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_uint8 op;
    kal_bool ret_val = KAL_FALSE;
     switch (source_string_ptr->cmd_mode)
     {
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            op = (kal_uint8)rmmi_int_validator_range_check(NULL,
                                                           source_string_ptr,
                                                           RMMI_PTR->s_reg.s3,
                                                           3);
            if(op == RMMI_VALIDATOR_ERROR)
            {
                break;
            }
            if(op < 2)
            {
                CSCE_SetIsInterRatOpt((kal_bool)op);
            }
            else
            {
                meme_update_is3G2HandoverOpt((kal_bool)(op - 2));
            }
            ret_val = KAL_TRUE;
            break;
        }
        default:
            break;
     }   
     rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
}
#endif /* defined(__UMTS_TDD128_MODE__)*/

#if defined(__AT_ETSTLP_SUPPORT__) || !defined(__MMI_FMI__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_etstlp_hdlr
 * DESCRIPTION
 *  This command is used to set TST logging port.
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_etstlp_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    //kal_uint16 string_length = 0;
    kal_uint8 i;
    kal_uint8 logging_mode;
    rmmi_common_context_struct *rmmi_common_ptr = RMMI_COMM_PTR;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;

            rmmi_common_ptr->etstlp_port[0] = (kal_uint8) rmmi_int_validator_u8_check(
                                &error_cause,
                                source_string_ptr,
                                (kal_uint8) RMMI_COMMA);          

            if (error_cause != RMMI_PARSE_OK)
	        {
                break;
	        }

            rmmi_common_ptr->etstlp_port[1] = (kal_uint8) rmmi_int_validator_u8_check(
                                &error_cause,
                                source_string_ptr,
                                (kal_uint8) RMMI_COMMA);
            if (error_cause != RMMI_PARSE_OK)
	        {
                break;
	        }

            logging_mode = (kal_uint8) rmmi_int_validator_u8_check(
                                &error_cause,
                                source_string_ptr,
                                RMMI_PTR->s_reg.s3);
            if (error_cause != RMMI_PARSE_OK)
	        {
	            if (error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    logging_mode = 0; //1:USB logging; 2:SD logging
                }
                break;
	        }

            /* mapping port from rmmi_etstlp_port_enum to DCL_UART_DEV */
            for (i=0; i<2; i++)
            {
                switch (rmmi_common_ptr->etstlp_port[i])
                {
                    case ETSTLP_UART_PORT1:
                        rmmi_common_ptr->etstlp_port[i] = uart_port1;
                        break;
                    case ETSTLP_UART_PORT2:
                        rmmi_common_ptr->etstlp_port[i] = uart_port2;
                        break;
                    case ETSTLP_USB1:
                        rmmi_common_ptr->etstlp_port[i] = uart_port_usb;
                        break;
                    case ETSTLP_USB2:
                        rmmi_common_ptr->etstlp_port[i] = uart_port_usb2;
                        break;
                    case ETSTLP_DT_PORT:
                        rmmi_common_ptr->etstlp_port[i] = uart_port_dual_talk;
                        break;
                    default:
                        rmmi_common_ptr->etstlp_port[i] = uart_port_null;
                }
                
            }

            kal_brief_trace(TRACE_INFO, 
                            INFO_AT_ETSTLP, 
                            rmmi_common_ptr->etstlp_port[0], 
                            rmmi_common_ptr->etstlp_port[1]);

            ret_val = l4c_tst_change_log_port_req(source_string_ptr->src_id, 
                                                  rmmi_common_ptr->etstlp_port[1],
                                                  rmmi_common_ptr->etstlp_port[0],
                                                  logging_mode);
            if (ret_val == KAL_TRUE)
            {
                return; //print OK after NVRAM write cnf
            }
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}
#endif /* defined(__AT_ETSTLP_SUPPORT__) || !defined(__MMI_FMI__) */


#if !defined(__SLIM_AT__) || defined(__AT_FOR_SPEECH_TUNING_TOOL__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_eadp_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for de/activate Engineer Mode.
 *  mtk00468 add on 06/27
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_eadp_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 op, mode, type, level;    /* variable for en-/disable */
    kal_uint8 gain;
    kal_uint8 const *rsp_str = NULL;    /* response string and initialization */

    //kal_uint8        buffer[RMMI_SHORT_RSP_LEN];  /* temp buffer for response format usage */
    kal_uint16 string_length = 0;                   /* string length variable */
    audio_profile_struct audio_profile;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;


    /* checking the command mode */
    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:    /* at+eadp=? */
        {
            rsp_str = (kal_uint8 const*)"+EADP: (0,1),(0-2),(0-4),(0-6),(0-255)";      /* prepare the response string */
            string_length = strlen((char*)rsp_str); /* type casting */
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_SET_OR_EXECUTE_MODE:  /* at+eadp = 1,0,0,0,2  EM mode acivate */
        {
            /* Get the seed from the command line and validate it */
            kal_mem_set(&audio_profile, 0, sizeof(audio_profile_struct));

            op = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                            source_string_ptr,
                                                            (kal_uint8) RMMI_COMMA,
                                                            1);
            if (op == RMMI_VALIDATOR_ERROR)
            {
                break;
            }
            mode = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                              source_string_ptr,
                                                              (kal_uint8) RMMI_COMMA,
                                                              2);
            if (mode == RMMI_VALIDATOR_ERROR)
            {
                break;
            }
            type = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                              source_string_ptr,
                                                              (kal_uint8) RMMI_COMMA,
                                                              4);
            if (type == RMMI_VALIDATOR_ERROR)
            {
                break;
            }

            switch (op)
            {
                case 0:        //get
                {
                    level = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                                       source_string_ptr,
                                                                       (kal_uint8) rmmi_ptr->s_reg.s3,
                                                                       6);
                    if (level == RMMI_VALIDATOR_ERROR)
                    {
                        break;
                    }

                    //audio_profile.mode = mode;
                    rmmi_ptr->current_src = source_string_ptr->src_id;
                    l4c_eq_get_audio_profile_req(source_string_ptr->src_id, mode /* &audio_profile */ );
                    rmmi_ptr->em_eadp_action = RMMI_EADP_GET;

                    rmmi_ptr->em_audio_type = type;
                    rmmi_ptr->em_volume_level = level;

                    return;
                
                    //break;
                }
                case 1:        //set
                {
                    kal_uint8 error_cause;

                    level = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                                       source_string_ptr,
                                                                       (kal_uint8) RMMI_COMMA,
                                                                       6);
                    if (level == RMMI_VALIDATOR_ERROR)
                    {
                        break;
                    }

                    //audio_profile.mode = mode;
                    /* gain: 0~255 */
                    gain = (kal_uint8) rmmi_int_validator_range_check(&error_cause,
                                                                       source_string_ptr,
                                                                       rmmi_ptr->s_reg.s3,
                                                                       255);

                    if (error_cause != RMMI_PARSE_OK)
                    {
                        break;
                    }

                    rmmi_ptr->current_src = source_string_ptr->src_id;
                    l4c_eq_get_audio_profile_req(source_string_ptr->src_id, mode /* &audio_profile */ );
                    rmmi_ptr->em_eadp_action = RMMI_EADP_SET;

                    rmmi_ptr->em_audio_gain = gain;
                    rmmi_ptr->em_audio_mode = mode;
                    rmmi_ptr->em_audio_type = type;
                    rmmi_ptr->em_volume_level = level;
                    return;             
                }
            }
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_eaps_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for FIR Audio parameter Get/Set
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_eaps_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_uint8 op;
    kal_uint8 para1;
    kal_uint8 para2 = 0xff; /* This parameter needs an initial value */
    kal_uint8 para3 = 0xff; /* This parameter needs an initial value */
    kal_uint32 FIR_Range = 0;
    kal_bool result = KAL_FALSE;
    kal_uint32 fir_coeff_num = SPEECH_FIR_COEFF_NUM;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;


    switch(source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            op = (kal_uint8)rmmi_int_validator_range_check(NULL,
                                                           source_string_ptr,
                                                           (kal_uint8)RMMI_COMMA,
                                                           1);
            if(op == RMMI_VALIDATOR_ERROR)
            {
                break;
            }
            para1 = (kal_uint8)rmmi_int_validator_range_check(NULL,
                                                              source_string_ptr,
                                                              (kal_uint8)RMMI_COMMA,
                                                              4);
            if(para1 == RMMI_VALIDATOR_ERROR)
            {
                break;
            }
            switch(para1)
            {
                case 0:
                case 1:
                {
                    para2 = (kal_uint8)rmmi_int_validator_range_check(NULL,
                                                                      source_string_ptr,
                                                                      (kal_uint8)RMMI_COMMA,
                                                                      #if !defined(__AMRWB_LINK_SUPPORT__)
                                                                      5
                                                                      #else
                                                                      11
                                                                      #endif
                                                                      );
                    if(para2 == RMMI_VALIDATOR_ERROR)
                    {
                        break;
                    }

                    if(para2 < 6)
                    {
                        FIR_Range = (fir_coeff_num- 1)/10;
                    }
                    #if defined(__AMRWB_LINK_SUPPORT__)
                    else
                    {
                        fir_coeff_num = WB_SPEECH_FIR_COEFF_NUM;
                        FIR_Range = (fir_coeff_num - 1)/10;
                    }
                    #endif
                    para3 = (kal_uint8)rmmi_int_validator_range_check(NULL,
                                                                      source_string_ptr,
                                                                      (kal_uint8)RMMI_COMMA,
                                                                      FIR_Range);
                    if(para3 != RMMI_VALIDATOR_ERROR)
                    {
                        result = KAL_TRUE;
                    }
                    break;
                }
                case 2:
                case 3:
                {
                    result = KAL_TRUE;
                    break;
                }
                case 4:
                {
                    para2 = (kal_uint8)rmmi_int_validator_range_check(NULL,
                                                                      source_string_ptr,
                                                                      (kal_uint8)RMMI_COMMA,
                                                                      #if !defined(__AMRWB_LINK_SUPPORT__)
                                                                      7
                                                                      #else
                                                                      15
                                                                      #endif
                                                                      );
                    if(para2 != RMMI_VALIDATOR_ERROR)
                    {
                        result = KAL_TRUE;
                    }
                    break;
                }
            }
            if(result == KAL_FALSE)
            {
                break;
            }
            
            if(op == 0)
            {
                #if defined(__AMRWB_LINK_SUPPORT__)
                if(((para1 <= 1) && (para2 > 5)) || ((para1 == 4) && (para2 > 7)))
                {
                    if(l4c_eq_get_audio_wb_param_req(source_string_ptr->src_id, para1) == KAL_TRUE)
                    {
                        if(para1 == 0)
                        {
                            rmmi_ptr->eaps_action = RMMI_EAPS_WB_INPUT_FIR_GET;
                        }
                        else if(para1 == 1)
                        {
                            rmmi_ptr->eaps_action = RMMI_EAPS_WB_OUTPUT_FIR_GET;
                        }
                        else
                        {
                            rmmi_ptr->eaps_action = RMMI_EAPS_WB_MODE_PARAM_GET;
                        }
                        rmmi_ptr->eaps_para1 = para1;
                        rmmi_ptr->eaps_para2 = para2;
                        rmmi_ptr->eaps_para3 = para3;
                        
                        return; 
                    }
                }
                else
                #endif
                {
                    if(l4c_eq_get_audio_param_req(source_string_ptr->src_id) == KAL_TRUE)
                    {
                        rmmi_ptr->eaps_action = RMMI_EAPS_GET;
                        rmmi_ptr->eaps_para1 = para1;
                        rmmi_ptr->eaps_para2 = para2;
                        rmmi_ptr->eaps_para3 = para3;
                        return;
                    }
                }
                
                break;
            }
            else
            {
                kal_uint8 error_cause;
                kal_uint8 ret_val = 0xff;
                kal_uint8 param_str[96];
                kal_uint32 in_limit;
                kal_uint16 setting;
                void *param_ptr;

                #if defined(__AMRWB_LINK_SUPPORT__)
                if((para1 <= 1) && (para2 > 5)) 
                {
                    param_ptr = (void *)get_ctrl_buffer(sizeof(audio_wb_speech_fir_struct));
                }
                else if((para1 == 4) && (para2 > 7))
                {
                    param_ptr = (void *)get_ctrl_buffer(sizeof(audio_wb_speech_mode_struct));
                }
                else
                #endif
                {
                    param_ptr = (void *)get_ctrl_buffer(sizeof(audio_param_struct));
                }
                
                switch(para1)
                {
                    case 0:
                    case 1:
                    {
                        ret_val = rmmi_string_validator(source_string_ptr,
                                                        rmmi_ptr->s_reg.s3,
                                                        95,
                                                        param_str);
                        if(ret_val == RMMI_VALIDATOR_ERROR)
                        {
                            result = KAL_FALSE;
                        }
                        if(para3 == FIR_Range)
                        {
                            in_limit = fir_coeff_num - (para3 * 10);
                        }
                        else
                        {
                            in_limit = 10;
                        }
                        #if defined(__AMRWB_LINK_SUPPORT__)
                        if(para2 > 5)
                        {
                            ret_val = check_dotted_value16(param_str,
                                                           (kal_uint16 *)(((audio_wb_speech_fir_struct*)param_ptr)->coeff[para2 - 6] + 10*para3),
                                                           in_limit);
                        }
                        else
                        #endif
                        {
                            if(para1 == 0)
                            {
                            
                                ret_val = check_dotted_value16(param_str,
                                                               (kal_uint16*)(((audio_param_struct*)param_ptr)->speech_input_FIR_coeffs[para2] + 10*para3),
                                                               in_limit);
                            }
                            else
                            {
                                ret_val = check_dotted_value16(param_str,
                                                               (kal_uint16*)(((audio_param_struct*)param_ptr)->speech_output_FIR_coeffs[para2] + 10*para3),
                                                               in_limit);
                            }
                        }

                        if(ret_val == RMMI_VALIDATOR_ERROR) 
                        {
                            result = KAL_FALSE;
                        }
                        break;
                    }
                    case 2:
                    {
                        setting = (kal_uint16)rmmi_int_validator_u16_check(&error_cause,
                                                                           source_string_ptr,
                                                                           rmmi_ptr->s_reg.s3);
                        if(error_cause != RMMI_PARSE_OK)
                        {
                            result = KAL_FALSE;
                        }
                        ((audio_param_struct *)param_ptr)->selected_FIR_output_index = setting;
                        break;
                    }
                    case 3:
                    case 4:
                    {
                        ret_val = rmmi_string_validator(source_string_ptr,
                                                        rmmi_ptr->s_reg.s3,
                                                        95,
                                                        param_str);
                        if(ret_val == RMMI_VALIDATOR_ERROR)
                        {
                            result = KAL_FALSE;
                        }
                        
                        if(para1 == 3)
                        {
                            ret_val = check_dotted_value16(param_str,
                                                           ((audio_param_struct*)param_ptr)->speech_common_para,
                                                           12);
                        }
                        else
                        {
                            #if defined(__AMRWB_LINK_SUPPORT__)
                            if(para2 > 7)
                            {
                                ret_val = check_dotted_value16(param_str,
                                                               (kal_uint16*)(((audio_wb_speech_mode_struct*)param_ptr)->param[para2 - 8]),
                                                               16);
                            }
                            else
                            #endif
                            {
                                ret_val = check_dotted_value16(param_str,
                                                               (kal_uint16*)(((audio_param_struct*)param_ptr)->speech_mode_para[para2]),
                                                               16);
                            }
                        }

                        if(ret_val == RMMI_VALIDATOR_ERROR)
                        {
                            result = KAL_FALSE;
                        }
                        break;
                    }
                }

                if(result == KAL_FALSE)
                {
                    free_ctrl_buffer((void*)param_ptr);
                    break;
                }
                else
                {
                    #if defined(__AMRWB_LINK_SUPPORT__)
                    if(((para1 <= 1) && (para2 > 5)) || ((para1 == 4) && (para2 > 7)))
                    {
                        if(l4c_eq_get_audio_wb_param_req(source_string_ptr->src_id, para1) == KAL_TRUE)
                        {
                            rmmi_ptr->eaps_audio_param = param_ptr;
                            if(para1 == 0)
                            {
                                rmmi_ptr->eaps_action = RMMI_EAPS_WB_INPUT_FIR_SET;
                            }
                            else if(para1 == 1)
                            {
                                rmmi_ptr->eaps_action = RMMI_EAPS_WB_OUTPUT_FIR_SET;
                            }
                            else
                            {
                                rmmi_ptr->eaps_action = RMMI_EAPS_WB_MODE_PARAM_SET;
                            }
                            rmmi_ptr->eaps_para1 = para1;
                            rmmi_ptr->eaps_para2 = para2;
                            rmmi_ptr->eaps_para3 = para3;
                            return;
                        }
                    }
                    else
                    #endif
                    {
                        if(l4c_eq_get_audio_param_req(source_string_ptr->src_id) == KAL_TRUE)
                        {
                            rmmi_ptr->eaps_audio_param = param_ptr;
                            rmmi_ptr->eaps_action = RMMI_EAPS_SET;
                            rmmi_ptr->eaps_para1 = para1;
                            rmmi_ptr->eaps_para2 = para2;
                            rmmi_ptr->eaps_para3 = para3;
                            return;
                        }
                    }
                    break;
                }
            }
            break;
        }
        default:
        {
            /* Unknown Command Format*/
            break;
        }
    }
    /* Audio parameter Get/Set action will wait for MED response, Run to here indicate error*/
    rmmi_result_code_fmttr(RMMI_RCODE_ERROR, L4C_NO_CAUSE);
}
#endif /* !defined(__SLIM_AT__) || defined(__AT_FOR_SPEECH_TUNING_TOOL__) */

#if defined(__NFC_SUPPORT__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_enfc_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for NFC realated test
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/

void rmmi_enfc_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 error_cause;
    kal_uint32 option;
    kal_uint32 type;
    kal_uint32 action;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    

    
    switch(source_string_ptr->cmd_mode)
	{
	    case RMMI_SET_OR_EXECUTE_MODE:
        {
            option = rmmi_int_validator_range_check(&error_cause,
                                                    source_string_ptr,
                                                    (kal_uint8)RMMI_COMMA,
                                                    3);
            /* Meaning of option:
               option = 0: NFC_SWP_SELF_TEST_REQ
               option = 1: NFC_ANTENNA_SELF_TEST_REQ
               option = 2: NFC_TAG_UID_RW_REQ
            */
            
            if(option == RMMI_VALIDATOR_ERROR)
            {
                break;
            }
            
            type = rmmi_int_validator_u32_check(&error_cause,
                                                source_string_ptr,
                                                (kal_uint8)RMMI_COMMA);

            if(error_cause != RMMI_PARSE_OK)
            {
                break;
            }

            action = rmmi_int_validator_u32_check(&error_cause,
                                                  source_string_ptr,
                                                  (kal_uint8)RMMI_COMMA);
            if(error_cause != RMMI_PARSE_OK)
            {
                break;
            }

            if(option == 0 || option == 1)
            {
                nfc_script_request msg_data;

                msg_data.type = type;
                msg_data.action = action;
                
                ret_val = l4c_eq_nfc_test_req(source_string_ptr->src_id, option, (void *)&msg_data);
                if(ret_val == KAL_TRUE)
                {
                    return;
                }
            }
            else if(option == 2)
            {
                kal_uint32 uid_length;
                kal_uint32 string_len;
                kal_uint8 temp_data[20];
                kal_uint8 data_string[40];
                nfc_script_uid_request msg_data;

                rmmi_string_validator_ext(&error_cause,
                                          source_string_ptr,
                                          RMMI_PTR->s_reg.s3,
                                          35,
                                          (kal_uint8 *)data_string);

                if(error_cause != RMMI_PARSE_OK)
                {
                    break;
                }
                string_len = strlen(data_string);
                if(string_len%2 != 0)
                {
                    break;
                }

                uid_length = string_len/2;
                if(uid_length > MAX_UID_DATA_LEN)
                {
                    break;
                }
                
                ret_val = check_hex_value_ext(data_string, temp_data);
                if(ret_val == KAL_FALSE)
                {
                    break;
                }

                kal_mem_cpy((void*)msg_data.data, (void *)temp_data, uid_length);
                msg_data.type = type;
                msg_data.action = action;
                msg_data.uid_length = uid_length;
                ret_val = l4c_eq_nfc_test_req(source_string_ptr->src_id, option,(void *)&msg_data);
                if(ret_val = KAL_TRUE)
                {
                    return;
                }
            }
            else if(option == 3)
            {
                kal_uint16 technology = 0;
                kal_uint16 protocols = 0;
                nfc_meta_card_emulation_request msg_data;
                
                technology = rmmi_int_validator_u16_check(&error_cause,
                                                          source_string_ptr,
                                                          (kal_uint8)RMMI_COMMA);
                if(error_cause != RMMI_PARSE_OK)
                {
                    break;
                }
                
                protocols = rmmi_int_validator_u16_check(&error_cause,
                                                          source_string_ptr,
                                                          (kal_uint8)RMMI_PTR->s_reg.s3);
                if(error_cause != RMMI_PARSE_OK)
                {
                    break;
                }
                
                msg_data.type = type;
                msg_data.action = action;
                msg_data.technology = technology;
                msg_data.protocols = protocols;
                ret_val = l4c_eq_nfc_test_req(source_string_ptr->src_id, option, (void *)&msg_data);
                if(ret_val = KAL_TRUE)
                {
                    return;
                }
            }
            break;
        }
        default:
        {
            break;
        }
	}

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
}
#endif


/*mtk01616_100303: The commands below are not used by MTK internally now.
   We wrap this feature option, so that we can disable these seldom used command to save ROM size 
   Currently, we only add this feature option in low cost project to default disable these command support */
#if !defined(__DISABLE_SELDOM_USED_PROPRIETARY_CMD__)
#ifdef __MMI_FMI__
/*****************************************************************************
 * FUNCTION
 *  rmmi_cems_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for de/activate Engineer Mode.
 *  mtk00468 add on 03/24
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cems_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 mode;                         /* variable for en-/disable */
    kal_uint8 const *rsp_str = NULL;        /* response string and initialization */
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];   /* temp buffer for response format usage */
    kal_uint16 string_length = 0;           /* string length variable */
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;


    kal_trace(TRACE_FUNC, FUNC_RMMI_CEMS_HDLR_ENTRY);

    /* checking the command mode */
    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:    /* at+cems=? */
        {
            rsp_str = (kal_uint8 const*)"+CEMS: (0-3)"; /* prepare the response string */
            string_length = strlen((char*)rsp_str);     /* type casting */
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_READ_MODE:    /* at+cems? */
        {

            rmmi_ptr->arg_list[0] = (void*)&rmmi_ptr->em_enable;       /* save the value into rmmi context para array */
            string_length = rmmi_fast_string_print(
                                /* using this macro to format the string quickly */ buffer,
                                (kal_uint8*) "+CEMS: %d",
                                rmmi_ptr->arg_list,
                                1);
            rsp_str = &buffer[0];
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:  /* at+cems = 1  EM mode acivate */
        {
            /* Get the seed from the command line and validate it */
            mode = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                              source_string_ptr,
                                                              rmmi_ptr->s_reg.s3,
                                                              3);
            if (mode == RMMI_VALIDATOR_ERROR)   /* error checking for invalid value */
            {
                break;
            }
            switch (mode)
            {
                case 0:
                case 1:
                    rmmi_ptr->em_enable = mode; /* set globale variable value */
                case 2:
                    //mmi_ind_ft[FACTORY_IND][LMMI_SRC](KAL_FALSE);
                    l4c_factory_test_lind(KAL_FALSE);
                    break;
                case 3:
                    //mmi_ind_ft[FACTORY_IND][LMMI_SRC](KAL_TRUE);
                    l4c_factory_test_lind(KAL_TRUE);
                    break;

            }
            ret_val = KAL_TRUE;
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_eslcd_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for set LCD contrast default value for customer.
 *  mtk00468 add on 03/12/16
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_eslcd_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 sign, value;              /* variable for en-/disable */
    kal_uint8 const *rsp_str = NULL;    /* response string and initialization */
    kal_uint16 string_length = 0;       /* string length variable */

    /* checking the command mode */
    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:    /* at+egslcd=? */
        {
            rsp_str = (kal_uint8 const*)"+ESLD: (0,1), (0-254)";       /* prepare the response string */
            string_length = strlen((char*)rsp_str); /* type casting */
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_SET_OR_EXECUTE_MODE:  /* at+egpio = 1,1  EM mode acivate */
        {
            /* Get the seed from the command line and validate it */
            l4c_hw_profile_struct hw_profile;
            kal_uint8 i;

            sign = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                              source_string_ptr,
                                                              (kal_uint8) RMMI_COMMA,
                                                              1);
            if (sign == RMMI_VALIDATOR_ERROR)
            {
                break;
            }
            value = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                               source_string_ptr,
                                                               RMMI_PTR->s_reg.s3,
                                                               254);
            if (value == RMMI_VALIDATOR_ERROR)  /* error checking for invalid value */
            {
                break;
            }

            l4c_eq_get_hw_level_req(source_string_ptr->src_id, &hw_profile);
            switch (sign)
            {
                case 0:        //negative
                {
                    for (i = 0; i < 15; i++)
                    {
                        if (hw_profile.MainLCD_Contrast_Level_Info[i] >= value)
                        {
                            hw_profile.MainLCD_Contrast_Level_Info[i] =
                                hw_profile.MainLCD_Contrast_Level_Info[i] - value;
                        }
                        else
                        {
                            hw_profile.MainLCD_Contrast_Level_Info[i] = 0;
                        }
                    }
                    break;
                }
                case 1:        //postive
                {
                    for (i = 0; i < 15; i++)
                    {
                        if ((0xff - hw_profile.MainLCD_Contrast_Level_Info[i]) >= value)
                        {
                            hw_profile.MainLCD_Contrast_Level_Info[i] =
                                hw_profile.MainLCD_Contrast_Level_Info[i] + value;
                        }
                        else
                        {
                            hw_profile.MainLCD_Contrast_Level_Info[i] = 0xff;
                        }
                    }
                    break;
                }
            }
            l4c_eq_set_hw_level_req(source_string_ptr->src_id, &hw_profile);
            return;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_eshw_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for read/write PWM hw default value.
 *  mtk00714 add on 06/28
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_eshw_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 op;                           /* variable for en-/disable */
    kal_uint8 type;                         /* PWM1, PWM2, AlTER */
    kal_uint8 const *rsp_str = NULL;        /* response string and initialization */
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];   /* temp buffer for response format usage */
    kal_uint16 string_length = 0;           /* string length variable */
    l4c_hw_profile_struct hw_profile;
    kal_uint8 i;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;


    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
            /* checking the command mode */
        case RMMI_TEST_MODE:    /* at+espwm=? */
        {
            rsp_str = (kal_uint8 const*)"+ESHW: (0,1), (1-5)"; /* prepare the response string */
            string_length = strlen((char*)rsp_str); /* type casting */
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_SET_OR_EXECUTE_MODE:  /* at+epwm = 0  EM mode acivate */
        {
            /* Get the seed from the command line and validate it */
            op = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                            source_string_ptr,
                                                            (kal_uint8) RMMI_COMMA,
                                                            1);
            if (op == RMMI_VALIDATOR_ERROR)
            {
                break;
            }

            switch (op)
            {
                case 0:        //get
                {
                    type = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                                      source_string_ptr,
                                                                      (kal_uint8) rmmi_ptr->s_reg.s3,
                                                                      5);
                    if ((type == RMMI_VALIDATOR_ERROR) || (type == 0))
                    {
                        break;
                    }

                    l4c_eq_get_hw_level_req(source_string_ptr->src_id, &hw_profile);

                    if (type <= 3)
                    {
                        for (i = 0; i < 5; i++)
                        {
                            if (type == 1)
                            {
                                rmmi_ptr->arg_list[i * 2] = (void*)&hw_profile.PWM1_freq_Level_Info[i];
                                rmmi_ptr->arg_list[i * 2 + 1] = (void*)&hw_profile.PWM1_duty_Level_Info[i];
                            }
                            else if (type == 2)
                            {
                                rmmi_ptr->arg_list[i * 2] = (void*)&hw_profile.PWM2_freq_Level_Info[i];
                                rmmi_ptr->arg_list[i * 2 + 1] = (void*)&hw_profile.PWM2_duty_Level_Info[i];
                            }
                            else        //if(type == 3)
                            {
                                rmmi_ptr->arg_list[i * 2] = (void*)&hw_profile.PWM3_freq_Level_Info[i];
                                rmmi_ptr->arg_list[i * 2 + 1] = (void*)&hw_profile.PWM3_duty_Level_Info[i];
                            }
                        }
                        string_length = rmmi_fast_string_print(
                                            buffer,
                                            (kal_uint8*) "(%g,%g),(%g,%g),(%g,%g),(%g,%g),(%g,%g)",
                                            rmmi_ptr->arg_list,
                                            10);
                    }
                    else        // type = 4 or type ==5
                    {
                        for (i = 0; i < 15; i++)
                        {
                            if (type == 4)      //get Main LCD contract
                            {
                                rmmi_ptr->arg_list[i] = (void*)&hw_profile.MainLCD_Contrast_Level_Info[i];
                            }
                        #ifdef DUAL_LCD
                            else        //if(type==5)      //get Sub LCD contract
                            {
                                rmmi_ptr->arg_list[i] = (void*)&hw_profile.SubLCD_Contrast_Level_Info[i];
                            }
                        #endif /* DUAL_LCD */ 
                        }
                        string_length = rmmi_fast_string_print(
                                            buffer,
                                            (kal_uint8*) "%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d",
                                            rmmi_ptr->arg_list,
                                            15);
                    }
                    rsp_str = &buffer[0];
                    ret_val = KAL_TRUE;
                    break;
                }
                case 1:        //set
                {
                    kal_uint8 i;
                    kal_uint32 pwm_value[10];
                    kal_uint8 lcd_value[15];
                    kal_uint8 seperator;
                    kal_bool parse_error = KAL_FALSE;

                    type = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                                      source_string_ptr,
                                                                      (kal_uint8) RMMI_COMMA,
                                                                      5);
                    if ((type == RMMI_VALIDATOR_ERROR) || (type == 0))
                    {
                        break;
                    }

                    if ((type >= 1) && (type <= 3))     //PWMs
                    {
                        for (i = 0; i < 10; i++)
                        {
                            if (i == 9) //last one
                            {
                                seperator = rmmi_ptr->s_reg.s3;
                            }
                            else
                            {
                                seperator = RMMI_COMMA;
                            }

                            pwm_value[i] = (kal_uint32) rmmi_int_validator(source_string_ptr, (kal_uint8) seperator);
                            if (pwm_value[i] == RMMI_VALIDATOR_ERROR)
                            {
                                parse_error = KAL_TRUE;
                                break;
                            }
                        }
                    }
                    else        //Main LCD and Sub LCD
                    {
                        for (i = 0; i < 15; i++)
                        {
                            if (i == 14)        //last one
                            {
                                seperator = rmmi_ptr->s_reg.s3;
                            }
                            else
                            {
                                seperator = RMMI_COMMA;
                            }
                            lcd_value[i] = (kal_uint8) rmmi_int_validator(source_string_ptr, (kal_uint8) seperator);
                            if (lcd_value[i] == RMMI_VALIDATOR_ERROR)
                            {
                                parse_error = KAL_TRUE;
                                break;
                            }
                        }
                    }
                    if (parse_error == KAL_TRUE)
                    {
                        break;
                    }

                    l4c_eq_get_hw_level_req(source_string_ptr->src_id, &hw_profile);
                    switch (type)
                    {
                        case 1:        //set PWM1
                        {
                            for (i = 0; i < 5; i++)
                            {
                                /* set to global variable */
                                //                                                                      PWM1_Level_Info[i][0] = pwm_value[i*2];
                                //                                                                      PWM1_Level_Info[i][1] = pwm_value[i*2+1];
                                /* write to NVRAM */
                                hw_profile.PWM1_freq_Level_Info[i] = pwm_value[i * 2];
                                hw_profile.PWM1_duty_Level_Info[i] = pwm_value[i * 2 + 1];
                            }
                            break;
                        }
                        case 2:        //set PWM2
                        {
                            for (i = 0; i < 5; i++)
                            {
                                //                                                                      PWM2_Level_Info[i][0] = pwm_value[i*2];
                                //                                                                      PWM2_Level_Info[i][1] = pwm_value[i*2+1];
                                hw_profile.PWM2_freq_Level_Info[i] = pwm_value[i * 2];
                                hw_profile.PWM2_duty_Level_Info[i] = pwm_value[i * 2 + 1];
                            }
                            break;
                        }
                        case 3:        //set PWM3
                        {
                            for (i = 0; i < 5; i++)
                            {
                                //                                                                      Alter_Level_Info[i][0] = pwm_value[i*2];
                                //                                                                      Alter_Level_Info[i][1] = pwm_value[i*2+1];
                                hw_profile.PWM3_freq_Level_Info[i] = pwm_value[i * 2];
                                hw_profile.PWM3_duty_Level_Info[i] = pwm_value[i * 2 + 1];
                            }
                            break;
                        }
                        case 4:        //set Main Contract
                        {
                            for (i = 0; i < 15; i++)
                            {
                                //                                                       MainLCD_Contrast_Level_Info[i]=lcd_value[i];
                                hw_profile.MainLCD_Contrast_Level_Info[i] = lcd_value[i];
                            }
                            break;
                        }
                        case 5:        //set Sub Contract
                        default:
                        {
                            for (i = 0; i < 15; i++)
                            {
                                //                                                     SubLCD_Contrast_Level_Info[i]=lcd_value[i];
                                hw_profile.SubLCD_Contrast_Level_Info[i] = lcd_value[i];
                            }
                        }
                    }
                    l4c_eq_set_hw_level_req(source_string_ptr->src_id, &hw_profile);
                    return;
                }
            }
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_emmistr_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_emmistr_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 op;
    kal_uint16 length;
    kal_uint8 data_string[250];
    kal_uint8 error_cause;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    kal_uint8 const *rsp_str = NULL;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    l4c_context_struct *l4c_ptr = L4C_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_EMMISTR_HDLR_ENTRY);

    kal_mem_set(data_string, 0, 250);

    rmmi_ptr->action_cmd = source_string_ptr->cmd_index;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:
        {
            kal_sprintf((kal_char*) buffer, "+EMMISTR: %d", rmmi_ptr->MMI_string_enable);

            string_length = strlen((char*)buffer);
            rsp_str = &buffer[0];
            ret_val = KAL_TRUE;
            break;

        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            /* parse <op> */
            op = (kal_uint8) rmmi_int_validator_range_check(&error_cause,
                                                            source_string_ptr,
                                                            (kal_uint8) RMMI_COMMA,
                                                            3);

            if (op == 0)    /* disable MMI trace string function */
            {
                l4c_eq_str_enable_req_lind(KAL_FALSE);
                rmmi_ptr->MMI_string_enable = RMMI_EMMISTR_DISABLE;

		   l4c_ptr->route_thru_lmmi = KAL_TRUE;						
		   l4c_ptr->route_thru_lmmi_user= source_string_ptr->src_id;		   
                return; /* wait for MSG_ID_MMI_AT_GENERAL_RES_REQ to return OK/ERROR */
            }
            else if (op == 1)   /* enable MMI trace string function */
            {
                l4c_eq_str_enable_req_lind(KAL_TRUE);
                rmmi_ptr->MMI_string_enable = RMMI_EMMISTR_ENABLE;

		   l4c_ptr->route_thru_lmmi = KAL_TRUE;						
		   l4c_ptr->route_thru_lmmi_user= source_string_ptr->src_id;		   
                return; /* wait for MSG_ID_MMI_AT_GENERAL_RES_REQ to return OK/ERROR */
            }
            else if (op == 2)   /* PC sends data to MMI */
            {
                if (rmmi_ptr->MMI_string_enable == RMMI_EMMISTR_DISABLE)
                {
                    break;
                }

                length = (kal_uint16) rmmi_int_validator_range_check(&error_cause,
                                                                     source_string_ptr,
                                                                     (kal_uint8) RMMI_COMMA,
                                                                     250);

                if ((length == 0) || (error_cause != RMMI_PARSE_OK))
                {
                    break;
                }

                ret_val = rmmi_string_validator_ext(
                            &error_cause,
                            source_string_ptr,
                            (kal_uint8) rmmi_ptr->s_reg.s3,
                            250,
                            (kal_uint8*) data_string);

                if (error_cause != RMMI_PARSE_OK)
                {
                    break;
                }

                if (length > 0)
                {
                    l4c_eq_str_req_lind(length, data_string);

			 l4c_ptr->route_thru_lmmi = KAL_TRUE;						
		       l4c_ptr->route_thru_lmmi_user= source_string_ptr->src_id;		   
                    return; /* wait for MSG_ID_MMI_AT_GENERAL_RES_REQ to return OK/ERROR */
                }
            }
            else if (op == 3)   /* write MMI data string to UART transparently */
            {
                rmmi_ptr->MMI_string_enable = RMMI_EMMISTR_DATA_FROM_MMI;
                ret_val = KAL_TRUE;
            }
            else    /* invalid op */
            {
                break;
            }
        }
        default:
            break;
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    rmmi_ptr->action_cmd = RMMI_MAX_CMD_NUM;
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_esdp_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for set MMI defaul prof with wallparper and ring tone.
 *  mtk00468 add on 11/17
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_esdp_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 op, category, param1, param2, param3; /* variable for en-/disable */
    kal_uint8 const *rsp_str = NULL;                /* response string and initialization */
    kal_uint16 string_length = 0;                   /* string length variable */
    kal_uint8 param4[10];
    kal_bool parse_error = KAL_FALSE;
    kal_uint8 number;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    switch (source_string_ptr->cmd_mode)
    {
            //#ifdef __test_mode__
            /* checking the command mode */
        case RMMI_TEST_MODE:    /* at+elcm=? */
        {
        #ifdef PLUTO_MMI
            number = PhnsetGetATDisplayBound();
        #else 
            number = 4;
        #endif 

            string_length = (kal_uint16)kal_sprintf((char*)buffer, "+ESDP: (0-1), (0,2-%d)", number);
            rsp_str = &buffer[0];
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE: 
        {
            /* Get the seed from the command line and validate it */
            op = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                            source_string_ptr,
                                                            (kal_uint8) RMMI_COMMA,
                                                            1);
            if (op == RMMI_VALIDATOR_ERROR)
            {
                break;  //error handling
            }
            category = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                                  source_string_ptr,
                                                                  (kal_uint8) RMMI_COMMA,
                                                                  ESDP_CATEGORY_MAX);
            if ((category == RMMI_VALIDATOR_ERROR) || (category == ESDP_CATEGORY_RINGTONE))
            {
                /* Currently Ringtone setting is disabled */
                break;  //error handle
            }
            if (op == 0)        //query the valid range of type and value
            {
                l4c_em_set_mmi_default_prof_ind(source_string_ptr->src_id, op, category, 0, 0, 0, NULL);
                return;
            }
            else        //op=1, set command
            {
                param1 = (kal_uint8) rmmi_int_validator_u8_check(NULL,
                                                                 source_string_ptr,
                                                                 (kal_uint8) RMMI_COMMA);
                
                if (param1 != 0)        // only 0 is ok
                {
                    rmmi_ptr->cmee_err = RMMI_ERR_OPERATION_NOT_SUPPORTED;
                    break;
                }
                param2 = (kal_uint8) rmmi_int_validator_u8_check(NULL,
                                                                 source_string_ptr,
                                                                 (kal_uint8) RMMI_COMMA);
                if (param2 != 0)        //only 0 is ok  
                {
                    rmmi_ptr->cmee_err = RMMI_ERR_OPERATION_NOT_SUPPORTED;
                    break;
                }

                param3 = (kal_uint8) rmmi_int_validator_u8_check(NULL,
                                                                 source_string_ptr,
                                                                 rmmi_ptr->s_reg.s3);
                switch (category)
                {
                    case ESDP_CATEGORY_WALLPAPER:    //wall paper
                    //case ESDP_CATEGORY_RINGTONE:    //tone
                    case ESDP_CATEGORY_HOMECITY:    //home city
                    case ESDP_CATEGORY_THEME:    //theme
                    case ESDP_CATEGORY_SCREENSAVER:    //screen saver 
                    case ESDP_CATEGORY_PWRONDISPLAY:    //power_on display
                    case ESDP_CATEGORY_PWROFFDISPLAY:    //power_off display                                      
                    {
                        if (param3 == 0 || param3 == RMMI_VALIDATOR_ERROR)
                        {
                            rmmi_ptr->cmee_err = RMMI_ERR_OPERATION_NOT_SUPPORTED;
                            parse_error = KAL_TRUE;
                        }
                        break;
                    }
                    case ESDP_CATEGORY_SHORTCUT:    //short cut
                    {
                        kal_uint8 result;
                        kal_uint8 get_num;
                        kal_uint8 param4_str[30];

                        result = rmmi_string_validator(
                                    source_string_ptr,
                                    (kal_uint8) rmmi_ptr->s_reg.s3,
                                    30,
                                    (kal_uint8*) param4_str);
                        if (result == RMMI_VALIDATOR_ERROR)
                        {
                            rmmi_ptr->cmee_err = RMMI_ERR_SYNTEX_ERROR;
                            parse_error = KAL_TRUE;
                            break;
                        }

                        //MAUI_02555586 mtk02126 refine check_dotted_value8
                        get_num = check_dotted_value8(param4_str, param4, 10);
                        if (get_num != 10)  // get_num != 10 including the RMMI_VALIDATOR_ERROR case
                        {
                            rmmi_ptr->cmee_err = RMMI_ERR_SYNTEX_ERROR;
                            parse_error = KAL_TRUE;
                            break;
                        }
                        break;
                    }
                }
                if (parse_error == KAL_TRUE)
                {
                    break;
                }
            }
            l4c_em_set_mmi_default_prof_ind(source_string_ptr->src_id, op, category, param1, param2, param3, param4);
            return;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}
#endif /*  __MMI_FMI__ */


/*****************************************************************************
 * FUNCTION
 *  rmmi_egpio_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for de/activate Engineer Mode.
 *  mtk00468 add on 06/27
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_egpio_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 type;
    kal_uint8 level;                    /* variable for en-/disable */
    kal_uint8 const *rsp_str = NULL;    /* response string and initialization */
    kal_uint16 string_length = 0;       /* string length variable */
    kal_uint8 error_cause;

    /* checking the command mode */
    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:    /* at+egpio=? */
        {

            //AT will not be responsible for error checking of invalid gpio value, there'll be too many chips.
            // #if (defined(MT6218B))
            //       rsp_str=(kal_uint8 const *)"+EGPIO: (0-48),(0,1)"; /*prepare the response string */
            // #else
            //       rsp_str=(kal_uint8 const *)"+EGPIO: (0-20),(0,1)"; /*prepare the response string */
            // #endif
            // string_length = strlen ((char *)rsp_str);    /* type casting */

            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_SET_OR_EXECUTE_MODE:  /* at+egpio = 1,1  EM mode acivate */
        {
            type = (kal_uint8) rmmi_int_validator_u8_check(&error_cause,
                                                           source_string_ptr,
                                                           (kal_uint8) RMMI_COMMA);
            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }

            level = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                               source_string_ptr,
                                                               RMMI_PTR->s_reg.s3,
                                                               1);
            if (level == RMMI_VALIDATOR_ERROR)
            {
                break;
            }

            //AT will not be responsible for error checking of invalid gpio value, there'll be too many chips.
            // #if (defined(MT6218B))
            //       if (type > 48 || level > 1)    /*error checking for invalid value*/
            // #else
            //       if (type > 20 || level > 1)    /*error checking for invalid value*/
            //  #endif
            //           break;

            switch (level)
            {
                case 0:
            #ifdef __CUST_NEW__
                    custom_em_gpio_stop(type | GPIO_MAGIC_NUM);
            #else 
                    custom_em_gpio_stop((kal_uint8) type);
            #endif 
                    break;
                case 1:
            #ifdef __CUST_NEW__
                    custom_em_gpio_start(type | GPIO_MAGIC_NUM);
            #else 
                    custom_em_gpio_start((kal_uint8) type);
            #endif 
                    break;
            }
            ret_val = KAL_TRUE;
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_epwm_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for de/activate Engineer Mode.
 *  mtk00468 add on 06/28
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_epwm_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 op;                           /* variable for en-/disable */
    kal_uint8 type;                         /* PWM1, PWM2, AlTER */
    kal_uint8 level;
    kal_uint16 freq;
    kal_uint8 duty;
    kal_uint8 const *rsp_str = NULL;        /* response string and initialization */
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];   /* temp buffer for response format usage */
    kal_uint16 string_length = 0;           /* string length variable */
    kal_uint32 temp;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
            /* checking the command mode */
        case RMMI_TEST_MODE:    /* at+epwm=? */
        {
            rsp_str = (kal_uint8 const*)"+EPWM: (0-3),(0-2),(0-4),(0-65535),(0-100)";  /* prepare the response string */
            string_length = strlen((char*)rsp_str); /* type casting */
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_SET_OR_EXECUTE_MODE:  /* at+epwm = 0  EM mode acivate */
        {
            /* Get the seed from the command line and validate it */
            op = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                            source_string_ptr,
                                                            (kal_uint8) RMMI_COMMA,
                                                            3);
            if (op == RMMI_VALIDATOR_ERROR)
            {
                break;
            }

            if (op != 3)
            {
                type = (kal_uint8) rmmi_int_validator_u8_check(NULL,
                                                               source_string_ptr,
                                                               (kal_uint8) RMMI_COMMA);
            }
            else
            {
                type = (kal_uint8) rmmi_int_validator_u8_check(NULL,
                                                               source_string_ptr,
                                                               (kal_uint8) rmmi_ptr->s_reg.s3);
            }
            if (type >= CUSTOM_EM_PWM_TYPE_MAX)
            {
                break;
            }

            switch (op)
            {
                case 0:        //get
                {
                    level = (kal_uint8) rmmi_int_validator_u8_check(NULL,
                                                                    source_string_ptr,
                                                                    (kal_uint8) rmmi_ptr->s_reg.s3);
                    if (level >= CUSTOM_EM_PWM_LEVEL_MAX)
                    {
                        break;
                    }

                    custom_em_pwm_get_level_value(type, level, &freq, &duty);

                    rmmi_ptr->arg_list[0] = (void*)&freq;
                    rmmi_ptr->arg_list[1] = (void*)&duty;

                    string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+EPWM: %u,%d", rmmi_ptr->arg_list, 2);
                    rsp_str = &buffer[0];
                    ret_val = KAL_TRUE;
                    break;
                }
                case 1:        //set
                {
                    kal_uint8 error_cause;

                    level = (kal_uint8) rmmi_int_validator_u8_check(NULL,
                                                                    source_string_ptr,
                                                                    (kal_uint8) RMMI_COMMA);
                    if (level >= CUSTOM_EM_PWM_LEVEL_MAX)
                    {
                        break;
                    }

                    temp = (kal_uint32) rmmi_int_validator_u32_check(&error_cause,
                                                                     source_string_ptr,
                                                                     (kal_uint8) RMMI_COMMA);
                    duty = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                                      source_string_ptr,
                                                                      (kal_uint8) rmmi_ptr->s_reg.s3,
                                                                      100);
                    if ((error_cause != RMMI_PARSE_OK) || (duty == RMMI_VALIDATOR_ERROR))
                    {
                        break;
                    }

                    freq = (kal_uint16) temp;
                    custom_em_pwm_set_level_value(type, level, freq, duty);
                    ret_val = KAL_TRUE;
                    break;
                }
                case 2:        //start test
                {
                    kal_uint8 error_cause;
                    
                    temp = (kal_uint16) rmmi_int_validator_u16_check(&error_cause,
                                                                     source_string_ptr,
                                                                     (kal_uint8) RMMI_COMMA);
                    duty = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                                      source_string_ptr,
                                                                      (kal_uint8) rmmi_ptr->s_reg.s3,
                                                                      100);
                    if ((error_cause != RMMI_PARSE_OK) || (duty == RMMI_VALIDATOR_ERROR))
                    {
                        break;
                    }

                    freq = (kal_uint16) temp;
                    custom_em_pwm_start(type, freq, duty);
                    ret_val = KAL_TRUE;
                    break;
                }
                case 3:        //stop test
                {
                    custom_em_pwm_stop(type);
                    custom_em_pwm_set_level(type, custom_em_pwm_get_hw_current_level(type));
                    ret_val = KAL_TRUE;
                    break;
                }
            }
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_eslt_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for set LCM for factory test.
 *  mtk00468 add on 07/28
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
extern void uem_set_gain(kal_uint8 type, kal_uint8 gain);
void rmmi_eslt_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 type;                     /* variable for en-/disable */
    kal_uint16 gain;
    kal_uint8 const *rsp_str = NULL;    /* response string and initialization */
    kal_uint16 string_length = 0;       /* string length variable */

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
            /* checking the command mode */
        case RMMI_TEST_MODE:    /* at+esam=? */
        {
            rsp_str = (kal_uint8 const*)"+ESLT: (0-6),(0-255)";        /* prepare the response string */
            string_length = strlen((char*)rsp_str); /* type casting */
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_SET_OR_EXECUTE_MODE:  /* at+eslt = 4,10  back to normal idle screen */
        {
            kal_uint8 error_cause;

            /* Get the seed from the command line and validate it */
            type = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                              source_string_ptr,
                                                              (kal_uint8) RMMI_COMMA,
                                                              6);
            if (type == RMMI_VALIDATOR_ERROR)
            {
                break;  //error handling
            }

            /* gain: 0~255 */
            gain = (kal_uint16) rmmi_int_validator_range_check(&error_cause,
                                                               source_string_ptr,
                                                               RMMI_PTR->s_reg.s3,
                                                               255);
            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }

            uem_set_gain(type, (kal_uint8) gain);
            ret_val = KAL_TRUE;
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_ealt_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for de/activate keypad enevt report.
 *  mtk00468 add on 07/16
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
extern void uem_set_loopback(kal_bool on);
void rmmi_ealt_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 op;                       /* variable for en-/disable */
    kal_uint8 const *rsp_str = NULL;    /* response string and initialization */
    kal_uint16 string_length = 0;       /* string length variable */

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
            /* checking the command mode */
        case RMMI_TEST_MODE:    /* at+ealt=? */
        {
            rsp_str = (kal_uint8 const*)"+EALT: (0,1)"; /* prepare the response string */
            string_length = strlen((char*)rsp_str);     /* type casting */
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_SET_OR_EXECUTE_MODE:  /* at+ealt = 0  loop back test mode acivate */
        {
            /* Get the seed from the command line and validate it */
            op = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                            source_string_ptr,
                                                            RMMI_PTR->s_reg.s3,
                                                            1);
            if (op == RMMI_VALIDATOR_ERROR)
            {
                break;  //error handling
            }
            uem_set_loopback((kal_bool) op);
            ret_val = KAL_TRUE;
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_eadc_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for de/activate Engineer Mode.
 *  mtk00468 add on 06/27
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_eadc_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 op;                       /* variable for en-/disable */
    kal_uint8 const *rsp_str = NULL;    /* response string and initialization */
    kal_uint16 string_length = 0;       /* string length variable */
    l4c_context_struct *l4c_ptr = L4C_PTR;

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
            /* checking the command mode */
        case RMMI_TEST_MODE:    /* at+eadc=? */
        {
            rsp_str = (kal_uint8 const*)"+EADC: (0,1)"; /* prepare the response string */
            string_length = strlen((char*)rsp_str);     /* type casting */
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_SET_OR_EXECUTE_MODE:  /* at+eadc = 0  EM mode acivate */
        {
            /* Get the seed from the command line and validate it */
            op = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                            source_string_ptr,
                                                            RMMI_PTR->s_reg.s3,
                                                            1);
            if (op == RMMI_VALIDATOR_ERROR)
            {
                break;  //error handling
            }
            if (op)
            {
                l4c_eq_get_adc_all_channel_start_req();
                l4c_ptr->adc_flag = KAL_TRUE;
            }
            else
            {
                if (l4c_ptr->adc_flag == KAL_TRUE)  /* error handle if never active we dont sent stop to uem */
                {
                    l4c_eq_get_adc_all_channel_stop_req();
                    l4c_ptr->adc_flag = KAL_FALSE;
                }
            }
            ret_val = KAL_TRUE;
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_egpo_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for GPO setting for factory test.
 *  mtk00468 add on 09/17
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_egpo_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 data, port;               /* variable for en-/disable */
    kal_uint8 const *rsp_str = NULL;    /* response string and initialization */
    kal_uint16 string_length = 0;       /* string length variable */

    /* checking the command mode */
    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:    /* at+egpo=? */
        {
            rsp_str = (kal_uint8 const*)"+EGPO: (0-254),(0-254)";      /* prepare the response string */
            string_length = strlen((char*)rsp_str); /* type casting */
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_SET_OR_EXECUTE_MODE:  /* at+egpio = 1,1  EM mode acivate */
        {
            /* Get the seed from the command line and validate it */

            port = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                              source_string_ptr,
                                                              (kal_uint8) RMMI_COMMA,
                                                              254);
            data = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                              source_string_ptr,
                                                              RMMI_PTR->s_reg.s3,
                                                              254);
            if (data == RMMI_VALIDATOR_ERROR || port == RMMI_VALIDATOR_ERROR)   /* error checking for invalid value */
            {
                break;
            }
            custom_em_gpo_writeio(data, port);
            ret_val = KAL_TRUE;
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_edft_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for GPIO device factory test.
 *  mtk00468 add on 09/05
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_edft_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 device, level;
    kal_uint8 const *rsp_str = NULL;    /* response string and initialization */
    kal_uint16 string_length = 0;       /* string length variable */

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
            /* checking the command mode */
        case RMMI_TEST_MODE:    /* at+edft=? */
        {
            rsp_str = (kal_uint8 const*)"+EDFT: (0-20),(0,1-5)";       /* prepare the response string */
            string_length = strlen((char*)rsp_str); /* type casting */
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_SET_OR_EXECUTE_MODE:  /* at+edft = 1,0  off GPIO 1 */
        {
            /* Get the seed from the command line and validate it */

            device = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                                source_string_ptr,
                                                                (kal_uint8) RMMI_COMMA,
                                                                20);
            level = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                               source_string_ptr,
                                                               RMMI_PTR->s_reg.s3,
                                                               5);
            if ((device == RMMI_VALIDATOR_ERROR) || (level == RMMI_VALIDATOR_ERROR))   /* error checking for invalid value */
            {
                break;
            }
            ret_val = custom_uem_gpio_set_level(device, level);
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


#endif /* !defined(__DISABLE_SELDOM_USED_PROPRIETARY_CMD__) */

/*mtk01616_100303: we plan to phase out the commands below and they are not used by MTK internally.
   And they don't listed in AT document. So we remove them directly. */
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #ifdef __test_mode__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif /* __test_mode__ */ 
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #ifdef __test_mode__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif /* __test_mode__ */ 
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #ifdef __test_mode__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif /* __test_mode__ */ 
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

