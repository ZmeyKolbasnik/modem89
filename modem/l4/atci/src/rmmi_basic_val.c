/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 * RMMI_BASIC_VAL.C
 *
 * Project:
 * --------
 *   MT6208
 *
 * Description:
 * ------------
 *   This file is intends for ...
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/********************************************************************************
*  Copyright Statement:
*  --------------------
*
*  This product has been developed using a protocol stack
*  developed by Sasken Communication Technologies Limited.
*
********************************************************************************/

#define RMMI_BASIC_VAL_C
#include <string.h>
#include <stdio.h>
//#include "kal_non_specific_general_types.h"
//#include "kal_release.h"
//#include "stack_common.h"
//#include "stack_msgs.h"
//#include "app_ltlcom.h" /* Task message communiction */
//#include "stacklib.h"   /* Basic type for dll, evshed, stacktimer */
//#include "app_buff_alloc.h"
//#include "stack_timer.h"
//#include "event_shed.h"
//#include "nvram_editor_data_item.h"
//#include "custom_nvram_editor_data_item.h"
//#include "ps_trace.h"
#include "kal_trace.h"
#include "kal_public_defs.h" //MSBB change #include "stack_config.h"

#ifdef __MOD_SMU__
//#include "ps2sim_struct.h"
//#include "sim_common_enums.h"
//#include "smu_common_enums.h"
#endif /* __MOD_SMU__ */ 
//#include "csmss_common_enums.h"


#include "mcd_l4_common.h"

#include "l4c_common_enum.h"
#include "rmmi_common_enum.h"
#include "rmmi_context.h"
#include "l4c_context.h"
#include "layer4_context.h"
//#include "l4c_msghdlr.h"
//#include "l4c_rspfmttr.h"
//#include "l4_defs.h"
//#include "uart_sw.h"
#include "dcl.h"
#include "l4_trc.h"
#include "atci_trc.h"

//#include "l4c_aux_struct.h"
/////////add to provide SAT sturcture ///////////////////

//#include "sim_common_enums.h"

//#include "mcd_ss_parameters.h"  /* csm */
//#include "mcd_ss_tcapmessages.h"

#include "l4c_common_enum.h"
#include "csmcc_enums.h"
#include "csmcc_common_enums.h"
//#include "ps2sat_struct.h"
//#include "l4c2csm_cc_struct.h"

//#include "l4c2csm_ss_struct.h"
//#include "l4c2smsal_struct.h"
//#include "ps2sat_struct.h"

//#include "mcd_ps2sat_peer.h"
 
#include "csmcc_atfunc.h"
#include "csmcc_defs.h"
#include "csmcc_common_enums.h"

//#include "mncc_struct.h"
//#include "csmcc_bc_types.h"
#include "csmcc_types.h"


//#include "mcd_l3_inc_struct.h"
 
#ifdef __MOD_SMSAL__
//#include "l4c2smsal_struct.h"
#endif 
#ifdef __MOD_UEM__
#include "device.h"
//#include "l4c2uem_struct.h"
#endif /* __MOD_UEM__ */ 

#include "l4c_ss_parse.h"
#include "rmmi_rspfmttr.h"
#include "rmmi_utility.h"

#include "l4c_cc_cmd.h"
#if defined (VM_SUPPORT)
#include "med_struct.h"
#endif 
#include "l4c_eq_cmd.h"
#include "l4c_data_cmd.h"

//#include "l4c2phb_enums.h" 
//#include "l4c2phb_struct.h"
#include "l4c_phb_cmd.h"
//#include "csm_data_enums.h"     
#include "l4c_utility.h"
//#include "L4c2smu_struct.h"
//#include "keypad_sw.h"
#include "lmmi_ind.h"
//#include "l4c_sim_cmd.h"

//#include "l4c2abm_struct.h"
//#include "smsal_l4c_enum.h"
//#include "lmmi_rsp.h"

#include "rmmi_msghdlr.h"

#include "rmmi_parser.h" 
#include "csmcc_utility.h" 
#include "custom_ecc.h"
#if defined(__L4C_GEMINI_BT_HF__)
#include "l4c_root.h"
#endif

#ifdef UART_ENABLE
#include "drv_comm.h"
#endif
#include "kal_general_types.h"
#include "kal_public_api.h"
#include "ps_public_struct.h"
#include "cmux_vp_num.h"
#include "ps_public_enum.h"
#include "rmmi_sio.h"


extern kal_bool l4c_ps_gprs_resume_req(kal_uint8 src_id);
extern kal_bool custom_disallow_gprs_dialup_when_ms_busy(void);

extern UART_PORT PS_UART_PORT;

const kal_char *const RMMI_ATI_STRING[10] = 
{
    "",
    "",
    "",
    "MediaTek Inc.",
    "MAUI Project",
    "Revision",
    "",
    "",
    "",
    ""
};

const kal_uint8 RMMI_VOLUME[4] = {1, 1, 3, 6};


/*****************************************************************************
 * FUNCTION
 *  rmmi_ata_hdlr
 * DESCRIPTION
 *  This is rmmi_ata_hdlr function of L4C module.
 *  handler of the ata command
 * PARAMETERS
 *  source_string_ptr       [IN]        Input command string
 *  head_node_ptr           [OUT]       Cmd info
 *  err_id                  [OUT]       Error number
 * RETURNS
 *  kal_bool    result of the cmd execution
 *****************************************************************************/
#ifndef __UCM_SUPPORT__
kal_bool rmmi_ata_hdlr(
            rmmi_string_struct *source_string_ptr,
            rmmi_multiple_basic_cmd_struct *head_node_ptr,
            rmmi_err_id_enum *err_id)
{
    kal_bool ret_val = KAL_FALSE;

#ifdef __VOIP__
    rmmi_string_struct *string_ptr = NULL;
    rmmi_multiple_basic_cmd_struct *node_ptr = NULL;
    rmmi_err_id_enum *id = 0;
#endif /* __VOIP__ */ 

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_ATA_HDLR_ENTRY);

#ifdef __VOIP__
    if (!RMMI_PTR->cm_cmd_approve)
    {   //cmd not approved, send to MMI CM to check the call status
        RMMI_PTR->string_ptr = (rmmi_string_struct*) get_ctrl_buffer(sizeof(rmmi_string_struct));
        RMMI_PTR->node_ptr = (rmmi_multiple_basic_cmd_struct*) get_ctrl_buffer(sizeof(rmmi_multiple_basic_cmd_struct));
        RMMI_PTR->id = (rmmi_err_id_enum*) get_ctrl_buffer(sizeof(rmmi_err_id_enum));

        kal_mem_cpy(RMMI_PTR->string_ptr, source_string_ptr, sizeof(rmmi_string_struct));
        ((rmmi_string_struct*) RMMI_PTR->string_ptr)->string_ptr = (kal_uint8*) get_ctrl_buffer(50);
        kal_mem_cpy(((rmmi_string_struct*) RMMI_PTR->string_ptr)->string_ptr, source_string_ptr->string_ptr, 50);
        kal_mem_cpy(RMMI_PTR->node_ptr, head_node_ptr, sizeof(rmmi_multiple_basic_cmd_struct));
        kal_mem_cpy(RMMI_PTR->id, err_id, sizeof(rmmi_err_id_enum));

        #ifdef __MMI_FMI__     
        L4C_PTR->route_thru_lmmi = KAL_TRUE;
        L4C_PTR->route_thru_lmmi_user = source_string_ptr->src_id;
        #endif

        l4c_mmi_voip_at_call_ctrl_approve_lind(RMMI_CM_ATA, (void*)string_ptr, (void*)node_ptr, (void*)id);
        while (source_string_ptr->string_ptr[source_string_ptr->index] != RMMI_PTR->s_reg.s3)
        {
            source_string_ptr->index++;
        }
        return KAL_TRUE;
    }
    else
    {
        RMMI_PTR->cm_cmd_approve = KAL_FALSE;
        ASSERT((source_string_ptr != NULL) && (head_node_ptr != NULL));
        ret_val = l4c_cc_exe_ata_req(source_string_ptr->src_id);
    }

#else /* __VOIP__ */ 
    ASSERT((source_string_ptr != NULL) && (head_node_ptr != NULL));

#if defined(__BT_SUPPORT__)
    if ((source_string_ptr->src_id == RMMI_COMM_PTR->rmmi_hf_src) && (L4C_PTR->waiting_call_id != CSMCC_INVALID_CALL_ID))
    {
        /* Some HF uses ATA instead of AT+CHLD=1 or 2 to accept waiting call, but CSM doesn't allow
           L4C helps to Hold active(if any) and Accept the waiting call */
        ret_val = l4c_cc_exe_chld_req(source_string_ptr->src_id, CSMCC_HOLD_ACTIVE_AND_ACCEPT, L4C_PTR->waiting_call_id);
        if (ret_val == KAL_TRUE )
        {
            RMMI_PTR->send_ciev_callheld = KAL_TRUE;
        }
    }
    else
#endif
    ret_val = l4c_cc_exe_ata_req(source_string_ptr->src_id);
#endif /* __VOIP__ */ 

    if (ret_val == KAL_TRUE)
    {
        source_string_ptr->index++;
        rmmi_skip_spaces(source_string_ptr);

        /* As per the standard ITU-T V.25, other chars coming after ATA
           is ignored so this loop reaches upto the end of character so
           that once this function returns to the main loop, it should
           come out fulfilling the conditions as no further processing
           is needed. */
        while (source_string_ptr->string_ptr[source_string_ptr->index] != RMMI_PTR->s_reg.s3)
        {
            source_string_ptr->index++;
            rmmi_skip_spaces(source_string_ptr);
        }

        /*
         * // store command information into the list 
         * head_node_ptr->cmd_code = RMMI_CMD_ATA;
         * head_node_ptr->cmd_mode = RMMI_SET_OR_EXECUTE_MODE;      
         * head_node_ptr->value   = 1;
         * head_node_ptr->is_this_node_used = KAL_TRUE;
         */
    }
    else
    {
        *err_id = OPERATION_NOT_ALLOWED_ERR;
    }

    return ret_val;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_atd_hdlr
 * DESCRIPTION
 *  This is rmmi_ata_hdlr function of L4C module.
 *  handler of the atd command
 * PARAMETERS
 *  source_string_ptr       [IN]        Input command string
 *  head_node_ptr           [OUT]       Cmd info
 *  err_id                  [OUT]       Error number
 * RETURNS
 *  kal_bool    result of the cmd execution
 *****************************************************************************/
kal_bool rmmi_atd_hdlr(
            rmmi_string_struct *source_string_ptr,
            rmmi_multiple_basic_cmd_struct *head_node_ptr,
            rmmi_err_id_enum *err_id)
{
    kal_bool ret_val = KAL_TRUE;
    kal_uint8 result;
    kal_uint16 length;
    rmmi_string_struct ss_string;
    l4c_ss_string_info_struct info;
    kal_uint8 cid;
    kal_bool is_emergency_call = KAL_FALSE;
    kal_uint8 call_type = CSMCC_DATA_CALL;
    kal_uint16 tmp_index;
    kal_uint8 count = 0;
    l4_addr_bcd_struct called_number;
    kal_uint8 number[50];
    ecc_call_type_enum which_sim;
#ifdef __VOIP__
    rmmi_string_struct *string_ptr = NULL;
    rmmi_multiple_basic_cmd_struct *node_ptr = NULL;
    rmmi_err_id_enum *id = 0;
#endif
#if defined(__VOIP__) || !defined(__PS_DIALUP__) || defined(__BT_SUPPORT__) || defined(__VIDEO_CALL_SUPPORT__)
    kal_bool gprs_string = KAL_FALSE;
#endif //fix build warning
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim
    l4c_context_struct *l4c_ptr = L4C_PTR; //for slim

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_ATD_HDLR_ENTRY);
    ASSERT((source_string_ptr != NULL) && (head_node_ptr != NULL));

    tmp_index = source_string_ptr->index;

    /* MUST increase index before we return to rmmi_basic_cmd_processor, 
       otherwise, while loop might occur in rmmi_basic_cmd_processor. */
    source_string_ptr->index++;

#if defined(__VOIP__) || !defined(__PS_DIALUP__) || defined(__BT_SUPPORT__) || defined(__VIDEO_CALL_SUPPORT__)
    if (((source_string_ptr->string_ptr[source_string_ptr->index] == rmmi_char_t ||
          source_string_ptr->string_ptr[source_string_ptr->index] == RMMI_CHAR_T) &&
         source_string_ptr->string_ptr[source_string_ptr->index + 1] == RMMI_CHAR_STAR &&
         source_string_ptr->string_ptr[source_string_ptr->index + 2] == RMMI_CHAR_9 &&
         source_string_ptr->string_ptr[source_string_ptr->index + 3] == RMMI_CHAR_9 &&
         source_string_ptr->string_ptr[source_string_ptr->index + 4] == RMMI_CHAR_POUND) ||
        (source_string_ptr->string_ptr[source_string_ptr->index] == RMMI_CHAR_STAR &&
         source_string_ptr->string_ptr[source_string_ptr->index + 1] == RMMI_CHAR_9 &&
         source_string_ptr->string_ptr[source_string_ptr->index + 2] == RMMI_CHAR_9 &&
         source_string_ptr->string_ptr[source_string_ptr->index + 3] == RMMI_CHAR_POUND))
    {
        gprs_string = KAL_TRUE;
    }
#endif //fix build warning

#ifdef __VOIP__
    if (!gprs_string)
    {
        if (!RMMI_PTR->cm_cmd_approve)
        {       //cmd not approved, send to MMI CM to check the call status
            RMMI_PTR->string_ptr = (rmmi_string_struct*) get_ctrl_buffer(sizeof(rmmi_string_struct));
            RMMI_PTR->node_ptr =
                (rmmi_multiple_basic_cmd_struct*) get_ctrl_buffer(sizeof(rmmi_multiple_basic_cmd_struct));
            RMMI_PTR->id = (rmmi_err_id_enum*) get_ctrl_buffer(sizeof(rmmi_err_id_enum));

            kal_mem_cpy(RMMI_PTR->string_ptr, source_string_ptr, sizeof(rmmi_string_struct));
            ((rmmi_string_struct*) RMMI_PTR->string_ptr)->string_ptr = (kal_uint8*) get_ctrl_buffer(50);
            kal_mem_cpy(((rmmi_string_struct*) RMMI_PTR->string_ptr)->string_ptr, source_string_ptr->string_ptr, 50);
            kal_mem_cpy(RMMI_PTR->node_ptr, head_node_ptr, sizeof(rmmi_multiple_basic_cmd_struct));
            kal_mem_cpy(RMMI_PTR->id, err_id, sizeof(rmmi_err_id_enum));

            #ifdef __MMI_FMI__      
            l4c_ptr->route_thru_lmmi = KAL_TRUE;
            l4c_ptr->route_thru_lmmi_user = source_string_ptr->src_id;
            #endif

            l4c_mmi_voip_at_call_ctrl_approve_lind(RMMI_CM_ATD, (void*)string_ptr, (void*)node_ptr, (void*)id);
            while (source_string_ptr->string_ptr[source_string_ptr->index] != RMMI_PTR->s_reg.s3)
            {
                source_string_ptr->index++;
            }
            return KAL_TRUE;
        }
        else
        {
            RMMI_PTR->cm_cmd_approve = KAL_FALSE;
            ASSERT((source_string_ptr != NULL) && (head_node_ptr != NULL));

        }

    }
#else /* __VOIP__ */ 
    ASSERT((source_string_ptr != NULL) && (head_node_ptr != NULL));

#endif /* __VOIP__ */ 

#ifdef __MOD_TCM__
    rmmi_ptr->cgatt_last_action = 0xff; /* atd*99# might change attach status, so clear +CGATT flag here */
#endif //mtk02285, 201003, 6251_ram

    /* mtk00714 20040422 */
    /* turn on the isATDAction_flag, ATD action must be remebered till result code is sent to DTE */
    /* 1. when ATD is not allowed, eg. LMMI is dialing call, 
       or when dial string is invalid,
       we need this flag to print NO CARRIER instead of ERROR
       when return to rmmi_basic_cmd_processor() */
    /* 2. when ATD is allowed: 
       after SETUP_CNF, RMMI's action becomes L4C_NO_ACTION at that time,
       we need this flag in rmmi_uart_read_data(). According to 07.07, 
       ATD should be abort by receiving any additional charactor. */

    cid = rmmi_srcid_2_cid(source_string_ptr->src_id);

    //mtk01616_070516: now always return OK for ATD at l4cphb_approve_cnf

    //if (cid < RMMI_MAX_CHANNEL_NUMBER) 
    {
        RMMI_COMM_PTR->isAtdAction_flag |= (0x01 << cid);
    }

#if !defined(__PS_DIALUP__)
    if (KAL_TRUE == gprs_string)
    {
        return KAL_FALSE;
    } //20110711, mtk02285: When PS DIALUP is diabled, it's used to prevent dial *99/98# as a call (normal/CSD)
#endif /* !defined(__PS_DIALUP__) */

    if ((source_string_ptr->string_ptr[source_string_ptr->index] == RMMI_CHAR_PLUS &&
         source_string_ptr->string_ptr[source_string_ptr->index + 1] == RMMI_CHAR_PLUS) ||
        source_string_ptr->string_ptr[source_string_ptr->index] == RMMI_SEMICOLON)
    {   /* reject ATD; or ATD++xxx; */
        return KAL_FALSE;
    }

    //mtk00758 - atdL last number dialed
    if (source_string_ptr->string_ptr[source_string_ptr->index] == rmmi_char_l ||
        source_string_ptr->string_ptr[source_string_ptr->index] == RMMI_CHAR_L)
    {

        ss_string.index = 0;
        ss_string.string_ptr = get_ctrl_buffer(50);
        ss_string.ip_string = get_ctrl_buffer(21);
        ss_string.ip_string[0] = 0;

        kal_mem_cpy(ss_string.string_ptr, rmmi_ptr->last_number_dialed, MAX_CC_ADDR_LEN);
        length = (kal_uint16)strlen((char*)ss_string.string_ptr);

        if (length > 0)
        {
            ret_val = l4c_ss_string_parsing(source_string_ptr->src_id, 0x0f, &ss_string, (kal_uint8) length,
                                            &info, CSMCC_VOICE_CALL, KAL_FALSE,ALS_DIAL_BY_SETTING,INFO_ECC_CHECK_BY_MODEM);

            if (info.opcode != CC_OPERATION)
            {
                RMMI_COMM_PTR->isAtdAction_flag &= ~(0x01 << cid);
            }
        }
        else
        {
            //mtk01616_070711
            ret_val = KAL_FALSE;
            kal_brief_trace(TRACE_INFO, ATDL_NO_LAST_NUMBER_DIALED);
        }

        free_ctrl_buffer(ss_string.string_ptr);
        free_ctrl_buffer(ss_string.ip_string);

        source_string_ptr->index++;
        while (source_string_ptr->string_ptr[source_string_ptr->index] != rmmi_ptr->s_reg.s3)
        {
            source_string_ptr->index++;
            rmmi_skip_spaces(source_string_ptr);
        }

        return ret_val;
    }

    //mtk00758 - atd>xxx; or atd>xxx
    if (source_string_ptr->string_ptr[source_string_ptr->index] == RMMI_R_ANGLE_BRACKET)
    {
        kal_uint16 total, used, index;

        source_string_ptr->index++;
        /* get total for different storage */
        l4c_phb_get_storage_info(source_string_ptr->src_id, rmmi_ptr->phb_storage_type, &used, &total);

        index = (kal_uint16) rmmi_int_validator(source_string_ptr, RMMI_SEMICOLON);
        if (index != RMMI_VALIDATOR_ERROR)
        {
            if (index > total || index == 0)
            {
                //mtk01616_070719:return ERROR instead of "NO CARRIER" , if memory location is not valid
                RMMI_COMM_PTR->isAtdAction_flag &= ~(0x01 << cid);
                return KAL_FALSE;
            }
        }

        RMMI_COMM_PTR->isAtdAction_flag &= ~(0x01 << cid);

        //MAUI_02743641 temp solution
        if ((rmmi_ptr->phb_storage_type == RMMI_PHB_LD) ||
            (rmmi_ptr->phb_storage_type == RMMI_PHB_MC) ||
            (rmmi_ptr->phb_storage_type == RMMI_PHB_RC) ||
            (rmmi_ptr->phb_storage_type == RMMI_PHB_DC) || 
            (rmmi_ptr->phb_storage_type == RMMI_PHB_LA))
        {
            return KAL_FALSE;
        }
        
	    if(source_string_ptr->string_ptr[source_string_ptr->index-1] != ';')// ';' is not found: its a data call
        {
        #if defined(__VIDEO_CALL_SUPPORT__)
            kal_uint8 speed, name, ce;
			
            ret_val = l4c_cc_get_bearer_service_req(source_string_ptr->src_id, &speed, &name, &ce);
			
            if (ret_val == KAL_TRUE && speed == CSMCC_64000_BPS_MULTIMEDIA)
            {
                kal_brief_trace(TRACE_INFO, ATD_HDLR_ATD_DIAL_VT_CALL);
            #ifndef __VT_TRANSPORT_SUPPORT__
                return KAL_FALSE;
            #endif
            }
        #endif
       	    rmmi_ptr->rmmi_atd_mem = RMMI_MEM_DIAL_DATA;
	    }
	    else
	    {
	        rmmi_ptr->rmmi_atd_mem = RMMI_MEM_DIAL_VOICE;
	    }

        ret_val = rmmi_cpbr_read(source_string_ptr->src_id, rmmi_ptr->phb_storage_type, index, index);

        source_string_ptr->index++;
        while (source_string_ptr->string_ptr[source_string_ptr->index] != rmmi_ptr->s_reg.s3)
        {
            source_string_ptr->index++;
            rmmi_skip_spaces(source_string_ptr);
        }

        return ret_val;
    }

    rmmi_skip_leading_chars(source_string_ptr);

    tmp_index = source_string_ptr->index;

    while (source_string_ptr->string_ptr[tmp_index] != rmmi_ptr->s_reg.s3)
    {
        if (source_string_ptr->string_ptr[tmp_index] == ';')    // ';' is found: its a voice call
        {
            call_type = CSMCC_VOICE_CALL;
            break;
        }
        tmp_index++;
        count++;
    }

    if (call_type == CSMCC_VOICE_CALL)
    {
    #ifdef __ATD_EXPLICIT_ECC__
        if (source_string_ptr->string_ptr[source_string_ptr->index] == RMMI_CHAR_E ||
            source_string_ptr->string_ptr[source_string_ptr->index] == rmmi_char_e)
        {
            is_emergency_call = KAL_TRUE; //MAUI_02378474
            source_string_ptr->index++;
        }
        else
    #endif
        {
            kal_mem_set(number, 0, 50);
            kal_mem_set(&called_number, 0, sizeof(l4_addr_bcd_struct));
	        //mtk01616_081221: atd is used to dial voice call ,we don't support too long called number 
            if(count > 50)
            {
                count = 50;
            }
            kal_mem_cpy(number, &(source_string_ptr->string_ptr[source_string_ptr->index]), count);
            called_number.addr_bcd[0] = 129;
            count = convert_to_bcd(number, (kal_uint8*) & (called_number.addr_bcd[1]), MAX_CC_ADDR_LEN - 1);
            called_number.addr_length = count + 1;

            //is_emergency_call = phb_is_number_ecc(&called_number);

            //ecc_revise
            which_sim = ECC_SIM1_CALL + (l4c_current_mod_id - MOD_L4C);
            is_emergency_call = ecc_custom_verify_emergency_number(
                                            called_number.addr_bcd, 
                                            called_number.addr_length, 
                                            ECC_ENCODING_BCD, 
                                            which_sim,
                                            NULL, NULL, NULL);
        }
    }
    else
    {
        /* MAUI_02850462: 2011/02/01, avoid dialup on USB COM2 */
		/* MAUI_02738549: 2011/03/02, avoid dialup on 1T1R USB COM */
        #if defined(__USB_MULTIPLE_COMPORT_SUPPORT__)
        {
            kal_uint8 port = rmmi_cid_2_port(cid);
            
            if (KAL_FALSE == RMMI_UART_is_usb_cdc_acm(port))
            {
                kal_brief_trace(TRACE_WARNING, WARNING_DIALUP_NOT_ALLOWED_ON_1T1R, port);
                return KAL_FALSE;
            }
        }
        #endif /* __USB_MULTIPLE_COMPORT_SUPPORT__ */

        if (custom_disallow_gprs_dialup_when_ms_busy() == KAL_TRUE)
        {        			
            #if defined(__BT_SUPPORT__)
            kal_uint8 port;
            port = rmmi_cid_2_port(cid);			
			
            if((port >= start_of_virtual_port) && (port <= end_of_virtual_port)&&(gprs_string == KAL_TRUE))
            {
            #if defined(__L4C_GEMINI_BT_HF__)
                if (l4c_root_check_call_exist(NULL) == KAL_TRUE)
            #else
                if (csmcc_is_any_call_exist() == KAL_TRUE)
            #endif
                {
                    /*MAUI_01790553: For BQB DUN TC_GW_APS_BV_02_I */        
                    kal_brief_trace(TRACE_WARNING, WARNING_DISALLOW_GPRS_DIALUP_WHEN_MS_BUSY);

                    rmmi_ptr->response_type = RMMI_RCODE_BUSY; 
                    return KAL_FALSE;							            
                }	
            }		
            #endif
        }		

        #if defined(__VIDEO_CALL_SUPPORT__)
        if(gprs_string == KAL_FALSE)
        {
            kal_uint8 speed, name, ce;
			
            ret_val = l4c_cc_get_bearer_service_req(source_string_ptr->src_id, &speed, &name, &ce);
			
            if (ret_val == KAL_TRUE && speed == CSMCC_64000_BPS_MULTIMEDIA)
            {
                kal_brief_trace(TRACE_INFO, ATD_HDLR_ATD_DIAL_VT_CALL);
            #ifdef __VT_TRANSPORT_SUPPORT__
                call_type = CSMCC_VIDEO_CALL;
            #else
                return KAL_FALSE;
            #endif
            }
        }
        #endif
    }

#if defined (__MMI_FMI__)
    /* LMMI has dial a call, RMMI not allowed to dial a voice call at the same time */
    if (l4c_ptr->cc_current_action[LMMI_SRC] == ATD_EXE ||
        l4c_ptr->cc_current_action[LMMI_SRC] == ATD_ECC || 
        l4c_ptr->cc_current_action[LMMI_SRC] == ATD_ECC_CHANGE_RAT ||
        l4c_ptr->cc_current_action[LMMI_SRC] == ATD_APP)
    {

        if (call_type == CSMCC_VOICE_CALL)
        {
            return KAL_FALSE;
        }
        //else (ATD*99# or data call): continue.
    }
#endif /* defined (__MMI_FMI__) */ 

    if (is_emergency_call == KAL_FALSE)
    {
    #if defined(__MMI_FMI__)
        if (l4c_ptr->mmi_ready_flag == KAL_FALSE)       // MMI is not ready yet , ATD not allowed 
        {
            return KAL_FALSE;
        }
    #endif /* defined(__MMI_FMI__) */ 

        if (l4c_ptr->csm_state != CSM_STATE_CISS_READY)  /* ciss is not ready yet , ATD not allowed */
        {
            return KAL_FALSE;
        }

    #ifdef __MOD_TCM__
        if (l4c_ptr->tcm_ready_flag == KAL_FALSE)   /* tcm is not ready yet , ATD not allowed */
        {
            return KAL_FALSE;
        }
    #endif /* __MOD_TCM__ */ 
    }
    else //emergency call
    {
        //CSM is not initiated, even ECC is not allowed
        if (l4c_ptr->csm_state == CSM_STATE_NOT_INITIATED)
        {
            return KAL_FALSE;
        }
    }

    if (source_string_ptr->string_ptr[source_string_ptr->index] == rmmi_ptr->s_reg.s3)
    {
        ret_val = l4c_cc_exe_call_modify_req(source_string_ptr->src_id);
        return ret_val;
    }

    ss_string.index = 0;
    ss_string.string_ptr = get_ctrl_buffer(50);
    ss_string.ip_string = get_ctrl_buffer(21);
    ss_string.ip_string[0] = 0;

    result = extract_number_string(
                source_string_ptr,
                rmmi_ptr->s_reg.s3, /* separator */
                ss_string.string_ptr,
                50);

    if (result == KAL_FALSE)
    {
        free_ctrl_buffer(ss_string.string_ptr);
        free_ctrl_buffer(ss_string.ip_string);
        return KAL_FALSE;
    }

    length = (kal_uint16)strlen((char*)ss_string.string_ptr);
    ret_val = l4c_ss_string_parsing(
                source_string_ptr->src_id,
                0x0f,
                &ss_string,
                (kal_uint8)length,
                &info,
                call_type,
                KAL_FALSE,
                ALS_DIAL_BY_SETTING,
            #ifdef __ATD_EXPLICIT_ECC__
                (is_emergency_call == KAL_TRUE)? INFO_ECC_CALL : INFO_ECC_CHECK_BY_MODEM); //MAUI_02378474
            #else
                INFO_ECC_CHECK_BY_MODEM);
            #endif

    if (info.opcode != CC_OPERATION)
    {
        RMMI_COMM_PTR->isAtdAction_flag &= ~(0x01 << cid);
    }

    free_ctrl_buffer(ss_string.string_ptr);
    free_ctrl_buffer(ss_string.ip_string);
    if (ret_val == KAL_FALSE)
    {
        return KAL_FALSE;
    }

    return KAL_TRUE;
}
#else /* __UCM_SUPPORT__ */ 


/*****************************************************************************
 * FUNCTION
 *  rmmi_ata_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 *  head_node_ptr           [?]     
 *  err_id                  [?]     
 * RETURNS
 *  
 *****************************************************************************/
kal_bool rmmi_ata_hdlr(
            rmmi_string_struct *source_string_ptr,
            rmmi_multiple_basic_cmd_struct *head_node_ptr,
            rmmi_err_id_enum *err_id)
{
    kal_bool ret_val = KAL_FALSE;
    kal_bool active_call_exist = KAL_FALSE;
    kal_bool result = KAL_FALSE;
    kal_uint8 active_call_id;
    l4c_call_entry_struct active_call_entry;
    kal_bool cmd_from_bt = KAL_FALSE;
    kal_bool route_through_ucm = KAL_TRUE;
    rmmi_ucm_action_enum action = RMMI_UCM_ATA; //MAUI_02825249
    csmcc_crss_req_enum opcode = CSMCC_INVALID_CRSS_TYPE; //MAUI_02825249
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim
    kal_uint8 sim_id;

    //err_id  for rmmi_basic_cmd_processor handling xxx_hdlr return KAL_FALSE,print +CME ERROR:<err>
    *err_id = OPERATION_NOT_ALLOWED_ERR;

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_ATA_HDLR_ENTRY);

    ASSERT((source_string_ptr != NULL) && (head_node_ptr != NULL));

    // MAUI_01609296: responds ERROR instead of NO CARRIER
    if (source_string_ptr->string_ptr[source_string_ptr->index+1] != rmmi_ptr->s_reg.s3)
        return ret_val;

    active_call_exist = l4ccsm_cc_get_active_call(&active_call_id);

    if ((active_call_exist == KAL_TRUE) && (active_call_id != CSMCC_INVALID_CALL_ID))
    {
        result = l4ccsm_cc_get_call_info(active_call_id, &active_call_entry, NULL);

        if (result == KAL_TRUE &&
            ((active_call_entry.call_mode == ALT_DATA_VOICE_CALL)
            || (active_call_entry.call_mode == FOLLOW_VOICE_CALL)
            || (active_call_entry.call_mode == ALT_FAX_VOICE_CALL)))
        {
            route_through_ucm = KAL_FALSE;  //for call modify                  
        }
    }

    if (route_through_ucm == KAL_TRUE)
    {
    #if defined(__BT_SUPPORT__)
        if (source_string_ptr->src_id == RMMI_COMM_PTR->rmmi_hf_src)
        {
            cmd_from_bt = KAL_TRUE;
        }
    #endif /* defined(__BT_SUPPORT__) */ 

        //MAUI_02825249: ATA to accept waiting acll, translate to CHLD for UCM
        for (sim_id = 0; sim_id < RMMI_MAX_SIM_NUM; sim_id++)
        {
            if (L4C_PTR_X(waiting_call_id, sim_id) != CSMCC_INVALID_CALL_ID)
            {
                action = RMMI_UCM_CHLD;
                opcode = CSMCC_HOLD_ACTIVE_AND_ACCEPT;
                break;
            }
        }
        
        l4c_mmi_ucm_at_req_lind(action, source_string_ptr->src_id, cmd_from_bt, 0, NULL, opcode, 0); //MAUI_02825249

        // we've sent request to UCM , but action is not set yet , to prevent print OK in rmmi_basic_cmd_processor
        rmmi_ptr->is_ucm_action = KAL_TRUE;
        #ifdef __MMI_FMI__      
        L4C_PTR->route_thru_lmmi = KAL_TRUE;
        L4C_PTR->route_thru_lmmi_user = source_string_ptr->src_id;
        #endif

        ret_val = KAL_TRUE;
    }
    else
    {
        kal_brief_trace(TRACE_INFO, ATA_FOR_DATA_CALL);
        ret_val = l4c_cc_exe_ata_req(source_string_ptr->src_id);
        if (ret_val == KAL_FALSE)
        {
            rmmi_ptr->is_ata_action = KAL_TRUE; //mtk01616_070910 : return NO CARRIER for ATA in basic_cmd_processor                  
        }
    }

    if (ret_val == KAL_TRUE)
    {
        source_string_ptr->index++;
        rmmi_skip_spaces(source_string_ptr);

        /* As per the standard ITU-T V.25, other chars coming after ATA
           is ignored so this loop reaches upto the end of character so
           that once this function returns to the main loop, it should
           come out fulfilling the conditions as no further processing
           is needed. */
        while (source_string_ptr->string_ptr[source_string_ptr->index] != rmmi_ptr->s_reg.s3)
        {
            source_string_ptr->index++;
            rmmi_skip_spaces(source_string_ptr);
        }
    }

    return ret_val;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_atd_hdlr
 * DESCRIPTION
 *  This is rmmi_ata_hdlr function of L4C module.
 *  handler of the atd command
 * PARAMETERS
 *  source_string_ptr       [IN]        Input command string
 *  head_node_ptr           [OUT]       Cmd info
 *  err_id                  [OUT]       Error number
 * RETURNS
 *  kal_bool    result of the cmd execution
 *****************************************************************************/
kal_bool rmmi_atd_hdlr(
            rmmi_string_struct *source_string_ptr,
            rmmi_multiple_basic_cmd_struct *head_node_ptr,
            rmmi_err_id_enum *err_id)
{
    kal_bool ret_val = KAL_TRUE;
    kal_uint8 length = 0;
    rmmi_string_struct ss_string;
#ifdef __MOD_TCM__
    kal_bool format_valid = KAL_TRUE;
#endif
    kal_uint8 cid;
    kal_bool is_emergency_call = KAL_FALSE;
    kal_uint8 number[50];
    kal_bool result;
    kal_bool is_voice_call = KAL_FALSE;
    kal_uint16 tmp_index;
    kal_bool cmd_from_bt = KAL_FALSE;
    kal_uint16 count = 0;
    l4_addr_bcd_struct called_number;
    kal_bool gprs_string = KAL_FALSE;
    ecc_call_type_enum which_sim;
    kal_uint8 port = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim
    l4c_context_struct *l4c_ptr = L4C_PTR; //for slim

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_ATD_HDLR_ENTRY);
    ASSERT((source_string_ptr != NULL) && (head_node_ptr != NULL));

    tmp_index = source_string_ptr->index;

    /* MUST increase index before we return to rmmi_basic_cmd_processor, 
       otherwise, while loop might occur in rmmi_basic_cmd_processor. */
    source_string_ptr->index++;
    kal_mem_set(number, 0, 50);

    if (((source_string_ptr->string_ptr[source_string_ptr->index] == rmmi_char_t ||
        source_string_ptr->string_ptr[source_string_ptr->index] == RMMI_CHAR_T) &&
        source_string_ptr->string_ptr[source_string_ptr->index + 1] == RMMI_CHAR_STAR &&
        source_string_ptr->string_ptr[source_string_ptr->index + 2] == RMMI_CHAR_9 &&
        (source_string_ptr->string_ptr[source_string_ptr->index + 3] == RMMI_CHAR_9 ||
        source_string_ptr->string_ptr[source_string_ptr->index + 3] == RMMI_CHAR_8) &&
        source_string_ptr->string_ptr[source_string_ptr->index + 4] == RMMI_CHAR_POUND) ||
        (source_string_ptr->string_ptr[source_string_ptr->index] == RMMI_CHAR_STAR &&
        source_string_ptr->string_ptr[source_string_ptr->index + 1] == RMMI_CHAR_9 &&
        (source_string_ptr->string_ptr[source_string_ptr->index + 2] == RMMI_CHAR_9 ||
        source_string_ptr->string_ptr[source_string_ptr->index + 2] == RMMI_CHAR_8) &&
        source_string_ptr->string_ptr[source_string_ptr->index + 3] == RMMI_CHAR_POUND))
    {
        // ATDT*99# or ATDT*99# or ATD*98# or ATD*99#
        gprs_string = KAL_TRUE;
    }

#ifdef __MOD_TCM__
    rmmi_ptr->cgatt_last_action = 0xff; /* atd*99# might change attach status, so clear +CGATT flag here */
#endif //mtk02285, 201003, 6251_ram

    /* mtk00714 20040422 */
    /* turn on the isATDAction_flag, ATD action must be remebered till result code is sent to DTE */
    /* 1. when ATD is not allowed, eg. LMMI is dialing call, 
       or when dial string is invalid,
       we need this flag to print NO CARRIER instead of ERROR
       when return to rmmi_basic_cmd_processor() */
    /* 2. when ATD is allowed: 
       after SETUP_CNF, RMMI's action becomes L4C_NO_ACTION at that time,
       we need this flag in rmmi_uart_read_data(). According to 07.07, 
       ATD should be abort by receiving any additional charactor. */

    cid = rmmi_srcid_2_cid(source_string_ptr->src_id);
    port = rmmi_cid_2_port(cid);

#if defined(__BT_SUPPORT__)
    if (source_string_ptr->src_id == RMMI_COMM_PTR->rmmi_hf_src)
    {
        cmd_from_bt = KAL_TRUE;
    }
#endif /* defined(__BT_SUPPORT__) */ 

    //if (cid < RMMI_MAX_CHANNEL_NUMBER) 
    {
        RMMI_COMM_PTR->isAtdAction_flag |= (0x01 << cid);
    }

#if !defined(__PS_DIALUP__)
    if (KAL_TRUE == gprs_string)
    {
        return KAL_FALSE; 
    } //20110711, mtk02285: When PS DIALUP is diabled, it's used to prevent dial *99/98# as a call (normal/CSD)
#endif /* !defined(__PS_DIALUP__) */

    if ((source_string_ptr->string_ptr[source_string_ptr->index] == RMMI_CHAR_PLUS &&
         source_string_ptr->string_ptr[source_string_ptr->index + 1] == RMMI_CHAR_PLUS) ||
        source_string_ptr->string_ptr[source_string_ptr->index] == RMMI_SEMICOLON)
    {   /* reject ATD; or ATD++xxx; */
        return KAL_FALSE;
    }

    // atdL last number dialed
    if (source_string_ptr->string_ptr[source_string_ptr->index] == rmmi_char_l ||
        source_string_ptr->string_ptr[source_string_ptr->index] == RMMI_CHAR_L)
    {

        kal_mem_cpy(number, rmmi_ptr->last_number_dialed, MAX_CC_ADDR_LEN);
        length = strlen((char*)number);
        if (length > 0)
        {
            l4c_mmi_ucm_at_req_lind(RMMI_UCM_ATD, source_string_ptr->src_id, cmd_from_bt, length, number, 0, 0);
            rmmi_ptr->is_ucm_action = KAL_TRUE;
        #ifdef __MMI_FMI__      
            l4c_ptr->route_thru_lmmi = KAL_TRUE;
            l4c_ptr->route_thru_lmmi_user = source_string_ptr->src_id;
        #endif
        }
        else
        {
            RMMI_COMM_PTR->isAtdAction_flag &= ~(0x01 << cid);
            kal_brief_trace(TRACE_INFO, ATDL_NO_LAST_NUMBER_DIALED);
            return KAL_FALSE;
        }
        source_string_ptr->index++;
        while (source_string_ptr->string_ptr[source_string_ptr->index] != rmmi_ptr->s_reg.s3)
        {
            source_string_ptr->index++;
            rmmi_skip_spaces(source_string_ptr);
        }

        // the meaning of is_ucm_action flag: 
        // we've sent request to UCM , but action is not set yet , to prevent print OK in rmmi_basic_cmd_processor
        rmmi_ptr->is_ucm_action = KAL_TRUE;
        return KAL_TRUE;
    }

    //mtk00758 - atd>xxx; or atd>xxx
    if (source_string_ptr->string_ptr[source_string_ptr->index] == RMMI_R_ANGLE_BRACKET)
    {
        kal_uint16 total, used, index;
        kal_uint8 action_type = RMMI_UCM_MEM_DIAL;
        kal_bool route_through_mmi = KAL_FALSE;

        source_string_ptr->index++;
        /* get total for different storage */
        l4c_phb_get_storage_info(source_string_ptr->src_id, rmmi_ptr->phb_storage_type, &used, &total);

        index = (kal_uint16) rmmi_int_validator(source_string_ptr, RMMI_SEMICOLON);

        //mtk01616_080111: Move memory dial handling to UCM
    #ifdef __GEMINI__
        if (cmd_from_bt == KAL_TRUE)
        {
            route_through_mmi = KAL_TRUE;
        }
        action_type += (rmmi_current_mod_id-MOD_ATCI);

    #endif /* __GEMINI__ */ 

        if (route_through_mmi == KAL_TRUE)
        {
            number[0] = index;
            l4c_mmi_ucm_at_req_lind(action_type, source_string_ptr->src_id, cmd_from_bt, length, number, 0, 0);
            rmmi_ptr->is_ucm_action = KAL_TRUE;
            #ifdef __MMI_FMI__      
            l4c_ptr->route_thru_lmmi = KAL_TRUE;
            l4c_ptr->route_thru_lmmi_user = source_string_ptr->src_id;
            #endif
            ret_val = KAL_TRUE;
        }
        else
        {
            RMMI_COMM_PTR->isAtdAction_flag &= ~(0x01 << cid);
            if (index != RMMI_VALIDATOR_ERROR)
            {
                if (index > total || index == 0)
                {
                    //mtk01616_070719:return ERROR instead of "NO CARRIER" , if memory location is not valid
                    //RMMI_PTR->isAtdAction_flag &= ~(0x01 << cid);
                    kal_brief_trace(TRACE_WARNING, ATD_MEMORY_DIAL_INVALID_MEMORY_LOCATION);
                    return KAL_FALSE;
                }
            }

            //MAUI_02277383 temp solution
            if ((rmmi_ptr->phb_storage_type == RMMI_PHB_LD) ||
                (rmmi_ptr->phb_storage_type == RMMI_PHB_MC) ||
                (rmmi_ptr->phb_storage_type == RMMI_PHB_RC) ||
                (rmmi_ptr->phb_storage_type == RMMI_PHB_DC) || 
                (rmmi_ptr->phb_storage_type == RMMI_PHB_LA))
            {
                return KAL_FALSE;
            }

	        if(source_string_ptr->string_ptr[source_string_ptr->index-1] != ';')// ';' is not found: its a data call
	        {
            #if defined(__VIDEO_CALL_SUPPORT__)
                kal_uint8 speed, name, ce;
                
                ret_val = l4c_cc_get_bearer_service_req(source_string_ptr->src_id, &speed, &name, &ce);
                
                if (ret_val == KAL_TRUE && speed == CSMCC_64000_BPS_MULTIMEDIA)
                {
                    kal_brief_trace(TRACE_INFO, ATD_HDLR_ATD_DIAL_VT_CALL);
                    return KAL_FALSE;
                }
            #endif
	            rmmi_ptr->rmmi_atd_mem = RMMI_MEM_DIAL_DATA;
	        }
	        else
	        {
	            rmmi_ptr->rmmi_atd_mem = RMMI_MEM_DIAL_VOICE;
	        }

            ret_val = rmmi_cpbr_read(source_string_ptr->src_id, rmmi_ptr->phb_storage_type, index, index);
        }

        source_string_ptr->index++;
        while (source_string_ptr->string_ptr[source_string_ptr->index] != rmmi_ptr->s_reg.s3)
        {
            source_string_ptr->index++;
            rmmi_skip_spaces(source_string_ptr);
        }

        return ret_val;
    }

    rmmi_skip_leading_chars(source_string_ptr);

    tmp_index = source_string_ptr->index;

    while (source_string_ptr->string_ptr[tmp_index] != rmmi_ptr->s_reg.s3)
    {
        if (source_string_ptr->string_ptr[tmp_index] == ';')    // ';' is found: its a voice call
        {
            is_voice_call = KAL_TRUE;
            break;
        }
        tmp_index++;
        count++;
    }

    if (is_voice_call == KAL_TRUE)
    {
        kal_mem_set(&called_number, 0, sizeof(l4_addr_bcd_struct));
	//mtk01616_081221: atd is used to dial voice call ,we don't support too long called number 
	if(count > 50)
	    count = 50;		
        kal_mem_cpy(number, &(source_string_ptr->string_ptr[source_string_ptr->index]), count);
        called_number.addr_bcd[0] = 129;
        count = convert_to_bcd(number, (kal_uint8*) & (called_number.addr_bcd[1]), MAX_CC_ADDR_LEN - 1);
        called_number.addr_length = count + 1;

        //is_emergency_call = phb_is_number_ecc(&called_number);

        //ecc_revise
        which_sim = (ecc_call_type_enum)(ECC_SIM1_CALL + (l4c_current_mod_id - MOD_L4C));
        is_emergency_call = ecc_custom_verify_emergency_number(
                                        called_number.addr_bcd, 
                                        called_number.addr_length, 
                                        ECC_ENCODING_BCD, 
                                        which_sim,
                                        NULL, NULL, NULL);
    }

    if (is_emergency_call == KAL_FALSE)
    {
        if (l4c_ptr->csm_state != CSM_STATE_CISS_READY)  /* ciss is not ready yet */
        {
            if(gprs_string == KAL_TRUE)
            {				
                rmmi_start_ath_for_dialup_hdlr(port);	
            }	
			
            return KAL_FALSE;
        }

    #ifdef __MOD_TCM__
        if (l4c_ptr->tcm_ready_flag == KAL_FALSE)   /* tcm is not ready yet , ATD not allowed */
        {
            if(gprs_string == KAL_TRUE)
            {				
                rmmi_start_ath_for_dialup_hdlr(port);	
            }	
			
            return KAL_FALSE;
        }
    #endif /* __MOD_TCM__ */ 
    }
    else //emergency call
    {
        //CSM is not initiated, even ECC is not allowed
        if (l4c_ptr->csm_state == CSM_STATE_NOT_INITIATED)
        {
            if(gprs_string == KAL_TRUE)
            {				
                rmmi_start_ath_for_dialup_hdlr(port);	
            }
            return KAL_FALSE;
        }
    }

    if (source_string_ptr->string_ptr[source_string_ptr->index] == rmmi_ptr->s_reg.s3)
    {
        ret_val = l4c_cc_exe_call_modify_req(source_string_ptr->src_id);
        kal_brief_trace(TRACE_INFO, ATD_HDLR_CALL_MODIFY_REQUEST, ret_val);
        return ret_val;
    }

    if (is_voice_call == KAL_TRUE)      //it's a "ATDxxxx;" string. not allowed when MMI is dialing a call
    {
        kal_mem_set(number, 0, 50);
        result = (kal_bool)extract_number_string(
                    source_string_ptr,
                    rmmi_ptr->s_reg.s3, /* separator */
                    number,
                    50);

        if (result == KAL_FALSE)
        {
            return KAL_FALSE;
        }

        length = strlen((char*)number);

        if (length > MAX_CC_ADDR_LEN)
        {
            kal_brief_trace(TRACE_WARNING, ATD_HDLR_DIAL_NUMBER_LENGTH_ILLEGAL);
            return KAL_FALSE;
        }

    #if defined(__GEMINI__) && defined(__BT_SUPPORT__) 
        if (cmd_from_bt == KAL_TRUE) //mtk01616_080111:ATD from BT HF, this is for pass BQB SIM2
        {
            l4c_mmi_ucm_at_req_lind((RMMI_UCM_ATD+rmmi_current_mod_id-MOD_ATCI), 
                                    source_string_ptr->src_id, 
                                    cmd_from_bt, 
                                    length, number, 0, 0);
        }
        else
    #endif /* __GEMINI__ */ 
        {
            l4c_mmi_ucm_at_req_lind(RMMI_UCM_ATD, source_string_ptr->src_id, cmd_from_bt, length, number, 0, 0);
        }
        // the meaning of is_ucm_action flag: 
        // we've sent request to UCM , but action is not set yet , to prevent print OK in rmmi_basic_cmd_processor
        rmmi_ptr->is_ucm_action = KAL_TRUE;
        #ifdef __MMI_FMI__      
        l4c_ptr->route_thru_lmmi = KAL_TRUE;
        l4c_ptr->route_thru_lmmi_user = source_string_ptr->src_id;
        #endif
    }
    else //UCM3.0 can handle data call but not gprs dial up
    {
        kal_brief_trace(TRACE_INFO, ATD_HDLR_PROCESSING_ATD_GPRS_DIALUP_OR_DATA_CALL);

        /* MAUI_02850462: 2011/02/01, avoid dialup on USB COM2 */
		/* MAUI_02738549: 2011/03/02, avoid dialup on 1T1R USB COM */
        #if defined(__USB_MULTIPLE_COMPORT_SUPPORT__)
        {
            kal_uint8 port = rmmi_cid_2_port(cid);
            
            if (KAL_FALSE == RMMI_UART_is_usb_cdc_acm(port))
            {
                kal_brief_trace(TRACE_WARNING, WARNING_DIALUP_NOT_ALLOWED_ON_1T1R, port);
                return KAL_FALSE;
            }
        }
        #endif /* __USB_MULTIPLE_COMPORT_SUPPORT__ */

        if(custom_disallow_gprs_dialup_when_ms_busy() == KAL_TRUE)
        {
            #if defined(__BT_SUPPORT__)			
			
            if((port >= start_of_virtual_port) && (port <= end_of_virtual_port)&&(gprs_string == KAL_TRUE))			
            {		
                if(csmcc_is_any_call_exist()== KAL_TRUE)
                {
                    /*MAUI_01790553: For BQB DUN TC_GW_APS_BV_02_I */        
                    kal_brief_trace(TRACE_WARNING, WARNING_DISALLOW_GPRS_DIALUP_WHEN_MS_BUSY);

                    rmmi_start_ath_for_dialup_hdlr(port);	

                    rmmi_ptr->response_type = RMMI_RCODE_BUSY; 
				
                    return KAL_FALSE;											
                }	
            }	
            #endif
        }

    #if defined(__VIDEO_CALL_SUPPORT__)
        if(gprs_string == KAL_FALSE)
        {
            kal_uint8 speed, name, ce;
			
            ret_val = l4c_cc_get_bearer_service_req(source_string_ptr->src_id, &speed, &name, &ce);
			
            if (ret_val == KAL_TRUE && speed == CSMCC_64000_BPS_MULTIMEDIA)
            {
                kal_brief_trace(TRACE_INFO, ATD_HDLR_ATD_DIAL_VT_CALL);
                return KAL_FALSE;
            }
        }
    #endif

        ss_string.index = 0;
        ss_string.string_ptr = get_ctrl_buffer(50);

        result = (kal_bool)extract_number_string(
                    source_string_ptr,
                    rmmi_ptr->s_reg.s3, /* separator */
                    ss_string.string_ptr,
                    50);

        if (result == KAL_FALSE)
        {
            free_ctrl_buffer(ss_string.string_ptr);
            return KAL_FALSE;
        }
        length = strlen((char*)ss_string.string_ptr);
        
    #if defined(__MOD_TCM__) && defined(__PS_DIALUP__)
        if (is_gprs_string(source_string_ptr->src_id, &ss_string, (kal_bool*) & format_valid) == KAL_TRUE)
        {
            //RMMI_PTR->is_gprs_data_dialing = KAL_TRUE; //mtk02285, 201003, 6251_ram
            free_ctrl_buffer(ss_string.string_ptr);
            return KAL_TRUE;
        }
        else if (format_valid == KAL_TRUE)
        {
            kal_brief_trace(TRACE_WARNING, WARNING_RMMI_GPRS_STRING_VALID_CMD_NOT_ALLOWED);
            free_ctrl_buffer(ss_string.string_ptr);
            return KAL_FALSE;
        }
    #endif

#ifdef CSD_SUPPORT
        //route data call to UCM
        l4c_mmi_ucm_at_req_lind(RMMI_UCM_ATD_DATA, source_string_ptr->src_id, cmd_from_bt, length, ss_string.string_ptr, 0, 0);
        rmmi_ptr->is_ucm_action = KAL_TRUE;
    #ifdef __MMI_FMI__      
        l4c_ptr->route_thru_lmmi = KAL_TRUE;
        l4c_ptr->route_thru_lmmi_user = source_string_ptr->src_id;
    #endif
        free_ctrl_buffer(ss_string.string_ptr);
#else
        free_ctrl_buffer(ss_string.string_ptr);
        return KAL_FALSE;
#endif
    }

    return KAL_TRUE;
}

#endif /* __UCM_SUPPORT__ */ /* __UCM_PRESENT__ */


/*****************************************************************************
 * FUNCTION
 *  rmmi_ate_hdlr
 * DESCRIPTION
 *  This is rmmi_ata_hdlr function of L4C module.
 *  handler of the ate command
 * PARAMETERS
 *  source_string_ptr       [IN]        Input command string
 *  head_node_ptr           [OUT]       Cmd info
 *  err_id                  [OUT]       Error number
 * RETURNS
 *  kal_bool    result of the cmd execution
 *****************************************************************************/
kal_bool rmmi_ate_hdlr(
            rmmi_string_struct *source_string_ptr,
            rmmi_multiple_basic_cmd_struct *head_node_ptr,
            rmmi_err_id_enum *err_id)
{
    rmmi_validator_cause_enum result;
    kal_bool ret_val = KAL_TRUE;
    kal_uint8 value;
    kal_uint8 cid;

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_ATE_HDLR_ENTRY);
    ASSERT((source_string_ptr != NULL) && (head_node_ptr != NULL));

    /* Increment the index to get the next character from the  command line */
    source_string_ptr->index++;
    /* Skip all leading white spaces, which are coming after 'E'. e.g. : ATE________0.  */
    rmmi_skip_spaces(source_string_ptr);

    cid = rmmi_srcid_2_cid(source_string_ptr->src_id);
    if (cid == 0xff)
    {
        return KAL_FALSE;
    }

    value = (kal_uint8)rmmi_extract_number_ext(source_string_ptr, &result, 1);
    if(result == RMMI_PARSE_NOT_FOUND)
        {
        value = RMMI_ECHO_ON;         
    }

    if(result != RMMI_PARSE_ERROR)
    {
        if (value == RMMI_ECHO_ON)
        {
            RMMI_PTR->rsp_mode.echo_flag |= (0x01 << cid);            
        }
        else        //RMMI_ECHO_OFF
        {
            RMMI_PTR->rsp_mode.echo_flag &= ~(0x01 << cid);           
        }
		
#if !defined(__ULC_AT__)		
        RMMI_PTR->rmmi_current_profile.rmmi_ate = value;
#endif 
        
        ret_val = KAL_TRUE;
    }
    else        
    {
        ret_val = KAL_FALSE;
    }    

    return ret_val;

}


/*****************************************************************************
 * FUNCTION
 *  rmmi_ats_hdlr
 * DESCRIPTION
 *  This is rmmi_ata_hdlr function of L4C module.
 *  handler of the ats command
 * PARAMETERS
 *  source_string_ptr       [IN]        Input command string
 *  head_node_ptr           [OUT]       Cmd info
 *  err_id                  [OUT]       Error number
 * RETURNS
 *  kal_bool    result of the cmd execution
 *****************************************************************************/
kal_bool rmmi_ats_hdlr(
            rmmi_string_struct *source_string_ptr,
            rmmi_multiple_basic_cmd_struct *head_node_ptr,
            rmmi_err_id_enum *err_id)
{
    kal_bool ret_val = KAL_TRUE;
    kal_uint8 cmd_value = 0;
    kal_uint8 cmd_code;
    kal_uint8 cmd_mode;
    kal_uint16 string_length;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint8 cmd_value_string[4];
    rmmi_validator_cause_enum result;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_ATS_HDLR_ENTRY);
    ASSERT((source_string_ptr != NULL) && (head_node_ptr != NULL));

    /* Increment the index to get the next character from the command line */
    source_string_ptr->index++;
    /* Skip all leading white spaces, which are coming after 'S'. e.g. : ATS________0/3/4. */
    rmmi_skip_spaces(source_string_ptr);

    /*
     * Call the atci_sparam_validator function to check whether
     * * the given basic command is S3 type or not
     */

    cmd_code = (kal_uint8) rmmi_extract_number(source_string_ptr, &result, 1024);
    if(result != RMMI_PARSE_OK)
    {
        return KAL_FALSE; //MAUI_01609188
    }

    rmmi_skip_spaces(source_string_ptr);

    cmd_mode = rmmi_find_cmd_mode(source_string_ptr);

    switch (cmd_mode)
    {
        case RMMI_TEST_MODE:
            break;
        case RMMI_READ_MODE:
        {
            switch (cmd_code)
            {
                case 0:
                    cmd_value = rmmi_ptr->s_reg.s0;
                    break;
            #if !defined(__ULC_AT__)
            /* only support ATS0 for dial-up in ULC AT */
                case 2:
                    cmd_value = rmmi_ptr->s_reg.s2;
                    break;
                case 3:
                    cmd_value = rmmi_ptr->s_reg.s3;
                    break;
                case 4:
                    cmd_value = rmmi_ptr->s_reg.s4;
                    break;
                case 5:
                    cmd_value = rmmi_ptr->s_reg.s5;
                    break;
                case 6:
                    cmd_value = rmmi_ptr->s_reg.s6;
                    break;
                case 7:
                    cmd_value = rmmi_ptr->s_reg.s7;
                    break;
                case 8:
                    cmd_value = rmmi_ptr->s_reg.s8;
                    break;
                case 10:
                    cmd_value = rmmi_ptr->s_reg.s10;
                    break;
                case 32:
                    cmd_value = rmmi_ptr->s_reg.s32;
                    break;
                case 33:
                    cmd_value = rmmi_ptr->s_reg.s33;
                    break;
                case 95:
                    cmd_value = rmmi_ptr->s_reg.s95;
                    break;
            #endif /* !defined(__ULC_AT__) */
                default:
                    ret_val = KAL_FALSE;
                    return ret_val;
            }
            kal_sprintf((kal_char*) cmd_value_string, "%03d", cmd_value);
            rmmi_ptr->arg_list[0] = (void*)cmd_value_string;
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "%s", rmmi_ptr->arg_list, 1);
            rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);

            rmmi_skip_spaces(source_string_ptr);
            if (source_string_ptr->string_ptr[source_string_ptr->index] != rmmi_ptr->s_reg.s3)
            {
                ret_val = KAL_FALSE;
            }
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            /* mtk02514 * MAUI_01411358 * 090327 *******************
            * From V.25 ter, 
            * We can deal with "ATS<paramter>=<value>" as default 0 
            * when <value> does not present or Error.
            * But, we think that ERROR is more friendly, 
            * so we modify the code to deal with this string as Error
            **************************************************/    
            cmd_value = (kal_uint8)rmmi_extract_number_ext(source_string_ptr, &result, 255);
            if (result != RMMI_PARSE_OK)
            {
                ret_val = KAL_FALSE;
                break;
            }


            switch (cmd_code)
            {
                case 0:
        		    if (cmd_value > 255)
        		    {
        		        ret_val = KAL_FALSE;
        		        break;
        		    }
                    rmmi_ptr->s_reg.s0 = cmd_value;
                #if !defined(__ULC_AT__)
                    rmmi_ptr->rmmi_current_profile.s_reg.s0 = cmd_value;
                #endif
                    rmmi_ptr->ats0_src_id = source_string_ptr->src_id; //MAUI_02743662
                    break;
            #if !defined(__ULC_AT__)
            /* only support ATS0 for dial-up in ULC AT */
                case 2:
                    rmmi_ptr->s_reg.s2 = cmd_value;
                    rmmi_ptr->rmmi_current_profile.s_reg.s2 = cmd_value;
                    break;
                case 3:
        		    if (cmd_value > 127)
        		    {
        		        ret_val = KAL_FALSE;
        		        break;
        		    }
                    rmmi_ptr->s_reg.s3 = cmd_value;
                    rmmi_ptr->rmmi_current_profile.s_reg.s3 = cmd_value;
                    break;
                case 4:
        		    if (cmd_value > 127)
        		    {
        		        ret_val = KAL_FALSE;
        			    break;
        		    }
                    rmmi_ptr->s_reg.s4 = cmd_value;
                    rmmi_ptr->rmmi_current_profile.s_reg.s4 = cmd_value;
                    break;
                case 5:
        		    if (cmd_value > 127)
        		    {
        		        ret_val = KAL_FALSE;
        			    break;
        		    }
                    rmmi_ptr->s_reg.s5 = cmd_value;
                    rmmi_ptr->rmmi_current_profile.s_reg.s5 = cmd_value;
                    break;
                case 6:
        		    if (cmd_value < 2 || cmd_value > 10)
        		    {
        		        ret_val = KAL_FALSE;
        			    break;
        		    }
                    rmmi_ptr->s_reg.s6 = cmd_value;
                    rmmi_ptr->rmmi_current_profile.s_reg.s6 = cmd_value;
                    break;
                case 7:
        		    if (cmd_value < 1 || cmd_value > 255)
        		    {
        		        ret_val = KAL_FALSE;
        			    break;
        		    }
                    rmmi_ptr->s_reg.s7 = cmd_value;
                    rmmi_ptr->rmmi_current_profile.s_reg.s7 = cmd_value;
                    break;
                case 8:
        		    if (cmd_value > 255)
        		    {
        		        ret_val = KAL_FALSE;
        			    break;
        		    }
                    rmmi_ptr->s_reg.s8 = cmd_value;
                    rmmi_ptr->rmmi_current_profile.s_reg.s8 = cmd_value;
                    break;
                case 10:
        		    if (cmd_value < 1 || cmd_value > 254)
        		    {
        		        ret_val = KAL_FALSE;
        			    break;
        		    }
                    rmmi_ptr->s_reg.s10 = cmd_value;
                    rmmi_ptr->rmmi_current_profile.s_reg.s10 = cmd_value;
                    break;
                case 32:
                    rmmi_ptr->s_reg.s32 = cmd_value;
                    rmmi_ptr->rmmi_current_profile.s_reg.s32 = cmd_value;
                    break;
                case 33:
                    rmmi_ptr->s_reg.s33 = cmd_value;
                    rmmi_ptr->rmmi_current_profile.s_reg.s33 = cmd_value;
                    break;
                case 95:
                    rmmi_ptr->s_reg.s95 = cmd_value;
                    rmmi_ptr->rmmi_current_profile.s_reg.s95 = cmd_value;
                    break;
            #endif /* !defined(__ULC_AT__) */
                default:
                    ret_val = KAL_FALSE;
                    return ret_val;
            }
            break;
        }
        default:
            ret_val = KAL_FALSE;
            return ret_val;

    }

    /*
     * head_node_ptr->cmd_mode = cmd_mode;
     * head_node_ptr->value = cmd_value;
     * head_node_ptr->cmd_code = cmd_code;
     * head_node_ptr->is_this_node_used = KAL_TRUE ;
     */
    return ret_val;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_atv_hdlr
 * DESCRIPTION
 *  This is rmmi_atv_hdlr function of L4C module.
 *  handler of the atv command
 * PARAMETERS
 *  source_string_ptr       [IN]        Input command string
 *  head_node_ptr           [OUT]       Cmd info
 *  err_id                  [OUT]       Error number
 * RETURNS
 *  kal_bool    result of the cmd execution
 *****************************************************************************/
kal_bool rmmi_atv_hdlr(
            rmmi_string_struct *source_string_ptr,
            rmmi_multiple_basic_cmd_struct *head_node_ptr,
            rmmi_err_id_enum *err_id)
{
    rmmi_validator_cause_enum result;
    kal_bool ret_val;
    kal_uint8 value;

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_ATV_HDLR_ENTRY);
    ASSERT((source_string_ptr != NULL) && (head_node_ptr != NULL));

    source_string_ptr->index++;
    rmmi_skip_spaces(source_string_ptr);

    value = (kal_uint8)rmmi_extract_number_ext(source_string_ptr, &result, 1);
    if( result == RMMI_PARSE_NOT_FOUND)
    {
        value = RMMI_VERBOSE_FULL_HEAD_TAIL; 
    }
    
    if(result != RMMI_PARSE_ERROR)
    {
        RMMI_PTR->rsp_mode.format = value;
    #if !defined(__ULC_AT__)
        RMMI_PTR->rmmi_current_profile.rmmi_atv = value;
    #endif
        ret_val = KAL_TRUE;
    }
    else
    {
        ret_val = KAL_FALSE;
    }
    
    return ret_val;
}


#ifndef __UCM_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  rmmi_ath_hdlr
 * DESCRIPTION
 *  This is rmmi_ata_hdlr function of L4C module.
 *  handler of the ath command
 * PARAMETERS
 *  source_string_ptr       [IN]        Input command string
 *  head_node_ptr           [OUT]       Cmd info
 *  err_id                  [OUT]       Error number
 * RETURNS
 *  kal_bool    result of the cmd execution
 *****************************************************************************/
kal_bool rmmi_ath_hdlr(
            rmmi_string_struct *source_string_ptr,
            rmmi_multiple_basic_cmd_struct *head_node_ptr,
            rmmi_err_id_enum *err_id)
{
    kal_bool ret_val = KAL_TRUE;
    kal_bool result;
    kal_bool disc = KAL_FALSE;
    kal_bool call_exist = KAL_FALSE;
    kal_uint8 call_id;
    kal_uint8 port;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim
    l4c_context_struct *l4c_ptr = L4C_PTR; //for slim

#ifdef __VOIP__
    rmmi_string_struct *string_ptr = NULL;
    rmmi_multiple_basic_cmd_struct *node_ptr = NULL;
    rmmi_err_id_enum *id = 0;
#endif /* __VOIP__ */ 

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_ATH_HDLR_ENTRY);

#ifdef __VOIP__
    if (!RMMI_PTR->cm_cmd_approve)
    {   //cmd not approved, send to MMI CM to check the call status
        if (RMMI_PTR->string_ptr != NULL || RMMI_PTR->node_ptr != NULL || RMMI_PTR->id != NULL)
        {
            return KAL_FALSE;
        }
        RMMI_PTR->string_ptr = (rmmi_string_struct*) get_ctrl_buffer(sizeof(rmmi_string_struct));
        RMMI_PTR->node_ptr = (rmmi_multiple_basic_cmd_struct*) get_ctrl_buffer(sizeof(rmmi_multiple_basic_cmd_struct));
        RMMI_PTR->id = (rmmi_err_id_enum*) get_ctrl_buffer(sizeof(rmmi_err_id_enum));

        kal_mem_cpy(RMMI_PTR->string_ptr, source_string_ptr, sizeof(rmmi_string_struct));
        ((rmmi_string_struct*) RMMI_PTR->string_ptr)->string_ptr = (kal_uint8*) get_ctrl_buffer(50);
        kal_mem_cpy(((rmmi_string_struct*) RMMI_PTR->string_ptr)->string_ptr, source_string_ptr->string_ptr, 50);
        kal_mem_cpy(RMMI_PTR->node_ptr, head_node_ptr, sizeof(rmmi_multiple_basic_cmd_struct));
        kal_mem_cpy(RMMI_PTR->id, err_id, sizeof(rmmi_err_id_enum));

        #ifdef __MMI_FMI__    
        l4c_ptr->route_thru_lmmi = KAL_TRUE;
        l4c_ptr->route_thru_lmmi_user = source_string_ptr->src_id;
        #endif

        l4c_mmi_voip_at_call_ctrl_approve_lind(RMMI_CM_ATH, (void*)string_ptr, (void*)node_ptr, (void*)id);
        while (source_string_ptr->string_ptr[source_string_ptr->index] != RMMI_PTR->s_reg.s3)
        {
            source_string_ptr->index++;
        }
        return KAL_TRUE;
    }
    else
    {
        RMMI_PTR->cm_cmd_approve = KAL_FALSE;
        ASSERT((source_string_ptr != NULL) && (head_node_ptr != NULL));
    }

#else /* __VOIP__ */ 
    ASSERT((source_string_ptr != NULL) && (head_node_ptr != NULL));
#endif /* __VOIP__ */ 

    source_string_ptr->index++;

    rmmi_skip_spaces(source_string_ptr);

    if ((source_string_ptr->string_ptr
         [source_string_ptr->index] == RMMI_CHAR_0) ||
        (source_string_ptr->string_ptr[source_string_ptr->index] == RMMI_CHAR_1))
    {
        head_node_ptr->value = 0;
        source_string_ptr->index++;
        rmmi_skip_spaces(source_string_ptr);
    }

    /* no other basic commands are allowed after one execution
       command. Since, we have already got ATH so check that the next
       caharacter is line termination char */
    if (source_string_ptr->string_ptr[source_string_ptr->index] != rmmi_ptr->s_reg.s3)
    {
        return KAL_FALSE;
    }

    //mtk01616_071001: ATH is for dialup failure, we should prevent it to disconnect call
    if (rmmi_ptr->ath_for_dialup != uart_port_null)
    {
        port = rmmi_cid_2_port(rmmi_srcid_2_cid(source_string_ptr->src_id));
        if (rmmi_ptr->ath_for_dialup == port)
        {
            kal_brief_trace(TRACE_INFO, ATH_FOR_GPRS_DIALUP_FAILURE);
            return KAL_TRUE;
        }
    }
    
    if (rmmi_ptr->cvhu_mode == 1)
    {
        //kal_brief_trace(TRACE_INFO, ATH_IGNORED_WHEN_CVHU_EQUAL_TO_ONE);
        return KAL_TRUE;
    } //MAUI_02862643, mtk02285, support CVHU=1 to ignore ATH

    /* ATH should check source id */
    result = l4ccsm_cc_get_active_call(&call_id);
    if ((result == KAL_TRUE) && (call_id != CSMCC_INVALID_CALL_ID))
    {
        call_exist = KAL_TRUE;

        disc = KAL_TRUE;
    }

    if (csmcc_find_call(CSMCC_MO_CALL, (CSMCC_CALL_INIT | CSMCC_CALL_ALERT), &call_id) == CSMCC_NO_ERROR || 
        csmcc_find_call(CSMCC_MT_CALL, (CSMCC_CALL_ACCEPT), &call_id) == CSMCC_NO_ERROR ||		// mtk01616_090320: allow to end call whe ata is still processing
        csmcc_find_call(CSMCC_ORIG_NONE, CSMCC_NW_CALL_DISC, &call_id) == CSMCC_NO_ERROR)        //mtk00924: the call disconnect by network but waiting for user's response, ex:unassigned number
    {
        call_exist = KAL_TRUE;
        
        disc = KAL_TRUE;    //mtk00924 2005_0427 : for abort MO call which is setup by AT only
    }

    if (l4ccsm_cc_get_mt_call(&call_id) == KAL_TRUE)
    {
        call_exist = KAL_TRUE;
        disc = KAL_TRUE;
    }

    //mtk00924: ATH can disc HELD call
    if (l4ccsm_cc_get_hold_call(&call_id) == KAL_TRUE)
    {
        disc = KAL_TRUE;
    }

#if defined(__BT_SUPPORT__)
    if (source_string_ptr->src_id == RMMI_COMM_PTR->rmmi_hf_src)
    {
        disc = KAL_TRUE;        //in bluetooth, ATH should disconnect all activate call, not to check source id
    }
#endif /* defined(__BT_SUPPORT__) */ 

    if (disc == KAL_FALSE && (l4c_ptr->retry_cc == KAL_FALSE && l4c_ptr->retry_ss == KAL_FALSE))
    {
        if (call_exist == KAL_FALSE)
        {
            //RMMI_PTR->is_gprs_data_dialing = KAL_FALSE;
            /* store command information into the list */
            head_node_ptr->cmd_code = RMMI_CMD_ATH;
            head_node_ptr->cmd_mode = RMMI_SET_OR_EXECUTE_MODE;
            head_node_ptr->is_this_node_used = KAL_TRUE;
            *err_id = RMMI_ERR_NO_CALL_DISC;

            kal_brief_trace(TRACE_INFO, INFO_RMMI_ATH_NO_CALL_HANGUP);
            ret_val = KAL_TRUE; //return OK for this case
        }
        else
        {
            kal_brief_trace(TRACE_WARNING, WARNING_ATH_DISCONNECT_AT_INITIAL_CALL);
            ret_val = KAL_FALSE;        //return ERROR for this case
        }

        return ret_val;
    }

#if defined(__BT_SUPPORT__) 
    if (source_string_ptr->src_id == RMMI_COMM_PTR->rmmi_hf_src)
    {
        kal_uint8 active_call_id, hold_call_id, mt_call_id, mo_call_id;

        if (l4ccsm_cc_get_active_call(&active_call_id) == KAL_TRUE &&
            l4ccsm_cc_get_hold_call(&hold_call_id) == KAL_TRUE)
        {       // 1A1H , 2A1H , 1A2H 
            kal_brief_trace(TRACE_INFO, ATH_REL_ACTIVE_AND_ACCEPT);
            ret_val = l4c_cc_exe_chld_req(source_string_ptr->src_id, CSMCC_REL_ACTIVE_AND_ACCEPT, call_id);
            return ret_val;
        }
        else if (l4ccsm_cc_get_mt_call(&mt_call_id) == KAL_FALSE && l4ccsm_cc_get_outgoing_call(&mo_call_id) == KAL_FALSE)      //handle 2A ,3A..conference call
        {
            l4c_call_entry_struct call_entry;
            kal_uint8 next_index;
            kal_bool resp;

            //mtk01616_070817: for BQB HFP1.5 testcase TWC_BV_04 ,ath shall end all call in conference
            if (l4ccsm_cc_get_active_call(&active_call_id) == KAL_TRUE)
            {
                resp = l4ccsm_cc_get_call_info(active_call_id, &call_entry, &next_index);

                if (resp == KAL_TRUE && call_entry.mpty == CLCC_MPTY)   // 2A ,3A ...
                {
                    kal_brief_trace(TRACE_INFO, ATH_REL_ACTIVE, active_call_id);
                    ret_val = l4c_cc_exe_chld_req(source_string_ptr->src_id, CSMCC_REL_ACTIVE, call_id);
                    return ret_val;
                }
            }

            if (l4ccsm_cc_get_hold_call(&hold_call_id) == KAL_TRUE)
            {
                resp = l4ccsm_cc_get_call_info(hold_call_id, &call_entry, &next_index);

                if (resp == KAL_TRUE && call_entry.mpty == CLCC_MPTY)   // 2H, 3H ...
                {
                    kal_brief_trace(TRACE_INFO, ATH_REL_HELD, hold_call_id);
                    ret_val = l4c_cc_exe_chld_req(source_string_ptr->src_id, CSMCC_REL_HELD, call_id);
                    return ret_val;
                }

            }
        }
        else if ((l4ccsm_cc_get_active_call(&active_call_id) == KAL_TRUE) && 
                (l4ccsm_cc_get_mt_call(&mt_call_id) == KAL_TRUE))
        {
            /* For PTS test TC_AG_TCA_BV_05: When 1A1W HF sends AT+CHUP to terminate the active call
               MOD_BT translates AT+CHUP to ATH. ATCI shall release the 1A and 1W changed to incoming
               */
            ret_val = l4c_cc_exe_chld_req (source_string_ptr->src_id, CSMCC_REL_ACTIVE, call_id);
            return ret_val;
        }

        ret_val = l4c_cc_exe_ath_req(source_string_ptr->src_id, L4C_DISCONNECT_NONE);
    }
    else
#endif /*  defined(__BT_SUPPORT__) */    
    {
        ret_val = l4c_cc_exe_chld_req(source_string_ptr->src_id, CSMCC_REL_ALL, call_id);
    }

    if (ret_val == KAL_TRUE)
    {
        /* store command information into the list */
        /*
         * head_node_ptr->cmd_code = RMMI_CMD_ATH;
         * head_node_ptr->cmd_mode = RMMI_SET_OR_EXECUTE_MODE;
         * head_node_ptr->is_this_node_used = KAL_TRUE;
         */
    }

    return ret_val;
}
#else /* __UCM_SUPPORT__ */ 


/*****************************************************************************
 * FUNCTION
 *  rmmi_ath_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 *  head_node_ptr           [?]     
 *  err_id                  [?]     
 * RETURNS
 *  
 *****************************************************************************/
kal_bool rmmi_ath_hdlr(
            rmmi_string_struct *source_string_ptr,
            rmmi_multiple_basic_cmd_struct *head_node_ptr,
            rmmi_err_id_enum *err_id)
{
    kal_uint8 port;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim
    #ifdef __MMI_FMI__ 
    l4c_context_struct *l4c_ptr = L4C_PTR;
    #endif

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_ATH_HDLR_ENTRY);

    //remove VOIP code here

    ASSERT((source_string_ptr != NULL) && (head_node_ptr != NULL));

    source_string_ptr->index++;

    rmmi_skip_spaces(source_string_ptr);

    if ((source_string_ptr->string_ptr
         [source_string_ptr->index] == RMMI_CHAR_0) ||
        (source_string_ptr->string_ptr[source_string_ptr->index] == RMMI_CHAR_1))
    {
        head_node_ptr->value = 0;
        source_string_ptr->index++;
        rmmi_skip_spaces(source_string_ptr);
    }

    /* no other basic commands are allowed after one execution
       command. Since, we have already got ATH so check that the next
       caharacter is line termination char */
    if (source_string_ptr->string_ptr[source_string_ptr->index] != rmmi_ptr->s_reg.s3)
    {
        return KAL_FALSE;
    }

    //mtk01616_071001: ATH is for dialup failure, we should prevent it to disconnect call
    if (rmmi_ptr->ath_for_dialup != uart_port_null)
    {
        port = rmmi_cid_2_port(rmmi_srcid_2_cid(source_string_ptr->src_id));
        if (rmmi_ptr->ath_for_dialup == port)
        {
            kal_brief_trace(TRACE_INFO, ATH_FOR_GPRS_DIALUP_FAILURE);
            return KAL_TRUE;
        }
    }

    if (rmmi_ptr->cvhu_mode == 1)
    {
        //kal_brief_trace(TRACE_INFO, ATH_IGNORED_WHEN_CVHU_EQUAL_TO_ONE);
        return KAL_TRUE;
    } //MAUI_02862643, mtk02285, support CVHU=1 to ignore ATH

#if defined(__BT_SUPPORT__)
    if (source_string_ptr->src_id == RMMI_COMM_PTR->rmmi_hf_src)
    {
        //mtk01616_071013: ath from bt handling is done by UCM , action UCM_ATH is only for BT Handfree
        l4c_mmi_ucm_at_req_lind(RMMI_UCM_ATH, source_string_ptr->src_id, KAL_TRUE, 0, NULL, 0, 0);
    }
    else
#endif /* defined(__BT_SUPPORT__) */ 
    {
        l4c_mmi_ucm_at_req_lind(
            RMMI_UCM_CHLD,
            source_string_ptr->src_id,
            KAL_FALSE,
            0,
            NULL,
            CSMCC_REL_ALL,
            CSMCC_INVALID_CALL_ID);
    }
    // the meaning of is_ucm_action flag: 
    // we've sent request to UCM , but action is not set yet , to prevent print OK in rmmi_basic_cmd_processor
    rmmi_ptr->is_ucm_action = KAL_TRUE;
    #ifdef __MMI_FMI__     
    l4c_ptr->route_thru_lmmi = KAL_TRUE;
    l4c_ptr->route_thru_lmmi_user = source_string_ptr->src_id;
    #endif

    return KAL_TRUE;
}
#endif /* __UCM_SUPPORT__ */ /* __UCM_PRESENT__ */


#if !defined(__ULC_AT__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_atq_hdlr
 * DESCRIPTION
 *  This is rmmi_atq_hdlr function of L4C module.
 *  handler of the atq command
 * PARAMETERS
 *  source_string_ptr       [IN]        Input command string
 *  head_node_ptr           [OUT]       Cmd info
 *  err_id                  [OUT]       Error number
 * RETURNS
 *  kal_bool    result of the cmd execution
 *****************************************************************************/
kal_bool rmmi_atq_hdlr(
            rmmi_string_struct *source_string_ptr,
            rmmi_multiple_basic_cmd_struct *head_node_ptr,
            rmmi_err_id_enum *err_id)
{
    rmmi_validator_cause_enum result;
    kal_bool ret_val;
    kal_uint8 value;

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_ATQ_HDLR_ENTRY);
    ASSERT((source_string_ptr != NULL) && (head_node_ptr != NULL));

    source_string_ptr->index++;
    rmmi_skip_spaces(source_string_ptr);

    value = (kal_uint8)rmmi_extract_number_ext(source_string_ptr, &result, 1);
    if( result == RMMI_PARSE_NOT_FOUND)
    {
        value = RMMI_SUPRESS_ON;
    }
    
    if(result != RMMI_PARSE_ERROR)
    {
        RMMI_PTR->rsp_mode.suppress_flag = value;
        RMMI_PTR->rmmi_current_profile.rmmi_atq = value;
        ret_val = KAL_TRUE;
    }
    else
    {
        ret_val = KAL_FALSE;
    }

    return ret_val;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_ati_hdlr
 * DESCRIPTION
 *  This is rmmi_ati_hdlr function of L4C module.
 *  handler of the ati command
 * PARAMETERS
 *  source_string_ptr       [IN]        Input command string
 *  head_node_ptr           [OUT]       Cmd info
 *  err_id                  [OUT]       Error number
 * RETURNS
 *  kal_bool    result of the cmd execution
 *****************************************************************************/
kal_bool rmmi_ati_hdlr(
            rmmi_string_struct *source_string_ptr,
            rmmi_multiple_basic_cmd_struct *head_node_ptr,
            rmmi_err_id_enum *err_id)
{
    rmmi_validator_cause_enum result;
    kal_bool ret_val = KAL_TRUE;
    kal_uint16 string_length;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint8 eq_id[UEM_EQUIP_ID_LEN];
    kal_uint8 eq_id2[UEM_EQUIP_ID_LEN];
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_ATI_HDLR_ENTRY);
    ASSERT((source_string_ptr != NULL) && (head_node_ptr != NULL));

    source_string_ptr->index++;
    rmmi_skip_spaces(source_string_ptr);

    rmmi_extract_number_ext(source_string_ptr, &result, 10);
    if (result == RMMI_PARSE_ERROR)
    {
        return KAL_FALSE;
    }

    /*
     * if (item >= 1 && item <= 10)
     * {
     * RMMI_COMM_PTR->arg_list[0] = (void *)RMMI_ATI_STRING[item];
     * string_length = rmmi_fast_string_print (
     * buffer,
     * (kal_uint8 *)"%s",
     * RMMI_COMM_PTR->arg_list,
     * 1
     * );
     * }
     */
    ret_val = l4c_eq_get_equip_id_req(source_string_ptr->src_id, EQ_ME_MODEL_ID, (kal_uint8*) eq_id);
    ret_val = l4c_eq_get_equip_id_req(source_string_ptr->src_id, EQ_ME_REVISION_ID, (kal_uint8*) eq_id2);
    if (ret_val == KAL_TRUE)
    {
        rmmi_ptr->arg_list[0] = (void*)eq_id;
        rmmi_ptr->arg_list[1] = (void*)eq_id2;
        string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "%s\r\n%s", rmmi_ptr->arg_list, 2);
        rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
    }
    return ret_val;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_atl_hdlr
 * DESCRIPTION
 *  This is rmmi_atl_hdlr function of L4C module.
 *  handler of the atl command
 * PARAMETERS
 *  source_string_ptr       [IN]        Input command string
 *  head_node_ptr           [OUT]       Cmd info
 *  err_id                  [OUT]       Error number
 * RETURNS
 *  kal_bool    result of the cmd execution
 *****************************************************************************/
kal_bool rmmi_atl_hdlr(
            rmmi_string_struct *source_string_ptr,
            rmmi_multiple_basic_cmd_struct *head_node_ptr,
            rmmi_err_id_enum *err_id)
{
    rmmi_validator_cause_enum result;
    kal_bool ret_val;
    kal_uint32 value;

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_ATL_HDLR_ENTRY);
    ASSERT((source_string_ptr != NULL) && (head_node_ptr != NULL));

    source_string_ptr->index++;
    rmmi_skip_spaces(source_string_ptr);

    value = rmmi_extract_number_ext(source_string_ptr, &result, 3);
    if(result == RMMI_PARSE_NOT_FOUND)
    {
        value = 2;        
    }
    
    if(result != RMMI_PARSE_ERROR)
    {
        ret_val = l4c_eq_exe_volume_req(source_string_ptr->src_id, VOL_TYPE_SPH, RMMI_VOLUME[value]);
        #if defined(__MMI_FMI__) && !defined(EXTERNAL_MMI)
        if (ret_val == KAL_TRUE)
        {
            L4C_PTR->route_thru_lmmi = KAL_TRUE;						
            L4C_PTR->route_thru_lmmi_user= source_string_ptr->src_id;	
        }
        #endif
    }
    else
    {
        ret_val = KAL_FALSE;
    }    
    return ret_val;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_atm_hdlr
 * DESCRIPTION
 *  This is rmmi_atm_hdlr function of L4C module.
 *  handler of the atm command
 * PARAMETERS
 *  source_string_ptr       [IN]        Input command string
 *  head_node_ptr           [OUT]       Cmd info
 *  err_id                  [OUT]       Error number
 * RETURNS
 *  kal_bool    result of the cmd execution
 *****************************************************************************/
kal_bool rmmi_atm_hdlr(
            rmmi_string_struct *source_string_ptr,
            rmmi_multiple_basic_cmd_struct *head_node_ptr,
            rmmi_err_id_enum *err_id)
{
    rmmi_validator_cause_enum result;

    /*************************
    * Don't remove this command since IVT program 
    * will use this command...
    ***************************/

    source_string_ptr->index++;
    rmmi_skip_spaces(source_string_ptr);

    rmmi_extract_number_ext(source_string_ptr, &result, 2);

    if( result != RMMI_PARSE_ERROR)
        return KAL_TRUE;
    else
        return KAL_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_ato_hdlr
 * DESCRIPTION
 *  This is rmmi_ato_hdlr function of L4C module.
 *  handler of the ato command
 * PARAMETERS
 *  source_string_ptr       [IN]        Input command string
 *  head_node_ptr           [OUT]       Cmd info
 *  err_id                  [OUT]       Error number
 * RETURNS
 *  kal_bool    result of the cmd execution
 *****************************************************************************/
kal_bool rmmi_ato_hdlr(
            rmmi_string_struct *source_string_ptr,
            rmmi_multiple_basic_cmd_struct *head_node_ptr,
            rmmi_err_id_enum *err_id)
{
    kal_bool ret_val = KAL_FALSE;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_ATO_HDLR_ENTRY);
    ASSERT((source_string_ptr != NULL) && (head_node_ptr != NULL));

    kal_brief_trace(TRACE_GROUP_3, RMMI_ATO_HDLR, rmmi_ptr->online_cmd_state);
   //mtk01616_080912: RMMI online_cmd_state is used to record which online connection is escaped

    if (rmmi_ptr->online_cmd_state == L4C_ONLINE_DATA_STATE)
    {
        ret_val = l4c_df_exe_back_data_state_req(source_string_ptr->src_id);
    }
#ifdef __MOD_TCM__
    else if ((rmmi_ptr->online_cmd_state == L4C_ONLINE_DATA_GPRS_STATE) &&
    		(rmmi_ptr->online_cmd_state_src_id == source_string_ptr->src_id)) //MAUI_01652672, mtk02285, 20090324
    {        
        ret_val = l4c_ps_gprs_resume_req(source_string_ptr->src_id);
    }
#endif /* __MOD_TCM__ */ 
    else
    {
        ret_val = KAL_FALSE;
    }
    rmmi_ptr->online_cmd_state = L4C_COMMAND_STATE;
    rmmi_ptr->online_cmd_state_src_id = INVALID_SRC; //MAUI_01652672, mtk02285, 20090324	

    if (ret_val == KAL_TRUE)
    {
        source_string_ptr->index++;
        rmmi_skip_spaces(source_string_ptr);
        /* As per the standard ITU-T V.25, other chars coming after ATA
           is ignored so this loop reaches upto the end of character so
           that once this function returns to the main loop, it should
           come out fulfilling the conditions as no further processing
           is needed. */
        while (source_string_ptr->string_ptr[source_string_ptr->index] != rmmi_ptr->s_reg.s3)
        {
            source_string_ptr->index++;
            rmmi_skip_spaces(source_string_ptr);
        }

    }
    else
    {
        *err_id = OPERATION_NOT_ALLOWED_ERR;
    }

    return ret_val;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_att_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 *  head_node_ptr           [?]     
 *  err_id                  [?]     
 * RETURNS
 *  
 *****************************************************************************/
kal_bool rmmi_att_hdlr(
            rmmi_string_struct *source_string_ptr,
            rmmi_multiple_basic_cmd_struct *head_node_ptr,
            rmmi_err_id_enum *err_id)
{
    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_ATE_HDLR_ENTRY);
    ASSERT((source_string_ptr != NULL) && (head_node_ptr != NULL));

    source_string_ptr->index++;
    rmmi_skip_spaces(source_string_ptr);
    
    if ( source_string_ptr->string_ptr[source_string_ptr->index] !=  RMMI_PTR->s_reg.s3)
        return KAL_FALSE;
    return KAL_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_atz_hdlr
 * DESCRIPTION
 *  This is rmmi_atz_hdlr function of L4C module.
 *  handler of the atz command
 * PARAMETERS
 *  source_string_ptr       [IN]        Input command string
 *  head_node_ptr           [OUT]       Cmd info
 *  err_id                  [OUT]       Error number
 * RETURNS
 *  kal_bool    result of the cmd execution
 *****************************************************************************/
kal_bool rmmi_atz_hdlr(
            rmmi_string_struct *source_string_ptr,
            rmmi_multiple_basic_cmd_struct *head_node_ptr,
            rmmi_err_id_enum *err_id)
{
    rmmi_validator_cause_enum result;
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 value;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    ASSERT((source_string_ptr != NULL) && (head_node_ptr != NULL));

    source_string_ptr->index++;
    rmmi_skip_spaces(source_string_ptr);

    value = (kal_uint8)rmmi_extract_number_ext(source_string_ptr, &result, 1);
    if (result == RMMI_PARSE_ERROR)
    {
        *err_id = OPERATION_NOT_ALLOWED_ERR;
        return KAL_FALSE;
    }
    if (value == 0) /* ATZ0 */
    {
        kal_mem_cpy(&rmmi_ptr->rmmi_current_profile, &rmmi_ptr->rmmi_default_profile, sizeof(rmmi_profile_struct));
    }
    else if (value == 1)    /*ATZ1*/
    {
        kal_mem_cpy(&rmmi_ptr->rmmi_current_profile, &rmmi_ptr->rmmi_user_profile, sizeof(rmmi_profile_struct));
    }


    rmmi_reset();
    ret_val = l4c_cc_set_call_mode_req(source_string_ptr->src_id, 0);

    ret_val = l4c_eq_load_default_config_req(source_string_ptr->src_id);

    if (ret_val == KAL_TRUE)
    {
        rmmi_skip_spaces(source_string_ptr);
        /* As per the standard ITU-T V.25, other chars coming after ATZ
           is ignored so this loop reaches upto the end of character so
           that once this function returns to the main loop, it should
           come out fulfilling the conditions as no further processing
           is needed. */
        while (source_string_ptr->string_ptr[source_string_ptr->index] != rmmi_ptr->s_reg.s3)
        {
            source_string_ptr->index++;
            rmmi_skip_spaces(source_string_ptr);
        }

        /*
         * // store command information into the list 
         * head_node_ptr->cmd_code = RMMI_CMD_ATZ;
         * head_node_ptr->cmd_mode = RMMI_SET_OR_EXECUTE_MODE;
         * head_node_ptr->value   = 0;
         * head_node_ptr->is_this_node_used = KAL_TRUE;
         */
    }
    else
    {
        *err_id = OPERATION_NOT_ALLOWED_ERR;
    }

    return ret_val;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_atw_hdlr
 * DESCRIPTION
 *  This is rmmi_atv_hdlr function of L4C module.
 *  handler of the atv command
 * PARAMETERS
 *  source_string_ptr       [IN]        Input command string
 *  head_node_ptr           [OUT]       Cmd info
 *  err_id                  [OUT]       Error number
 * RETURNS
 *  kal_bool    result of the cmd execution
 *****************************************************************************/
kal_bool rmmi_atw_hdlr(
            rmmi_string_struct *source_string_ptr,
            rmmi_multiple_basic_cmd_struct *head_node_ptr,
            rmmi_err_id_enum *err_id)
{
    rmmi_validator_cause_enum result;
    kal_uint8 value;

    ASSERT((source_string_ptr != NULL) && (head_node_ptr != NULL));

    source_string_ptr->index++;
    rmmi_skip_spaces(source_string_ptr);

    value = (kal_uint8)rmmi_extract_number_ext(source_string_ptr, &result, 2);
    if (result != RMMI_PARSE_ERROR)
    {
        if(value == 2)
        {
            RMMI_PTR->rsp_mode.ext_result_code = 2;
            RMMI_PTR->rmmi_current_profile.rmmi_atw = 2;
            return KAL_TRUE;
        }
    }

    return KAL_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_atx_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 *  head_node_ptr           [?]     
 *  err_id                  [?]     
 * RETURNS
 *  
 *****************************************************************************/
kal_bool rmmi_atx_hdlr(
            rmmi_string_struct *source_string_ptr,
            rmmi_multiple_basic_cmd_struct *head_node_ptr,
            rmmi_err_id_enum *err_id)
{
    rmmi_validator_cause_enum result;

    ASSERT((source_string_ptr != NULL) && (head_node_ptr != NULL));

    source_string_ptr->index++;
    rmmi_skip_spaces(source_string_ptr);

    rmmi_extract_number_ext(source_string_ptr, &result, 4);
    if (result != RMMI_PARSE_ERROR)
    {
        RMMI_PTR->rmmi_current_profile.rmmi_atx = 4;
        return KAL_TRUE;
    }

    return KAL_FALSE;


}


/*****************************************************************************
 * FUNCTION
 *  rmmi_atamp_hdlr
 * DESCRIPTION
 *  This is rmmi_atamp_hdlr function of L4C module.
 *  handler of the commands start with at&
 * PARAMETERS
 *  source_string_ptr       [IN]        Input command string
 *  head_node_ptr           [OUT]       Cmd info
 *  err_id                  [OUT]       Error number
 * RETURNS
 *  kal_bool    result of the cmd execution
 *****************************************************************************/
kal_bool rmmi_atamp_hdlr(
            rmmi_string_struct *source_string_ptr,
            rmmi_multiple_basic_cmd_struct *head_node_ptr,
            rmmi_err_id_enum *err_id)
{
    rmmi_validator_cause_enum result;
    kal_bool ret_val = KAL_TRUE;
    kal_uint8 cmd_value = 0;
    kal_uint16 cmd_code;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint8 string_length = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

#ifdef UART_ENABLE
    UART_CONFIG_T dcb = 
    {
        0,          /* init */
        len_8,      /* dataBits; */
        sb_1,       /* stopBits; */
        pa_none,    /* parity; */
        fc_none,    /* flow control */
        0x11,       /* xonChar; */
        0x13,       /* xoffChar; */
        KAL_FALSE
    };
#endif /* UART_ENABLE */ 

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_ATAMP_HDLR_ENTRY);
    ASSERT((source_string_ptr != NULL) && (head_node_ptr != NULL));

    source_string_ptr->index++;
    rmmi_skip_spaces(source_string_ptr);

    cmd_code = source_string_ptr->string_ptr[source_string_ptr->index];
    source_string_ptr->index++;
    rmmi_skip_spaces(source_string_ptr);

    cmd_value = (kal_uint8)rmmi_extract_number_ext(source_string_ptr, &result, 4);
    if (result == RMMI_PARSE_ERROR)
    {
        return KAL_FALSE;
    }
    ret_val = KAL_TRUE;


    switch (cmd_code)
    {
        case rmmi_char_c:
        case RMMI_CHAR_C:
            cmd_code = RMMI_CMD_ATAMPC;
    #ifdef UART_ENABLE
            //RMMI_UART_CtrlDCD(PS_UART_PORT, cmd_value);
    #endif 
            break;
        case rmmi_char_d:
        case RMMI_CHAR_D:
            cmd_code = RMMI_CMD_ATAMPD;

            if (RMMI_UART_GetOwnerID(PS_UART_PORT) != MOD_ATCI || 
                cmd_value > 2)
            {
                ret_val = KAL_FALSE;
                break;
            }
            
            rmmi_ptr->rmmi_current_profile.rmmi_atampD = cmd_value;

        #ifdef UART_ENABLE

            #if defined(__CMUX_SUPPORT__)
                /* MAUI_02281302 avoid to call uart function when CMUX enable */
                if(RMMI_COMM_PTR->cmux_enable)
                {
                    ret_val = KAL_FALSE;
                    break;
                }
            #endif

            RMMI_UART_CtrlDTR(PS_UART_PORT, (IO_level)cmd_value, MOD_ATCI);
        #endif 
            break;
        case rmmi_char_f:
        case RMMI_CHAR_F:

            if (cmd_value != 0)
            {
                ret_val = KAL_FALSE;
                break;  //only allow AT&F or AT&F0
            }

            /* reset to Factory defined configuration */
            rmmi_reset();
            ret_val = l4c_cc_set_call_mode_req(source_string_ptr->src_id, 0);
            break;
        case rmmi_char_k:
        case RMMI_CHAR_K:   /* flow control option */

            /* 0: disable all flow control
               3: enable bi-directional HW flow control (only support if using USB)
               4: enable XON/XOFF flow control (only support if not using USB) */
        #ifdef UART_ENABLE

            if (cmd_value == 0)
            {
                dcb.u1FlowControl = fc_none;
            }
            else if (cmd_value == 3)
            {
                dcb.u1FlowControl = fc_hw;
            }
            else if (cmd_value == 4)
            {
                dcb.u1FlowControl = fc_sw;
            }
            else
            {
                ret_val = KAL_FALSE;
                break;
            }
            //rmmi_ptr->flow_ctrl = cmd_value;           

            if (RMMI_UART_GetOwnerID(PS_UART_PORT) != MOD_ATCI)
            {
                ret_val = KAL_FALSE;
                break;
            }
            else
            {
                #if defined(__CMUX_SUPPORT__)
                    /* MAUI_02281302 avoid to call uart function when CMUX enable */
                    if(RMMI_COMM_PTR->cmux_enable)
                    {
                        ret_val = KAL_FALSE;
                        break;
                    }
                #endif
                
                RMMI_UART_SetDCBConfig(PS_UART_PORT, &dcb, MOD_ATCI);
            }

            rmmi_ptr->rmmi_current_profile.rmmi_atampK = cmd_value;
        #endif /* UART_ENABLE */ 

            break;
        case rmmi_char_v:
        case RMMI_CHAR_V:   /* view current profile */

            kal_sprintf((kal_char*) buffer, "DEFAULT PROFILE");
            string_length = (kal_uint8)strlen((char*)buffer);
            rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
            rmmi_view_profile(&rmmi_ptr->rmmi_default_profile);

            kal_sprintf((kal_char*) buffer, "USER PROFILE");
            string_length = (kal_uint8)strlen((char*)buffer);
            rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
            rmmi_view_profile(&rmmi_ptr->rmmi_user_profile);

            kal_sprintf((kal_char*) buffer, "ACTIVE PROFILE");
            string_length = (kal_uint8)strlen((char*)buffer);
            rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
            rmmi_view_profile(&rmmi_ptr->rmmi_current_profile);
            break;

        case rmmi_char_w:
        case RMMI_CHAR_W:   /* save current profile to user profile */

            kal_mem_cpy(&rmmi_ptr->rmmi_user_profile, &rmmi_ptr->rmmi_current_profile, sizeof(rmmi_profile_struct));
            break;

        default:
            cmd_code = RMMI_NO_CMD;
            ret_val = KAL_FALSE;
            return ret_val;
    }
    /*
     * head_node_ptr->cmd_mode = RMMI_SET_OR_EXECUTE_MODE;
     * head_node_ptr->value = cmd_value;
     * head_node_ptr->cmd_code = cmd_code;
     * head_node_ptr->is_this_node_used = KAL_TRUE ;
     */
    return ret_val;
}
#endif /* !defined(__ULC_AT__) */

