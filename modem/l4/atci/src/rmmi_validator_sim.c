/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 * RMMI_VALIDATOR_SIM.C
 *
 * Project:
 * --------
 *   MAUI
 *
 * Description:
 * ------------
 *   This file is intends for ...
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "kal_public_defs.h" //MSBB change #include "stack_msgs.h"
#include "kal_public_api.h"
#include "sim_ps_msgid.h"
#ifdef __MOD_SMU__
#include "ps2sim_struct.h"
#include "sim_common_enums.h"
#include "smu_common_enums.h"
#endif /* __MOD_SMU__ */ 
#include "rmmi_common_enum.h"
#include "rmmi_context.h"
#include "l4c_context.h"
#include "layer4_context.h"
//#include "l4c_rspfmttr.h"
#include "l4c_msghdlr.h"
#include "l4_trc.h"
#include "atci_trc.h"
#include "ps2sat_struct.h"
#include "sim_common_enums.h"
#include "ps2sat_struct.h"
#include "l4c_sim_cmd.h"
#include "l4c_utility.h"
#include "rmmi_rspfmttr.h"
#include "rmmi_utility.h"
#if defined(__BT_SUPPORT__)
#include "bluetooth_struct.h"
#endif 
#include "l4c_sendmsg.h"

#include "sat_def.h"
#include "rmmi_msghdlr.h"

/* for data item NVRAM_EF_SYS_CACHE_OCTET_LID */
#include "nvram_struct.h"

#include "kal_trace.h"

#if !defined(__MMI_FMI__)
#include "custom_nvram_extra.h"
#endif
#include "l4crac_func.h"
#include "l4c_root.h"

#include "tst_sap.h"
#include "tst_msgid.h"
#include "sim_ps_enum.h"

#include "sim_public_enum.h"
#include "sim_public_enum.h"
#include "l4c_eq_cmd.h"
#include "ps_public_utility.h"
#include "rmmi_rsp.h"

extern kal_bool rmmi_translate_oper_name(
                    kal_uint8 format1,
                    kal_uint8 *oper_str1,
                    kal_uint8 format2,
                    kal_uint8 *oper_str2);

/* sim group */

#ifdef __MOD_SMU__

/*****************************************************************************
 * FUNCTION
 *  rmmi_esims_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for sim detection .
 *  mtk00468 add on 08/05
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_esims_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];   /* temp buffer for response format usage */
    kal_uint8 const *rsp_str = NULL;        /* response string and initialization */
    kal_uint16 string_length = 0;           /* string length variable */

    switch (source_string_ptr->cmd_mode)
    {
            /* checking the command mode */
        case RMMI_READ_MODE:    /* at+esim? */
        {
            RMMI_PTR->arg_list[0] = (void*)&L4C_PTR->single_sim_inserted_status;
            string_length = rmmi_fast_string_print(
                                /* using this macro to format the string quickly */ buffer,
                                (kal_uint8*) "+ESIMS: %d",
                                RMMI_PTR->arg_list,
                                1);
            rsp_str = &buffer[0];
            ret_val = KAL_TRUE;
            break;
        }
    #ifndef __MMI_FMI__
	 case RMMI_ACTIVE_MODE:

	  /*****************************************************************
	    * Three combination should be supported:
	    * 1. Only defined __GSMCDMA_DUALSIM__
	    * 2. Only defined __CTA_DUAL_SIM_STANDARD__
	    * 3. Defined __GSMCDMA_DUALSIM__ and __CTA_DUAL_SIM_STANDARD__
	    *****************************************************************/
	  #ifdef __GSMCDMA_DUALSIM__
	     l4c_sim_get_gsmcdma_dualsim_info_req(source_string_ptr->src_id);
	     return;
	  #endif

	     l4c_sim_reset_req(source_string_ptr->src_id);  
	     return;
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 mode, error_cause;

            mode = (kal_uint8) rmmi_int_validator_range_check(&error_cause, source_string_ptr, RMMI_PTR->s_reg.s3, 1);

            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }
	     else
	     {
                RMMI_PTR->report_mode.esims = mode;
                ret_val = KAL_TRUE;
	     }
            break;            
        }
    #endif        
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


#if !defined(__ULC_AT__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_cimi_hdlr
 * DESCRIPTION
 *  request IMSI
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cimi_hdlr(rmmi_string_struct *source_string_ptr)
{
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 imsi[17];
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CIMI_HDLR_ENTRY);

    /* mtk0071420040726 */
    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_READ_MODE:
        case RMMI_ACTIVE_MODE:
        {
            ret_val = l4c_smu_get_imsi_req(source_string_ptr->src_id, (kal_uint8*) imsi);

            // imsi[0] is parity bit, don't print out
            rmmi_ptr->arg_list[0] = (void*)&imsi[1];

            if (source_string_ptr->cmd_mode == RMMI_ACTIVE_MODE)
            {
                //spec defined : AT+CIMI <CR>
                string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "%s", rmmi_ptr->arg_list, 1);
            }
            else
            {
                // proprietary for tool team , they need "+CIMI:" prefix information
                string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CIMI: \"%s\"", rmmi_ptr->arg_list, 1);
            }
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            rmmi_ptr->cmee_err = RMMI_ERR_UNSPECIFIED;
            break;
        }
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, buffer, string_length);
    return;
}

#ifdef __VSIM__
/*****************************************************************************
 * FUNCTION
 *  rmmi_evsim_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_evsim_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint8 const *rsp_str = NULL;    /* response string and initialization */
    kal_uint16 string_length = 0;       /* string length variable */
	
    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:   
        {
            kal_uint8 is_vsim_on = (kal_uint8)l4c_is_vsim_on();
                
            RMMI_PTR->arg_list[0] = (void*)&is_vsim_on;
            string_length = rmmi_fast_string_print(buffer,(kal_uint8*) "+EVSIM: %d", RMMI_PTR->arg_list, 1);
            rsp_str = &buffer[0];
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:    
        {
            kal_uint8 error_cause;
            kal_uint8 mode;

            /* Get the mode, 1:switch_on 0:switch_off */
            mode = (kal_uint8)rmmi_int_validator_range_check(
                    &error_cause,
                    source_string_ptr,
                    RMMI_PTR->s_reg.s3,
                    1);	

            if (mode == RMMI_VALIDATOR_ERROR)
            {
                break;
            }

            ret_val = l4c_sim_vsim_req(source_string_ptr->src_id, mode);		 
            if (ret_val == KAL_TRUE)
            {
                return;
            }

            break;
        }		
        default:
        {
            break;
        }
    }

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}
#endif


#endif /* !defined(__ULC_AT__) */

#if !defined(__SLIM_AT__)


/*****************************************************************************
 * FUNCTION
 *  rmmi_eusim_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for sim detection .
 *  mtk00468 add on 08/05
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_eusim_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];   /* temp buffer for response format usage */
    kal_uint8 const *rsp_str = NULL;        /* response string and initialization */
    kal_uint16 string_length = 0;           /* string length variable */

    switch (source_string_ptr->cmd_mode)
    {
            /* checking the command mode */
        case RMMI_READ_MODE:    /* at+eusim? */
        {
			kal_bool is_usim = check_is_usim();

            RMMI_PTR->arg_list[0] = (void*)&is_usim;
            string_length = rmmi_fast_string_print(
                                /* using this macro to format the string quickly */ buffer,
                                (kal_uint8*) "+EUSIM: %d",
                                RMMI_PTR->arg_list,
                                1);
            rsp_str = &buffer[0];
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 mode, error_cause;

            mode = (kal_uint8) rmmi_int_validator_range_check(&error_cause, source_string_ptr, RMMI_PTR->s_reg.s3, 1);

            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }
            else
            {
                RMMI_PTR->report_mode.eusim = mode;
                ret_val = KAL_TRUE;
            }
            break;            
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}

/*****************************************************************************
 * FUNCTION
 *  rmmi_etestsim_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for test sim detection .
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_etestsim_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];   /* temp buffer for response format usage */
    kal_uint8 const *rsp_str = NULL;        /* response string and initialization */
    kal_uint16 string_length = 0;           /* string length variable */

    switch (source_string_ptr->cmd_mode)
    {
            /* checking the command mode */
        case RMMI_READ_MODE:    /* at+etestsim? */
        {
			kal_bool is_test_sim = l4c_is_test_sim();

            RMMI_PTR->arg_list[0] = (void*)&is_test_sim;
            string_length = rmmi_fast_string_print(
                                /* using this macro to format the string quickly */ buffer,
                                (kal_uint8*) "+ETESTSIM: %d",
                                RMMI_PTR->arg_list,
                                1);
            rsp_str = &buffer[0];
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 mode, error_cause;

            mode = (kal_uint8) rmmi_int_validator_range_check(&error_cause, source_string_ptr, RMMI_PTR->s_reg.s3, 1);

            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }
            else
            {
                RMMI_PTR->report_mode.etestsim = mode;
                ret_val = KAL_TRUE;
            }
            break;            
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_cpin_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cpin_hdlr(rmmi_string_struct *source_string_ptr)
{
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 result, result2;
    kal_uint8 type;
    kal_uint8 name[10];
    kal_uint8 old_pin[(SML_MAX_SUPPORT_KEY_LEN*2)+1];
    kal_uint8 new_pin[SML_MAX_SUPPORT_KEY_LEN+1];
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 temp_index;
    kal_uint16 string_length = 0;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CPIN_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:
        {
            ret_val = l4c_smu_get_pin_type_req(source_string_ptr->src_id, (kal_uint8*) & type);

            if (ret_val == KAL_FALSE)
            {
                if (L4C_PTR->sim_error_cause == 0x00)
                {
                    rmmi_ptr->cmee_err = SIM_BUSY;
                }
                else if (L4C_PTR->sim_error_cause == SIM_NO_INSERTED)
                {
                    rmmi_ptr->cmee_err = SIM_NOT_INSERTED;
                }
                else
                {
                    rmmi_ptr->cmee_err = SIM_WRONG; 
                }

                break;
            }
            else
            {
                if (type == ID_SIM_BLOCKED)
                {   //mtk01616_080508: there is no mapping for Blcok SIM in 07.07 spec. So we use error cause 15(SIM WRONG) for WM and ECMT to know it's block SIM
                    rmmi_ptr->cmee_err = SIM_WRONG;
                    ret_val = KAL_FALSE;
                    break;
                }

                if (type == ID_SIM_BUSY)
                {
                    rmmi_ptr->cmee_err = SIM_BUSY;
                    ret_val = KAL_FALSE;
                    break;
                }
            }

            //[MAUI_01296349] mtk02480, 27.007: +CPIN? return  PIN2/PUK2 if previous command execured authentication failure
            if (rmmi_ptr->last_executed_P2_fail != RMMI_NO_ERR)
            {
                switch(rmmi_ptr->last_executed_P2_fail)
                {
                    case SIM_PIN2_REQUIRED:
                        type = ID_SIM_PIN2;
                        break;
                    case SIM_PUK2_REQUIRED:
                        type = ID_SIM_PUK2;				
                        break;
                    default:
                        break;
                }
                //rmmi_ptr->last_executed_P2_fail = RMMI_NO_ERR;
            }	

            // [MAUI_00285031] cpin does not support phone lock according to the spec
            if (type == ID_PHONELOCK)
            {
                rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNSPECIFIED);
                return;
            }
            else
            {
                check_pin_name(type, name);
                rmmi_ptr->arg_list[0] = (void*)name;
                string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CPIN: %s", rmmi_ptr->arg_list, 1);
            }
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            rmmi_ptr->last_executed_P2_fail = RMMI_NO_ERR; // [MAUI_01296349] mtk02480 27.007
            
            kal_mem_set((kal_uint8*) old_pin, 0, sizeof(old_pin)); //set to zero
            kal_mem_set((kal_uint8*) new_pin, 0, sizeof(new_pin)); //set to zero

            temp_index = source_string_ptr->index;
            result = rmmi_string_validator(
                        source_string_ptr,
                        (kal_uint8) RMMI_COMMA, /* separator */
                        (SML_MAX_SUPPORT_KEY_LEN*2)+1,
                        (kal_uint8*) old_pin);

            /* mtk00924 20050513 if the PIN required is PUK or PUK2, the second PIN is required */
            result2 = l4c_smu_get_pin_type_req(source_string_ptr->src_id, (kal_uint8*) & type);

            if (result2 == KAL_FALSE)
            {
                rmmi_ptr->cmee_err = SIM_NOT_INSERTED;
                break;
            }

            // [MAUI_00285031] cpin does not support phone lock according to the spec
            if (type == ID_PHONELOCK)
            {
                rmmi_ptr->cmee_err = RMMI_ERR_UNSPECIFIED;
                break;
            }

            if (type == ID_SIM_PUK1 || type == ID_SIM_PUK2)
            {
                if (result == RMMI_VALIDATOR_ERROR)
                {
                    // ret_val = KAL_FALSE;
                    break;
                }
            }
            /* mtk00924 20050513 ig the PIN required is PUK or PUK2, the second PIN is required */

            if (result == RMMI_VALIDATOR_ERROR)
            {
                source_string_ptr->index = temp_index;
                result = rmmi_string_validator(
                            source_string_ptr,
                            rmmi_ptr->s_reg.s3, /* separator */
                            (SML_MAX_SUPPORT_KEY_LEN*2)+1,
                            (kal_uint8*) old_pin);
                if (result == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }
                kal_mem_set((kal_uint8*) new_pin, 0, sizeof(new_pin)); //set to zero
            }
            else // old pin exist so new pin should exist
            {
                result = rmmi_string_validator(
                            source_string_ptr,
                            rmmi_ptr->s_reg.s3, /* separator */
                            SML_MAX_SUPPORT_KEY_LEN+1,
                            (kal_uint8*) new_pin);
                if (result == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }
            }

            ret_val = l4c_smu_exe_verify_pin_req(
                        source_string_ptr->src_id,
                        TYPE_UNSPECIFIED,
                        (kal_uint8*) old_pin,
                        (kal_uint8*) new_pin);
            if (ret_val == KAL_TRUE)
            {
                return;
            }
            else
            {
                rmmi_ptr->cmee_err = OPERATION_NOT_ALLOWED_ERR;
            }
            break;
        }
        default:
        {
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) buffer, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_epin1_hdlr
 * DESCRIPTION
 *  this command is used to validate the PIN1 code (CHV1) or PUK1(UBCHV1)
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_epin1_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 result;
    kal_uint8 name[16];
    kal_uint8 old_pin[9];
    kal_uint8 new_pin[9];
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;

    kal_trace(TRACE_FUNC, FUNC_RMMI_EPIN1_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
            return;
        }
    #endif /* __test_mode__ */ 
        case RMMI_READ_MODE:
        {
            kal_uint8 pending_pwd_type;

            ret_val = l4c_smu_get_pin_type_req(source_string_ptr->src_id, (kal_uint8*) & pending_pwd_type);

	     if (ret_val==KAL_FALSE)
	     {
	         break;
	     }

            if (pending_pwd_type == ID_READY)
            {
                strcpy((char*)name, "READY\0");
            }
            else if (pending_pwd_type == ID_SIM_PIN1)
            {
                strcpy((char*)name, "SIM PIN\0");
            }
            else if (pending_pwd_type == ID_SIM_PUK1)
            {
                strcpy((char*)name, "SIM PUK\0");
            }
            else if (pending_pwd_type == ID_SIM_BLOCKED)
            {
                strcpy((char*)name, "SIM BLOCKED\0");
            }			
            else
            {
		  ret_val=KAL_FALSE;
		  break;		  	
            }

            RMMI_PTR->arg_list[0] = (void*)name;
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+EPIN1: \"%s\"", RMMI_PTR->arg_list, 1);
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;
            kal_uint8 pwd_type;
            kal_uint8 pending_pwd_type;

	     /* mtk02480, AT+EPIN1 is used to unblock PIN when pending_password_id is PIN/PUK/READY.
	       *    To verify PIN when PIN is not pending, suggest to use AT+CPWD="SC","PIN","PIN"
	       *    To unblock PIN, use AT+EPIN1="PUK","new_PIN"
	       */

            ret_val = l4c_smu_get_pin_type_req(source_string_ptr->src_id, (kal_uint8*) & pending_pwd_type);

            result = rmmi_string_validator_ext(
                        &error_cause,
                        source_string_ptr,
                        (kal_uint8) RMMI_COMMA, /* separator */
                        9,
                        (kal_uint8*) old_pin);

            if (result == RMMI_VALIDATOR_ERROR)
            {
           	  ret_val = KAL_FALSE;            
                break;
            }

            result = rmmi_string_validator_ext(
                        &error_cause,
                        source_string_ptr,
                        RMMI_PTR->s_reg.s3, /* separator */
                        9,
                        (kal_uint8*) new_pin);

            if (result == RMMI_VALIDATOR_ERROR)
            {
                if (error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    kal_mem_set((kal_uint8*) new_pin, 0, sizeof(new_pin));     //set to zero
                    pwd_type = TYPE_CHV1;
                }
                else
                {
                    ret_val = KAL_FALSE;
                    break;
                }
            }
            else
            {
                pwd_type = TYPE_UBCHV1;
            }


            /* mtk02480 , Not allow if in SML required state */
            switch (pending_pwd_type)				
            {
		case ID_PH_NET_PIN:
		case ID_PH_NET_PUK:
		case ID_PH_NETSUB_PIN:
		case ID_PH_NETSUB_PUK:
		case ID_PH_SP_PIN:
		case ID_PH_SP_PUK:			
		case ID_PH_CORP_PIN:
		case ID_PH_CORP_PUK:						
		case ID_PH_FSIM_PIN:
		case ID_PH_FSIM_PUK:
		case ID_PH_LINK_NS_SP_PIN:
   		case ID_PH_LINK_NS_SP_PUK:
   		case ID_PH_LINK_SIM_C_PIN:
   		case ID_PH_LINK_SIM_C_PUK:
                	rmmi_result_code_fmttr(RMMI_RCODE_ERROR, OPERATION_NOT_ALLOWED_ERR);
                	return;
		default:
			break;
            }		

            ret_val = l4c_smu_exe_verify_pin_req(
                        source_string_ptr->src_id,
                        pwd_type,
                        (kal_uint8*) old_pin,
                        (kal_uint8*) new_pin);
            if (ret_val == KAL_FALSE)
            {
                rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNKNOWN);
            }
            return;
        }

        default:
        {
            /* unrecognized format of AT command line */
            rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNSPECIFIED);
            return;
        }
    }   /* end of the switch */

    if (ret_val == KAL_TRUE)
    {
        rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
        rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
    }
    else
    {
        rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNSPECIFIED);
    }
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_epin2_hdlr
 * DESCRIPTION
 *  this command is used to validate the PIN2 code (CHV2) or PUK2(UBCHV2)
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_epin2_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 result;
    kal_uint8 name[16];
    kal_uint8 old_pin[9];
    kal_uint8 new_pin[9];
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length;

    kal_trace(TRACE_FUNC, FUNC_RMMI_EPIN2_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
            return;
        }
    #endif /* __test_mode__ */ 
        case RMMI_READ_MODE:
        {
 	     sim_chv_info_struct chv_info;
 	     sim_chv_status_struct chv_status;			
	     ret_val = l4c_sim_check_pin_status_req(&chv_info, &chv_status);
	     
            if (chv_info.chv2_count==0 && chv_info.ubchv2_count==0)
            {
                strcpy((char*)name, "SIM BLOCKED\0");
            }
            else if (chv_info.chv2_count==0)
            {
                strcpy((char*)name, "SIM PUK2\0");
            }
            else
            {
                strcpy((char*)name, "READY\0");
            }

            RMMI_PTR->arg_list[0] = (void*)name;
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+EPIN2: \"%s\"", RMMI_PTR->arg_list, 1);
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;
            kal_uint8 pwd_type;

	     /* mtk02480, AT+EPIN2 is used to unblock PIN2.
	       *    To verify PIN2 , suggest to use AT+CPWD="P2","PIN2","PIN2"
	       *    To unblock PIN2, use AT+EPIN2="PUK2","new_PIN2"
	       */

            result = rmmi_string_validator_ext(
                        &error_cause,
                        source_string_ptr,
                        (kal_uint8) RMMI_COMMA, /* separator */
                        9,
                        (kal_uint8*) old_pin);

            if (result == RMMI_VALIDATOR_ERROR)
            {
                ret_val = KAL_FALSE;
                break;
            }

            result = rmmi_string_validator_ext(
                        &error_cause,
                        source_string_ptr,
                        RMMI_PTR->s_reg.s3, /* separator */
                        9,
                        (kal_uint8*) new_pin);

            if (result == RMMI_VALIDATOR_ERROR)
            {
                if (error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    kal_mem_set((kal_uint8*) new_pin, 0, sizeof(new_pin));     //set to zero
                    pwd_type = TYPE_CHV2;
                }
                else
                {
                    ret_val = KAL_FALSE;
                    break;
                }
            }
            else
            {
                pwd_type = TYPE_UBCHV2;
            }

            ret_val = l4c_smu_exe_verify_pin_req(
                        source_string_ptr->src_id,
                        pwd_type,
                        (kal_uint8*) old_pin,
                        (kal_uint8*) new_pin);
            if (ret_val == KAL_FALSE)
            {
                rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNKNOWN);
            }
            return;
        }

        default:
        {
            /* unrecognized format of AT command line */
            rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNSPECIFIED);
            return;
        }
    }   /* end of the switch */

    if (ret_val == KAL_TRUE)
    {
        rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
        rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
    }
    else
    {
        rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNSPECIFIED);
    }
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_epinc_hdlr
 * DESCRIPTION
 *  this command is to read remain try times of PIN
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_epinc_hdlr(rmmi_string_struct *source_string_ptr)
{
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    sim_chv_info_struct chv_info;
    sim_chv_status_struct chv_status;
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;

    kal_trace(TRACE_FUNC, FUNC_RMMI_EPINC_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:
        case RMMI_ACTIVE_MODE:
        {
            ret_val = l4c_sim_check_pin_status_req(&chv_info, &chv_status);

            if (ret_val == KAL_FALSE)
            {
                if (L4C_PTR->sim_error_cause == 0x00)
                {
                    rmmi_ptr->cmee_err = SIM_BUSY;
                }
                else if (L4C_PTR->sim_error_cause == SIM_NO_INSERTED)
                {
                    rmmi_ptr->cmee_err = SIM_NOT_INSERTED;
                }
                else
                {
                    rmmi_ptr->cmee_err = SIM_WRONG; 
                }

                break;
            }

            rmmi_ptr->arg_list[0] = (void*)&chv_info.chv1_count;
            rmmi_ptr->arg_list[1] = (void*)&chv_info.chv2_count;
            rmmi_ptr->arg_list[2] = (void*)&chv_info.ubchv1_count;
            rmmi_ptr->arg_list[3] = (void*)&chv_info.ubchv2_count;

            string_length = rmmi_fast_string_print(
                                buffer,
                                (kal_uint8*) "+EPINC: %d, %d, %d, %d",
                                rmmi_ptr->arg_list,
                                4);

            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNSPECIFIED);
            return;
        }
    }

    //if (ret_val == KAL_TRUE)
    //{
    //    rmmi_write_to_uart((kal_uint8 *)buffer, string_length, KAL_TRUE);
    //    rmmi_result_code_fmttr (RMMI_RCODE_OK, L4C_NO_CAUSE);
    //}

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, buffer, string_length);

}

#ifdef __AOC_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  rmmi_cpuc_hdlr
 * DESCRIPTION
 *  Set command sets the parameters of Advice of Charge related price per unit
 *  and currency table in SIM file EFPUCT.
 *  PUCT information can be used to convert the home units (as used in +CAOC,
 *  +CACM and +CAMM) into currency units.
 *  SIM PIN2 is usually required to set the parameters.
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cpuc_hdlr(rmmi_string_struct *source_string_ptr)
{
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 result;
    kal_uint8 passwd[9];
    kal_uint8 currency[4];
    kal_uint8 hex[8];
    kal_uint8 i = 0, j = 0;
    kal_uint8 ucs2_currency[13];
    kal_uint8 ppu[20], temp[20];
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    kal_uint8 rmmi_error_cause = RMMI_PARSE_OK;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CPUC_HDLR_ENTRY);
    kal_mem_set(ucs2_currency, 0, sizeof(ucs2_currency));
    
    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
            return;
        }
    #endif /* __test_mode__ */ 
        case RMMI_READ_MODE:
        {
            ret_val = l4c_smu_get_puc_params_req(source_string_ptr->src_id, (kal_uint8*) currency, (kal_uint8*) temp);

            if (ret_val == KAL_FALSE)
            {
	        /*  [DUMA00121499], mtk02480
	          *		For WinMo, if SIM has no PUC file, report 0, to allow user to enter price page
		   */			
		#ifdef __WM_RIL_SUPPORT__
            	  string_length = rmmi_fast_string_print(
            	  		     buffer,
                                (kal_uint8*) "+CPUC: \"\", \"0\"",
                                rmmi_ptr->arg_list,
                                0);
		  ret_val = KAL_TRUE;
		#else 	   
                rmmi_error_cause = RMMI_ERR_UNKNOWN;
		#endif
                break;
            }

            if (rmmi_ptr->char_set == RMMI_CHSET_UCS2)
            {

                for (i = 0; i < 3; i++)
                {
                    if (currency[i] != 0)
                    {
                        j += kal_sprintf((char*)ucs2_currency + j, "%02X", 0);
                        j += kal_sprintf((char*)ucs2_currency + j, "%02X", currency[i]);
                    }
                }
                ucs2_currency[12] = RMMI_END_OF_STRING_CHAR;

                rmmi_ptr->arg_list[0] = (void*)ucs2_currency;
            }
            else
            {
                currency[3] = RMMI_END_OF_STRING_CHAR;
                rmmi_ptr->arg_list[0] = (void*)currency;
            }

            check_ppu_string(temp, ppu);

            rmmi_ptr->arg_list[1] = (void*)ppu;
            string_length = rmmi_fast_string_print(
                                buffer,
                                (kal_uint8*) "+CPUC: \"%s\", \"%s\"",
                                rmmi_ptr->arg_list,
                                2);
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;
            kal_wchar wch_currency[4];
            kal_bool ret;

            /* get currency */

            if (rmmi_ptr->char_set == RMMI_CHSET_UCS2)
            {
                result = rmmi_string_validator_ext(
                            &error_cause,
                            source_string_ptr,
                            (kal_uint8) RMMI_COMMA, /* separator */
                            13,
                            (kal_uint8*) ucs2_currency);

                if (result == RMMI_VALIDATOR_ERROR)
                {
                    if ((error_cause == RMMI_PARSE_OK) || (error_cause == RMMI_PARSE_NOT_FOUND))
                    {
                        currency[0] = '\0';
                    }
                    else
                    {
                        if (error_cause == RMMI_PARSE_TEXT_TOO_LONG)
                        {
                            rmmi_error_cause = TEXT_ERRSTRING_TOO_LONG_ERR;
                        }
                        else
                        {
                            rmmi_error_cause = INVALID_CHARACTERS_IN_TEXT_ERRSTRING_ERR;
                        }
                        break;
                    }
                }

                //convert string to hex value
                ret = check_hex_value_ext(ucs2_currency, hex);

                if (ret == KAL_FALSE)
                {
                    rmmi_error_cause = INVALID_CHARACTERS_IN_TEXT_ERRSTRING_ERR;
                    break;
                }

                //convert type u8 to wchar
                for (i = 0; i < 3; i++)
                {
                    wch_currency[i] = (hex[2 * i] << 8) + hex[2 * i + 1];
                }
                wch_currency[3] = RMMI_END_OF_STRING_CHAR;

                ret = ucs2_to_ascii(wch_currency, currency);

                if (ret == KAL_FALSE)
                {
                    rmmi_error_cause = INVALID_CHARACTERS_IN_TEXT_ERRSTRING_ERR;
                    break;
                }
            }
            else
            {
                result = rmmi_string_validator_ext(
                            &error_cause,
                            source_string_ptr,
                            (kal_uint8) RMMI_COMMA, /* separator */
                            4,
                            (kal_uint8*) currency);

                if (result == RMMI_VALIDATOR_ERROR)
                {
                    if ((error_cause == RMMI_PARSE_OK) || (error_cause == RMMI_PARSE_NOT_FOUND))
                    {
                        currency[0] = '\0';
                    }
                    else
                    {
                        rmmi_error_cause = INVALID_CHARACTERS_IN_TEXT_ERRSTRING_ERR;
                        break;
                    }
                }
            }

            /* get ppu */
            result = rmmi_string_validator_ext(
                        &error_cause,
                        source_string_ptr,
                        (kal_uint8) RMMI_COMMA, /* separator */
                        20,
                        (kal_uint8*) ppu);

            if (result == RMMI_VALIDATOR_ERROR)
            {
                rmmi_error_cause = INVALID_CHARACTERS_IN_TEXT_ERRSTRING_ERR;
                break;
            }

            /* get passwd */
            result = rmmi_string_validator_ext(
                        &error_cause,
                        source_string_ptr,
                        rmmi_ptr->s_reg.s3, /* separator */
                        9,
                        (kal_uint8*) passwd);
            if (result == RMMI_VALIDATOR_ERROR)
            {
                if ((error_cause == RMMI_PARSE_OK) || (error_cause == RMMI_PARSE_NOT_FOUND))
                {
                    rmmi_error_cause = SIM_PIN2_REQUIRED;
                    break;
                }
                else
                {
                    rmmi_error_cause = INVALID_CHARACTERS_IN_TEXT_ERRSTRING_ERR;
                    break;
                }
            }

            ret_val = check_ppu_value(ppu, temp);
	     if (ret_val == KAL_FALSE)
	     {
                    rmmi_error_cause = INVALID_CHARACTERS_IN_TEXT_ERRSTRING_ERR;
                    break;	     
	     }

            ret_val = l4c_smu_set_puc_params_req(
                        source_string_ptr->src_id,
                        (kal_uint8*) passwd,
                        (kal_uint8*) currency,
                        (kal_uint8*) temp);
            if (ret_val == KAL_FALSE)
            {
                rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNKNOWN);
            }

            return;
        }

        default:
        {
            /* unrecognized format of AT command line */
            rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNSPECIFIED);
            return;
        }
    }   /* end of the switch */

    if (ret_val == KAL_TRUE)
    {
        rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
        rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
    }
    else
    {
        rmmi_result_code_fmttr(RMMI_RCODE_ERROR, rmmi_error_cause);
    }
    return;
}
#endif

/*****************************************************************************
 * FUNCTION
 *  rmmi_cpol_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cpol_hdlr(rmmi_string_struct *source_string_ptr)
{
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 result;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    kal_uint16 i, num = 0;
    kal_uint8 index;
    kal_uint8 format;
    kal_uint8 oper[7];
    kal_uint8 *oper_list;
    kal_uint8 *rat_list;
    kal_uint8 oper_str[17];
    kal_uint16 file_idx_rsp;
    kal_uint16 UTRA_AcT = 0, GSM_com_AcT = 0, GSM_AcT = 0;
    kal_uint8 rat;
    sim_file_index_enum selected_file;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CPOL_HDLR_ENTRY);

    kal_mem_set(oper_str, 0x00, 17);

    if (rmmi_ptr->cpls_selected == 2)
    {
        selected_file = FILE_HPLMNACT_IDX;
    }
    else if (rmmi_ptr->cpls_selected == 1)
    {
        selected_file = FILE_OPLMNWACT_IDX;
    }
    else
    {
        if (l4c_smu_file_idx_for_preferred_oper_list(FILE_PLMNWACT_IDX) != FILE_NONE)
        {
            selected_file = FILE_PLMNWACT_IDX;
        }
        else
        {
            selected_file = FILE_PLMNSEL_IDX;
        }
    }

    // get max index
    ret_val = l4c_smu_get_preferred_oper_list_req(source_string_ptr->src_id, 0, selected_file, &num, NULL, NULL, &file_idx_rsp);

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_TEST_MODE:
        {
            if (ret_val == KAL_TRUE)
            {
                num--;  /* index start from 0 */
            }
            else
            {
                break;
            }

            rmmi_ptr->arg_list[0] = (void*)&num;
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CPOL: (0-%d), (0-2)", rmmi_ptr->arg_list, 1);
            rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
            rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
            return;
        }
        case RMMI_READ_MODE:
        {
            if (num > 0)
            {
                if ((kal_uint16) (num * 7) >= 2048)
                {
                    ASSERT(0);
                }

                oper_list = get_ctrl_buffer((kal_uint16) (num * 7));
                rat_list = get_ctrl_buffer((num * 2));
            }
            else
            {
                ret_val = KAL_FALSE;
                break;
            }

            ret_val = l4c_smu_get_preferred_oper_list_req
                (source_string_ptr->src_id, 0, selected_file, &num, oper_list, rat_list, &file_idx_rsp);

            if (ret_val == KAL_FALSE)
            {
                rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_RETURN_ERROR);
                free_ctrl_buffer(oper_list);
                free_ctrl_buffer(rat_list);
                return;
            }

            for (i = 0; i < num; i++)
            {
                kal_uint8 temp_oper[7];

                /* temp_oper: numeric <oper> */
                kal_mem_cpy(temp_oper, (kal_uint8*) oper_list + i * 7, 7);

                if ((rmmi_is_number_string(temp_oper) == KAL_FALSE) || (temp_oper[0]==RMMI_END_OF_STRING_CHAR))
                {
                    continue; // Don't show empty entry
                }

                UTRA_AcT = 0;
                GSM_com_AcT = 0;
                GSM_AcT = 0;

                rmmi_ptr->arg_list[0] = (void*)&i;
                if (rmmi_translate_oper_name(RMMI_PLMN_NUMERIC, temp_oper, rmmi_ptr->CPOL_plmn_format, oper_str) == KAL_TRUE)
                {
                    rmmi_ptr->arg_list[1] = (void*)&rmmi_ptr->CPOL_plmn_format;
                }
                else
                {
                    format = RMMI_PLMN_NUMERIC;
                    rmmi_ptr->arg_list[1] = (void*)&format;
                }
                rmmi_ptr->arg_list[2] = (void*)oper_str;

                if (oper_str[0] != RMMI_END_OF_STRING_CHAR)
                {
                    if (file_idx_rsp != FILE_PLMNSEL_IDX)
                    {
                        UTRA_AcT = (rat_list[2 * i] & 0x80) >> 7;
                        GSM_com_AcT = (rat_list[2 * i + 1] & 0x40) >> 6;
                        GSM_AcT = (rat_list[2 * i + 1] & 0x80) >> 7;
                    }
                }

                rmmi_ptr->arg_list[3] = (void*)&GSM_AcT;
                rmmi_ptr->arg_list[4] = (void*)&GSM_com_AcT;
                rmmi_ptr->arg_list[5] = (void*)&UTRA_AcT;

                if (file_idx_rsp == FILE_PLMNSEL_IDX)
                {
                    string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CPOL: %d,%d,\"%s\"", rmmi_ptr->arg_list, 3);
                }
                else
                {
                    string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CPOL: %d,%d,\"%s\",%u,%u,%u", rmmi_ptr->arg_list, 6);
                }
                rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
            }

            rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
            free_ctrl_buffer(oper_list);
            free_ctrl_buffer(rat_list);
            return;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;

            if (ret_val == KAL_TRUE)
            {
                num--;
            }
            else
            {
                break;
            }

            // get <index> ,  index start from 0 
            index = (kal_uint8) rmmi_int_validator_ext(
                                    &error_cause,
                                    source_string_ptr,
                                    (kal_uint8) RMMI_COMMA /* separator */ );

            if (error_cause == RMMI_PARSE_NOT_FOUND)
            {
                index = 0xff;
            }
            else if (error_cause == RMMI_PARSE_ERROR || index > num)
            {
                ret_val = KAL_FALSE;
                break;
            }

            // get <format>
            format = (kal_uint8) rmmi_int_validator_range_check(
                                    &error_cause,
                                    source_string_ptr,
                                    (kal_uint8) RMMI_COMMA, /* separator */
                                    2);

 	     if (error_cause == RMMI_PARSE_OK)
 	     {
	         rmmi_ptr->CPOL_plmn_format = format; 	     
 	     }
	     else if (error_cause == RMMI_PARSE_NOT_FOUND)
	     {
	         rmmi_ptr->CPOL_plmn_format = 2; 		     
	     }
	     else
	     {
                ret_val = KAL_FALSE;
                break;
	     }

            //get <result>
            result = rmmi_string_validator_ext(
                        &error_cause,
                        source_string_ptr,
                        RMMI_COMMA, /* separator */
                        17,
                        (kal_uint8*) oper_str);

            if (result != RMMI_VALIDATOR_ERROR)
            {
                // get <GSM_AcT>
                GSM_AcT = (kal_uint8)rmmi_int_validator_range_check(
                                        &error_cause, 
                                        source_string_ptr, 
                                        (kal_uint8) RMMI_COMMA, 
                                        1);

                if (error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    GSM_AcT = 1;
                }
                else if (error_cause == RMMI_PARSE_ERROR)
                {
                    ret_val = KAL_FALSE;
                    break;
                }

                // get <GSM_com_AcT>
                GSM_com_AcT = (kal_uint8)rmmi_int_validator_range_check(
                                        &error_cause, 
                                        source_string_ptr, 
                                        (kal_uint8) RMMI_COMMA, 
                                        1);

                if (error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    GSM_com_AcT = 0;
                }
                else if (error_cause == RMMI_PARSE_ERROR || GSM_com_AcT == 1) // Not support GSM_com
                {
                    ret_val = KAL_FALSE;
                    break;
                }

                // get <UTRA_AcT>
                UTRA_AcT = (kal_uint8)rmmi_int_validator_range_check(
                                        &error_cause, 
                                        source_string_ptr, 
                                        (kal_uint8) RMMI_COMMA, 
                                        1);

                if (error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    UTRA_AcT = 1;
                }
                else if (error_cause == RMMI_PARSE_ERROR)
                {
                    ret_val = KAL_FALSE;
                    break;
                }

                if (GSM_AcT == 1 && UTRA_AcT == 0)
                {
                    rat = L4C_RAT_GSM;
                }
                else if (GSM_AcT == 0 && UTRA_AcT == 1)
                {
                    rat = L4C_RAT_UMTS;
                }
                else if (GSM_AcT == 1 && UTRA_AcT == 1)
                {
                    rat = L4C_RAT_GSM_UMTS;
                }
                else
                {
                    rat = L4C_RAT_NONE;
                }

                /* [MAUI_01881362], mtk02480, PLMN shoud be 5 or 6 digits */
                if (rmmi_ptr->CPOL_plmn_format==RMMI_PLMN_NUMERIC && 
                    (strlen((char*)oper_str)<5 || rmmi_is_number_string(oper_str)==KAL_FALSE))
                {
                    ret_val = KAL_FALSE;
                    break;
                }

                ret_val = rmmi_translate_oper_name(rmmi_ptr->CPOL_plmn_format, oper_str, RMMI_PLMN_NUMERIC, oper);
                if (ret_val == KAL_TRUE)
                {
                    if (index == 0xff)  //index is not given, wirte to free location
                    {
                        ret_val = l4c_smu_set_preferred_oper_list_req_ext(
                                    source_string_ptr->src_id,
                                    selected_file,
                                    index,
                                    SMU_INSERT_EMPTY,
                                    (kal_uint8*) oper,
                                    rat);
                    }
                    else
                    {
                        ret_val = l4c_smu_set_preferred_oper_list_req_ext(
                                    source_string_ptr->src_id,
                                    selected_file,
                                    index,
                                    SMU_REPLACE_PLMNSEL,
                                    (kal_uint8*) oper,
                                    rat);
                    }
                }
                else    /* unknown plmn string */
                {
                    rmmi_ptr->cmee_err = INVALID_CHARACTERS_IN_TEXT_ERRSTRING_ERR;
                    break;
                }
            }
            else
            {
                if (error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    /* when <index> is given and <oper> is left out, <index> is deleted */
                    if (index != 0xff)
                    {
                        ret_val = l4c_smu_set_preferred_oper_list_req_ext(
                                    source_string_ptr->src_id,
                                    selected_file,
                                    index,
                                    SMU_REPLACE_PLMNSEL /* SMU_REMOVE_PLMNSEL */ ,
                                    NULL,
                                    0);
                    }
                    else    /* only format changed, return OK*/
                    {
                        ret_val = KAL_TRUE;
                        rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
                    }
                }
                else
                {
                    ret_val = KAL_FALSE;
                }
            }

            if (ret_val == KAL_TRUE)
            {
                return;
            }

            rmmi_ptr->cmee_err = RMMI_ERR_COMMAND_CONFLICT;            
            break;
        }
        default:
            break;
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}

/*****************************************************************************
 * FUNCTION
 *  rmmi_cpls_hdlr
 * DESCRIPTION
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cpls_hdlr(rmmi_string_struct *source_string_ptr)
{
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;	
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;

    switch (source_string_ptr->cmd_mode)
    {	
        case RMMI_TEST_MODE:
        {
            kal_bool is_plmnwact = KAL_FALSE;
            kal_bool is_oplmnwact = KAL_FALSE;
            kal_bool is_hplmnwact = KAL_FALSE;

            if (l4c_smu_file_idx_for_preferred_oper_list(FILE_PLMNSEL_IDX) != FILE_NONE || 
                l4c_smu_file_idx_for_preferred_oper_list(FILE_PLMNWACT_IDX) != FILE_NONE)
            {
                is_plmnwact = KAL_TRUE;
            }

            if (l4c_smu_file_idx_for_preferred_oper_list(FILE_OPLMNWACT_IDX) != FILE_NONE)
            {
                is_oplmnwact = KAL_TRUE;
            }

            if (l4c_smu_file_idx_for_preferred_oper_list(FILE_HPLMNACT_IDX) != FILE_NONE)
            {
                is_hplmnwact = KAL_TRUE;
            }

            if ((is_plmnwact || is_oplmnwact || is_hplmnwact) != KAL_TRUE)
            {
                break;
            }

            rmmi_ptr->arg_list[0] = (void*)&rmmi_ptr->s_reg.s3;
            rmmi_ptr->arg_list[1] = (void*)&rmmi_ptr->s_reg.s4;

            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "%c%c+CPLS: ", rmmi_ptr->arg_list, 2);
            rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_FALSE);

            if (is_plmnwact && is_oplmnwact && is_hplmnwact)
            {
                string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "(0,1,2)%c%c", rmmi_ptr->arg_list, 2);
            }
            else if (is_plmnwact && is_oplmnwact)
            {
                string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "(0,1)%c%c", rmmi_ptr->arg_list, 2);
            }
            else if (is_plmnwact && is_hplmnwact)
            {
                string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "(0,2)%c%c", rmmi_ptr->arg_list, 2);
            }
            else if (is_oplmnwact && is_hplmnwact)
            {
                string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "(1,2)%c%c", rmmi_ptr->arg_list, 2);
            }
            else if (is_plmnwact)
            {
                string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "(0)%c%c", rmmi_ptr->arg_list, 2);
            }
            else if (is_oplmnwact)
            {
                string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "(1)%c%c", rmmi_ptr->arg_list, 2);
            }
            else if (is_hplmnwact)
            {
                string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "(2)%c%c", rmmi_ptr->arg_list, 2);
            }

            rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_FALSE);
            rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
            return;
        }
        case RMMI_READ_MODE:
        {
            rmmi_ptr->arg_list[0] = (void*)&rmmi_ptr->cpls_selected;
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CPLS: %d", rmmi_ptr->arg_list, 1);

            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;
            kal_uint8 list;

            list = (kal_uint8)rmmi_int_validator_range_check(&error_cause, source_string_ptr, RMMI_COMMA, 2);
            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }

            if (list == 0)  // PLMNwact or PLMNsel
            {
                if (l4c_smu_file_idx_for_preferred_oper_list(FILE_PLMNSEL_IDX) == FILE_NONE &&
                    l4c_smu_file_idx_for_preferred_oper_list(FILE_PLMNWACT_IDX) == FILE_NONE)
                {
                    break;
                }
            }
            else if (list == 1)  // OPLMNwact
            {
                if (l4c_smu_file_idx_for_preferred_oper_list(FILE_OPLMNWACT_IDX) == FILE_NONE)
                {
                    break;
                }
            }
            else if (list == 2)  // HPLMNwact
            {
                if (l4c_smu_file_idx_for_preferred_oper_list(FILE_HPLMNACT_IDX) == FILE_NONE)
                {
                    break;
                }
            }

            rmmi_ptr->cpls_selected = list;
            ret_val = KAL_TRUE;
            break;
        }                
        default:
            break;
    }

    rsp_str = &buffer[0];
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);	
}

/*****************************************************************************
 * FUNCTION
 *  rmmi_pacsp_hdlr
 * DESCRIPTION
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_pacsp_hdlr(rmmi_string_struct *source_string_ptr)
{
#if defined(__MODEM_CARD__) || defined(__SP_RIL_SUPPORT__)
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;	
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;

    // +PACSP0 disable PLMN selection menu
    // +PACSP1 enable PLMN selection menu

    switch (source_string_ptr->cmd_mode)
    {	
        case RMMI_READ_MODE:
        {
            kal_sprintf((char*)buffer, "+PACSP%d", RMMI_PTR->csp_plmn_mode);
            rmmi_write_to_uart((kal_uint8*) buffer, (kal_uint16) strlen((char*)buffer), KAL_TRUE);

            ret_val = KAL_TRUE;
            break;
        }                
        default:
            break;
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);	
#endif
}

/*****************************************************************************
 * FUNCTION
 *  rmmi_crsm_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_crsm_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 result;
    kal_uint16 fileid;
    kal_uint8 command;
    kal_uint16 length = 0;
    kal_uint8 p1, p2, p3;
    kal_uint8 data[256+2], data_str[256*2+1];
    kal_uint8 pathid[6+2], pathid_str[6*2+1];

    kal_trace(TRACE_FUNC, FUNC_RMMI_CRSM_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE:
        {
	     kal_uint8 error_cause;			
	     kal_bool param_required = KAL_FALSE;

		  /* mtk02480: MAUI_01342143 */
             if (L4C_PTR->sim_error_cause == SIM_FATAL_ERROR)
	     {
	         RMMI_PTR->cmee_err = SIM_FAILURE;
	     	  rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_PTR->cmee_err);
	         return;
            }
			
            command = rmmi_int_validator_u8_check(
					 &error_cause,
                                    source_string_ptr,
                                    (kal_uint8) RMMI_COMMA /* separator */ );
            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }
	     else
	     {
	         if (command != GET_RESPONSE && command != STATUS_CMD)
	         {
	             param_required = KAL_TRUE; /* Accroding to 27.007, <p1>,<p2>,<p3> is mandatory if command is not GET RESPONSE and STATUS */
	         }
	     }

            fileid = rmmi_int_validator_u16_check(
					 &error_cause,				
                                    source_string_ptr,
                                    (kal_uint8) RMMI_COMMA /* separator */ );

            p1 = rmmi_int_validator_u8_check(
				    &error_cause,				
                                source_string_ptr,
                                (kal_uint8) RMMI_COMMA /* separator */ );

            if (error_cause != RMMI_PARSE_OK)
	     {
	     	     if (error_cause == RMMI_PARSE_NOT_FOUND && param_required == KAL_FALSE)
		     {
		         p1 = 0;
		     }
		     else
		     {
		         break;	
		     }
	     }
		 
            p2 = rmmi_int_validator_u8_check(
				    &error_cause,								
                                source_string_ptr,
                                (kal_uint8) RMMI_COMMA /* separator */ );

            if (error_cause != RMMI_PARSE_OK)
	     {
	     	     if (error_cause == RMMI_PARSE_NOT_FOUND && param_required == KAL_FALSE)
		     {
		         p2 = 0;
		     }
		     else
		     {
		         break;	
		     }
	     }

            p3 = rmmi_int_validator_u8_check(
				    &error_cause,								
                                source_string_ptr,
                                (kal_uint8) RMMI_COMMA /* separator */ );

            if (error_cause != RMMI_PARSE_OK)
	     {
	     	     if (error_cause == RMMI_PARSE_NOT_FOUND && param_required == KAL_FALSE)
		     {
		         p3 = 0;
		     }
		     else
		     {
		         break;	
		     }
	     }

            result = rmmi_string_validator_ext(
		    	   &error_cause,					
                        source_string_ptr,
                        (kal_uint8) RMMI_COMMA, /* separator */
                        256*2+1,
                        (kal_uint8*) data_str);

            if (result == RMMI_VALIDATOR_ERROR)
            {
	  	     if (error_cause == RMMI_PARSE_NOT_FOUND)
	  	     {
			   if (command == UPDATE_BINARY || command == UPDATE_RECORD)
			   {
	  	 	   	break;		     			   
			   }
	  	     }
		     else
		     {
	  	 	   break;		     
		     }
            }
	     else
	     {
	            ret_val = check_hex_value_ext(data_str, data);
		     if (ret_val == KAL_FALSE)
		     {
	  	 	   break;			     
		     }
	     }

            result = rmmi_string_validator_ext(
		    	   &error_cause,					
                        source_string_ptr,
                        RMMI_PTR->s_reg.s3, /* separator */
                        6*2+1,
                        (kal_uint8*) pathid_str);

            if (result == RMMI_VALIDATOR_ERROR)
            {
	  	     if (error_cause == RMMI_PARSE_NOT_FOUND)
	  	     {
			   kal_mem_set(pathid, 0x00, 4);
	  	     }
		     else
		     {
	  	 	   break;		     
		     }
            }
	     else
	     {
	     	     ret_val = check_hex_value_ext(pathid_str, pathid);	
		     if (ret_val == KAL_FALSE)
		     {
	  	 	   break;			     
		     }
		     length = strlen((char*)pathid_str) >> 1;

                  if (length > 4)
                  {
                        kal_uint8 ef_rat_path[] = {0x7f, 0xff, 0x7f, 0x66, 0x5f, 0x30};
                        if (kal_mem_cmp(pathid, ef_rat_path, sizeof(ef_rat_path)) == 0)
                        {
                            kal_mem_set(pathid, 0x00, 4);
                            length = 0;
                        }
                        else
                        {
                            break;
                        }
                  }
	     }
			
            ret_val = l4c_smu_exe_restricted_access_req(
                        source_string_ptr->src_id,
                        command,
                        fileid,
                        USIM_DEFAULT_CH,
                        p1,
                        p2,
                        p3,
                        (kal_uint8*) data,
                        (kal_uint8*) pathid,
                        length);
            if (ret_val == KAL_FALSE)
            {
                rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_COMMAND_CONFLICT);
            }
            return;
        }

        default:
        {
            /* unrecognized format of AT command line */
            rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNSPECIFIED);
            return;
        }
    }   /* end of the switch */

    rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_SYNTEX_ERROR);
    return;
}

#ifdef __CSIM__
/*****************************************************************************
 * FUNCTION
 *  rmmi_csim_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for SIM read and write operation.
  * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_csim_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 result;
    kal_uint8 cmd_str[256*2], cmd[256];
    kal_uint16 length;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CSIM_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:    
        {
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE: 
        {
	     kal_uint8 error_cause;

            length = rmmi_int_validator_u16_check(
					 &error_cause,
                                    source_string_ptr,
                                    (kal_uint8) RMMI_COMMA);
            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }
	     else
	     {
	         length = length >> 1;
	     }

            result = rmmi_string_validator_ext(
		    	   &error_cause,					
                        source_string_ptr,
                        RMMI_PTR->s_reg.s3, /* separator */
                        256*2,
                        (kal_uint8*) cmd_str);
	     if (result == RMMI_VALIDATOR_ERROR)
	     {
                break;	     
	     }

            ret_val = check_hex_value_ext(cmd_str, cmd);
	     if (ret_val == KAL_FALSE)
	     {
                break;	     
	     }			

		 /* MAUI_03082391 AT+CSIM is for SIM. For UICC , we always access the basic channel 0 */	
	     ret_val = l4c_sim_apdu_access_req(source_string_ptr->src_id,CSIM_EXE, length, cmd,0);
	 
	     if (ret_val == KAL_FALSE)
	     {
	         RMMI_PTR->cmee_err = OPERATION_NOT_ALLOWED_ERR;
                break;	     
	     }
	
	     return;
        }
        default:
        {
            break;	
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) buffer, string_length);
    return;
}
#endif

//mtk02514_nfc
#ifdef __CGLA__ /* MAUI_03082391 : AT+CGLA */
/*****************************************************************************
 * FUNCTION
 *  rmmi_cgla_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for SIM read and write operation.
  * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cgla_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 result;
    kal_uint8 cmd_str[APDU_REQ_MAX_LEN*2+1], cmd[APDU_REQ_MAX_LEN];
    kal_uint16 length, cmd_len;
    kal_uint8 channel_id = 0;	
    kal_uint8 error_cause;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CGLA_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE: 
        {
            channel_id = rmmi_int_validator_range_check(
                                     &error_cause,
                                     source_string_ptr,
                                     (kal_uint8) RMMI_COMMA,
                                     UICC_CHANNEL_MAX_NUM);			
            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }

            length = rmmi_int_validator_range_check(
                                    &error_cause,
                                    source_string_ptr,
                                    (kal_uint8) RMMI_COMMA,
                                    APDU_REQ_MAX_LEN*2);
            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }
            // length should not be  0 or odd value
            else if ((length != ((length>>1)*2)) || (length==0))
            {
                break;
            }
            else
            {
                length = length >> 1;
            }

            result = rmmi_string_validator_ext(
                        &error_cause,					
                        source_string_ptr,
                        RMMI_PTR->s_reg.s3, /* separator */
                        APDU_REQ_MAX_LEN*2+1,
                        (kal_uint8*) cmd_str);
//            kal_prompt_trace(MOD_ATCI, "%d %d %d", result, length, APDU_REQ_MAX_LEN*2);
            if (result == RMMI_VALIDATOR_ERROR)
            {
                break;	     
            }
            else
            {
                
                cmd_len = strlen((char*)cmd_str);
   //             kal_prompt_trace(MOD_ATCI, "%d %d %d", result, length, cmd_len);
                if (cmd_len != (length*2))
                {
                    break;
                }
            }

            ret_val = check_hex_value_ext(cmd_str, cmd);
            if (ret_val == KAL_FALSE)
            {
                break;	     
            }

            ret_val = l4c_sim_apdu_access_req(source_string_ptr->src_id,CGLA_EXE, length, cmd,channel_id);
            if (ret_val == KAL_FALSE)
            {
                RMMI_PTR->cmee_err = OPERATION_NOT_ALLOWED_ERR;
                break;	     
            }
            return;
        }
        default:
        {
            break;	
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}
#endif

#ifdef __UICC_CHANNEL_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  rmmi_crla_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for SIM read and write operation.
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string      
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_crla_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 result;
    kal_uint16 fileid;
    kal_uint8 command;
    kal_uint16 length = 0;
    kal_uint8 p1, p2, p3;
    kal_uint8 data[256+2], data_str[256*2+1];
    kal_uint8 pathid[6+2], pathid_str[6*2+1];
    kal_uint8 channel_id = 0;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CRLA_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;
            kal_bool param_required = KAL_FALSE;

            /* mtk02480: MAUI_01342143 */
            if (L4C_PTR->sim_error_cause == SIM_FATAL_ERROR)
            {
                RMMI_PTR->cmee_err = SIM_FAILURE;
                rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_PTR->cmee_err);
                return;
            }

            // 1. Get session id
            channel_id = rmmi_int_validator_range_check(&error_cause,
                                                        source_string_ptr,
                                                        (kal_uint8) RMMI_COMMA,
                                                        UICC_CHANNEL_MAX_NUM);

            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }

            
            // 2. Get commandS
            command = rmmi_int_validator_u8_check(&error_cause,
                                                  source_string_ptr,
                                                  (kal_uint8) RMMI_COMMA /* separator */ );

            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }
            else
            {
                if (command != GET_RESPONSE && command != STATUS_CMD)
                {
                    param_required = KAL_TRUE; /* Accroding to 27.007, <p1>,<p2>,<p3> is mandatory if command is not GET RESPONSE and STATUS */
                }
            }

            // 3. Get field id
            fileid = rmmi_int_validator_u16_check(&error_cause,
                                                  source_string_ptr,
                                                  (kal_uint8) RMMI_COMMA /* separator */ );

            // 4. Get P1, P2, P3
            p1 = rmmi_int_validator_u8_check(&error_cause,
                                             source_string_ptr,
                                             (kal_uint8) RMMI_COMMA /* separator */ );

            if (error_cause != RMMI_PARSE_OK)
            {
                if (error_cause == RMMI_PARSE_NOT_FOUND && param_required == KAL_FALSE)
                {
                    p1 = 0;
                }
                else
                {
                    break;
                }
            }
         
            p2 = rmmi_int_validator_u8_check(&error_cause,
                                             source_string_ptr,
                                             (kal_uint8) RMMI_COMMA /* separator */ );

            if (error_cause != RMMI_PARSE_OK)
            {
                if (error_cause == RMMI_PARSE_NOT_FOUND && param_required == KAL_FALSE)
                {
                    p2 = 0;
                }
                else
                {
                    break;
                }
            }

            p3 = rmmi_int_validator_u8_check(&error_cause,
                                             source_string_ptr,
                                             (kal_uint8) RMMI_COMMA /* separator */ );

            if (error_cause != RMMI_PARSE_OK)
            {
                if (error_cause == RMMI_PARSE_NOT_FOUND && param_required == KAL_FALSE)
                {
                    p3 = 0;
                }
                else
                {
                    break;
                }
            }

            // 5. Get data
            result = rmmi_string_validator_ext(&error_cause,
                                               source_string_ptr,
                                               (kal_uint8) RMMI_COMMA, /* separator */
                                               256*2+1,
                                               (kal_uint8*) data_str);

            if (result == RMMI_VALIDATOR_ERROR)
            {
                if (error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    if (command == UPDATE_BINARY || command == UPDATE_RECORD)
                    {
                        break;
                    }
                }
                else
                {
                    break;
                }
            }
            else
            {
                ret_val = check_hex_value_ext(data_str, data);
                if (ret_val == KAL_FALSE)
                {
                    break;
                }
            }

            // 6. Get pathid
            result = rmmi_string_validator_ext(&error_cause,
                                               source_string_ptr,
                                               RMMI_PTR->s_reg.s3, /* separator */
                                               6*2+1,
                                               (kal_uint8*) pathid_str);

            if (result == RMMI_VALIDATOR_ERROR)
            {
                if (error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    kal_mem_set(pathid, 0x00, 4);
                }
                else
                {
                    break;
                }
            }
            else
            {
                ret_val = check_hex_value_ext(pathid_str, pathid);
                if (ret_val == KAL_FALSE)
                {
                    break;
                }
                length = strlen((char*)pathid_str) >> 1;

                if (length > 4)
                {
                    kal_uint8 ef_rat_path[] = {0x7f, 0xff, 0x7f, 0x66, 0x5f, 0x30};
                    if (kal_mem_cmp(pathid, ef_rat_path, sizeof(ef_rat_path)) == 0)
                    {
                        kal_mem_set(pathid, 0x00, 4);
                        length = 0;
                    }
                    else
                    {
                        break;
                    }
                }
            }
            RMMI_PTR->is_crla |= (kal_uint16) (1 << (source_string_ptr->src_id));

            ret_val = l4c_smu_exe_restricted_access_req(
                                         source_string_ptr->src_id,
                                         command,
                                         fileid,
                                         channel_id,
                                         p1,
                                         p2,
                                         p3,
                                         (kal_uint8*) data,
                                         (kal_uint8*) pathid,
                                         length);
            if (ret_val == KAL_FALSE)
            {
                rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_COMMAND_CONFLICT);
            }
            return;
        }

        default:
        {
            /* unrecognized format of AT command line */
            rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNSPECIFIED);
            return;
        }
    }   /* end of the switch */

    rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_SYNTEX_ERROR);
    return;    
}

/*****************************************************************************
 * FUNCTION
 *  rmmi_ccho_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for UICC channel open
  * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_ccho_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 result;
    kal_uint8 aid_str[SIM_AID_MAX_LEN*2+1], aid[SIM_AID_MAX_LEN];
    kal_uint16 aid_len;
    kal_uint8 error_cause;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CCHO_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE: 
        {
            result = rmmi_string_validator_ext(
                        &error_cause,					
                        source_string_ptr,
                        RMMI_PTR->s_reg.s3, /* separator */
                        SIM_AID_MAX_LEN*2+1,
                        (kal_uint8*) aid_str);
            if (result == RMMI_VALIDATOR_ERROR)
            {
                break;	     
            }
            else
            {
                aid_len = strlen((char*)aid_str);
                // aid_len should not be  0 or odd value
                if (aid_len != ((aid_len>>1)*2))
                {
                    break;
                }
                aid_len >>= 1;
            }

            ret_val = check_hex_value_ext(aid_str, aid);
            if (ret_val == KAL_FALSE)
            {
                break;	     
            }

            ret_val = l4c_sim_manage_channel_req(
                    source_string_ptr->src_id, 
                    CCHO_EXE, SIM_CHANNEL_OPEN, aid_len, aid);
            if (ret_val == KAL_FALSE)
            {
                RMMI_PTR->cmee_err = OPERATION_NOT_ALLOWED_ERR;
                break;	     
            }
            return;
        }
        default:
        {
            break;	
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}

/*****************************************************************************
 * FUNCTION
 *  rmmi_cchc_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for UICC channel close
  * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cchc_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 error_cause;
    kal_uint8 channel_id = 0;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CCHC_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE: 
        {
            channel_id = rmmi_int_validator_range_check(
                                     &error_cause,
                                     source_string_ptr,
                                     (kal_uint8) RMMI_PTR->s_reg.s3,
                                     UICC_CHANNEL_MAX_NUM);			
            if ((error_cause != RMMI_PARSE_OK) || (channel_id == 0))
            {
                break;
            }

            /* When close channel, we should set req_len as 1
            * and set req[0] = channel_id
            */
            ret_val = l4c_sim_manage_channel_req(
                    source_string_ptr->src_id, 
                    CCHC_EXE, SIM_CHANNEL_CLOSE, 1, &channel_id);
            if (ret_val == KAL_FALSE)
            {
                RMMI_PTR->cmee_err = OPERATION_NOT_ALLOWED_ERR;
                break;	     
            }
            return;
        }
        default:
        {
            break;	
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}
#endif

#if defined(__SIM_RECOVERY_ENHANCEMENT__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_esimrec_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for sim recovery
 *
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_esimrec_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 mode, error_cause;

            mode = (kal_uint8) rmmi_int_validator_range_check(&error_cause, source_string_ptr, RMMI_PTR->s_reg.s3, 1);

            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }
            else
            {
                ret_val = l4c_sim_recovery_enhancement_switch_req(mode);
            }
            break;            
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}
#endif /* __SIM_RECOVERY_ENHANCEMENT__ */


#if defined(__SIM_UT__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_csrm_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_csrm_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 command;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CSRM_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            command = (kal_uint8) rmmi_int_validator(
                                    source_string_ptr,
                                    RMMI_PTR->s_reg.s3 /* separator */ );

            ret_val = l4c_sim_remove_req(source_string_ptr->src_id, command);
            if (ret_val == KAL_FALSE)
            {
                break;
            }
            rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
            return;
        }

        default:
        {
            /* unrecognized format of AT command line */
            rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNSPECIFIED);
            return;
        }
    }   /* end of the switch */

    rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNSPECIFIED);
    return;
}
#endif


#if !defined(__MMI_FMI__)
kal_bool rmmi_sml_add_data(rmmi_string_struct *source_string_ptr, kal_uint8 category,
						kal_uint8 *data_len, kal_uint8 *data)
{
	char imsi_str[15+1], temp_imsi_str[15+1+1], gid1_str[4], gid2_str[4];
	kal_uint8 result;
	
	switch (category)
	{
		case RMMI_SML_NP_CATEGORY:
			result = (kal_uint8)rmmi_string_validator(
                        source_string_ptr,
                        RMMI_PTR->s_reg.s3,  /* separator */
                        (15+1), (kal_uint8 *)imsi_str
                       );
			if (result == RMMI_VALIDATOR_ERROR)
			    return KAL_FALSE;
			if (strlen(imsi_str) != 5 && strlen(imsi_str) != 6)
			{
			    ASSERT(0);
			}
			//kal_prompt_trace(l4c_current_mod_id, "imsi_str=%s", imsi_str);
			
			data[0] = ((imsi_str[0] - RMMI_CHAR_0) << 4) + (imsi_str[1] - RMMI_CHAR_0);

			//kal_prompt_trace(l4c_current_mod_id, "data[0]=%x", data[0]);
			
			data[1] = ((imsi_str[2] - RMMI_CHAR_0) << 4) + (imsi_str[3] - RMMI_CHAR_0);
			if (strlen(imsi_str) == 5)
			    data[2] = ((imsi_str[4] - RMMI_CHAR_0) << 4) + 0x0F;
			else
			    data[2] = ((imsi_str[4] - RMMI_CHAR_0) << 4) + (imsi_str[5] - RMMI_CHAR_0);
			//kal_prompt_trace(l4c_current_mod_id, "data[2]=%x", data[2]);
			*data_len = 3;
			break;
		case RMMI_SML_NSP_CATEGORY:
			result = (kal_uint8)rmmi_string_validator(
                        source_string_ptr,
                        RMMI_PTR->s_reg.s3,  /* separator */
                        (15+1), (kal_uint8 *)imsi_str
                       );
			if (result == RMMI_VALIDATOR_ERROR)
			    return KAL_FALSE;
			if (strlen(imsi_str) != 7 && strlen(imsi_str) != 8)
			{
			    ASSERT(0);
			}
			data[0] = ((imsi_str[0] - RMMI_CHAR_0) << 4) + (imsi_str[1] - RMMI_CHAR_0);
			data[1] = ((imsi_str[2] - RMMI_CHAR_0) << 4) + (imsi_str[3] - RMMI_CHAR_0);
			if (strlen(imsi_str) == 7)
			{
			    data[2] = ((imsi_str[4] - RMMI_CHAR_0) << 4) + 0x0F;
			    data[3] = ((imsi_str[5] - RMMI_CHAR_0) << 4) + (imsi_str[6] - RMMI_CHAR_0);
			}
			else
			{
			    data[2] = ((imsi_str[4] - RMMI_CHAR_0) << 4) + (imsi_str[5] - RMMI_CHAR_0);
			    data[3] = ((imsi_str[6] - RMMI_CHAR_0) << 4) + (imsi_str[7] - RMMI_CHAR_0);
			}
			*data_len = 4;
			break;
		case RMMI_SML_SP_CATEGORY:
			result = (kal_uint8)rmmi_string_validator(
                        source_string_ptr,
                        (kal_uint8)RMMI_COMMA,
                        (15+1), (kal_uint8 *)imsi_str
                       );
			if (result == RMMI_VALIDATOR_ERROR)
			    return KAL_FALSE;
			if (strlen(imsi_str) != 5 && strlen(imsi_str) != 6)
			{
			    ASSERT(0);
			}
			data[0] = ((imsi_str[0] - RMMI_CHAR_0) << 4) + (imsi_str[1] - RMMI_CHAR_0);
			data[1] = ((imsi_str[2] - RMMI_CHAR_0) << 4) + (imsi_str[3] - RMMI_CHAR_0);
			if (strlen(imsi_str) == 5)
			    data[2] = ((imsi_str[4] - RMMI_CHAR_0) << 4) + 0x0F;
			else
			    data[2] = ((imsi_str[4] - RMMI_CHAR_0) << 4) + (imsi_str[5] - RMMI_CHAR_0);
			result = (kal_uint8)rmmi_string_validator(
                        source_string_ptr,
                        RMMI_PTR->s_reg.s3,  /* separator */
                        (3+1), (kal_uint8 *)gid1_str
                       );
			if (result == RMMI_VALIDATOR_ERROR)
			    return KAL_FALSE;
			data[3] = (kal_uint8) atoi(gid1_str);
			*data_len = 4;
			break;
		case RMMI_SML_CP_CATEGORY:
			result = (kal_uint8)rmmi_string_validator(
                        source_string_ptr,
                        (kal_uint8)RMMI_COMMA,
                        (15+1), (kal_uint8 *)imsi_str
                       );
			if (result == RMMI_VALIDATOR_ERROR)
			    return KAL_FALSE;
			if (strlen(imsi_str) != 5 && strlen(imsi_str) != 6)
			{
			    ASSERT(0);
			}
			data[0] = ((imsi_str[0] - RMMI_CHAR_0) << 4) + (imsi_str[1] - RMMI_CHAR_0);
			data[1] = ((imsi_str[2] - RMMI_CHAR_0) << 4) + (imsi_str[3] - RMMI_CHAR_0);
			if (strlen(imsi_str) == 5)
			    data[2] = ((imsi_str[4] - RMMI_CHAR_0) << 4) + 0x0F;
			else
			    data[2] = ((imsi_str[4] - RMMI_CHAR_0) << 4) + (imsi_str[5] - RMMI_CHAR_0);
			result = (kal_uint8)rmmi_string_validator(
                        source_string_ptr,
                        (kal_uint8)RMMI_COMMA,
                        (3+1), (kal_uint8 *)gid1_str
                       );
			if (result == RMMI_VALIDATOR_ERROR)
			    return KAL_FALSE;
			data[3] = (kal_uint8) atoi(gid1_str);
			result = (kal_uint8)rmmi_string_validator(
                        source_string_ptr,
                        RMMI_PTR->s_reg.s3,  /* separator */
                        (3+1), (kal_uint8 *)gid2_str
                       );
			if (result == RMMI_VALIDATOR_ERROR)
			    return KAL_FALSE;
			data[4] = (kal_uint8) atoi(gid2_str);
			*data_len = 5;
			break;
		case RMMI_SML_SIM_CATEGORY:
			result = (kal_uint8)rmmi_string_validator(
                        source_string_ptr,
                        RMMI_PTR->s_reg.s3,  /* separator */
                        (15+1), (kal_uint8 *)imsi_str
                       );
			if (result == RMMI_VALIDATOR_ERROR)
			    return KAL_FALSE;
			temp_imsi_str[0] = RMMI_CHAR_9;
			strcpy(&temp_imsi_str[1], imsi_str);
			*data_len = (strlen(temp_imsi_str) + 1) / 2;
			convert_to_bcd((kal_uint8 *) temp_imsi_str, data, 8);
			break;
			
		}
		return (KAL_TRUE);
}

/*****************************************************************************
* FUNCTION
*  rmmi_esmlck_hdlr
*  for +EMSLCK
*
* DESCRIPTION
*   this command is to read remain try times of PIN
*
* PARAMETERS
*  source_string_ptr		IN		at cmd string
*
* RETURNS
*  none.
*
* GLOBALS AFFECTED
*  none.
*****************************************************************************/
void rmmi_esmlck_hdlr (rmmi_string_struct *source_string_ptr)
{
    kal_uint8 category, op, data_len = 0;
    kal_uint8 key_str[SML_MAX_SUPPORT_KEY_LEN*2+1], data[10], result;
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 error_cause;
	
    switch (source_string_ptr->cmd_mode )
    {
        case RMMI_READ_MODE :
        case RMMI_ACTIVE_MODE :
        {
            ret_val = l4c_smu_sml_status_req(source_string_ptr->src_id);
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            category = (kal_uint8)rmmi_int_validator(source_string_ptr, (kal_uint8)RMMI_COMMA);
            op = (kal_uint8)rmmi_int_validator(source_string_ptr, (kal_uint8)RMMI_COMMA);
            kal_mem_set(key_str, 0, sizeof(key_str));
            
            if (op == 0 || op == 1 || op == 2)
            {
                result = (kal_uint8)rmmi_string_validator_ext(&error_cause,
                                                              source_string_ptr,
                                                              (kal_uint8)RMMI_COMMA,
                                                              SML_MAX_SUPPORT_KEY_LEN*2+1,
                                                              (kal_uint8 *)key_str);

                if (result == RMMI_VALIDATOR_ERROR)
                {
                    if (error_cause != RMMI_PARSE_OK && error_cause != RMMI_PARSE_NOT_FOUND)
                    {
                        ret_val = KAL_FALSE;
                        break;
                    }
                }

                if (op == 2)
                {
                    ret_val = rmmi_sml_add_data(source_string_ptr, category, &data_len, data);
                    if (ret_val == KAL_FALSE)
                    {
                        break;
                    }
                }
            }

            ret_val = l4c_smu_set_personalization_req(source_string_ptr->src_id, 
                                                      category, 
                                                      op, 
                                                      key_str, 
                                                      data_len, 
                                                      data);
            break;
        }
    }
    
    if (ret_val == KAL_FALSE)
    {
        rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNSPECIFIED);
    }
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_espn_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_espn_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:    
        {
            if (RMMI_PTR->is_spn_valid)
            {
                kal_uint8 spn_str[33];

                kal_mem_set(spn_str, 0, 33);
                check_sms_pdu_string(16, &(RMMI_PTR->spn[1]), spn_str);
                
                RMMI_PTR->arg_list[0] = (void*)spn_str;
                string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+ESPN: %s", RMMI_PTR->arg_list, 1);

                ret_val = KAL_TRUE;
            }
            break;
        }
        default:
        {
            break;	
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) buffer, string_length);
    return;
}

/*****************************************************************************
 * FUNCTION
 *  rmmi_iccid_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_iccid_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_ACTIVE_MODE:
        case RMMI_READ_MODE:
        {
            kal_uint8 iccid[11];
            kal_uint8 iccid_str[21];
            kal_uint8 i,j=0;
            kal_uint8 ch1, ch2;

            if (L4C_PTR->sim_detected == KAL_FALSE)
            {
                RMMI_PTR->cmee_err = SIM_NOT_INSERTED;
                break;
            }

            (*pSmuSecurityInfog->query_a)(SMU_ICCID_A, iccid, NUM_OF_BYTE_ICCID, (l4c_current_mod_id - MOD_L4C));

            iccid[10] = 0xFF;

            //convert_to_digit(iccid, iccid_str);

            for (i=0; i<10; i++)
            {
                ch1 = iccid[i] & 0x0f;
                ch2 = (iccid[i] & 0xf0) >> 4;

                iccid_str[j] = get_ch_byte_raw(ch1, CONVERT_TO_DIGIT_NORMAL);
                iccid_str[j+1] = get_ch_byte_raw(ch2, CONVERT_TO_DIGIT_NORMAL);

                j += 2;
            }
            iccid_str[20] = '\0';

            RMMI_PTR->arg_list[0] = (void*)iccid_str; 
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+ICCID: %s", RMMI_PTR->arg_list, 1);

            ret_val = KAL_TRUE;
            break;
        }
        default:
        {
            break;	
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) buffer, string_length);
    return;
}


#if defined(__SINGLE_AP_DUAL_MODEM__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_esadm_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_esadm_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:
        {
            RMMI_PTR->arg_list[0] = (void*)&(L4C_ROOT_PTR->sim_support_mode);
            
            string_length = rmmi_fast_string_print(
                                buffer,
                                (kal_uint8*) "+ESADM: %d",
                                RMMI_PTR->arg_list,
                                1);
            ret_val = KAL_TRUE;

            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 mode;
            
            mode = rmmi_int_validator_u8_check(
                            NULL,
	                        source_string_ptr,
		                    RMMI_PTR->s_reg.s3  /* separator */
		                    );
            if (mode != RMMI_VALIDATOR_ERROR)
            {
    	        ret_val = l4c_root_sim_support_mode_req(source_string_ptr->src_id, mode);
            }
            
            break;
        }
        default:
        {
            break;	
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*)buffer, string_length);
    return;
}
#endif /* defined(__SINGLE_AP_DUAL_MODEM__) */


#ifdef __BT_SIM_PROFILE__
/*****************************************************************************
 * FUNCTION
 *  rmmi_ebtsap_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for BT SIM Access profile
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_ebtsap_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:
        {
            break;
        }    
        case RMMI_SET_OR_EXECUTE_MODE:
        {
	     kal_uint8 error_cause;
	     kal_uint8 action;
	     kal_uint8 tp = 0;
	     kal_uint8 apdu_str[APDU_REQ_MAX_LEN*2];
	     kal_uint8 apdu[APDU_REQ_MAX_LEN];
	
	     /* AT+EBTSAP=<command>,[<tp>,[apdu]]  */
		 
            action = (kal_uint8)rmmi_int_validator_range_check(
                                &error_cause,
                                source_string_ptr,
                                (kal_uint8) RMMI_COMMA /* separator */,
                                5);
	     if (error_cause != RMMI_PARSE_OK)
	     {
	     		break;
	     }
	     else
	     {
			/********************
			  * <action>
			  *    0: connect
			  *	 1: Disconnect
			  *    2: SIM Power On
			  *    3: SIM Power Off
			  *    4. SIM Reset
			  *    5. APDU
			  ********************/
	
			if (action==2 || action==4 || action ==5)
			{
			    tp = (kal_uint8)rmmi_int_validator_range_check(
		                                &error_cause,
		                                source_string_ptr,
		                                (kal_uint8) RMMI_COMMA /* separator */,
		                                1);
                if (error_cause != RMMI_PARSE_OK)
                {
                    break;
                }

                if (action == 5)
                {
                    rmmi_string_validator_ext(
                            &error_cause,
                            source_string_ptr,
                            (kal_uint8) RMMI_PTR->s_reg.s3,
                            APDU_REQ_MAX_LEN*2,
                            (kal_uint8*) apdu_str);
                    if (error_cause != RMMI_PARSE_OK)
                    {
                        break;
                    }

                    check_hex_value_ext(apdu_str, apdu);					 	
                }
			}
			
			ret_val = l4c_bt_sim_profile_req(source_string_ptr->src_id, action, tp, (kal_uint8*)apdu, strlen((char*)apdu_str) >>1);
			if (ret_val == KAL_TRUE)
			{
				return;
			}
			else
			{
				RMMI_PTR->cmee_err = OPERATION_NOT_ALLOWED_ERR;
			}
	     }
        }
	 default:
	     break;
    }
	
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}
#endif


/*****************************************************************************
 * FUNCTION
 *  rmmi_esiminfo_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_esiminfo_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    sim_query_info_enum info_id;
    kal_uint8 error_cause;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE:
        {


            info_id = (kal_uint8) rmmi_int_validator_range_check(
                    &error_cause, source_string_ptr, RMMI_PTR->s_reg.s3, SIM_INFO_MAX-1);

            if (error_cause == RMMI_PARSE_OK)
            {
                l4c_sim_query_info_req(source_string_ptr->src_id, info_id);

                return;
            }       
            break;            
        }
        default:
        {
            break;	
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;

}

/*****************************************************************************
 * FUNCTION
 *  rmmi_esimtc_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_esimtc_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 additional_interface;
    kal_uint8 error_cause;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE:
        {


            additional_interface = (kal_uint8) rmmi_int_validator_range_check(
                    &error_cause, source_string_ptr, RMMI_PTR->s_reg.s3, 1);

            if (error_cause == RMMI_PARSE_OK)
            {
                l4c_sim_terminal_capability_setting_req(additional_interface);

                ret_val = KAL_TRUE;
            }       
            break;            
        }
        default:
        {
            break;	
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;

}


#endif

#if defined(__SIM_UNIT_TEST__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_esimtest_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for SIM related test
 *
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_esimtest_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_TRUE;
    kal_uint8 value;
    kal_uint8 error_cause;
    tst_module_string_inject_struct *param_ptr;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            value = rmmi_int_validator_u8_check(&error_cause,
                    source_string_ptr,
                    (kal_uint8) RMMI_PTR->s_reg.s3 /* separator */ );

            /* 17: plugout SIM card (open __DUAL_SIM_HOT_SWAP_CO_DECK_SUPPORT__: deck)
               18: plugin SIM card (open __DUAL_SIM_HOT_SWAP_CO_DECK_SUPPORT__: deck), Single SIM inserted
               19: plugin SIM deck, All SIMs inserted (open __DUAL_SIM_HOT_SWAP_CO_DECK_SUPPORT__)
               20: plugin SIM deck, no SIM inserted (open __DUAL_SIM_HOT_SWAP_CO_DECK_SUPPORT__)
               64: disable sim recovery
               65: sim lost, trigger sim recovery
               66: sim not lost*/

            param_ptr = (tst_module_string_inject_struct*)construct_local_para
                            (sizeof(tst_module_string_inject_struct), TD_RESET);

            param_ptr->index = value;

            if ((value == 17) ||
                (value == 18) ||
                (value == 19) ||
                (value == 20) ||
                (value == 64) ||
                (value == 65) ||
                (value == 66) )
            {
                l4c_send_msg_to_sim(MSG_ID_TST_INJECT_STRING,
                        param_ptr, 
                        NULL);
            }
            else
            {
                free_local_para((local_para_struct*) param_ptr);

                ret_val = KAL_FALSE;
            }
            
            break;

        }
        default:
            break;
    }
    
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);

    return;
}
#endif

#if !defined(__MMI_FMI__) || defined(__EAUTH_SUPPORT__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_eauth_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for SIM authentication
  * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_eauth_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 result;
    kal_uint8 rand_str[16*2+1], rand[16+2], rand_len;
    kal_uint8 auth_str[16*2+1], auth[16+2], auth_len;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:    
        {
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE: 
        {
            kal_uint8 error_cause;

            if (L4C_PTR->sim_detected == KAL_FALSE)
            {
                RMMI_PTR->cmee_err = SIM_NOT_INSERTED;
                break;
            }

            rand[0] = '\0';
            result = rmmi_string_validator_ext(
		    	   &error_cause,					
                        source_string_ptr,
                        (kal_uint8) RMMI_COMMA, /* separator */
                        16*2+1,
                        (kal_uint8*) rand_str);
            if (result == RMMI_VALIDATOR_ERROR)
            {
                break;
            }
            else
            {
                if (strlen((char *)rand_str) != 32)
                {
                    break;
                }

                ret_val = check_hex_value_ext(rand_str, rand);
                if (ret_val == KAL_FALSE)
                {
                    break;
                }
                else
                {
                    rand_len = 16;
                }
            }

            auth[0] = '\0';
            result = rmmi_string_validator_ext(
                        &error_cause,                   
                        source_string_ptr,
                        RMMI_PTR->s_reg.s3, /* separator */
                        16*2+1,
                        (kal_uint8*) auth_str);
            if (result == RMMI_VALIDATOR_ERROR)
            {
                if (error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    auth_len = 0;
                }
                else
                {
                    break;
                }
            }
            else
            {
                if (strlen((char *)auth_str) != 32)
                {
                    ret_val = KAL_FALSE;
                    break;
                }

                ret_val = check_hex_value_ext(auth_str, auth);
                if (ret_val == KAL_FALSE)
                {
                    break;
                }
                else
                {
                    auth_len = 16;
                }                
            }
	        ret_val = l4c_sim_authenticate_req(source_string_ptr->src_id, rand_len, rand, auth_len, auth);
    	     if (ret_val == KAL_FALSE)
    	     {
    	         RMMI_PTR->cmee_err = OPERATION_NOT_ALLOWED_ERR;
                    break;	     
    	     }
	
	        return;
        }
        default:
        {
            break;	
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) buffer, string_length);
    return;
}
#endif /* !deined(__MMI_FMI__) || defined(__EAUTH_SUPPORT__) */


#ifdef __SAT__
#ifdef __RSAT__
/*****************************************************************************
 * FUNCTION
 *  rmmi_stktr_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for STK Terminal Respose operation.
 *  mtk00468 add on 05/07
 *  mtk00924 050308 add for Remote SAT
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_stktr_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint16 length;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_TEST_MODE:
        {
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;
            kal_uint8 temp_terminal_rsp[513];
            kal_uint8 terminal_rsp[261];

            rmmi_string_validator_ext(
                        &error_cause,
                        source_string_ptr,
                        (kal_uint8) RMMI_PTR->s_reg.s3,
                        513,
                        (kal_uint8*) temp_terminal_rsp);
            if ((error_cause == RMMI_PARSE_ERROR) || (error_cause == RMMI_PARSE_TEXT_TOO_LONG))
            {
                break;
            }
            else if (error_cause == RMMI_PARSE_OK)
            {
                length = strlen((char*)temp_terminal_rsp);
                length = ((length + 1) >> 1);
                check_hex_value(temp_terminal_rsp, terminal_rsp);
                l4c_sat_terminal_response_req(length, terminal_rsp);     //length should be correct, terminal_rsp should leave the first 5 bytes empty
                ret_val = KAL_TRUE;
            }
            break;
        }
        default:
            break;
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_stkenv_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for STK Envelope operation.
 *  mtk00468 add on 05/07
 *  mtk00924 050308 add for Remote SAT
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_stkenv_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint16 length;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_TEST_MODE:
        {
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;
            kal_uint8 temp_env_req[513];
            kal_uint8 env_req[261];

            rmmi_string_validator_ext(
                        &error_cause,
                        source_string_ptr,
                        (kal_uint8) RMMI_PTR->s_reg.s3,
                        513,
                        (kal_uint8*) temp_env_req);
            if ((error_cause == RMMI_PARSE_ERROR) || (error_cause == RMMI_PARSE_TEXT_TOO_LONG))
            {
                break;
            }
            else if (error_cause == RMMI_PARSE_OK)
            {
                length = strlen((char*)temp_env_req);
                length = ((length + 1) >> 1);
                check_hex_value(temp_env_req, env_req);
                l4c_sat_envelope_req(source_string_ptr->src_id, length, env_req);  //length should be correct, terminal_rsp should leave the first 5 bytes empty
                ret_val = KAL_TRUE;
            }
            break;
        }
        default:
            break;
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_stkcall_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for setup CALL.
 *  mtk00924 050308 add for Remote SAT
 *****************************************************************************/
void rmmi_stkcall_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_TEST_MODE:
        {
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_ACTIVE_MODE:
        {
            ret_val = l4c_sat_setup_call();
            break;
        }

        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;
            kal_uint8 terminal_response;
            kal_uint8 additional_info;

            terminal_response = (kal_uint8) rmmi_int_validator_ext(
                                                &error_cause,
                                                source_string_ptr,
                                                (kal_uint8) RMMI_COMMA /* separator */ );

            additional_info = (kal_uint8) rmmi_int_validator_ext(
                                            &error_cause,
                                            source_string_ptr,
                                            (kal_uint8) RMMI_PTR->s_reg.s3 /* separator */ );

            if ((terminal_response == SAT_CMD_PERFORMED_SUCCESSFULLY) ||    /* user wants to setup the SAT call */
				(terminal_response == SAT_CMD_PERFORMED_BUT_ICON_COULD_NOT_DSPL))  /* ICON can not display */
            {
                ret_val = l4c_sat_setup_call();
				
                if(ret_val == KAL_TRUE)                    
                {
                    if(terminal_response == SAT_CMD_PERFORMED_BUT_ICON_COULD_NOT_DSPL)
                    {
                        RMMI_PTR->sat_icon_displayed = KAL_FALSE; 
                    }  
                }   

                break;
            }
            else if((terminal_response == SAT_USER_DID_NOT_ACCEPT_THE_PROACTIVE_CMD)||
                    (terminal_response == SAT_PROACTIVE_CMD_TERMINATED_BY_USER)||
                    (terminal_response == SAT_ME_CURRENTLY_UNABLE_TO_PROCESS_CMD)||
                    (terminal_response == SAT_NET_CURRENTLY_UNABLE_TO_PROCESS_CMD)||
                    (terminal_response == SAT_CMD_DATA_NOT_UNDERSTAND_BY_ME)||                    
                    (terminal_response == SAT_NO_RESPONSE_FROM_USER))
            {
                sat_setup_call_res_struct *param_ptr = (sat_setup_call_res_struct*)
                    construct_local_para(
                        (kal_uint16) sizeof(sat_setup_call_res_struct),
                        TD_RESET);

                kal_mem_set(param_ptr->cmd_detail, 0, 5);   /* do not have to fill it, SIM module will fill this field */
                if(terminal_response == SAT_NO_RESPONSE_FROM_USER)
                {
                     /* "no reponse from user" is not a possible res value for STKCALL  
                        listed in 11.14. So we translate it with other proper res value */
                    param_ptr->res = SAT_ME_CURRENTLY_UNABLE_TO_PROCESS_CMD;			
                }
                else
                {    		
                    param_ptr->res = terminal_response;
               	}

                if (additional_info == RMMI_VALIDATOR_ERROR)
                {
                    param_ptr->cause = L4C_NO_CAUSE;    /* additional info */
                }
                else
                {
                    param_ptr->cause = additional_info; /* additional info */
                }

                ret_val = l4c_sat_setup_call_res(param_ptr);
                break;
            }
            else
            {
                /* other res shall not be responded by AP */
                break;
            }			

        }

        default:
            break;
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_stksms_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for sending SMS.
 *  mtk00924 050308 add for Remote SAT
 *****************************************************************************/
void rmmi_stksms_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_TEST_MODE:
        {
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_ACTIVE_MODE:  /* can display icon */
        {
            ret_val = l4c_sat_setup_sms(source_string_ptr->src_id);
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;
            kal_uint8 terminal_response;

            terminal_response = (kal_uint8) rmmi_int_validator_ext(
                                                &error_cause,
                                                source_string_ptr,
                                                (kal_uint8) RMMI_PTR->s_reg.s3 /* separator */ );

            if (terminal_response == SAT_CMD_PERFORMED_BUT_ICON_COULD_NOT_DSPL
                || terminal_response == SAT_CMD_PERFORMED_SUCCESSFULLY ) 
            {
                ret_val = l4c_sat_setup_sms(source_string_ptr->src_id);
 
                if(ret_val == KAL_TRUE)                    
                {
                    if(terminal_response == SAT_CMD_PERFORMED_BUT_ICON_COULD_NOT_DSPL)
                    {
                        RMMI_PTR->sat_icon_displayed = KAL_FALSE; /* can NOT display icon */
                    }
                }    
		else 
		{
		  	sat_send_sms_res_struct *param_ptr = (sat_send_sms_res_struct*)
                		construct_local_para(
                    		(kal_uint16) sizeof(sat_send_sms_res_struct),
                    		TD_RESET);

            		kal_mem_set(param_ptr->cmd_detail, 0, 5);   /* do not have to fill it, SIM module will fill this field */
			param_ptr->res = SAT_ME_CURRENTLY_UNABLE_TO_PROCESS_CMD;
			param_ptr->cause = 0;
			l4c_sat_send_sms_res(param_ptr);
		}
                
                break;
            }
            else
            {   
                /* other res shall not be responded by AP */
                break;
            }
        }
        default:
            break;
    }
    
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}

/*****************************************************************************
 * FUNCTION
 *  rmmi_stkss_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for sending SS.
 *  mtk00924 050308 add for Remote SAT
 *****************************************************************************/
void rmmi_stkss_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_TEST_MODE:
        {
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_ACTIVE_MODE:  /* can display icon */
        {
            ret_val = l4c_sat_setup_ss();
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;
            kal_uint8 terminal_response;
            kal_uint8 additional_info;

            terminal_response = (kal_uint8) rmmi_int_validator_ext(
                                                &error_cause,
                                                source_string_ptr,
                                                (kal_uint8) RMMI_COMMA /* separator */ );

            additional_info = (kal_uint8) rmmi_int_validator_ext(
                                            &error_cause,
                                            source_string_ptr,
                                            (kal_uint8) RMMI_PTR->s_reg.s3 /* separator */ );

            if ((terminal_response == SAT_CMD_PERFORMED_SUCCESSFULLY) ||
				(terminal_response == SAT_CMD_PERFORMED_BUT_ICON_COULD_NOT_DSPL)) /* can NOT display icon */
            {
                ret_val = l4c_sat_setup_ss();            

                if(ret_val == KAL_TRUE)                    
                {
                    if(terminal_response == SAT_CMD_PERFORMED_BUT_ICON_COULD_NOT_DSPL)
                    {
                        RMMI_PTR->sat_icon_displayed = KAL_FALSE; 
                    }  
                }   
				
                break;
            }
            else if (terminal_response == SAT_CMD_DATA_NOT_UNDERSTAND_BY_ME)
            {
                sat_send_ss_res_struct *param_ptr = (sat_send_ss_res_struct*)
                    construct_local_para(
                        (kal_uint16) sizeof(sat_send_ss_res_struct),
                        TD_RESET);

                kal_mem_set(param_ptr->cmd_detail, 0, 5);   /* do not have to fill it, SIM module will fill this field */
                param_ptr->res = terminal_response;
                param_ptr->size_of_additional_info = 1;

                if (additional_info == RMMI_VALIDATOR_ERROR)
                {
                    param_ptr->additional_info[0] = L4C_NO_CAUSE;
                }
                else
                {
                    param_ptr->additional_info[0] = additional_info;
                }

                ret_val = l4c_sat_send_ss_res(param_ptr);
                break;
            }
            else
            {
                /* other res shall not be responded by AP */
                break;
            }
		   
        }
        default:
            break;
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_stkussd_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for sending USSD.
 *  mtk00924 050308 add for Remote SAT
 *****************************************************************************/
void rmmi_stkussd_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_TEST_MODE:
        {
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_ACTIVE_MODE:  /* can display icon */
        {
            ret_val = l4c_sat_setup_ussd();
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;
            kal_uint8 terminal_response;
            kal_uint8 additional_info;

            terminal_response = (kal_uint8) rmmi_int_validator_ext(
                                                &error_cause,
                                                source_string_ptr,
                                                (kal_uint8) RMMI_COMMA /* separator */ );

            additional_info = (kal_uint8) rmmi_int_validator_ext(
                                            &error_cause,
                                            source_string_ptr,
                                            (kal_uint8) RMMI_PTR->s_reg.s3 /* separator */ );

            if ((terminal_response == SAT_CMD_PERFORMED_SUCCESSFULLY) ||
				(terminal_response == SAT_CMD_PERFORMED_BUT_ICON_COULD_NOT_DSPL)) /* can NOT display icon */
            {
                ret_val = l4c_sat_setup_ussd();            

                if(ret_val == KAL_TRUE)                    
                {
                    if(terminal_response == SAT_CMD_PERFORMED_BUT_ICON_COULD_NOT_DSPL)
                    {
                        RMMI_PTR->sat_icon_displayed = KAL_FALSE; 
                    }  
                }   
				
                break;
            }
            else if (terminal_response == SAT_CMD_DATA_NOT_UNDERSTAND_BY_ME)
            {
                sat_send_ussd_res_struct *param_ptr = (sat_send_ussd_res_struct*)
                    construct_local_para(
                        (kal_uint16) sizeof(sat_send_ussd_res_struct),
                        TD_RESET);

                kal_mem_set(param_ptr->cmd_detail, 0, 5);   /* do not have to fill it, SIM module will fill this field */
                param_ptr->res = terminal_response;
                param_ptr->size_of_additional_info = 1;

                if (additional_info == RMMI_VALIDATOR_ERROR)
                {
                    param_ptr->additional_info[0] = L4C_NO_CAUSE;
                }
                else
                {
                    param_ptr->additional_info[0] = additional_info;
                }

                ret_val = l4c_sat_send_ussd_res(param_ptr);
                break;
            }
            else
            {
                /* other res shall not be responded by AP */
                break;
            }
        }
        default:
            break;
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_stkdtmf_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for sending DTMF.
 *  mtk00924 050308 add for Remote SAT
 *****************************************************************************/
void rmmi_stkdtmf_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_TEST_MODE:
        {
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_ACTIVE_MODE:  /* can display icon */
        {
            ret_val = l4c_sat_dtmf();
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;
            kal_uint8 terminal_response;
            kal_uint8 additional_info;

            terminal_response = (kal_uint8) rmmi_int_validator_ext(
                                                &error_cause,
                                                source_string_ptr,
                                                (kal_uint8) RMMI_COMMA /* separator */ );

            additional_info = (kal_uint8) rmmi_int_validator_ext(
                                            &error_cause,
                                            source_string_ptr,
                                            (kal_uint8) RMMI_PTR->s_reg.s3 /* separator */ );

            if ((terminal_response == SAT_CMD_PERFORMED_SUCCESSFULLY) ||
				(terminal_response == SAT_CMD_PERFORMED_BUT_ICON_COULD_NOT_DSPL)) /* can NOT display icon */
            {
                ret_val = l4c_sat_dtmf();            

                if(ret_val == KAL_TRUE)                    
                {
                    if(terminal_response == SAT_CMD_PERFORMED_BUT_ICON_COULD_NOT_DSPL)
                    {
                        RMMI_PTR->sat_icon_displayed = KAL_FALSE; 
                    }  
                }   
				
                break;
            }
            else if (terminal_response == SAT_ME_CURRENTLY_UNABLE_TO_PROCESS_CMD)
            {
                sat_send_dtmf_res_struct *param_ptr = (sat_send_dtmf_res_struct*)
                    construct_local_para(
                        (kal_uint16) sizeof(sat_send_dtmf_res_struct),
                        TD_RESET);

                kal_mem_set(param_ptr->cmd_detail, 0, 5);   /* do not have to fill it, SIM module will fill this field */
                param_ptr->res = terminal_response;

                if (additional_info == RMMI_VALIDATOR_ERROR)
                {
                    param_ptr->additional_info = L4C_NO_CAUSE;
                }
                else
                {
                    param_ptr->additional_info = additional_info;
                }

                if (L4C_PTR->parameter_sat.length != 0)
                {
                    local_para_struct *local_ptr;

                    local_ptr = (local_para_struct*) L4C_PTR->parameter_sat.data;
                    local_ptr->ref_count = 1;       /* make sure the reference count is 1 so that when 
                                                       call free locl para that pare will be freed successfull */
                    free_local_para(local_ptr);
                    L4C_PTR->parameter_sat.length = 0;
                    L4C_PTR->parameter_sat.data = NULL;
                }

                l4c_send_msg_to_sim(MSG_ID_SAT_SEND_DTMF_RES, param_ptr, NULL);
                break;
            }
            else
            {
                /* other res shall not be responded by AP */
                break;
            }
		   
        }
        default:
            break;
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}

#endif /* __RSAT__ */ 

#endif /* __SAT__ */ 

#ifdef __GEMINI_3G_SWITCH__
/*****************************************************************************
 * FUNCTION
 *  rmmi_es3g_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for Switch 3G capability SIM
 *
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_es3g_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 setting, new_setting;
    kal_uint8 error_cause, i;		
    l4c_rat_enum new_rat;
    sim_interface_enum simId;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:
        {
            /* +ES3G: <capability> */
            rmmi_header_rrsp("+ES3G:");
            rmmi_tail_int_rrsp(L4C_COMM_PTR->cur_3g_capability, RMMI_SPACE);
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            setting = rmmi_int_validator_u8_check(&error_cause, source_string_ptr, RMMI_COMMA);
            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }

            // invalid setting check, we could only accept 0x01, 0x02, 0x04, 0x08
            /*
            * We will check the bit one by one which map to a SIM
            * if we find a bit is set, we break.
            * and check if the remaining setting is 1 or not.
            * if not, it means that there are more than two bits are set. So the value is invalid.
            * On the other hand, if i>= L4_MAX_SIM_NUM,
            * it means that there is no bit set for the valid SIM and the value is also invalid.
            */
            new_setting = setting;
            for (i=0, simId=SIM1; i<L4_MAX_SIM_NUM; i++)
            {
                if (setting & 0x01)
                {
                    break;
                }
                simId++;
                setting >>= 1;
            }

            if (setting != 1 || i>=L4_MAX_SIM_NUM)
            {
                break;
            }

            new_rat = (l4c_rat_enum) rmmi_int_validator_u8_check(
                        &error_cause, 
                        source_string_ptr, 
                        RMMI_PTR->s_reg.s3);
            if (error_cause == RMMI_PARSE_NOT_FOUND)
            {
            #if defined(__UMTS_RAT__)
                new_rat = L4C_RAT_GSM_UMTS;
            #else
                new_rat = L4C_RAT_GSM;
            #endif
            }
            else if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }
            else if (new_rat == 0 || new_rat > L4C_RAT_GSM_UMTS)
            {
                break;
            }

            /* we need to set dual rat mode before updating NVRAM to simplify the flow,
            * so we need to call the RAC's function first and the order is important.
            * On the other hand, because RAC thinks that physical SIM1 is SIM2
            * when 3G service is set to SIM2. So we need to use the function
            * l4c_gemini_get_actual_sim_id to transfer again before calling
            * RAC's update function
            */
            simId = l4c_gemini_get_actual_sim_id(simId);
            l4crac_update_nvram_rat_mode(new_rat, simId);
                
            L4C_COMM_PTR->cur_3g_capability = new_setting;
            l4c_eq_read_nvram_req(
                    source_string_ptr->src_id, 
                    NVRAM_EF_SYS_CACHE_OCTET_LID, 
                    NVRAM_SYS_FLIGHTMODE_STATE, 1);

            l4c_set_user_action(L4C_EQ, source_string_ptr->src_id, ES3G_EXE);
            return;
        }
        default:
            break;
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;

}
#endif /*__GEMINI_3G_SWITCH__*/

#endif /* !(defined(__SLIM_AT__)) */ 

/*mtk01616_100303: we plan to phase out the commands below and they are not used by MTK internally.
   And they don't listed in AT document. So we remove them directly. */
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #ifdef __test_mode__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif /* __test_mode__ */ 
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #ifdef __test_mode__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif /* __test_mode__ */ 
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

#endif /* __MOD_SMU__ */ 

