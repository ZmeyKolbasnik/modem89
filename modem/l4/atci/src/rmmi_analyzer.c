/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 * RMMI_ANALYZER.C
 *
 * Project:
 * --------
 *   MT6208
 *
 * Description:
 * ------------
 *   This file is intends for ???K.
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/********************************************************************************
*  Copyright Statement:
*  --------------------
*
*  This product has been developed using a protocol stack
*  developed by Sasken Communication Technologies Limited.
*
********************************************************************************/

#include <stdio.h>
//#include "kal_release.h"
//#include "stack_common.h"
//#include "stack_msgs.h"
//#include "app_ltlcom.h" /* Task message communiction */
//#include "stacklib.h"   /* Basic type for dll, evshed, stacktimer */
//#include "app_buff_alloc.h"
//#include "stack_timer.h"
//#include "event_shed.h"

#ifdef __MOD_SMU__
//#include "ps2sim_struct.h"
//#include "sim_common_enums.h"
//#include "smu_common_enums.h"
#endif /* __MOD_SMU__ */ 
//#include "csmss_common_enums.h"


//#include "mcd_l4_common.h"
#include "l4c_common_enum.h"
#include "rmmi_common_enum.h"
#include "rmmi_context.h"
#include "l4c_context.h"
#include "layer4_context.h"
//#include "l4c_rspfmttr.h"
#include "l4_trc.h"
#include "atci_trc.h"

//#include "l4c_aux_struct.h"

//#include "l4_defs.h"
//#include "csmcc_atfunc.h"
//#include "mcd_l3_inc_struct.h"

#ifdef __MOD_SMSAL__
//#include "l4c2smsal_struct.h"
#endif 

#include "rmmi_rspfmttr.h"

//#include "ps2sat_struct.h"
//#include "mcd_ps2sat_peer.h"
#include "rmmi_parser.h"
#include "rmmi_validator_ft.h"
#include "rmmi_analyzer.h"
#include "rmmi_utility.h"
//#include "rmmi_bt.h"

#include "l4c_utility.h"
//#include "csmcc_enums.h"
//#include "csmcc_common_enums.h"
//#include "l4c2csm_cc_struct.h"
//#include "keypad_sw.h"
#include "rmmi_ind.h"

#ifdef __RMMI_EXTEND_CUSTOM_CMD__
#include "rmmi_custom_parser.h"
#endif

//#include "kal_non_specific_general_types.h"
#include "string.h"
//#include "ps_trace.h"
#include "kal_trace.h"

#include "kal_general_types.h"
#include "kal_public_api.h"
#include "cmux_vp_num.h"
#include "atci_trc.h"
#include "rmmi_root.h"


#ifdef __RMMI_IO_LOGGING__
#include "kal_public_defs.h" //MSBB change #include "stack_common.h"
#include "kal_public_defs.h" //MSBB change #include "stack_msgs.h"
#include "task_config.h"        /* Task creation */
#include "kal_public_defs.h" //MSBB change #include "stack_config.h"
#endif

#undef  _FILE_CODE_
#define _FILE_CODE_ _RMMI_ANALYZER_C_

extern kal_uint8 custom_get_atcmd_symbol(void);
extern kal_bool custom_command_hdlr(char *full_cmd_string);
extern kal_bool custom_check_is_atcmd_allowed(rmmi_cmd_id_enum cmd_id);

extern void rmmi_at_t_csq_hdlr(rmmi_string_struct *source_string_ptr);
extern void rmmi_uart_print_data(kal_uint8 *buffer, kal_uint16 length,kal_uint8 cid, kal_uint8 port,kal_uint8 URC);


#ifdef __RMMI_EXTEND_CUSTOM_CMD__
kal_bool static rmmi_custom_command_analyzer(
        kal_uint32 hash_value1, kal_uint32 hash_value2, 
        kal_uint16 *cmd_index_ptr, kal_uint16 *cmd_row_index_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 col_index = 0;
    kal_uint16 row_index;

    ASSERT(cmd_index_ptr != NULL);
    if ((hash_value1 == 0) && (hash_value2 == 0))
    {
        return ret_val;
    }
    
    for (row_index = 0; row_index < RMMI_MAX_CUSTOM_CMD_NUM; row_index++)
    {
        
        if ((hash_value1 == rmmi_custom_cmd_table[row_index][col_index]) &&
            (hash_value2 == rmmi_custom_cmd_table[row_index][col_index + 1]))
        {
            *cmd_index_ptr = *cmd_row_index_ptr = row_index;
            ret_val = KAL_TRUE;
            break;
        }
    }

    kal_brief_trace(TRACE_INFO, INFO_EXTCOMMAND_HASH_VALUE, hash_value1, hash_value2, row_index, RMMI_MAX_CUSTOM_CMD_NUM);

    return ret_val;
}

void static rmmi_custom_cmd_processor(rmmi_string_struct *source_string_ptr)
{

    /* Variable to store the character value meant for searching the basic
       command present in the table */
    kal_uint16 cmd_index = RMMI_MAX_CUSTOM_CMD_NUM;

    kal_char const *rsp_str = NULL;
    kal_uint16 string_length = 0;
    kal_bool ret_val = KAL_TRUE;

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_EXTENDED_CMD_PROCESSOR_ENTRY);
    ASSERT(source_string_ptr != NULL);

    cmd_index = source_string_ptr->cmd_index;

    if (source_string_ptr->cmd_mode == RMMI_TEST_MODE &&
        rmmi_custom_need_entry(cmd_index) == KAL_FALSE)
    {
        rsp_str = rmmi_custom_test_mode_string_table[cmd_index];
        string_length = strlen(rsp_str);

        rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    }
    else
    {
        /* Calling validator using FSM */
        (rmmi_custom_validator_ft[cmd_index]) (source_string_ptr);
    }
}


#endif

static void rmmi_compute_symbol_hash(rmmi_string_struct *source_string_ptr)
{
    /*Get the hash value of the symbol*/
    switch(source_string_ptr->string_ptr[source_string_ptr->index]) 
    {
        case RMMI_CHAR_PLUS:
            source_string_ptr->symbol_hash = RMMI_EXTEND_HASH_PLUS;
            break;
        case RMMI_HAT:
            source_string_ptr->symbol_hash = RMMI_EXTEND_HASH_HAT;
            break;
        case RMMI_CHAR_PERCENT:
            source_string_ptr->symbol_hash = RMMI_EXTEND_HASH_PERCENT;
            break;
        case RMMI_MONEY:
            source_string_ptr->symbol_hash = RMMI_EXTEND_HASH_MONEY;
            break;
        default:
            break;
    }

}

kal_bool rmmi_special_cmd_processor(rmmi_string_struct *source_string_ptr)
{
    kal_uint8 buffer[9];
    
    kal_mem_cpy(buffer, source_string_ptr->string_ptr, 9);
    buffer[8] = '\0';
    toUpper(buffer);

    if (0)
    {;}
    #if !defined(__SLIM_AT__)
    else if (strncmp((kal_char*)buffer, "AT$CSQ=?", 8) == 0)
    {
        source_string_ptr->cmd_mode = RMMI_TEST_MODE;
        rmmi_at_t_csq_hdlr(source_string_ptr);
    }
    else if (strncmp((kal_char*)buffer, "AT$CSQ", 6) == 0)
    {
        source_string_ptr->cmd_mode = RMMI_ACTIVE_MODE;
        rmmi_at_t_csq_hdlr(source_string_ptr);
    }    
    #endif
    else
    {
        return KAL_FALSE;
    }

    return KAL_TRUE;
}

static kal_uint16 rmmi_find_multicmd_seperator(kal_char *str, int length)
{
    kal_uint16 i;
    kal_bool in_string = KAL_FALSE;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    
    for (i=0; i<length; i++)
    {
        if (*str == RMMI_END_OF_STRING_CHAR || 
            *str == rmmi_ptr->s_reg.s3 ||
            *str == rmmi_ptr->s_reg.s4)
        {
            break;
        }
        else if (*str == RMMI_SEMICOLON && !in_string)
        {
            break;
        }
        else if (*str == RMMI_DOUBLE_QUOTE)
        {
            in_string = in_string ? KAL_FALSE : KAL_TRUE;
        }
        str++;
    }
    return i;
}

kal_bool rmmi_compute_basic_cmd_hash_value(rmmi_string_struct *source_string_ptr)
{
    kal_uint8 ascii_char = 0;   /* variable to store the character
                                   value meant for searching the
                                   basic command present in the table */
    kal_bool cmd_found = KAL_FALSE;
    kal_uint8 hash_value;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    if (source_string_ptr->string_ptr[source_string_ptr->index] == rmmi_ptr->s_reg.s3 || 
        source_string_ptr->string_ptr[source_string_ptr->index] == RMMI_SEMICOLON)
    {
        /* For "AT" or "AT;"case */
        source_string_ptr->cmd_index = RMMI_NO_CMD;
        source_string_ptr->cmd_row_index = RMMI_TOT_BASIC_CMD; //mtk02514
        return KAL_TRUE;
    }
    else if (RMMI_IS_UPPER(source_string_ptr->string_ptr[source_string_ptr->index]))
    {
       ascii_char = source_string_ptr->string_ptr[source_string_ptr->index] - RMMI_CHAR_A;
    }
    else if (RMMI_IS_LOWER(source_string_ptr->string_ptr[source_string_ptr->index]))
    {
        ascii_char = source_string_ptr->string_ptr[source_string_ptr->index] - rmmi_char_a;
    }
    #ifdef __CS_SERVICE__
    else if (source_string_ptr->string_ptr[source_string_ptr->index] == RMMI_CHAR_AMPSAND)
    {
        /* Small ugly hack: the ascii value of &, minus two gives me
           the row index of & in hash table */
        ascii_char = source_string_ptr->string_ptr[source_string_ptr->index] - 2;
    }
    #endif /* __CS_SERVICE__ */ 
    /*else if ((source_string_ptr->string_ptr
              [source_string_ptr->index] == RMMI_CHAR_PLUS)
             || (source_string_ptr->string_ptr[source_string_ptr->index] == RMMI_CHAR_STAR))
    {
        source_string_ptr->index++;
        rmmi_extended_cmd_processor(source_string_ptr);
        return;
    }*/
    else
    {
        //rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNRECOGNIZED_CMD);
        //return;
        return KAL_FALSE;
    }
    
    /*
     * The basic commands, so far have only one character as the
     * * command name.
     */

    /**** [MAUI_01319443] mtk02514, 090120 **********************
    *  We maps a-z,0-9,& to 0~36 and store it to the ascii_char
    *  but, the real hash value is 1~37, so the hash_value = ascii_char+1
    ******************************************************/
    hash_value = ascii_char+1;
    kal_brief_trace(TRACE_INFO, BASIC_COMMAND_HASH_VALUE, hash_value);

    cmd_found = rmmi_basic_command_analyzer(hash_value, 
            &source_string_ptr->cmd_index, &source_string_ptr->cmd_row_index);

    return cmd_found;

}

kal_bool rmmi_comptue_extended_cmd_hash_value(rmmi_string_struct *source_string_ptr, kal_uint8 *cmd_class)
{
    kal_int8 counter = 0;

    /* This variable is used to ensure that the chars coming on line for
    command are properly broken into set of 5 chars. So, the correct
    hash value can be calculated based on the parser expression and
    respectively stored in the variables hash_value1 and hash_value2 */
    kal_uint8 ascii_char;

    /* Variable used to store the calculated hash value of 2nd 5 characters
    as a part of a extended command */
    kal_bool cmd_found = KAL_FALSE;

    kal_bool (*cmd_analyzer) (kal_uint32, kal_uint32, kal_uint16 *, kal_uint16 *);

    kal_uint32 hash_value1, hash_value2;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    cmd_analyzer = rmmi_extended_command_analyzer;
    #ifdef __RMMI_EXTEND_CUSTOM_CMD__
    if (*cmd_class == RMMI_EXTENDED_CUSTOM_CMD)
    {
        cmd_analyzer = rmmi_custom_command_analyzer;
    }
    #endif

    /* if command is found, cmd_index is the command enum */
    hash_value1 = 0;

    /* Variable used to store the calculated hash value of 1st 5 characters
       as a part of a extended command */
    hash_value2 = 0;
    
    /* Skip all leading white spaces */
    rmmi_skip_spaces(source_string_ptr);

    /* Parser for Extended AT commands */

    while ((source_string_ptr->string_ptr[source_string_ptr->index]
            != RMMI_EQUAL) &&
           (source_string_ptr->string_ptr[source_string_ptr->index]
            != RMMI_QUESTION_MARK) &&
           (source_string_ptr->string_ptr[source_string_ptr->index]
            != RMMI_COMMA) &&
           (source_string_ptr->string_ptr[source_string_ptr->index]
            != RMMI_SEMICOLON) &&
           (counter <= RMMI_MAX_EXT_CMD_NAME_LEN) &&
           (source_string_ptr->string_ptr[source_string_ptr->index]
            != rmmi_ptr->s_reg.s3) && (source_string_ptr->string_ptr[source_string_ptr->index] != rmmi_ptr->s_reg.s4))
    {

        if (RMMI_IS_UPPER(source_string_ptr->string_ptr[source_string_ptr->index]))
        {
            ascii_char = source_string_ptr->string_ptr[source_string_ptr->index] - RMMI_CHAR_A;
        }

        else if (RMMI_IS_LOWER(source_string_ptr->string_ptr[source_string_ptr->index]))
        {
            ascii_char = source_string_ptr->string_ptr[source_string_ptr->index] - rmmi_char_a;
        }

    #ifdef __CS_SERVICE__
        else if (RMMI_IS_NUMBER(source_string_ptr->string_ptr[source_string_ptr->index]))
        {
            ascii_char = source_string_ptr->string_ptr
                [source_string_ptr->index] - RMMI_CHAR_0 + RMMI_NUMBER_OFFSET_IN_PARSER_TABLE;
        }
    #endif /* __CS_SERVICE__ */ 

        else
        {
            //rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNRECOGNIZED_CMD);            
            return KAL_FALSE;
            //break;
        }

        /**** [MAUI_01319443] mtk02514, 090120 *************************************************************
        *  The new hash value computed method is as follows.
        *  for AT+ABCDEFGH
        *  hash_value1 = hash(A)*38^4 + hash(B)*38^3 + hash(C)*38^2 + hash(D)*38^1 + hash(E)*38^0
        *                    = ((((hash(A)+0)*38 + hash(B))*38 + hash(C))*38 + hash(D))*38 + hash(E)  <== as following statements do.
        *  hash_value2 = hash(F)*38^2 + hash(G)*38^1 + hash(H)*38^0
        *                    = ((hash(F) + 0)*38 + hash(G))*38 + hash(H)  <== as following statements do.
        **********************************************************************************************/
        if (counter < RMMI_HASH_TABLE_SPAN)
            hash_value1 = hash_value1*(RMMI_HASH_TABLE_ROW+1)+(ascii_char+1);
        else
            hash_value2 = hash_value2*(RMMI_HASH_TABLE_ROW+1)+(ascii_char+1);

        counter++;

        /* Increment the index to get the next character */
        source_string_ptr->index++;

        /* skip all leading white  spaces */
        rmmi_skip_spaces(source_string_ptr);

    }   /* End of while loop */

    /*
    * For backward compatible, If we defined __TC01__ and __RMMI_EXTEND_CUSTOM_CMD__
    * we should use the old method first, which compute the hash value without including 
    * the header symbol. Then, if we didn't found the command, 
    * we will try to use the new method to find out the command in our table.
    *
    */
    #if !defined(__TC01__) || !defined(__RMMI_EXTEND_CUSTOM_CMD__)
    hash_value1 += source_string_ptr->symbol_hash;
    #endif
    cmd_found = cmd_analyzer(hash_value1, hash_value2, 
            &source_string_ptr->cmd_index, &source_string_ptr->cmd_row_index); 
    
    #if defined(__TC01__) && defined(__RMMI_EXTEND_CUSTOM_CMD__)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif

    #ifdef __RMMI_EXTEND_CUSTOM_CMD__
    if (*cmd_class == RMMI_EXTENDED_CUSTOM_CMD)
    {
        source_string_ptr->cmd_index = source_string_ptr->cmd_row_index;
    }
    else 
    #endif
    if (cmd_found && *cmd_class == RMMI_EXTENDED_CMD)
    {
        source_string_ptr->cmd_index = 
            rmmi_extended_cmd_id_table[source_string_ptr->cmd_row_index];
    }


    return cmd_found;

}

kal_uint8 rmmi_set_cmd_class_and_index(rmmi_string_struct *source_string_ptr)
{
    kal_uint8 cmd_class;

    if( (cmd_class = rmmi_find_cmd_class(source_string_ptr)) != RMMI_INVALID_CMD_TYPE )
    {
        if (cmd_class == RMMI_BASIC_CMD )
        {
            if (rmmi_compute_basic_cmd_hash_value(source_string_ptr) == KAL_FALSE)
            {
                cmd_class = RMMI_CUSTOMER_CMD;
            }
        }
        #ifndef __RMMI_EXTEND_CUSTOM_CMD__
        else if (cmd_class == RMMI_EXTENDED_CMD)
        #else
        else if (cmd_class == RMMI_EXTENDED_CMD || cmd_class == RMMI_EXTENDED_CUSTOM_CMD)
        #endif
        {
            if (rmmi_comptue_extended_cmd_hash_value(source_string_ptr, &cmd_class) == KAL_FALSE)
            {
                cmd_class = RMMI_CUSTOMER_CMD;
            }
        }
    }

    return cmd_class;
}

kal_bool rmmi_get_next_cmd(rmmi_string_struct *source_string_ptr, rmmi_string_struct *des_string_ptr)
{
    kal_uint16 end_index, begin_index;
    kal_uint16 cmd_index;
    kal_uint16 length, cmd_length;
    kal_bool is_ignore_following = KAL_FALSE;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    
    /* store the begin index */
    begin_index = source_string_ptr->index;
    length = (kal_uint16)strlen( (kal_char*) source_string_ptr->string_ptr);

    if ( begin_index >= length )
        return KAL_FALSE;

    source_string_ptr->cmd_class = rmmi_set_cmd_class_and_index(source_string_ptr);

    cmd_index = source_string_ptr->cmd_index;
    if (source_string_ptr->cmd_class == RMMI_BASIC_CMD)
    {
        /* judege if there is any ATD, ATA*/
        if ( cmd_index == RMMI_CMD_ATD )             
        {
            is_ignore_following = KAL_TRUE;
            /***************************************
             * ATD will Ignore the string following the command or ';'
             * For ATD, we should eliminate the string after ';'
             *******************************/

            /* compute the end index*/
            end_index = (kal_uint16)strcspn((kal_char*) source_string_ptr->string_ptr + begin_index , ";") + begin_index;            
            if(source_string_ptr->string_ptr[end_index] == RMMI_SEMICOLON)
            {
                end_index++;
            }

        }
        else
        {
            /* Assume ATX123E, the index will point to 'X' 
             * or AT&X123E, the index will point to '&' 
             */
            
            /* skip the command alphabet */ // at command
            end_index = source_string_ptr->index + 1;

            /* ATX123E, the index will point to '1' 
             *  AT&X123E, the index will point to 'X' 
             */
            
            if (cmd_index == RMMI_CMD_ATAMP)
            {
                /* skip the command alphabet for AT&X */
                end_index++;
            }

            /* ATX123E, the index will point to '1' 
             *  AT&X123E, the index will point to '1' 
             */


            /* skip digits to find next alphabet
             * which is the next command */
            for (  ; end_index  < length ; end_index++)
            {
                if ( RMMI_IS_ALPHA(source_string_ptr->string_ptr[end_index]) ||
                     source_string_ptr->string_ptr[end_index] == RMMI_CHAR_AMPSAND || 
                     source_string_ptr->string_ptr[end_index] == RMMI_CHAR_PLUS || 
                     source_string_ptr->string_ptr[end_index] == RMMI_SEMICOLON)
                {
                    break;
                }
            }

            /* ATX123E, the index will point to 'E' which is the next command
             *  AT&X123E, the index will point to 'E' which is the next command
             */
            if (cmd_index == RMMI_CMD_ATA)
            {
                is_ignore_following = KAL_TRUE;

                /******************************************************
                * MAUI_01609296
                * ATA will ignore the following commands
                * ex. ATA123!@DE 
                * we will pass ATA123!@ to rmmi_ata_hdlr and ignore DE
                *******************************************************/
            }        

        }
    }
    else if (source_string_ptr->cmd_class == RMMI_EXTENDED_CMD)
    {
        if (cmd_index == RMMI_CMD_ATCMGW || cmd_index == RMMI_CMD_ATCMGS || 
            cmd_index == RMMI_CMD_ATCMGC || cmd_index == RMMI_CMD_ATCNMA ||
            cmd_index == RMMI_CMD_ATEMGW || cmd_index == RMMI_CMD_ATEMGS ||
            cmd_index == RMMI_CMD_ATEMGC || cmd_index == RMMI_CMD_ATENMA)
        {
            /* for this two commands, we should transmit the whole command string */
            end_index = length;
        }
        else
        {
            end_index = rmmi_find_multicmd_seperator(
                (kal_char*) source_string_ptr->string_ptr + begin_index,
                length - begin_index) + begin_index;
        }
    }
    else
    {
        /* Since the cmd_class don't belong to any class, */
        /* we transmite the whole string as the next command*/ 
        end_index = length;
    }

    cmd_length = end_index - begin_index;
    
    /* caculate real index of des_string_ptr*/
    des_string_ptr->index = source_string_ptr->index - begin_index;
    
    des_string_ptr->cmd_class = source_string_ptr->cmd_class;
    des_string_ptr->cmd_index = source_string_ptr->cmd_index;
    des_string_ptr->cmd_row_index = source_string_ptr->cmd_row_index;
    des_string_ptr->src_id = source_string_ptr->src_id;
    kal_mem_cpy(des_string_ptr->string_ptr, source_string_ptr->string_ptr + begin_index, cmd_length);
    
    /* set the end of the command string */
    if(des_string_ptr->string_ptr[cmd_length-1] != rmmi_ptr->s_reg.s3)
    {
        des_string_ptr->string_ptr[cmd_length++] = rmmi_ptr->s_reg.s3;
    }
    des_string_ptr->string_ptr[cmd_length] = '\0';   
    
    /* we should decide the command mode after we determine the end of the command
    * since rmmi_find_cmd_mode will check if the command mode can have input follwoing the command*/
    #ifndef __RMMI_EXTEND_CUSTOM_CMD__
    if(des_string_ptr->cmd_class == RMMI_EXTENDED_CMD)
    #else
    if(des_string_ptr->cmd_class == RMMI_EXTENDED_CMD || des_string_ptr->cmd_class == RMMI_EXTENDED_CUSTOM_CMD)
    #endif
    {
        /* mtk0071420040726 */
        /* Find the command mode (READ/TEST/SET) */
        des_string_ptr->cmd_mode = rmmi_find_cmd_mode(des_string_ptr);
    }

    /* update the index of the source command string
     * we should let the index stop at the head of the next command if any*/
    if(is_ignore_following)
    {
        source_string_ptr->index = length;
    }
    else
    {
        source_string_ptr->index = end_index;
    }

    while(source_string_ptr->string_ptr[ source_string_ptr->index ] == RMMI_SPACE ||  
             source_string_ptr->string_ptr[ source_string_ptr->index ] == RMMI_SEMICOLON || 
             source_string_ptr->string_ptr[ source_string_ptr->index ] == rmmi_ptr->s_reg.s3)  
    {
        source_string_ptr->index++; 
    }
    
    return KAL_TRUE;
}

/*****************************************************************************
 * FUNCTION
 *  rmmi_cmd_processor
 * DESCRIPTION
 *  This is rmmi_cmd_processor function of L4C module.
 *  It uses recursive method to process the mutliple cmd string:
 *  seperate each command by ';' ,
 *  classify each command type(BASIC, EXTEND, PREVIOS, or CUSTOMER),
 *  and then call appropriate process function: rmmi_extended_cmd_processor()/ rmmi_basic_cmd_processer()
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 *  cmd_length              [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cmd_processor(rmmi_string_struct *source_string_ptr, kal_uint16 cmd_length)
{
    kal_uint16 index;   //mtk01616_071116: use int16 ,otherwise if cmd paramter over 255 ,the cmd will always fail
    kal_uint32 actual_length;               /* we filter te string which is not AT command */
    kal_uint16 single_cmd_length;
    kal_char *source_string_copy = NULL;    /* uing to duplicate this stinng so that we can copy to our RMMI context */
    rmmi_string_struct cooked_source_string_ptr;
    l4c_source_id_enum src_id;
    kal_uint8 cid;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    l4c_context_struct *l4c_ptr = L4C_PTR;
#if defined(__GEMINI__) && defined(__MMI_FMI__)
    l4c_common_context_struct *l4c_comm_ptr = L4C_COMM_PTR;
#endif
    kal_bool is_print_full_cmd = KAL_FALSE;
#if defined(__L4C_GEMINI_BT_HF__)
    kal_bool route_thru_root = KAL_FALSE;
    kal_uint8 which_sim = SIM1;
#endif

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_CMD_PROCESSOR_ENTRY);
    ASSERT(source_string_ptr != NULL);

#if defined(__RMMI_IO_LOGGING__) && !defined(__RMMI_UT__)
    l4c_fake_rmmi_input_str_logging(source_string_ptr);
#endif /* __RMMI_IO_LOGGING__ */

    /***********************************************/
    /* here we check: AT command should have prefix "AT" */

    /* skip none 'A' or 'a' character before CR form UART */
    /* 030617 mtk00468 add for +++ operation in GPRS and CSD */
    rmmi_skip_none_a(source_string_ptr, cmd_length);

    src_id = source_string_ptr->src_id;
    rmmi_ptr->current_src = (kal_uint8) src_id; 
    /* skip not "AT" */
    while (source_string_ptr->string_ptr[source_string_ptr->index + 1] != rmmi_char_t &&
           source_string_ptr->string_ptr[source_string_ptr->index + 1] != RMMI_CHAR_T &&
           source_string_ptr->index < cmd_length)
    {
        source_string_ptr->index += 2;  /* skip to the next next index ex: a~~~at */
        rmmi_skip_none_a(source_string_ptr, cmd_length);
    }

    /* count actual length which start from "AT" */
    actual_length = cmd_length - source_string_ptr->index;

    //mtk00468 040411 add to fixed stack overflow when uart had transfer to L4C but PC send lots of data to MS
    if (actual_length < 2)
    {
        return;
    }

    //memory allocate for source string copy
    source_string_copy = get_ctrl_buffer(actual_length + 1);    /* additional 1 byte for NULL terminated */

    /* copy content to source_string_copy: the full command string starts from "AT", ex: "AT+CGATT=?;+CREG?<CR>" */
    kal_mem_cpy(source_string_copy, &source_string_ptr->string_ptr[source_string_ptr->index], actual_length);
    source_string_copy[actual_length] = '\0';   /* add NULL terminate */

    kal_mem_cpy(
        (kal_uint8*) source_string_ptr->string_ptr,
        (kal_uint8*) source_string_copy,
        actual_length * sizeof(kal_uint8) + 1);
    source_string_ptr->index = 0;

    free_ctrl_buffer(source_string_copy);

    ///////////////////////////////////////////////////////////////////
    //from here we start to process the AT command source string
    //search ";" for checking if it is multi comand 
    //if can not find that sting in string1 it will return index as string1 length
    // we have to think about atd118; this case. We check if index+1 is not <CR>
    //at+cgatt=?;+creg=?
    //          ^(index+1)

    index = rmmi_find_multicmd_seperator((kal_char*)(source_string_ptr->string_ptr), actual_length);


    cid = rmmi_srcid_2_cid((kal_uint8)src_id);
    if (cid == 0xff)
    {

        if (RMMI_COMM_PTR->cmd_from_tst != KAL_TRUE   /* to allow command from TST*/
        #ifdef __SATCB__
            && src_id != RMMI_SAT
        #endif
        )
        {
            kal_brief_trace(TRACE_WARNING, WARNING_CANNOT_PROCESS_MULTI_CMD);
            rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNRECOGNIZED_CMD);
            return;
        }
    }

    /* Judge if this is a multi-command string*/
    if (index < actual_length && 
        source_string_ptr->string_ptr[index] == RMMI_SEMICOLON &&
        source_string_ptr->string_ptr[index+1] >= RMMI_SPACE )
    {
        kal_brief_trace(TRACE_INFO, RMMI_MULTI_CMD_RECEIVED);
        #if defined (__SLIM_AT__) 
            rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNRECOGNIZED_CMD);
            return;
        #endif /* defined (__SLIM_AT__) */ 
    }

    /* turn on is_multi_cmd flag */
    RMMI_COMM_PTR->is_multi_cmd |= (0x01 << cid);        //RMMI_PTR->is_multi_cmd = KAL_TRUE;


    cooked_source_string_ptr.string_ptr = get_ctrl_buffer(MAX_DATA_QUEUE_LENGTH * sizeof(kal_uint8) );
    cooked_source_string_ptr.index = 0;
    cooked_source_string_ptr.src_id = src_id;
    source_string_copy = (kal_char *)cooked_source_string_ptr.string_ptr;

    kal_mem_set(cooked_source_string_ptr.string_ptr, 0, MAX_DATA_QUEUE_LENGTH);
    while(rmmi_get_next_cmd(source_string_ptr, &cooked_source_string_ptr) == KAL_TRUE)
    {            
        /* mtk02514 * MAUI_01782358 * MAUI_01905145 * 20090912 ******
        * Do do a length check.
        * It is to check if there is any remaing characters
        * if true, we should check if the remaining command could be store into 
        * rmmi_ptr->multi_cmd_string. If not, we should not execute the command
        ************************************************************/

        if (source_string_ptr->index < actual_length && 
                (actual_length - source_string_ptr->index + 2) > MAX_MULTIPLE_CMD_INFO_LEN)
        {
            rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_SYNTEX_ERROR);
            break;
        }

        /* mtk02514 *******************************
        * Judge if the last multi-command
        * If ture, we clear the flag and let the output of OK and ERROR
        * be the job of command handler
        ****************************************/
        if(source_string_ptr->index >= actual_length)
        {
            /* there is no further command*/
            RMMI_COMM_PTR->is_multi_cmd &= ~(0x01 << cid);
        }
        else if (is_print_full_cmd == KAL_FALSE)
        {
            is_print_full_cmd = KAL_TRUE;
            kal_sys_trace((kal_char*) source_string_ptr->string_ptr);  /* for SYS Trace, can't take off */
        }
  
	rmmi_uart_print_data((kal_uint8*)source_string_copy,(kal_uint16)strlen((char*)source_string_copy),cid, rmmi_cid_2_port(cid), 3);

        /* debug information */
        kal_brief_trace(
           TRACE_INFO,
            AT_CMD_STRING,
            source_string_copy[0],source_string_copy[1],source_string_copy[2],
            source_string_copy[3],source_string_copy[4],source_string_copy[5],
            source_string_copy[6],source_string_copy[7],source_string_copy[8],
            source_string_copy[9],source_string_copy[10],source_string_copy[11]);

        single_cmd_length = (kal_uint16)strlen( (kal_char*)cooked_source_string_ptr.string_ptr);

        /****************************************************************
         ** BEGIN ** Judge if the command is special command with special handling method**
         ****************************************************************/

    #if defined(__L4C_GEMINI_BT_HF__)
        /*** mtk02508 special handling for BT HF commands ***/
        if ((rmmi_current_mod_id == MOD_ATCI) && 
            (rmmi_root_bt_hf_cmd_hdlr(&cooked_source_string_ptr, &which_sim) == KAL_TRUE))
        {
            route_thru_root = KAL_TRUE;
            layer4_module_context_selection(L4_MODULE(MOD_ATCI, which_sim));
            kal_brief_trace(TRACE_INFO, INFO_ATCI_ROOT_SWITCH_FOR_HF, which_sim);
            rmmi_ptr = RMMI_PTR;
            l4c_ptr = L4C_PTR;
        }
    #endif

#if 0 //MAUI_02554068
        #ifdef __UCM_SUPPORT__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
            #ifdef __SAT__        
/* under construction !*/
            #endif 
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #endif /* __UCM_SUPPORT__ */ 
#endif

        #if defined(__GEMINI__) && defined(__MMI_FMI__) 
        // Block Gemini feature phone only! 
        // modified for Gemini modem
        if (cooked_source_string_ptr.cmd_index != RMMI_NO_CMD)
        {
            if (l4c_comm_ptr->during_sim_mode_switch)
            {
                rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_COMMAND_CONFLICT);
                break;
            }
        }    
        #endif /* defined(__GEMINI__) && defined(__MMI_FMI__) */ 

        /* handling for "AT" or "at" */
        if( (cooked_source_string_ptr.cmd_index == RMMI_NO_CMD) && (cooked_source_string_ptr.cmd_class == RMMI_BASIC_CMD))
        {
#if defined(__TC01__) && defined(EXTERNAL_MMI)
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif			
        }

    #if !defined(__SLIM_AT__)
        if (  (l4c_ptr->sms_current_action[src_id] == CMGS_PDU_EXE)    
        #ifdef __MMI_FMI__
            ||(l4c_ptr->sms_current_action[SAT_SRC] == SAT_CMGS_EXE)
        #endif
            ||(l4c_ptr->sms_current_action[src_id] == CMGS_EXE) )
        {
            if (cooked_source_string_ptr.cmd_index == RMMI_CMD_ATCSMA)
            {
                //do nothing
            }
            else
            {
                break;
            }
        }
    #endif

        #if defined(__ATCMD_ONOFF_CHECK__)
        if (rmmi_check_at_enable && 
                    cooked_source_string_ptr.cmd_class == RMMI_EXTENDED_CMD &&
                    !custom_check_is_atcmd_allowed(
                            (rmmi_cmd_id_enum)cooked_source_string_ptr.cmd_index)) 
        {

            rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_AT_NOT_ALLOWED_BY_CUSTOMER); 
            break;
        }
        #endif

        /***************************************************************
         ** END ** Judge if the command is special command with special handling method**         
         ***************************************************************/
        
        /* Call the custom_command_hdlr() in custom folder to process the custom command first
         * If the command string didn't handled by the customer, we will check
         * if we can handle this command*/ 
        if (custom_command_hdlr((char*)cooked_source_string_ptr.string_ptr) == KAL_FALSE)
        {
            /* dispatch the command into the corresponding cmd processor*/
            switch (cooked_source_string_ptr.cmd_class)
            {
                case RMMI_EXTENDED_CMD:
                {
                    /*
                     * the command type is known now. Do a length check. All the
                     * * length checks will cease hereafter
                     */
                    if (single_cmd_length > MAX_SINGLE_CMD_INFO_LEN)
                    {
                        rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_SYNTEX_ERROR);
                        break;
                    }
                
                    /* Call the extended command processor to process the extended
                      command */
                    rmmi_extended_cmd_processor(&cooked_source_string_ptr);
                    break;
                }
                case RMMI_BASIC_CMD:
                {
                    /* Call the basic command processor to validate the basic
                    command */
                    rmmi_basic_cmd_processor(&cooked_source_string_ptr);
                    break;
                }   
                #ifdef __RMMI_EXTEND_CUSTOM_CMD__
                case RMMI_EXTENDED_CUSTOM_CMD:
                {
                    rmmi_custom_cmd_processor(&cooked_source_string_ptr);
                    break;
                }
                #endif
                default:
                {
                    if (rmmi_special_cmd_processor(&cooked_source_string_ptr) == KAL_FALSE)
                        rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNKNOWN);
                    break;
                }
            }
        }
        else
        {
            /*******************************************************
            * We don't allow to execute the commands after a custom command
            * So, we break here.
            * We suggest that we should only use the a custom command
            * as a single command or the last command in the multi-command
            ******************************************************/
            #if 0 // do we need this??
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
            #endif 

            kal_brief_trace(TRACE_INFO, CUSTOM_CMD_HDLR);
#ifdef __SAT__			
#ifdef __SATCB__
            if (rmmi_ptr->IsSATcommand == KAL_TRUE) {
                rmmi_send_rsp_to_SAT();
                rmmi_ptr->IsSATcommand = KAL_FALSE;            //custom cmd will not call result_code_fmtter,it call write_to_uart directly
            }
#endif
#endif
            break;
        }

       /* mtk02514 **********************************
        *  Since there is something wrong when handling previous command,
        *  we should not process the following commands, so we break direcly.
        ********************************************/
        if ( (RMMI_COMM_PTR->multi_cmd_error & (0x01 << cid)) )
        {
            break;
        }

        if (source_string_ptr->index < actual_length)   //the command string is not finsihed paring 
        {
            kal_brief_trace(TRACE_INFO, RMMI_MULTI_CMD_NOT_FINISHED);
            /* we got to check if previous AT command is in forward action state and waiting for confirm , 
             * if yes , we have to save command string in to our context and after receive confirm
             * we call command processor */
            #if defined(__SP_RIL_SUPPORT__)
                if (((l4c_ptr->cc_current_action[src_id] != L4C_NO_ACTION) && (l4c_ptr->cc_current_action[src_id] != POWERON_EXE) && (l4c_ptr->cc_current_action[src_id] != ATD_ECC)
                    && (l4c_ptr->cc_current_action[src_id] != ATD_EXE)
                    && (l4c_ptr->cc_current_action[src_id] != ATD_ECC_CHANGE_RAT)
                    && (l4c_ptr->cc_current_action[src_id] != ATD_ECC_CHANGE_RAT_ABORT)
                    ) || 
            	       (l4c_ptr->ss_user == src_id &&l4c_ptr->ss_current_action != L4C_NO_ACTION && l4c_ptr->ss_current_action != PARSE_SS_EXE && l4c_ptr->ss_current_action != USSR_FAC_IND) ||
                #ifdef __MOD_TCM__
                    (l4c_ptr->tcm_user == src_id && l4c_ptr->tcm_current_action != L4C_NO_ACTION) ||
                #endif //mtk02285, 201003, 6251_ram
                    (l4c_ptr->rac_user == src_id && l4c_ptr->rac_current_action != L4C_NO_ACTION 
                    						       && l4c_ptr->rac_current_action!=SET_GPRS_CON_TYPE
                    						       && l4c_ptr->rac_current_action!=PWRON_SET_RAT_MODE
                    						       && l4c_ptr->rac_current_action!=PWRON_ATTACH  /* DUMA00206309 */
                    						       && l4c_ptr->rac_current_action!=RFON_ATTACH    /* MAUI_01402986 */
                    						       && l4c_ptr->rac_current_action!=SET_RAT_MODE_ATTACH) ||  
                    (l4c_ptr->smu_user == src_id && l4c_ptr->smu_current_action != L4C_NO_ACTION) ||  
                    (l4c_ptr->sms_current_action[src_id] != L4C_NO_ACTION) ||
                    (l4c_ptr->phb_user == src_id && l4c_ptr->phb_current_action != L4C_NO_ACTION)||
                    (l4c_ptr->eq_user == src_id && l4c_ptr->eq_current_action != L4C_NO_ACTION))
            #else /* __SP_RIL_SUPPORT__ */ 
                if (    //(L4C_PTR->cc_sub_state[source_string_ptr->src_id] == L4C_CMD_FORWARDED_FOR_ACTION_STATE) ||
                       ((l4c_ptr->cc_current_action[source_string_ptr->src_id] != L4C_NO_ACTION) &&
                        (l4c_ptr->cc_current_action[source_string_ptr->src_id] != POWERON_EXE)) ||
                       //in poweron state, multi-cmd is allowed to set something.
			#if !defined(__MMI_FMI__) || defined(__ECUSD_SUPPORT__)//mtk01616_081201
            		   (l4c_ptr->ss_user == src_id && l4c_ptr->ss_current_action != L4C_NO_ACTION && l4c_ptr->ss_current_action != PARSE_SS_EXE)
			#else
                       (l4c_check_user_action(L4C_SS, L4C_NO_USER, L4C_NO_ACTION) != KAL_TRUE) 
			#endif                       
                       ||
                       l4c_ptr->eq_current_action != L4C_NO_ACTION ||
            #ifdef __MOD_TCM__
                       l4c_ptr->tcm_current_action != L4C_NO_ACTION ||
            #endif //mtk02285, 201003, 6251_ram                       
                       l4c_ptr->rac_current_action != L4C_NO_ACTION ||
                       l4c_ptr->smu_current_action != L4C_NO_ACTION ||
                       l4c_ptr->sms_current_action[source_string_ptr->src_id] != L4C_NO_ACTION ||
                       l4c_ptr->phb_current_action != L4C_NO_ACTION 
            #if defined(__MMI_FMI__)
                       || (l4c_ptr->route_thru_lmmi == KAL_TRUE) 
            #endif                       
                       || rmmi_ptr->is_ucm_action == KAL_TRUE)
            #endif /* __SP_RIL_SUPPORT__ */ 
                {
                    if (cooked_source_string_ptr.cmd_class == RMMI_BASIC_CMD && 
                             cooked_source_string_ptr.cmd_index != RMMI_CMD_ATH &&
                             cooked_source_string_ptr.cmd_index != RMMI_CMD_ATO &&
                             l4c_ptr->route_thru_lmmi == KAL_FALSE) 
                    {
                        /* we allow to execute the next command if the previouly one is a basic command
                            except ATO, ATD, ATA, and ATH while route_thru_lmmi is false*/
                    }
                    else
                    {
                        /* save remain command in RMMI_PTR context */
                        kal_sprintf(
                                (kal_char*) RMMI_COMM_PTR->multi_cmd_string[cid],
                                "at%s",
                                (kal_char*) source_string_ptr->string_ptr + source_string_ptr->index);

                        if (cooked_source_string_ptr.string_ptr != NULL)
                        {
                            free_ctrl_buffer(cooked_source_string_ptr.string_ptr);
                        }

                        kal_brief_trace(
                                TRACE_INFO,
                                RMMI_PROCESS_MULTI_CMD_ACTION_EXIST,
                                rmmi_ptr->is_ucm_action,
                                l4c_ptr->route_thru_lmmi);
                        kal_brief_trace(TRACE_WARNING, WARNING_RMMI_CMD_NOT_ALLOWED, RMMI_ERR_ACTION_ALREADY);
                        return;
                    }
                }
                source_string_ptr->string_ptr[source_string_ptr->index-2] = 'A';
                source_string_ptr->string_ptr[source_string_ptr->index-1] = 'T';
                source_string_ptr->index -= 2;

                kal_mem_set(cooked_source_string_ptr.string_ptr, 0, MAX_DATA_QUEUE_LENGTH);
        }        
    #if defined(__L4C_GEMINI_BT_HF__)
        /*** mtk02508 special handling for BT HF commands ***/
        if (route_thru_root == KAL_TRUE)
        {
            layer4_module_context_selection(MOD_ATCI);
            kal_brief_trace(TRACE_INFO, INFO_ATCI_ROOT_SWITCH_FOR_HF, 0); //switch back to SIM1
            rmmi_ptr = RMMI_PTR;
            l4c_ptr = L4C_PTR;
            route_thru_root = KAL_FALSE;
        }
    #endif
    }

    /* mtk02514 *** MAUI_01643487 *** 090309 *************
    * When the command ERROR occurs, 
    * we should clear and reset the relative flag and variable here
    * if the previously command do not issue any request to sub-module
    ************************************************/

    //kal_brief_trace(TRACE_GROUP_4, RMMI_MULTI_CMD_FINISHED);
    RMMI_COMM_PTR->is_multi_cmd &= ~(0x01 << cid);
    RMMI_COMM_PTR->multi_cmd_string[cid][0] = 0;
    RMMI_COMM_PTR->multi_cmd_error &= ~(0x01 << cid);    //reset variable
     
    free_ctrl_buffer(cooked_source_string_ptr.string_ptr);
    
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_find_cmd_class
 * DESCRIPTION
 *  This is rmmi_find_cmd_class function of L4C module.
 *  gives the class of the AT command
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
kal_uint8 rmmi_find_cmd_class(rmmi_string_struct *source_string_ptr)
{
    kal_uint8 ret_val = RMMI_INVALID_CMD_TYPE;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_FIND_CMD_CLASS_ENTRY);
    ASSERT(source_string_ptr != NULL);
    rmmi_skip_spaces(source_string_ptr);        // Skip all leading white spaces 

    /* Check if the first character is neither 'A' nor 'a' i.e. a invalid 
       command prefix */
    if ((source_string_ptr->string_ptr[source_string_ptr->index] != RMMI_CHAR_A) &&
        (source_string_ptr->string_ptr[source_string_ptr->index] != rmmi_char_a))
    {
        return ret_val;
    }

    /* Increment the index to get the next character */
    source_string_ptr->index++;

    /* Skip all white spaces */
    rmmi_skip_spaces(source_string_ptr);

    /* there are two possibilities of characters may come after the
       character A. One is '/' and other one is 'T'. First we check for
       the character '/', if not found then check for the character 'T'. */
    if ((source_string_ptr->string_ptr[source_string_ptr->index] == RMMI_FORWARD_SLASH) &&
        (source_string_ptr->index <= MAX_MULTIPLE_CMD_INFO_LEN))
    {
        /* Skip all leading spaces, which are coming after the "A/".
           Finally check for the command line termination character */
        source_string_ptr->index++;
        rmmi_skip_spaces(source_string_ptr);

        if ((source_string_ptr->string_ptr[source_string_ptr->index] == rmmi_ptr->s_reg.s3) &&
            (source_string_ptr->index <= MAX_MULTIPLE_CMD_INFO_LEN))
        {
            ret_val = RMMI_PREV_CMD;
        }
        /* else, command line is invalid */
        else
        {
            ret_val = RMMI_INVALID_CMD_TYPE;
        }
    }
    /* We failed to find '/'.the second alternative is 'T'.Check whether
       the second non spaces character is 'T' or not */
    else if (((source_string_ptr->string_ptr[source_string_ptr->index] == RMMI_CHAR_T) ||
              (source_string_ptr->string_ptr[source_string_ptr->index] == rmmi_char_t)) &&
             (source_string_ptr->index <= MAX_MULTIPLE_CMD_INFO_LEN))
    {
        /*
         * Skip all leading white space character which are coming after
         * * "AT".Again we can find two different character after "AT".One is
         * * '+' and other one is non '+' character.if we find '+' then we
         * * decided that the give command is a Extended command, otherwise
         * * Basic command.
         */
        /*
         * there's no need of check for command line termination, because that
         * * will be checked during the parsing of commands
         */
        source_string_ptr->index++;
        rmmi_skip_spaces(source_string_ptr);
	 #ifdef __RMMI_EXTEND_CUSTOM_CMD__
        if ( rmmi_is_custom_extended_cmd_character(
            (kal_char*) &source_string_ptr->string_ptr[source_string_ptr->index] ) )
        {
            ret_val = RMMI_EXTENDED_CUSTOM_CMD;
            rmmi_compute_symbol_hash(source_string_ptr);
            source_string_ptr->index++; /* to get the next character */
        }
        else
        #endif
        if ((source_string_ptr->string_ptr[source_string_ptr->index] == RMMI_CHAR_PLUS ||
             source_string_ptr->string_ptr[source_string_ptr->index] == RMMI_HAT ||
             source_string_ptr->string_ptr[source_string_ptr->index] == RMMI_CHAR_PERCENT ||
             source_string_ptr->string_ptr[source_string_ptr->index] == RMMI_MONEY) &&
            (source_string_ptr->index <= MAX_MULTIPLE_CMD_INFO_LEN))
        {
            /* the '+' character is found,hence it is extended command */
            ret_val = RMMI_EXTENDED_CMD;
            rmmi_compute_symbol_hash(source_string_ptr);
            source_string_ptr->index++; /* to get the next character */
        }
        else if ((source_string_ptr->string_ptr[source_string_ptr->index] == (custom_get_atcmd_symbol())) &&
                 (source_string_ptr->index <= MAX_MULTIPLE_CMD_INFO_LEN))
        {
            /* the special symbol defined by customer is found,hence it is customer-defined command */
            ret_val = RMMI_CUSTOMER_CMD;
            source_string_ptr->index++; /* to get the next character */
        }
        else
        {
            /* the non '+' character was not found; take it
               to be basic command */
            ret_val = RMMI_BASIC_CMD;
        }
    }

    /* We didn't find the either "AT" or "A/". Either the command was too long, 
       or the characters were unrecognizable */
    else if (source_string_ptr->index >= MAX_MULTIPLE_CMD_INFO_LEN)
    {
        ret_val = RMMI_INVALID_CMD_TYPE;
    }
    /* unrecognizable command line prefix */
    else
    {
        ret_val = RMMI_INVALID_CMD_TYPE;
    }

    return ret_val;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_basic_cmd_processor
 * DESCRIPTION
 *  This is rmmi_basic_cmd_processor function of L4C module.
 *  process the basic command
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_basic_cmd_processor(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_TRUE;
    kal_uint16 cmd_index;
    rmmi_err_id_enum err_id;
    rmmi_multiple_basic_cmd_struct head_node_ptr;   
    kal_uint8 cid;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    l4c_context_struct *l4c_ptr = L4C_PTR;
    rmmi_common_context_struct *rmmi_comm_ptr = RMMI_COMM_PTR;

    //rmmi_multiple_basic_cmd_struct  *temp_ptr;

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_BASIC_CMD_PROCESSOR_ENTRY);
    ASSERT(source_string_ptr != NULL);
    err_id = RMMI_ERR_UNKNOWN;

    /* Store head node pointer of the linked list */
    //head_node_ptr = (rmmi_multiple_basic_cmd_struct*) (&rmmi_ptr->cmd_info.multiple_cmd);

    /* Skip all leading white spaces */
    rmmi_skip_spaces(source_string_ptr);


    cmd_index = source_string_ptr->cmd_index;

    if (cmd_index != RMMI_NO_CMD)
    {        
        cid = rmmi_srcid_2_cid(source_string_ptr->src_id);
        /* Calling temp validator using FSM */
        ret_val = (rmmi_basic_validator_ft[cmd_index]) (source_string_ptr, &head_node_ptr, &err_id);

        //ATD: no other basic command allowed in the same command line, so RETURN!
        //if ret_val == FALSE, print "NO CARRIER" instead of "ERROR."
        if ( (rmmi_comm_ptr->isAtdAction_flag & (0x01 << cid)) 
             #ifdef __UCM_SUPPORT__             
             || (rmmi_ptr->is_ata_action == KAL_TRUE)
             #endif
           )
        {
            if (ret_val == KAL_FALSE)
            {
                if(rmmi_ptr->response_type == RMMI_RCODE_BUSY)
                {
                    rmmi_result_code_fmttr(RMMI_RCODE_BUSY, RMMI_ERR_UNKNOWN);
                    rmmi_ptr->response_type = 0xff; //reset
                }									
                else 
                {
                    rmmi_result_code_fmttr(RMMI_RCODE_NO_CARRIER, RMMI_ERR_UNKNOWN);
                }

                #ifdef __UCM_SUPPORT__
                if (rmmi_ptr->is_ucm_action == KAL_TRUE)
                {
                    rmmi_ptr->is_ucm_action = KAL_FALSE; 
                }
                
                if (rmmi_ptr->is_ata_action == KAL_TRUE)
                {
                    rmmi_ptr->is_ata_action = KAL_FALSE;
                }
                #endif /* __UCM_SUPPORT__ */ 
            }
        #if defined(__PHB_APPROVE_BY_MMI__)
            else if (rmmi_comm_ptr->isAtdAction_flag & (0x01 << cid))
            {
                /* PHB approve by function call, OK has been printed before returning to here 
                   this flag shall be cleaned here
                */
                rmmi_comm_ptr->isAtdAction_flag &= ~(0x01 << cid);
            }
        #endif
            return;
        }

        if (ret_val == KAL_FALSE)
        {
            /* Send error response to TE */
            rmmi_result_code_fmttr(RMMI_RCODE_ERROR, (kal_uint16) err_id);
            #ifdef __UCM_SUPPORT__
                if (rmmi_ptr->is_ucm_action == KAL_TRUE)
                {
                    rmmi_ptr->is_ucm_action = KAL_FALSE;    
                }
            #endif /* __UCM_SUPPORT__ */ 
            return;
        }

        /* Update the command info into the RMMI context */
        //rmmi_ptr->cmd_info.which_present = RMMI_BASIC_COMMAND_PRESENT;
        /* Call the Basic command handler */

        /* update that some command has come, since we have already
           prcoessed some basic commands */
        //rmmi_ptr->cmd_present = KAL_TRUE;

        //we pass this four cc action in rmmi_uart_read_data, so we shall handle here
        if ((l4c_ptr->cc_current_action[source_string_ptr->src_id] == L4C_NO_ACTION ||
             l4c_ptr->cc_current_action[source_string_ptr->src_id] == ATD_EXE || //MAUI_01615322
             l4c_ptr->cc_current_action[source_string_ptr->src_id] == ATD_ECC || 
             l4c_ptr->cc_current_action[source_string_ptr->src_id] == ATD_ECC_CHANGE_RAT ||
             l4c_ptr->cc_current_action[source_string_ptr->src_id] == POWERON_EXE ||
             l4c_ptr->rac_current_action == RFON_ATTACH) &&
            //L4C_PTR->ss_current_action == L4C_NO_ACTION &&      
            rmmi_ptr->rmmi_atd_mem == RMMI_MEM_DIAL_NONE)
        {
            #ifdef __UCM_SUPPORT__
                if (rmmi_ptr->is_ucm_action == KAL_TRUE)
                {
                    kal_brief_trace(TRACE_INFO, UCM_ACTION);
                }
                else
            #endif /* __UCM_SUPPORT__ */ 

                if (l4c_ptr->route_thru_lmmi == KAL_TRUE && l4c_ptr->route_thru_lmmi_user == source_string_ptr->src_id)
                {
                    kal_brief_trace(TRACE_INFO, ROUTE_THRU_LMMI_FOR_BASIC_CMD);
                }
                else
                {
                    rmmi_result_code_fmttr(RMMI_RCODE_OK, 0);
                }
        }
#if defined(__PHB_APPROVE_BY_MMI__) && defined(__PS_DIALUP__)
        else if (PHB_FDN_CHECK == l4c_ptr->cc_current_action[source_string_ptr->src_id])
        {
            l4c_ptr->cc_current_action[source_string_ptr->src_id] = L4C_NO_ACTION; //MAUI_02956467_CGDATA_APPROVE_FAIL
        }
#endif /* defined(__PHB_APPROVE_BY_MMI__) && defined(__PS_DIALUP__) */
    }
    else
    {
        /* no command present */
        //rmmi_ptr->cmd_info.which_present = RMMI_NONE_PRESENT;
    
        /* no command came.for Eg:AT or at */
        rmmi_result_code_fmttr(RMMI_RCODE_OK, 0);

        #if 0 //def __MOD_TCM__ //mtk02285, 201003, 6251_ram
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #endif /* __MOD_TCM__ */ 
    }

    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_extended_cmd_processor
 * DESCRIPTION
 *  This is rmmi_extended_cmd_processor function of L4C module.
 *  parse for the command code and appropriate validator will be called
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_extended_cmd_processor(rmmi_string_struct *source_string_ptr)
{

    /* Variable to store the character value meant for searching the basic
       command present in the table */
    kal_uint16 cmd_index = RMMI_MAX_CMD_NUM;
    kal_uint16 cmd_row_index = RMMI_MAX_CMD_NUM;

    /* mtk00924 20050222 for __test_mode__ modification */
    kal_char const *rsp_str = NULL;
    kal_uint16 string_length = 0;
    kal_bool ret_val = KAL_TRUE;

    /* mtk00924 20050222 for __test_mode__ modification */

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_EXTENDED_CMD_PROCESSOR_ENTRY);
    ASSERT(source_string_ptr != NULL);

    cmd_index = source_string_ptr->cmd_index;
    cmd_row_index = source_string_ptr->cmd_row_index;

    /* check if cmd is allowed: pin, phb ready...etc */
    if (check_cmd_allow(cmd_index) == KAL_TRUE)
    {
        /* Update the command code and mode */
        //rmmi_cmd_code_mode_update(RMMI_EXTENDED_COMMAND_PRESENT, cmd_index, source_string_ptr->cmd_mode);

        /* mtk00924 20050222 for __test_mode__ modification */
        #ifndef __test_mode__
            if (source_string_ptr->cmd_mode == RMMI_TEST_MODE)
            {
                rsp_str = rmmi_test_mode_string_table[cmd_row_index];
                string_length = (kal_uint16)strlen(rsp_str);

                if (rmmi_need_enter(cmd_index) == KAL_TRUE)
                {
                    (rmmi_extended_validator_ft[cmd_row_index]) (source_string_ptr);
                    return;
                }

                if (
            #if !defined(__SLIM_AT__)
            #if !defined(__MMI_FMI__) 		
                       cmd_index == RMMI_CMD_ATCAPL ||
            #endif 
                       cmd_index == RMMI_CMD_ATCSMA ||     
            #ifdef __MOD_TCM__
                       cmd_index == RMMI_CMD_ATCGSDATA ||
            #endif 
                       cmd_index == RMMI_CMD_ATESIMS ||
            #endif /* !defined(__SLIM_AT__) */ 
                       cmd_index == RMMI_MAX_CMD_NUM)
                {
                    ret_val = KAL_FALSE;
                }
                rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);

            #ifdef __BT_SUPPORT__
                //#ifdef __BTVCSR_HP__

                if (cmd_index == RMMI_CMD_ATCHLD)
                {
                    kal_uint8 call_status, callsetup_status, service_status;

                    l4c_check_cind_status(&call_status, &service_status, &callsetup_status);
                    if (call_status == 1 || callsetup_status == 2 || callsetup_status == 3)
                    {
                        l4c_cc_handfree_rind(RMMI_CIND_CALL, call_status);
                        l4c_cc_handfree_rind(RMMI_CIND_CALLSETUP, callsetup_status);
                    }
                }
                //#endif /*__BTVCSR_HP__*/
            #endif /* __BT_SUPPORT__ */ 
                return;
            }
        #endif /* __test_mode__ */ 

            /* Calling validator using FSM */
        (rmmi_extended_validator_ft[cmd_row_index]) (source_string_ptr);
    }

    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_extended_command_analyzer
 * DESCRIPTION
 *  This is rmmi_extended_command_analyzer function of L4C module.
 *  find the command code to get the function pointer of the command handler
 * PARAMETERS
 *  hash_value1         [IN]        Hash value of the first 5 chars
 *  hash_value2         [IN]        Hash value of the rest chars
 *  cmd_index_ptr       [OUT]       pointer to store the command ID
 *  cmd_row_index_ptr   [OUT]       pointer to store the command table index 
 *                                  used to lookup tables
 * RETURNS
 *  kal_bool    command found in the hash table or not
 *****************************************************************************/
kal_bool rmmi_extended_command_analyzer(
        kal_uint32 hash_value1, kal_uint32 hash_value2, 
        kal_uint16 *cmd_index_ptr, kal_uint16*cmd_row_index_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 col_index = 0;
    kal_uint16 row_index;

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_EXTENDED_COMMAND_ANALYZER_ENTRY);
    ASSERT(cmd_index_ptr != NULL);
    if ((hash_value1 == 0) && (hash_value2 == 0))
    {
        return ret_val;
    }
    for (row_index = 0; row_index < RMMI_TOT_EXTEND_CMD; row_index++) //mtk02514_cmd
    {
        if ((hash_value1 ==
             rmmi_extended_cmd_table[row_index][col_index]) &&
            (hash_value2 == rmmi_extended_cmd_table[row_index][col_index + 1]))
        {
            *cmd_row_index_ptr = row_index;
            *cmd_index_ptr = rmmi_extended_cmd_id_table[row_index];
            ret_val = KAL_TRUE;
            break;
        }
    }
    kal_brief_trace(TRACE_INFO, INFO_EXTCOMMAND_HASH_VALUE, hash_value1, hash_value2, row_index, RMMI_TOT_EXTEND_CMD);

    return ret_val;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_basic_command_analyzer
 * DESCRIPTION
 *  This is rmmi_basic_command_analyzer function of L4C module.
 *  find the command code to get the function pointer of the command handler
 * PARAMETERS
 *  hash_value          [IN]        
 *  cmd_index_ptr       [OUT]       Function pointer to the command handler
 *  hash_value1(?)      [IN]        Hash value of the command code
 * RETURNS
 *  kal_bool    command found in the hash table or not
 *****************************************************************************/
kal_bool rmmi_basic_command_analyzer(
        kal_uint8 hash_value, 
        kal_uint16 *cmd_index_ptr, kal_uint16 *cmd_row_index_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 low = 0;
    kal_uint8 high = RMMI_TOT_BASIC_CMD - 1;
    kal_uint8 mid = 0;

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_BASIC_COMMAND_ANALYZER_ENTRY);
    ASSERT(cmd_index_ptr != NULL);
    while (low <= high)
    {
        mid = (low + high) >> 1;
        if (hash_value < rmmi_basic_cmd_table[mid])
        {
            high = mid - 1;
        }
        else if (hash_value > rmmi_basic_cmd_table[mid])
        {
            low = mid + 1;
        }
        else
        {
            *cmd_index_ptr = *cmd_row_index_ptr = mid;
            ret_val = KAL_TRUE;
            break;
        }
    }

    return ret_val;
}



