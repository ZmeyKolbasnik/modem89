/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 * RMMI_VALIDATOR_EQ.C
 *
 * Project:
 * --------
 *   MAUI
 *
 * Description:
 * ------------
 *   This file is intends for ï¿½K.
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
#include <stdio.h>
#include <string.h>
#include "kal_public_defs.h" //MSBB change #include "stack_config.h"
//#include "kal_non_specific_general_types.h"
//#include "ps_trace.h"
#include "kal_trace.h"
//#include "kal_release.h"
//#include "stack_common.h"
//#include "stack_msgs.h"
//#include "app_ltlcom.h" /* Task message communiction */
//#include "stacklib.h"   /* Basic type for dll, evshed, stacktimer */
//#include "app_buff_alloc.h"
//#include "stack_timer.h"
//#include "event_shed.h"
//#include "nvram_editor_data_item.h"
//#include "custom_nvram_editor_data_item.h"

#ifdef __MOD_SMU__
//#include "ps2sim_struct.h"
//#include "sim_common_enums.h"
//#include "smu_common_enums.h"
#endif /* __MOD_SMU__ */ 
#include "device.h"
//#include "csmss_common_enums.h"

//#include "mcd_l3_inc_struct.h"
//#include "mcd_l3_inc_gprs_struct.h"
//#include "l3_inc_enums.h"

//#include "mcd_l4_common.h"

#include "l4c_common_enum.h"
#include "rmmi_common_enum.h"
#include "rmmi_context.h"
#include "l4c_context.h"
#include "layer4_context.h"
//#include "l4c_rspfmttr.h"
//#include "l4c_msghdlr.h"
#include "l4_trc.h"
#include "atci_trc.h"
#include "l4c_utility.h"

#include "dcl.h"
//#include "l4_defs.h"
#include "csmcc_atfunc.h"
//#include "csmss_atfunc.h"
//#include "l4c_aux_struct.h"
//#include "l4c_ss_parse.h"

#ifdef __MOD_CSM__
//#include "mcd_ss_parameters.h"
//#include "mcd_ss_tcapmessages.h"
#include "l4c_common_enum.h"
//#include "csmcc_enums.h"
//#include "csmcc_common_enums.h"
//#include "ps2sat_struct.h"
//#include "l4c2csm_cc_struct.h"

//#include "l4c_ciss_cmd.h"
//#include "l4c2csm_ss_struct.h"
//#include "l4c_cc_cmd.h"
#endif /* __MOD_CSM__ */ 

#if defined (VM_SUPPORT)
//#include "med_struct.h"
#endif 
#ifdef __MOD_UEM__
#include "device.h"
//#include "l4c2uem_struct.h"
#include "uem_at_cmd.h"
//#include "custom_em.h"
#include "l4c_eq_cmd.h"
#endif /* __MOD_UEM__ */ 
#ifdef __MOD_RAC__
//#include "l4crac_func.h"
//#include "l4c_nw_cmd.h"
//#include "l4crac_enums.h"
#endif /* __MOD_RAC__ */ 
#ifdef __MOD_PHB__
//#include "sim_common_enums.h"
//#include "l4c2phb_enums.h"
//#include "l4c2phb_struct.h"
//#include "phb_sap.h"
//#include "l4c_phb_cmd.h"
//#include "phb_defs.h"
//#include "phb_config.h"
#endif /* __MOD_PHB__ */ 
#ifdef __MOD_SMSAL__
//#include "l4c2smsal_struct.h"
//#include "smsal_l4c_defs.h"
//#include "smsal_l4c_funcs.h"
//#include "smsal_l4c_enum.h"
//#include "smsal_defs.h"
//#include "l4c_sms_cmd.h"
#endif /* __MOD_SMSAL__ */ 
#ifdef __MOD_SMU__
//#include "ps2sat_struct.h"
//#include "mcd_ps2sat_peer.h" 
//#include "l4c_sim_cmd.h"
#endif /* __MOD_SMU__ */ 
#ifdef __MOD_TCM__
//#include "mmi_l3_enums.h"
//#include "mmi_sm_enums.h"
//#include "ppp_l4_enums.h"
//#include "tcm_common_enums.h"
//#include "tcm_common.h"
//#include "custom_nvram_editor_data_item.h"
//#include "l4c2abm_struct.h"
//#include "abm2l4c_struct.h"
//#include "l4c2tcm_struct.h"
//#include "l4c2tcm_func.h"
//#ifdef __TCPIP__
//#include "l4c2abm_struct.h"
//#endif /* __TCPIP__ */
//#include "l4c_gprs_cmd.h"
#endif /* __MOD_TCM__ */ 

//#include "l4c_utility.h"
#include "rmmi_rspfmttr.h"
#include "rmmi_utility.h"
#include "rmmi_sio.h"
//#include "rmmi_rsp.h"
//#include "rmmi_validator.h"
//#include "nvram_data_items.h"
//#include "custom_hw_default.h"
//#include "l4c_table.h"
//#include "rmmi_parser.h"
//#include "resource_verno.h"     // for +EGMR read MMI resource version

#ifdef __CSD_FAX__
//#include "csm_data_enums.h"
//#include "l4c2t30_struct.h"
//#include "l4c_t30_cmd.h"
//#include "l4c2t30_enums.h"
#endif /* __CSD_FAX__ */ 
//#include "rmmi_parser.h"
#ifndef MED_NOT_PRESENT
//#include "med_global.h"
//#include "med_main.h"
#endif /* MED_NOT_PRESENT */ 
//#ifdef __J2ME__
//#include "jam_msg_handler.h"
//#endif 

#if defined(__BT_SUPPORT__)
//#include "bluetooth_struct.h"
#endif 

#ifdef __CTM_SUPPORT__
//#include "med_struct.h"
#endif 
//#include "l4c_sendmsg.h"

#ifdef __CUST_NEW__
//#include "gpio_sw.h"
#endif 

/* for data item NVRAM_EF_IMEI_IMEISV_LID move */
//#include "nvram_user_defs.h"
//#include "csmcc_defs.h"

//#include "keypad_sw.h"
//#include "l4c2smu_struct.h"
#include "lmmi_ind.h"

//#include "csmcc_common_enums.h"

//#include "mncc_struct.h"
//#include "csmcc_bc_types.h"
//#include "csmcc_types.h"
//#include "custom_em.h"
//#include "L4c_ctm_cmd.h"
//#include "csmcc_utility.h"

//#include "sat_def.h"

#include "uem_proc_cmd.h"

//#include "rmmi_msghdlr.h"

#include "kal_general_types.h"
#include "kal_public_api.h"
#include "ps_public_enum.h"
#include "ps_public_struct.h"
#if !defined(__SLIM_AT__)
#include "l1audio.h"
#endif

#include "ps_public_utility.h"
#if defined(__AT_IPR_WRITE_FS_SUPPORT__)
#include "nvram_struct.h"
#endif

#ifdef FMT_NOT_PRESENT
#define RMMI_MAX_IMAGE_FILE_NAME 30
#define RMMI_MAX_MELODY_FILE_NAME 30
#else /* FMT_NOT_PRESENT */ 
#define RMMI_MAX_IMAGE_FILE_NAME 250
#define RMMI_MAX_MELODY_FILE_NAME 250
#endif /* FMT_NOT_PRESENT */ 

extern UART_PORT PS_UART_PORT;
extern kal_uint16 rmmi_get_ckpd_default_time(void);
extern kal_uint16 rmmi_get_ckpd_default_pause(void);
#ifdef __CLAC_SUPPORT__
extern kal_bool rmmi_remove_listing_at_command(const kal_char*rsp_str);
extern kal_uint16 rmmi_add_listing_at_command(kal_char **rsp_str);
#endif

#if defined(__MOD_UEM__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_cgmr_hdlr
 * DESCRIPTION
 *  Request revision identification
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
extern kal_char *build_date_time(void);
void rmmi_cgmr_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 eq_id[NVRAM_EF_BARCODE_NUM_SIZE + 1];
    kal_uint8 buffer[MAX_UART_LENGTH];
    kal_uint8 build_time[20];
    kal_uint16 string_length = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CGMR_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_ACTIVE_MODE:
        {
            ret_val = get_ms_revision(L4C_SW_CODE, (kal_uint8*) eq_id);
            kal_mem_cpy(build_time, (kal_uint8*) build_date_time(), 20);

            if (ret_val == KAL_TRUE)
            {
                rmmi_ptr->arg_list[0] = (void*)eq_id;
                rmmi_ptr->arg_list[1] = (void*)build_time;

                #ifdef __AT_ME_IDENTIFICATION_WITHOUT_HEADER__
                string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "%s, %s", rmmi_ptr->arg_list, 2);
                #else
                string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CGMR: %s, %s", rmmi_ptr->arg_list, 2);
                #endif
            }
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) buffer, string_length);
} /* end of rmmi_cgmr_hdlr  */

/*****************************************************************************
 * FUNCTION
 *  rmmi_cmer_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for +CMER
 *  So far we only support keypad even reporting
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cmer_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];   /* temp buffer for response format usage */
    kal_uint16 string_length = 0;           /* string length variable */
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    /* checking the command mode */
    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:    /* at+cmer? query for parameter setting  */
        {
            rmmi_ptr->arg_list[0] = (void*)&rmmi_ptr->report_mode.cmer_mode;
            rmmi_ptr->arg_list[1] = (void*)&rmmi_ptr->report_mode.cmer_keyp;
            rmmi_ptr->arg_list[2] = (void*)&rmmi_ptr->report_mode.cmer_ind;
            rmmi_ptr->arg_list[3] = (void*)&rmmi_ptr->report_mode.cmer_bfr;
            #if defined(__MMI_FMI__) && defined(TOUCH_PANEL_SUPPORT)
            rmmi_ptr->arg_list[4] = (void*)&rmmi_ptr->report_mode.cmer_tscrn;
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CMER: %d,%d,0,%d,%d,%d", rmmi_ptr->arg_list, 5);
            #else
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CMER: %d,%d,0,%d,%d", rmmi_ptr->arg_list, 4);
            #endif
            rsp_str = &buffer[0];
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;
            kal_uint8 mode;
            kal_uint8 keyp;
            kal_uint8 disp;
            kal_uint8 ind;
            kal_uint8 bfr;
            #if defined(__MMI_FMI__) && defined(TOUCH_PANEL_SUPPORT)
            kal_uint8 tscrn = 0;
            #endif

            /* Get the <mode> */
            mode = (kal_uint8) rmmi_int_validator_range_check(&error_cause, 
                                                              source_string_ptr, 
                                                              (kal_uint8) RMMI_COMMA, 
                                                              3);
            if (mode == RMMI_VALIDATOR_ERROR)
            {
                if (error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    mode = 0;
                }
                else
                {
                    break;
                }
            }

            /* Get the <keyp> */
            keyp = (kal_uint8) rmmi_int_validator_range_check(&error_cause, 
                                                              source_string_ptr, 
                                                              (kal_uint8) RMMI_COMMA, 
                                                              2);
            if (keyp == RMMI_VALIDATOR_ERROR)
            {
                if (error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    keyp = 0;
                }
                else
                {
                    break;
                }
            }

            //get <disp>
            disp = (kal_uint8) rmmi_int_validator_range_check(&error_cause, 
                                                               source_string_ptr,
                                                               (kal_uint8) RMMI_COMMA,
                                                               0);
            if (disp == RMMI_VALIDATOR_ERROR)
            {
                if (error_cause != RMMI_PARSE_NOT_FOUND)
                {
                    break;
                }
                else
                {
                    disp = 0;
                }
            }

            //get <ind> 
            ind = (kal_uint8) rmmi_int_validator_range_check(&error_cause, 
                                                              source_string_ptr, 
                                                              (kal_uint8) RMMI_COMMA, 
                                                              2);
            if (ind == RMMI_VALIDATOR_ERROR)
            {
                if (error_cause != RMMI_PARSE_NOT_FOUND)
                {
                    break;
                }
                else
                {
                    ind = 0;
                }
            }

            //get <bfr> 
            bfr = (kal_uint8) rmmi_int_validator_range_check(&error_cause,
                                                             source_string_ptr,
                                                             (kal_uint8) RMMI_COMMA,
                                                             1);
            if (bfr == RMMI_VALIDATOR_ERROR)
            {
                if (error_cause != RMMI_PARSE_NOT_FOUND)
                {
                    break;
                }
                else
                {
                    bfr = 0;
                }
            }

            #if defined(__MMI_FMI__) && defined(TOUCH_PANEL_SUPPORT)
            /* Get <tscrn> */
            tscrn = (kal_uint8)rmmi_int_validator_range_check(&error_cause, source_string_ptr, rmmi_ptr->s_reg.s3, 3);
            if(tscrn == RMMI_VALIDATOR_ERROR)
            {
                if(error_cause != RMMI_PARSE_NOT_FOUND)
                {
                    break;
                }
                else
                {
                    tscrn = 0;
                }
            }
            rmmi_ptr->report_mode.cmer_tscrn = tscrn;
            #endif
            rmmi_ptr->report_mode.cmer_mode = mode;
            rmmi_ptr->report_mode.cmer_keyp = keyp;
            rmmi_ptr->report_mode.cmer_ind = ind;
            rmmi_ptr->report_mode.cmer_bfr = bfr;
            rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);

            if ((mode >= 1) && (mode <= 3))
            {
                if (bfr == 1)
                {
                    rmmi_flush_ResultCodeBuffer((void*)&rmmi_ptr->CNMI_ResultCodeBuffer, KAL_TRUE);
                }
                else
                {
                    rmmi_flush_ResultCodeBuffer((void*)&rmmi_ptr->CNMI_ResultCodeBuffer, KAL_FALSE);
                }
            }
            l4c_eq_keypad_event_act_lind(keyp);
            #if defined(__MMI_FMI__) && defined(TOUCH_PANEL_SUPPORT)
            l4c_eq_scrntch_event_act_lind(tscrn);
            #endif
            return;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
} /* end of rmmi_cmer_hdlr */

#if !defined(__ULC_AT__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_ifc_hdlr
 * DESCRIPTION
 *  used to set local flow control
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_ifc_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 dce_by_dte, dte_by_dce, flow_ctrl;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

#ifdef UART_ENABLE
    UART_CONFIG_T dcb = 
    {
        0,          /* init */
        len_8,      /* dataBits; */
        sb_1,       /* stopBits; */
        pa_none,    /* parity; */
        fc_none,    /* flow control */
        0x11,       /* xonChar; */
        0x13,       /* xoffChar; */
        KAL_FALSE
    };
#endif /* UART_ENABLE */ 

    switch (source_string_ptr->cmd_mode)
    {

        case RMMI_READ_MODE:
        {
        #ifdef UART_ENABLE

            #if defined(__CMUX_SUPPORT__)
                /* MAUI_02281302 avoid to call uart function when CMUX enable */
                if(RMMI_COMM_PTR->cmux_enable == KAL_TRUE)
                {
                    break;
                }
            #endif
            
            RMMI_UART_ReadDCBConfig(PS_UART_PORT, &dcb, MOD_ATCI);
        #endif 
            kal_trace(TRACE_INFO, INFO_FC, dcb.u1FlowControl);
            if (dcb.u1FlowControl == fc_none)
            {
                flow_ctrl = 0;
            }
            else if (dcb.u1FlowControl == fc_sw)
            {
                flow_ctrl = 1;
            }
            else if (dcb.u1FlowControl == fc_hw)
            {
                flow_ctrl = 2;
            }
            else
            {
                flow_ctrl = (kal_uint8) dcb.u1FlowControl;
            }

            rmmi_ptr->arg_list[0] = (void*)&flow_ctrl;
            rmmi_ptr->arg_list[1] = (void*)&flow_ctrl;

            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+IFC: %d, %d", rmmi_ptr->arg_list, 2);
            rsp_str = &buffer[0];
            ret_val = KAL_TRUE;
            break;
        }

        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;

            dce_by_dte = (kal_uint8) rmmi_int_validator_range_check(&error_cause,
                                                                    source_string_ptr,
                                                                    (kal_uint8) RMMI_COMMA,
                                                                    2);

            if (dce_by_dte == RMMI_VALIDATOR_ERROR)
            {
                break;
            }

            dte_by_dce = (kal_uint8) rmmi_int_validator_range_check(&error_cause,
                                                                    source_string_ptr,
                                                                    rmmi_ptr->s_reg.s3,
                                                                    0xff);

            if (dte_by_dce == RMMI_VALIDATOR_ERROR)
            {
                if (error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    dte_by_dce = dce_by_dte;
                }
                else
                {
                    break;
                }
            }

            if (dte_by_dce != dce_by_dte)
            {
                break;
            }

            if (dte_by_dce == 0)
            {
                dcb.u1FlowControl = fc_none;
            }
            else if (dte_by_dce == 1)
            {
                dcb.u1FlowControl = fc_sw;
            }
            else if (dte_by_dce == 2)
            {
                dcb.u1FlowControl = fc_hw;
            }
            else
            {
                break;
            }

            if (RMMI_UART_GetOwnerID(PS_UART_PORT) != MOD_ATCI)
            {
                break;
            }
            else
            {
            #ifdef UART_ENABLE

                #if defined(__CMUX_SUPPORT__)
                    /* MAUI_02281302 avoid to call uart function when CMUX enable */
                    if(RMMI_COMM_PTR->cmux_enable == KAL_TRUE)
                    {
                        break;
                    }
                #endif
            
                RMMI_UART_SetDCBConfig(PS_UART_PORT, &dcb, MOD_ATCI);
            #endif 
            }

            ret_val = KAL_TRUE;
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }
    /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
} /* end of rmmi_ifc_hdlr */


/*****************************************************************************
 * FUNCTION
 *  rmmi_ipr_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_ipr_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    kal_uint32 rate = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:
        {
        #ifdef UART_ENABLE
            UART_CONFIG_T dcb;

            #if defined(__CMUX_SUPPORT__)
                /* MAUI_02281302 avoid to call uart function when CMUX enable */
                if(RMMI_COMM_PTR->cmux_enable == KAL_TRUE)
                {
                    break;
                }
            #endif

            RMMI_UART_ReadDCBConfig(PS_UART_PORT, &dcb, MOD_ATCI);
            rate = (kal_uint32) dcb.u4Baud;
        #endif /* UART_ENABLE */ 

            rmmi_ptr->arg_list[0] = (void*)&rate;
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+IPR: %e", rmmi_ptr->arg_list, 1);
            rsp_str = &buffer[0];
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            rate = rmmi_int_validator(
                    source_string_ptr,
                    rmmi_ptr->s_reg.s3 /* separator */ );
            if ((rate == 0) || (rate == 75) || (rate == 150) || (rate == 300) || (rate == 600) ||
                (rate == 1200) || (rate == 2400) || (rate == 4800) || (rate == 7200) || (rate == 9600) || (rate == 14400) || (rate == 19200) ||
                (rate == 28800) || (rate == 38400) || (rate == 57600) || (rate == 115200) || (rate == 230400) || (rate == 460800) || (rate == 921600))
            {
                //these values are acceptable
            }
            else
            {
                break;
            }

			
        #ifdef UART_ENABLE
            {
                UART_CONFIG_T dcb;

                #if defined(__CMUX_SUPPORT__)
                    /* MAUI_02281302 avoid to call uart function when CMUX enable */
                    if(RMMI_COMM_PTR->cmux_enable == KAL_TRUE)
                    {
                        break;
                    }
                #endif
                #if defined(__AT_IPR_WRITE_FS_SUPPORT__)
                    /* Check if current PS_UART_PORT is USB port. USB port will be auto baud, no need to write NVRAM*/
                    if(PS_UART_PORT >= uart_port_usb)
                    {
                        rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
                        kal_sleep_task(100); // add this delay to prevent "OK" sent with new baud rate
                
                        RMMI_UART_ReadDCBConfig(PS_UART_PORT, &dcb, MOD_ATCI);
                        dcb.u4Baud = rate;
                        RMMI_UART_SetDCBConfig(PS_UART_PORT, &dcb, MOD_ATCI); 

                    }
                    else
                    {
                        nvram_read_req_struct *param_ptr;
                         
                        /* Read then Write NVRAM, return OK on receiving NVRAM write CNF*/
                        if(is_eq_cmd_conflict(source_string_ptr->src_id, ATIPR_SET))
                        {
                            break;
                        }
                        l4c_set_user_action(L4C_EQ, source_string_ptr->src_id, ATIPR_SET);
                        rmmi_ptr->atipr_rate = rate;
                        
                        param_ptr = (nvram_read_req_struct*)l4c_construct_nvram_read_local_para(source_string_ptr->src_id,
                                                                                                NVRAM_EF_PORT_SETTING_LID,
                                                                                                1,
                                                                                                1);

                        l4c_send_msg_to_nvm(MSG_ID_NVRAM_READ_REQ, param_ptr, NULL, 0);
                    }
                #else /* __AT_IPR_WRITE_FS_SUPPORT__ */
                    rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
	            kal_sleep_task(100); // add this delay to prevent "OK" sent with new baud rate

                    RMMI_UART_ReadDCBConfig(PS_UART_PORT, &dcb, MOD_ATCI);
                    dcb.u4Baud = rate;
                    RMMI_UART_SetDCBConfig(PS_UART_PORT, &dcb, MOD_ATCI);
                #endif /* __AT_IPR_WRITE_FS_SUPPORT__ */
            }
        #ifdef __CSD_FAX__
            if (rate == 0)
            {
                RMMI_UART_SetAutoBaud_Div(PS_UART_PORT, MOD_ATCI);
            }
        #endif /* __CSD_FAX__ */ 
            
        #else /* UART_ENABLE */
            rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
        #endif /* UART_ENABLE */ 
            return;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
} /* end of rmmi_ipr_hdlr */


// MMI/Modem both:
/*****************************************************************************
 * FUNCTION
 *  rmmi_cala_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cala_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 result;
    kal_uint8 time[25];
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    #if defined(__MMI_FMI__)
    l4c_context_struct *l4c_ptr = L4C_PTR;
    #endif

    kal_trace(TRACE_FUNC, FUNC_RMMI_CALA_HDLR_ENTRY);
    rmmi_ptr->cmd_mode = source_string_ptr->cmd_mode;
    rmmi_ptr->action_cmd = source_string_ptr->cmd_index;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_TEST_MODE:
        {
        #ifndef __MMI_FMI__
            kal_sprintf((char*)buffer, "+CALA: (0)");
            string_length = (kal_uint16)strlen((char*)buffer);
            ret_val = KAL_TRUE;
            break;
        #else /* __MMI_FMI__ */ 
            l4c_eq_at_alarm_query_req_lind();
            l4c_ptr->route_thru_lmmi = KAL_TRUE;
            l4c_ptr->route_thru_lmmi_user = source_string_ptr->src_id;			
            return;
        #endif /* __MMI_FMI__ */ 

            /*
             * ret_val = l4cuem_test_alarm_setting (&rsp_str);
             * string_length = strlen ((char *)rsp_str);
             * break;
             */
        }
        case RMMI_READ_MODE:
        {

        #ifdef __MMI_FMI__
            /* send query ind to MMI */
            l4c_eq_at_alarm_query_req_lind();
            l4c_ptr->route_thru_lmmi = KAL_TRUE;
            l4c_ptr->route_thru_lmmi_user = source_string_ptr->src_id;			
            return;

        #else /* __MMI_FMI__ */ 
            /* only AT, get hw_time from UEM */
            rtc_alarm_info_struct alarm;
            kal_uint8 date_mode, time_mode;

            ret_val = l4cuem_rtc_get_hw_time_req(RTC_ALARM_IND, 0, (rtc_alarm_info_struct*) & alarm);
            if (ret_val == KAL_TRUE)
            {
                /* transform rtc time back to string */
                if (rmmi_ptr->date_aux_mode == 2)
                {
                    date_mode = DATE_AUX_YYYY_MM_DD;
                }
                else
                {
                    date_mode = DATE_AUX_YY_MM_DD;
                }
                time_mode = TIME_HH_MM_24;
                rtc_to_string_format((kal_uint8*) time, date_mode, time_mode, &alarm.data_time);

                rmmi_ptr->arg_list[0] = (void*)time;
                string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CALA: \"%s\"", rmmi_ptr->arg_list, 1);
            }
            else
            {
                /* UEM return FALSE means there is no alarm in target, AT will return OK*/
                ret_val = KAL_TRUE;
            }
            break;
        #endif /* __MMI_FMI__ */ 
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;
            kal_uint8 *time_ptr;

        #ifdef __MMI_FMI__
            /* parse <time>, <index> and <recurr>, send indication to MMI */

            mmi_at_alarm_info_struct alarm;
            kal_uint8 recurr_string[14];
            kal_uint8 alarm_type;
            kal_bool error_flag = KAL_FALSE;

            /* parse <time> */
            result = rmmi_string_validator_ext(
                        &error_cause,
                        source_string_ptr,
                        (kal_uint8) RMMI_COMMA,
                        25,
                        (kal_uint8*) time);
            if (result == RMMI_VALIDATOR_ERROR)
            {
                break;
            }

            if (rmmi_ptr->date_aux_mode == 2)   //we convert yyyy/MM/dd to  yy/MM/dd
            {
                time_ptr = &time[2];    // ignore first 2 chars "yy"
            }
            else
            {
                time_ptr = time;
            }
            ret_val = string_to_rtc_format(&alarm.date_time, (kal_uint8*) time_ptr);
            if (ret_val == KAL_FALSE)
            {
                break;
            }

            /* get <index> */
            ret_val = KAL_FALSE;
            alarm.alarm_index = (kal_uint8) rmmi_int_validator_range_check(&error_cause,
                                                                           source_string_ptr,
                                                                           (kal_uint8) RMMI_COMMA,
                                                                           0xff);
            if (alarm.alarm_index == RMMI_VALIDATOR_ERROR)
            {
                if (error_cause != RMMI_PARSE_NOT_FOUND)
                {
                    break;
                }
                else
                {
                    alarm.alarm_index = 0;
                }
            }

            /* we don't care alarm_type */
            alarm_type = (kal_uint8) rmmi_int_validator_ext(
                                        &error_cause,
                                        source_string_ptr,
                                        (kal_uint8) RMMI_COMMA /* separator */ );
            if ((error_cause != RMMI_PARSE_OK) && (error_cause != RMMI_PARSE_NOT_FOUND))
            {
                break;
            }
            /* we don't care text */
            result = rmmi_string_validator_ext(
                        &error_cause,
                        source_string_ptr,
                        (kal_uint8) RMMI_COMMA, /* separator */
                        30,
                        (kal_uint8*) buffer);
            if (result == RMMI_VALIDATOR_ERROR)
            {
                if ((error_cause == RMMI_PARSE_NOT_FOUND) || (error_cause == RMMI_PARSE_OK))
                {
                    //there is no text appears.
                }
                else
                {
                    break;
                }
            }

            /* get <recurr> */
            result = rmmi_string_validator_ext(
                        &error_cause,
                        source_string_ptr,
                        (kal_uint8) rmmi_ptr->s_reg.s3, /* separator */
                        14,
                        (kal_uint8*) recurr_string);

            if (result == RMMI_VALIDATOR_ERROR)
            {
                if ((error_cause == RMMI_PARSE_NOT_FOUND) || (error_cause == RMMI_PARSE_OK))
                {
                    alarm.recurr = 0;
                }
                else
                {
                    break;
                }
            }
            else
            {
                kal_uint8 recurr_value[7];
                kal_uint8 num, i;

                kal_uint8 length;
                kal_uint16 temp_value;
                rmmi_string_struct source;

                alarm.recurr = 0;
                source.index = 0;;
                source.string_ptr = recurr_string;
                length = strlen((char*)recurr_string);
                num = 0;
                if (source.string_ptr[length] != rmmi_ptr->s_reg.s3)
                {
                    source.string_ptr[length] = rmmi_ptr->s_reg.s3;
                }

                //get "x,y,z.."
                while (source.index < length)
                {
                    temp_value = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                                            &source,
                                                                            (kal_uint8) RMMI_COMMA,
                                                                            7);
                    kal_trace(TRACE_INFO, INFO_TEMP_VALUE, temp_value);
                    if (temp_value == RMMI_VALIDATOR_ERROR)
                    {
                        error_flag = KAL_TRUE;
                        break;
                    }
                    recurr_value[num] = (kal_uint8) temp_value;
                    num++;
                }

                // check "0" should appear alone.  e.g "0,1,3" is wrong .
                if (num > 1)
                {
                    for (i = 0; i < num; i++)
                    {
                        if (recurr_value[i] == 0)
                        {
                            error_flag = KAL_TRUE;
                            break;
                        }
                    }
                }

                if (error_flag == KAL_TRUE)
                {
                    break;
                }

                // recurr = "0"  : set for all days in this week
                if (recurr_value[0] == 0)
                {
                    alarm.recurr = 0x7F;
                }
                else
                {
                    for (i = 0; i < num; i++)
                    {
                        alarm.recurr |= 0x01 << (recurr_value[i] % 7);
                    }
                }

            }

            kal_trace(TRACE_GROUP_3, INFO_ALARM_RECURR, alarm.recurr);
            l4c_eq_at_alarm_set_req_lind(alarm);
            l4c_ptr->route_thru_lmmi = KAL_TRUE;
            l4c_ptr->route_thru_lmmi_user = source_string_ptr->src_id;			
            return;

        #else /* __MMI_FMI__ */ 
            /* only AT, only parse <time> and set to UEM */

            rtc_alarm_info_struct alarm1;

            /* parse <time> */
            result = rmmi_string_validator_ext(
                        &error_cause,
                        source_string_ptr,
                        (kal_uint8) RMMI_COMMA,
                        25,
                        (kal_uint8*) time);
            if (result == RMMI_VALIDATOR_ERROR)
            {
                break;
            }

            if (rmmi_ptr->date_aux_mode == 2)   //we convert yyyy/MM/dd to  yy/MM/dd
            {
                time_ptr = &time[2];    // ignore first 2 chars "yy"
            }
            else
            {
                time_ptr = time;
            }
            ret_val = string_to_rtc_format(&alarm1.data_time, (kal_uint8*) time_ptr);
            if (ret_val == KAL_FALSE)
            {
                break;
            }

            alarm1.alarm_format = DEVICE_AL_EN_ChkYMDHMS;
            alarm1.alarm_index = RTC_ALARM1_IND;
            alarm1.type = RTC_ALARM_SOUND;
            alarm1.text[0] = '\0';
            alarm1.recurr = RTC_ALARM_DAY1;
            ret_val = l4c_eq_exe_rtc_time_req(source_string_ptr->src_id, RTC_ALARM_IND, RTC_SETTING_TYPE_DATETIME, alarm1);
            break;
        #endif /* __MMI_FMI__ */ 
        }

        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) buffer, string_length);
    return;
} /* end of rmmi_cala_hdlr */


/*****************************************************************************
 * FUNCTION
 *  rmmi_cald_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cald_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 index;
    kal_uint16 string_length = 0;
    kal_uint8 const *rsp_str = NULL;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    #if defined(__MMI_FMI__)
    l4c_context_struct *l4c_ptr = L4C_PTR;
    #endif


    kal_trace(TRACE_FUNC, FUNC_RMMI_CALD_HDLR_ENTRY);

    rmmi_ptr->cmd_mode = source_string_ptr->cmd_mode;
    rmmi_ptr->action_cmd = source_string_ptr->cmd_index;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_TEST_MODE:
        {
        #ifndef __MMI_FMI__
            rsp_str = (kal_uint8 const*)"+CALD: (0)";
            string_length = (kal_uint16)strlen((char*)rsp_str);
            ret_val = KAL_TRUE;
            break;
        #else /* __MMI_FMI__ */ 
            l4c_eq_at_alarm_query_req_lind();
            l4c_ptr->route_thru_lmmi = KAL_TRUE;
            l4c_ptr->route_thru_lmmi_user = source_string_ptr->src_id;			
            return;
        #endif /* __MMI_FMI__ */ 
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            index = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                               source_string_ptr,
                                                               rmmi_ptr->s_reg.s3,
                                                               0xff);
            if(index == RMMI_VALIDATOR_ERROR)
            {
                break;/* index = 255 is not available now, so ignor user input index = 255 */
            }
        #ifdef __MMI_FMI__
            l4c_eq_at_alarm_delete_req_lind(index);
            l4c_ptr->route_thru_lmmi = KAL_TRUE;
            l4c_ptr->route_thru_lmmi_user = source_string_ptr->src_id;			
            return;
        #else /* __MMI_FMI__ */ 
            if (index != 0)
            {
                break;
            }
            ret_val = l4c_eq_exe_rtc_delete_req(source_string_ptr->src_id, RTC_ALARM_IND, RTC_ALARM1_IND);
            break;
        #endif /* __MMI_FMI__ */ 
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
} /* end of rmmi_cald_hdlr */


/*****************************************************************************
 * FUNCTION
 *  rmmi_cclk_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cclk_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 result;
    kal_uint8 num;
    kal_uint8 date_mode, time_mode;
    kal_uint8 time[25];
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    kal_uint8 const *rsp_str = NULL;
    rtc_alarm_info_struct rtc;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CCLK_HDLR_ENTRY);
    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            /*
             * ret_val = l4cuem_test_clock_setting (&rsp_str);
             * string_length = strlen ((char *)rsp_str);
             * 
             * break;
             */
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_READ_MODE:
        {
            ret_val = l4c_eq_get_rtc_time_req(
                        source_string_ptr->src_id,
                        RTC_TIME_CLOCK_IND,
                        &num,
                        (rtc_alarm_info_struct*) & rtc);

            if (ret_val == KAL_TRUE)
            {

                /* transform rtc time back to string */
                // l4c_eq_get_date_time_format_req (source_string_ptr->src_id, KAL_TRUE, &date_mode);
                // l4c_eq_get_date_time_format_req (source_string_ptr->src_id, KAL_FALSE, &time_mode);
                if (rmmi_ptr->date_aux_mode == 2)
                {
                    date_mode = DATE_AUX_YYYY_MM_DD;
                }
                else
                {
                    date_mode = DATE_AUX_YY_MM_DD;
                }

                time_mode = TIME_HH_MM_24;

                rtc_to_string_format((kal_uint8*) time, date_mode, time_mode, &(rtc.data_time));

                rmmi_ptr->arg_list[0] = (void*)time;
                string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CCLK: \"%s\"", rmmi_ptr->arg_list, 1);
                rsp_str = &buffer[0];
            }
            break;

        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            result = rmmi_string_validator(
                        source_string_ptr,
                        rmmi_ptr->s_reg.s3, /* separator */
                        25,
                        (kal_uint8*) time);

            if (result == RMMI_VALIDATOR_ERROR)
            {
                break;
            }

            /* transform time into rtc format */
            ret_val = string_to_rtc_format(&rtc.data_time, (kal_uint8*) time);

            if (ret_val == KAL_FALSE)
            {
                break;
            }

        #ifdef __MMI_FMI__
            /* route through MMI to set RTC time */
            ret_val = l4c_eq_set_rtc_time_req(
                        source_string_ptr->src_id,
                        RTC_TIME_CLOCK_IND,
                        RTC_SETTING_TYPE_DATETIME,
                        rtc);
            return;     //Mtk00924_060215: wait for MMI's general_res_req to return OK or ERROR
        #else /* __MMI_FMI__ */ 
            ret_val = l4c_eq_exe_rtc_time_req(
                        source_string_ptr->src_id,
                        RTC_TIME_CLOCK_IND,
                        RTC_SETTING_TYPE_DATETIME,
                        rtc);
        #endif /* __MMI_FMI__ */ 
            break;
        }

        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
} /* end of rmmi_cclk_hdlr */

#endif /*!defined(__ULC_AT__) */


#if defined (__MMI_FMI__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_ckpd_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_ckpd_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 result;
    kal_uint8 key[170], keycode[170];
    kal_uint16 time;
    kal_uint16 pause;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CKPD_HDLR_ENTRY);


    if ( source_string_ptr->src_id != RMMI_SRC )
    {
        rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
        return;
    }

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_TEST_MODE:
        {
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;
            kal_uint8 error_cause1;
            kal_uint8 cid;

	     if (rmmi_ptr->cmec_keyp == 0) 
	     {
		  break;
	     }

            cid = rmmi_srcid_2_cid(source_string_ptr->src_id);

            if (RMMI_COMM_PTR->is_multi_cmd & (0x01 << cid))
            {
                kal_trace(TRACE_GROUP_3, ANY_CMD_AFTER_CKPD_IN_MULTI_CMD_IS_NOT_ALLOWED);
                rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
                return;
            }

            result = rmmi_string_validator_ext(
                        &error_cause,
                        source_string_ptr,
                        (kal_uint8) RMMI_COMMA, /* separator */
                        170,
                        (kal_uint8*) key);

            if (result == RMMI_VALIDATOR_ERROR)
            {
                break;
            }

            if (check_keypad_code((kal_uint8*) key, (kal_uint8*) keycode) == KAL_FALSE)
            {
                break;
            }

            time = (kal_uint16) rmmi_int_validator_range_check((kal_uint8*)&error_cause,
                                                               source_string_ptr,
                                                               (kal_uint8) RMMI_COMMA,
                                                               255);
            if (error_cause == RMMI_PARSE_ERROR)
            {
                break;
            }
            else if (error_cause == RMMI_PARSE_NOT_FOUND)
            {
                time = rmmi_get_ckpd_default_time();
            }

            pause = (kal_uint16) rmmi_int_validator_range_check((kal_uint8*)&error_cause1,
                                                                source_string_ptr,
                                                                (kal_uint8) rmmi_ptr->s_reg.s3,
                                                                255);
            //if pause exist we should have time value otherwise error return
            if (error_cause1 == RMMI_PARSE_OK && error_cause == RMMI_PARSE_NOT_FOUND)
            {
                break;
            }
            else if (error_cause1 == RMMI_PARSE_ERROR)
            {
                break;
            }
            else if (error_cause1 == RMMI_PARSE_NOT_FOUND)
            {
                pause = rmmi_get_ckpd_default_pause();
            }

            ret_val = l4c_eq_set_keypad_input_req(source_string_ptr->src_id, keycode, (kal_uint8) time, (kal_uint8) pause);
            if (ret_val == KAL_TRUE)
            {
                return;
            }
            break;
        }

        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    if(ret_val == KAL_FALSE)
        kal_trace(TRACE_ERROR, ERROR_CKPD_INPUT_FORMAT_ERROR);

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}
#endif /*defined (__MMI_FMI__)*/


/*****************************************************************************
 * FUNCTION
 *  rmmi_cgmm_hdlr
 * DESCRIPTION
 *  Request model identification
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cgmm_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 eq_id[UEM_EQUIP_ID_LEN];
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CGMM_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_ACTIVE_MODE:
        {
            ret_val = l4c_eq_get_equip_id_req(source_string_ptr->src_id, EQ_ME_MODEL_ID, (kal_uint8*) eq_id);

            if (ret_val == KAL_TRUE)
            {
                rmmi_ptr->arg_list[0] = (void*)eq_id;
                #ifdef __AT_ME_IDENTIFICATION_WITHOUT_HEADER__
                string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "%s", rmmi_ptr->arg_list, 1);
                #else
                string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CGMM: %s", rmmi_ptr->arg_list, 1);
                #endif
            }
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) buffer, string_length);
} /* end of rmmi_cgmm_hdlr */


/*****************************************************************************
 * FUNCTION
 *  rmmi_cmec_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cmec_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint8 keyp, disp, ind, error_cause;
    kal_uint16 string_length = 0;
    kal_uint8 const *rsp_str = NULL;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CMEC_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_TEST_MODE:
        {
            rsp_str = (kal_uint8 const*)"+CMEC: (0,2),(0),(0)";
            string_length = (kal_uint16)strlen((char*)rsp_str);
            ret_val = KAL_TRUE;
            break;
        }
	 case RMMI_READ_MODE:
	 {
            rmmi_ptr->arg_list[0] = (void*)&rmmi_ptr->cmec_keyp;
            rmmi_ptr->arg_list[1] = (void*)&rmmi_ptr->cmec_disp;
            rmmi_ptr->arg_list[2] = (void*)&rmmi_ptr->cmec_ind;

            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CMEC: %d, %d, %d", rmmi_ptr->arg_list, 3);
            rsp_str = &buffer[0];
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            keyp = (kal_uint8) rmmi_int_validator_range_check(
                                &error_cause,
                                source_string_ptr,
                                (kal_uint8) RMMI_COMMA,
                                2);

	    if (keyp == RMMI_VALIDATOR_ERROR)
           {
         	  if (error_cause == RMMI_PARSE_NOT_FOUND)
             	  {
                	// parmater mode is not given (return "OK" and do nothing)
              	ret_val = KAL_TRUE;
		  }
                break;
            }
	     else
	     {
		  if (keyp == 1) //only supoort 0,2
		  {
			break;
		  }	 
		  else
		  {
                	rmmi_ptr->cmec_keyp = keyp;
		  }
	     }
		 
            disp = (kal_uint8) rmmi_int_validator_range_check(
                                &error_cause,
                                source_string_ptr,
                                (kal_uint8) RMMI_COMMA,
                                0);
			
	     if (disp == RMMI_VALIDATOR_ERROR)
            {
         	  if (error_cause == RMMI_PARSE_NOT_FOUND)
             	  {
                	// parmater mode is not given (return "OK" and do nothing)
              	ret_val = KAL_TRUE;
		  }
                break;
            }
            else
            {
                rmmi_ptr->cmec_disp = disp;
            }

            ind = (kal_uint8) rmmi_int_validator_range_check(
                                &error_cause,
                                source_string_ptr,
                                rmmi_ptr->s_reg.s3,
                                0);
			
	     if (ind == RMMI_VALIDATOR_ERROR)
            {
         	  if (error_cause == RMMI_PARSE_NOT_FOUND)
             	  {
                	// parmater mode is not given (return "OK" and do nothing)
              	ret_val = KAL_TRUE;
		  }
                break;
            }
            else
            {
                rmmi_ptr->cmec_ind = ind;
            }

	     ret_val = KAL_TRUE;
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_ecal_hdlr
 * DESCRIPTION
 *  Query calibration data download status
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 * 
 *****************************************************************************/
void rmmi_ecal_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_trace(TRACE_FUNC, FUNC_RMMI_ECAL_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:
        case RMMI_ACTIVE_MODE:
        {
            l4c_eq_query_cal_data_dl_status_req(source_string_ptr->src_id);

            /* respond after receiving CNF message from MDO_L1 */
            return;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }
    
    rmmi_final_rsp_generator(source_string_ptr->src_id, KAL_FALSE, NULL, 0);
} /* end of rmmi_ecal_hdlr */


#if !defined(__SLIM_AT__)
#if defined (__MMI_FMI__)
// MMI only:
/*****************************************************************************
 * FUNCTION
 *  rmmi_csdf_hdlr
 * DESCRIPTION
 *  Settings Date Format
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_csdf_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 mode;
    kal_uint8 aux_mode = 1;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    l4c_context_struct *l4c_ptr = L4C_PTR;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CSDF_HDLR_ENTRY);
    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_TEST_MODE:
        {
            //ret_val = l4cuem_test_date_format (&rsp_str);
            kal_sprintf((kal_char*) buffer, "+CSDF: (1,8-12) ");
            ret_val = KAL_TRUE;
            rsp_str = &buffer[0];
            string_length = strlen((char*)rsp_str);
            break;
        }
        case RMMI_READ_MODE:
        {
            l4c_eq_query_datetime_format_req_lind(KAL_TRUE);
            l4c_ptr->route_thru_lmmi = KAL_TRUE;
            l4c_ptr->route_thru_lmmi_user = source_string_ptr->src_id;			
            return;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;

            mode = (kal_uint8) rmmi_int_validator_range_check(&error_cause,
                                                              source_string_ptr,
                                                              (kal_uint8) RMMI_COMMA,
                                                              0xff);

            if ((mode == 1) || ((mode >= 8) && (mode <= 12)))
            {
            }
            else        //not present or parse error
            {
                if (error_cause != RMMI_PARSE_NOT_FOUND)
                {
                    break;
                }
                else
                {
                    mode = 0;   //means <mode > is not present: don't send indication to mmi
                }
            }

            aux_mode = (kal_uint8) rmmi_int_validator_range_check(&error_cause,
                                                                  source_string_ptr,
                                                                  rmmi_ptr->s_reg.s3,
                                                                  0xff);

            if (aux_mode == 1 || aux_mode == 2)
            {
                rmmi_ptr->date_aux_mode = aux_mode;
            }
            else
            {
                if (error_cause != RMMI_PARSE_NOT_FOUND)
                {
                    break;
                }
            }

            if (mode != 0)
            {
                ret_val = l4c_eq_set_date_time_format_req(source_string_ptr->src_id, KAL_TRUE, mode);
                l4c_ptr->route_thru_lmmi = KAL_TRUE;
	            l4c_ptr->route_thru_lmmi_user = source_string_ptr->src_id;				
                return;
            }
            else        //mode = 0 : <mode> is not present
            {
                ret_val = KAL_TRUE;
            }
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
} /* end of rmmi_csdf_hdlr */


#if defined(__AT_CSGT_SUPPORT__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_csgt_hdlr
 * DESCRIPTION
 *  This command sets and activates the greeting text in the ME. The greeting 
 *  text is shown in the ME display when the ME is turned on. The command can
 *  also be used to deactivate a text
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_csgt_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;

    kal_uint8 result;
    kal_uint8 mode;
    kal_uint8 length;
    kal_uint8 greeting[UEM_MAX_GREETING_LEN * 2 + 2];
    kal_uint8 string[UEM_MAX_GREETING_LEN * 4 + 4];
    kal_uint16 string_length = 0;
    kal_uint8 const *rsp_str = NULL;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    l4c_context_struct *l4c_ptr = L4C_PTR;


    kal_trace(TRACE_FUNC, FUNC_RMMI_CSGT_HDLR_ENTRY);
    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_TEST_MODE:
        {
            ret_val = l4cuem_test_greeting_text(&rsp_str);
            string_length = strlen((char*)rsp_str);
            break;
        }
        case RMMI_READ_MODE:
        {
            l4c_eq_query_greeting_text_req_lind();
            l4c_ptr->route_thru_lmmi = KAL_TRUE;
            l4c_ptr->route_thru_lmmi_user = source_string_ptr->src_id;			
            return;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 dcs = L4_UCS2;
            kal_uint8 error_cause;

            mode = (kal_uint8) rmmi_int_validator_range_check(&error_cause,
                                                              source_string_ptr,
                                                              (kal_uint8) RMMI_COMMA,
                                                              1);
            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }

            kal_mem_set((kal_uint8*) greeting, 0, sizeof(greeting));
            if ((rmmi_ptr->char_set == RMMI_CHSET_IRA) || (rmmi_ptr->char_set == RMMI_CHSET_GSM))
            {
                result = rmmi_string_validator_ext(
                            &error_cause,
                            source_string_ptr,
                            rmmi_ptr->s_reg.s3, /* separator */
                            UEM_MAX_GREETING_LEN + 1,
                            (kal_uint8*) string);
                if (result == RMMI_VALIDATOR_ERROR &&
                    (error_cause == RMMI_PARSE_ERROR || error_cause == RMMI_PARSE_TEXT_TOO_LONG) /* && mode !=0 */ )
                {
                    break;
                }
                else if (result == RMMI_VALIDATOR_ERROR && error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    length = 0xff;  /* just on/off greeting text */
                }
                else
                {
                    length = strlen((char*)string);
                }

                ascii_to_ucs2(string, (kal_wchar*) greeting);
                ret_val = l4c_eq_set_greeting_text_req(
                            source_string_ptr->src_id,
                            (kal_bool) mode,
                            dcs,
                            (kal_uint8*) greeting,
                            length);
                return;
            }
            else if (rmmi_ptr->char_set == RMMI_CHSET_UCS2)
            {
                result = rmmi_string_validator_ext(
                            &error_cause,
                            source_string_ptr,
                            rmmi_ptr->s_reg.s3, /* separator */
                            UEM_MAX_GREETING_LEN * 4 + 1,
                            (kal_uint8*) string);
                check_hex_value(string, greeting);
                rmmi_byte_order_reverse(greeting, (kal_uint16) (strlen((char*)string) / 2));

                if (result == RMMI_VALIDATOR_ERROR &&
                    (error_cause == RMMI_PARSE_ERROR || error_cause == RMMI_PARSE_TEXT_TOO_LONG) /* && mode !=0 */ )
                {
                    break;
                }
                else if (result == RMMI_VALIDATOR_ERROR && error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    length = 0xff;  /* just on/off greeting text */
                }
                else
                {
                    length = strlen((char*)string) / 4;
                }

                ret_val = l4c_eq_set_greeting_text_req(
                            source_string_ptr->src_id,
                            (kal_bool) mode,
                            dcs,
                            (kal_uint8*) greeting,
                            length);
                return;

            }
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
} /* end of rmmi_csgt_hdlr */
#endif


/*****************************************************************************
 * FUNCTION
 *  rmmi_csil_hdlr
 * DESCRIPTION
 *  Enable/Disable the silent mode
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_csil_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
#if defined(__MMI_FMI__) && !defined(EXTERNAL_MMI)
    kal_uint8 on_off;
#endif
    kal_uint16 string_length = 0;
    kal_uint8 const *rsp_str = NULL;
    l4c_context_struct *l4c_ptr = L4C_PTR;
    

    kal_trace(TRACE_FUNC, FUNC_RMMI_CSIL_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    #if defined(__MMI_FMI__) && !defined(EXTERNAL_MMI)
        case RMMI_TEST_MODE:
        {
            ret_val = l4cuem_test_silent_mode(&rsp_str);
            string_length = strlen((char*)rsp_str);

            break;
        }
        case RMMI_READ_MODE:
        {
            l4c_eq_query_silent_mode_req_lind();
            l4c_ptr->route_thru_lmmi = KAL_TRUE;
            l4c_ptr->route_thru_lmmi_user = source_string_ptr->src_id;			
            return;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            on_off = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                                source_string_ptr,
                                                                RMMI_PTR->s_reg.s3,
                                                                1);
            if (on_off == RMMI_VALIDATOR_ERROR)
            {
                break;  //invalid value;
            }

            ret_val = l4c_eq_set_silent_mode_req(source_string_ptr->src_id, (kal_bool) on_off);
            //break;
            if (ret_val == KAL_TRUE)
            {
                l4c_ptr->route_thru_lmmi = KAL_TRUE;
                l4c_ptr->route_thru_lmmi_user = source_string_ptr->src_id;			
                return; /* mtk00924 wait for MMI's at_general_res_req to give result code */
            }
        }
    #endif /* __MMI_FMI__ */ 		
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
} /* end of rmmi_csil_hdlr */


/*****************************************************************************
 * FUNCTION
 *  rmmi_cstf_hdlr
 * DESCRIPTION
 *  Set Time Format
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cstf_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
#if defined(__MMI_FMI__) && !defined(EXTERNAL_MMI) 
    kal_uint8 mode = 1;
#endif
    kal_uint16 string_length = 0;
    kal_uint8 const *rsp_str = NULL;
    l4c_context_struct *l4c_ptr = L4C_PTR;
    

    kal_trace(TRACE_FUNC, FUNC_RMMI_CSTF_HDLR_ENTRY);
    switch (source_string_ptr->cmd_mode)
    {
    #if defined(__MMI_FMI__) && !defined(EXTERNAL_MMI)
        case RMMI_TEST_MODE:
        {
            ret_val = l4cuem_test_time_format(&rsp_str);
            string_length = strlen((char*)rsp_str);
            break;
        }
        case RMMI_READ_MODE:
        {
            l4c_eq_query_datetime_format_req_lind(KAL_FALSE);
            l4c_ptr->route_thru_lmmi = KAL_TRUE;
            l4c_ptr->route_thru_lmmi_user = source_string_ptr->src_id;			
            return;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;

            mode = (kal_uint8) rmmi_int_validator_range_check(&error_cause,
                                                              source_string_ptr,
                                                              RMMI_PTR->s_reg.s3,
                                                              2);

            if (mode == RMMI_VALIDATOR_ERROR)
            {
                if (error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    mode = 1;
                }
                else
                {
                    break;
                }
            }
            else if (mode == 0)
            {
                break;/* only mode = 1 or 2 is available*/
            }

            ret_val = l4c_eq_set_date_time_format_req(source_string_ptr->src_id, KAL_FALSE, mode);
            l4c_ptr->route_thru_lmmi = KAL_TRUE; 
            l4c_ptr->route_thru_lmmi_user = source_string_ptr->src_id;			
            return;
            //            break;
        }
    #endif /* __MMI_FMI__ */ 	 	
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
} /* end of rmmi_cstf_hdlr */


/*****************************************************************************
 * FUNCTION
 *  rmmi_cvib_hdlr
 * DESCRIPTION
 *  This command is used to enable and disable the vibrator alert feature of the ME
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cvib_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 mode;
    kal_uint16 string_length = 0;
    kal_uint8 const *rsp_str = NULL;
    l4c_context_struct *l4c_ptr = L4C_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CVIB_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_TEST_MODE:
        {
            ret_val = l4cuem_test_vibrator_mode(&rsp_str);
            string_length = strlen((char*)rsp_str);
            break;
        }
        case RMMI_READ_MODE:
        {
            l4c_eq_query_vibrator_mode_req_lind();
            l4c_ptr->route_thru_lmmi = KAL_TRUE;
            l4c_ptr->route_thru_lmmi_user = source_string_ptr->src_id;			
            return;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            mode = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                              source_string_ptr,
                                                              RMMI_PTR->s_reg.s3,
                                                              1);
            if (mode == RMMI_VALIDATOR_ERROR)
            {
                break;
            }
            ret_val = l4c_eq_set_vibrator_mode_req(source_string_ptr->src_id, mode);
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
} /* rmmi_cvib_hdlr */

/*****************************************************************************
 * FUNCTION
 *  rmmi_cbklt_hdlr
 * DESCRIPTION
 *  make backlight on/off
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cbklt_hdlr(rmmi_string_struct *source_string_ptr)
 {
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;    /* response string and initialization */
    kal_uint16 string_length = 0;       /* string length variable */
    kal_uint8 state;
    kal_uint16 duration = 0;
    l4c_context_struct *l4c_ptr = L4C_PTR;
    

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:  //AT+CBKLT?
        {
            /* send query ind to MMI */
            l4c_eq_at_cbklt_query_req_lind();
            l4c_ptr->route_thru_lmmi = KAL_TRUE;
            l4c_ptr->route_thru_lmmi_user = source_string_ptr->src_id;
            return;
        }
        case RMMI_SET_OR_EXECUTE_MODE:  //AT+CBKLT=<state>[, <duration>]
        {
            state = (kal_uint8) rmmi_int_validator_range_check(
                                NULL,
                                source_string_ptr,
                                (kal_uint8) RMMI_COMMA,
                                3); 
            if (state == RMMI_VALIDATOR_ERROR)
            {
                break;
            }
            
            if (state == 1)
            {
                duration = rmmi_int_validator_range_check(NULL, source_string_ptr, RMMI_PTR->s_reg.s3, 9999);
                if (duration == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }
                else if (duration == 0) //enable for 0 seconds
                {
                    break; //responds ERROR directly
                }
            }
            else if (state == 2) //enable indefinitely
            {
                duration = 0xffff; //tag for LMMI to indicate indifinite
            }
            
            ret_val = l4c_eq_set_backlight_req(state, duration);
            
            if (ret_val == KAL_TRUE)
            {
                return;
            }
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;

}
#endif /* defined (__MMI_FMI__) */


/*****************************************************************************
 * FUNCTION
 *  rmmi_clan_hdlr
 * DESCRIPTION
 *  This command sets the language in the ME. The set-command must confirm the 
 *  selected language with the MMImodule in the ME.
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_clan_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;

#ifdef __MMI_FMI__
    kal_uint8 result;
    kal_uint8 lang_code;
    kal_uint8 language[6];
#endif /* __MMI_FMI__ */ 
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    #if defined(__MMI_FMI__)
    l4c_context_struct *l4c_ptr = L4C_PTR;
    #endif


    kal_trace(TRACE_FUNC, FUNC_RMMI_CLAN_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __MMI_FMI__
        case RMMI_TEST_MODE:
        {
            /*
             * ret_val = l4cuem_test_language (&rsp_str);
             * string_length = strlen ((char *)rsp_str);
             */
            kal_sprintf((char*)buffer, "+CLAN: (\"AUTO\", \"en\", \"zh-TW\", \"zh-CN\") ");
            string_length = strlen((char*)buffer);
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_READ_MODE:
        {
            l4c_eq_query_language_req_lind();
            l4c_ptr->route_thru_lmmi = KAL_TRUE;
            l4c_ptr->route_thru_lmmi_user = source_string_ptr->src_id;			
            return;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            result = rmmi_string_validator(
                        source_string_ptr,
                        RMMI_PTR->s_reg.s3, /* separator */
                        6,
                        (kal_uint8*) language);
            if (result == RMMI_VALIDATOR_ERROR)
            {
                break;
            }

            /* convert language string to lang_code */
            lang_code = check_language_code(language);
            if (lang_code == 0xff)
            {
                break;
            }
            else if (lang_code == MMI_PS_AT_LANG_DEFAULT)       //unspecified language: remain current language
            {
                ret_val = KAL_TRUE;
                break;
            }

            ret_val = l4c_eq_set_language_req(source_string_ptr->src_id, lang_code);
            if (ret_val == KAL_TRUE)
            {
                return;
            }

            /*
             * if((ret_val==KAL_TRUE)&&(RMMI_PTR->clae_mode==1))
             * {
             * RMMI_PTR->arg_list[0] = (void *)language;
             * string_length = rmmi_fast_string_print (
             * buffer,
             * (kal_uint8 *)"+CLAV: \"%s\"",
             * RMMI_PTR->arg_list,
             * 1
             * );
             * rmmi_write_to_uart((kal_uint8 *)buffer, string_length, KAL_TRUE);
             * }
             */
            break;
        }
    #endif /* __MMI_FMI__ */ 
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) buffer, string_length);
    return;
} /* end of rmmi_clan_hdlr */


/*****************************************************************************
 * FUNCTION
 *  rmmi_clae_hdlr
 * DESCRIPTION
 *  This command sets the language event in the ME. this command is used 
 *  to en/disable unsolicited code +CLAV:<code> 
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_clae_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 mode;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CLAE_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            kal_sprintf((kal_char*) buffer, "+CLAE: (0,1) ");
            ret_val = KAL_TRUE;
            rsp_str = &buffer[0];
            string_length = strlen((char*)rsp_str);

            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_READ_MODE:
        {

            rmmi_ptr->arg_list[0] = (void*)&rmmi_ptr->clae_mode;
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CLAE: %d", rmmi_ptr->arg_list, 1);
            ret_val = KAL_TRUE;
            rsp_str = &buffer[0];

            break;

        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            mode = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                              source_string_ptr,
                                                              rmmi_ptr->s_reg.s3,
                                                              1);
            if (mode == RMMI_VALIDATOR_ERROR)
            {
                break;
            }
            rmmi_ptr->clae_mode = mode;
            ret_val = KAL_TRUE;
            break;
        }

        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
} /* end of rmmi_clae_hdlr */


/*****************************************************************************
 * FUNCTION
 *  rmmi_vgr_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
extern void L1SP_SetOutputVolume( kal_uint8 volume1, kal_int8 digital_gain_index );
void rmmi_vgr_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    kal_uint32 gain;
    kal_uint8 const *rsp_str = NULL;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;


    kal_trace(TRACE_FUNC, FUNC_RMMI_VGR_HDLR_ENTRY);
    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
            return;
        }
    #endif /* __test_mode__ */
        case RMMI_READ_MODE:
        {
	        rmmi_ptr->arg_list[0] = (void*)&rmmi_ptr->vgr_gain;
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+VGR: %d", rmmi_ptr->arg_list, 1);
	    rsp_str = &buffer[0];
	    ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            gain = rmmi_int_validator(source_string_ptr, rmmi_ptr->s_reg.s3);

	    if (gain <= 255)
	    {
	        rmmi_ptr->vgr_gain = (kal_uint8) gain; 
		L1SP_SetOutputVolume((kal_uint8)gain, 0);
	        ret_val = KAL_TRUE;
	    }	 
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
} /* end of rmmi_vgr_hdlr */


/*****************************************************************************
 * FUNCTION
 *  rmmi_vgt_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
extern void L1SP_SetMicrophoneVolume( kal_uint8 mic_volume );
void rmmi_vgt_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    kal_uint32 gain;
    kal_uint8 const *rsp_str = NULL;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;


    kal_trace(TRACE_FUNC, FUNC_RMMI_VGT_HDLR_ENTRY);
    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
            return;
        }
    #endif /* __test_mode__ */
        case RMMI_READ_MODE:
        {
	        rmmi_ptr->arg_list[0] = (void*)&rmmi_ptr->vgt_gain;
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+VGT: %d", rmmi_ptr->arg_list, 1);
	    rsp_str = &buffer[0];
	    ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            gain = rmmi_int_validator(source_string_ptr, rmmi_ptr->s_reg.s3);

            if (gain <= 255)
            {
	            rmmi_ptr->vgt_gain = (kal_uint8) gain; 
                L1SP_SetMicrophoneVolume((kal_uint8)gain);
	        ret_val = KAL_TRUE;
            }
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
} /* end of rmmi_vgt_hdlr */


/*****************************************************************************
 * FUNCTION
 *  rmmi_cbc_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cbc_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 battery_status;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    kal_uint32 battery_vol;
    kal_uint8 const *rsp_str = NULL;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CBC_HDLR_ENTRY);
    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CBC: (0,2), (0-100)", rmmi_ptr->arg_list, 0);
            rsp_str = &buffer[0];
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_ACTIVE_MODE:
        {

            ret_val = l4c_eq_get_battery_capacity_status_req(source_string_ptr->src_id, &battery_status, &battery_vol);

            if (battery_status == PMIC_INVALID_BATTERY)
            {
                battery_status = 2;
            }
            else
            {
                battery_status = 0;
            }
            battery_vol = battery_vol / 100;
            rmmi_ptr->arg_list[0] = (void*)&battery_status;
            rmmi_ptr->arg_list[1] = (void*)&battery_vol;
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CBC: %d, %d", rmmi_ptr->arg_list, 2);
            rsp_str = &buffer[0];
            break;
        }
        default:
            break;
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
} /* end of rmmi_cbc_hdlr */


/*****************************************************************************
 * FUNCTION
 *  rmmi_clvl_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_clvl_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 vol_level;
    kal_uint16 string_length = 0;
    kal_uint8 const *rsp_str = NULL;
    #if defined(__MMI_FMI__)
    l4c_context_struct *l4c_ptr = L4C_PTR;
    #endif

    kal_trace(TRACE_FUNC, FUNC_RMMI_CLVL_HDLR_ENTRY);
    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_TEST_MODE:
        {
            ret_val = l4cuem_test_volume_level(&rsp_str);
            string_length = (kal_uint16)strlen((char*)rsp_str);

            break;
        }
        case RMMI_READ_MODE:
        {
            //if(RMMI_PTR->loudspeaker_vol_level == 0xFF)//mtk00924 050704 : reset vol_level when multi cmd are finished                     
            ret_val = l4c_eq_get_volume_req(source_string_ptr->src_id, VOL_TYPE_SPH);
            return;
            break;

        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            vol_level = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                                   source_string_ptr,
                                                                   RMMI_PTR->s_reg.s3,
                                                                   0xff);
            if (vol_level > MAX_VOL_LEVEL - 1)
            {
                break;
            }
            ret_val = l4c_eq_exe_volume_req(source_string_ptr->src_id, VOL_TYPE_SPH, vol_level);

            if (ret_val == KAL_TRUE)
            {
                #if defined(__MMI_FMI__)
                    l4c_ptr->route_thru_lmmi = KAL_TRUE;						
                    l4c_ptr->route_thru_lmmi_user= source_string_ptr->src_id;	
                   return;
		#endif
            }

            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
} /* end of rmmi_clvl_hdlr */


/*****************************************************************************
 * FUNCTION
 *  rmmi_cmut_hdlr
 * DESCRIPTION
 *  This command is used to enable and disable the uplink voice muting 
 *  during a voice call
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cmut_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 on_off;
    kal_uint16 string_length = 0;
    kal_uint8 const *rsp_str = NULL;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    #if defined(_MMI_FMI__)
    l4c_context_struct *l4c_ptr = L4C_PTR;
    #endif

    kal_trace(TRACE_FUNC, FUNC_RMMI_CMUT_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            ret_val = l4cuem_test_mute_mode(&rsp_str);
            string_length = strlen((char*)rsp_str);

            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_READ_MODE:
        {
        #ifdef __MMI_FMI__
            l4c_eq_query_mute_mode_req_lind();
            l4c_ptr->route_thru_lmmi = KAL_TRUE;
            l4c_ptr->route_thru_lmmi_user = source_string_ptr->src_id;			
            return;
        #else /* __MMI_FMI__ */ 
            kal_uint8 buffer[RMMI_SHORT_RSP_LEN];

            rmmi_ptr->arg_list[0] = (void*)&rmmi_ptr->cmut_mode;
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CMUT: %d", rmmi_ptr->arg_list, 1);
            rsp_str = &buffer[0];
            ret_val = KAL_TRUE;
            break;
        #endif /* __MMI_FMI__ */ 

        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 call_id = 255;

            on_off = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                                source_string_ptr,
                                                                rmmi_ptr->s_reg.s3,
                                                                1);
            if (on_off == RMMI_VALIDATOR_ERROR)
            {
                break;
            }

            l4ccsm_cc_get_active_call(&call_id);
            if (call_id == 255) // currently no call, mute cannot work.
            {
                break;
            }

            ret_val = l4c_eq_exe_mute_req(source_string_ptr->src_id, AUDIO_DEVICE_MICROPHONE, (kal_bool) on_off);
            if (ret_val == KAL_TRUE)
            {
                rmmi_ptr->cmut_mode = (kal_bool) on_off;        //this value is used for read command when #ifndef __MMI_FMI__ 
            }

            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
} /* end of rmmi_cmut_hdlr */


/*****************************************************************************
 * FUNCTION
 *  rmmi_crsl_hdlr
 * DESCRIPTION
 *  This command is used to select the general alert sound mode of the ME 
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_crsl_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 vol_level;
    kal_uint16 string_length = 0;
    kal_uint8 const *rsp_str = NULL;
    #if defined(__MMI_FMI__)
    l4c_context_struct *l4c_ptr = L4C_PTR;
    #endif


    kal_trace(TRACE_FUNC, FUNC_RMMI_CRSL_HDLR_ENTRY);
    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_TEST_MODE:
        {
            ret_val = l4cuem_test_ring_volume_level(&rsp_str);
            string_length = (kal_uint16)strlen((char*)rsp_str);

            break;
        }
        case RMMI_READ_MODE:
        {
            //if(RMMI_PTR->ringer_vol_level == 0xFF)//mtk00924 050704 : reset vol_level when multi cmd are finished 
            ret_val = l4c_eq_get_volume_req(source_string_ptr->src_id, VOL_TYPE_MEDIA);
            return;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            vol_level = (kal_uint8) rmmi_int_validator_range_check(NULL,
                                                                   source_string_ptr,
                                                                   RMMI_PTR->s_reg.s3,
                                                                   0xff);

            vol_level--;        //to be consistant with MMI
            if (vol_level > (MAX_VOL_LEVEL - 1))
            {
                ret_val = KAL_FALSE;
                break;
            }

            ret_val = l4c_eq_exe_volume_req(source_string_ptr->src_id, VOL_TYPE_MEDIA, vol_level);

            if (ret_val == KAL_TRUE)
            {
                #if defined(__MMI_FMI__)
                    l4c_ptr->route_thru_lmmi = KAL_TRUE;						
                    l4c_ptr->route_thru_lmmi_user= source_string_ptr->src_id;	
                    return;
                #endif
            }
					 
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_cgmi_hdlr
 * DESCRIPTION
 *  Request manufacturer identification
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cgmi_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 eq_id[UEM_EQUIP_ID_LEN];
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CGMI_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_ACTIVE_MODE:
        {
            ret_val = l4c_eq_get_equip_id_req(source_string_ptr->src_id, EQ_ME_MANUFACTURE_ID, (kal_uint8*) eq_id);

            if (ret_val == KAL_TRUE)
            {
                rmmi_ptr->arg_list[0] = (void*)eq_id;

                #ifdef __AT_ME_IDENTIFICATION_WITHOUT_HEADER__
                string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "%s", rmmi_ptr->arg_list, 1);
                #else
                string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CGMI: %s", rmmi_ptr->arg_list, 1);
                #endif
                
            }
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) buffer, string_length);
} /* end of rmmi_cgmi_hdlr */


/*****************************************************************************
 * FUNCTION
 *  rmmi_cgsn_hdlr
 * DESCRIPTION
 *  Request product serial number identification & IMEI
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  serial number and IMEI(?)
 *****************************************************************************/
void rmmi_cgsn_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 eq_id[UEM_EQUIP_ID_LEN + 11];
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CGSN_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_ACTIVE_MODE:
        {
            kal_uint8 type;
            sim_interface_enum simId;

            simId = l4c_gemini_get_actual_sim_id(l4c_current_mod_id-MOD_L4C);
            type = (simId == SIM1)? EQ_ME_SERIAL_NUMBER_ID:EQ_ME_SERIAL_NUMBER_SIM2_ID;

            ret_val = l4c_eq_get_equip_id_req(source_string_ptr->src_id, type, (kal_uint8*) eq_id);

            if (ret_val == KAL_TRUE)
            {
                rmmi_ptr->arg_list[0] = (void*)eq_id;
                string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "%s", rmmi_ptr->arg_list, 1);
            }
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) buffer, string_length);

} /* end of rmmi_cgsn_hdlr */


#if defined(PLUTO_MMI)
/*****************************************************************************
 * FUNCTION
 *  rmmi_cso_hdlr
 * DESCRIPTION
 *  Screen Orientation Set/Read
 * PARAMETERS
 *  source_string_ptr        [IN]       At cmd string
 * RETURNS
 *  void
******************************************************************************/
void rmmi_cso_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_uint8 orient;
    kal_uint8 error_cause;
    l4c_context_struct *l4c_ptr = L4C_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CSO_HDLR_ENTRY);
    switch(source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:
        {
            /* Send message to MMI and return OK/ERROR out in scrnorient_res_req */
            l4c_eq_scrnorient_req_lind(0, 0);/* 1st parameter means this is query action, 2nd para means nothing */
            l4c_ptr->route_thru_lmmi = KAL_TRUE; 
            l4c_ptr->route_thru_lmmi_user = source_string_ptr->src_id;
            return;
        }
        /* We do not support set mode at present, but this maybe completed some days later */
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            orient = (kal_uint8)rmmi_int_validator_range_check(&error_cause, source_string_ptr, RMMI_PTR->s_reg.s3, 1);
            if(error_cause != RMMI_PARSE_OK)
            {
                break;
            }
            /* Send message to MMI and return OK/ERROR out in scrnorient_res_req */
            l4c_eq_scrnorient_req_lind(1, orient);/* 1st parameter means this is setting action*/
            l4c_ptr->route_thru_lmmi = KAL_TRUE; 
            l4c_ptr->route_thru_lmmi_user = source_string_ptr->src_id;
            return;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, KAL_FALSE, NULL, 0);
    return;
}/* End of rmmi_cso_hdlr */


/*****************************************************************************
 * FUNCTION
 *  rmmi_css_hdlr
 * DESCRIPTION
 *  Get screen size
 * PARAMETERS
 *  source_string_ptr        [IN]       At cmd string
 * RETURNS
 *  void
******************************************************************************/
void rmmi_css_hdlr(rmmi_string_struct *source_string_ptr)
{
    l4c_context_struct *l4c_ptr = L4C_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CSS_HDLR_ENTRY);
    switch(source_string_ptr->cmd_mode)
    {
        case RMMI_ACTIVE_MODE:
        {
            /* Send message to MMI and return OK/ERROR out in scrnsize_query_res_req */
            l4c_eq_scrnsize_query_req_lind();
            l4c_ptr->route_thru_lmmi = KAL_TRUE; 
            l4c_ptr->route_thru_lmmi_user = source_string_ptr->src_id;
            return;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, KAL_FALSE, NULL, 0);
    return;
}/* End of rmmi_css_hdlr */


#endif /* defined(PLUTO_MMI) */

#endif /* !defined(__SLIM_AT__) */


#if defined(PLUTO_MMI)
#if defined(TOUCH_PANEL_SUPPORT)
/*****************************************************************************
 * FUNCTION
 *  rmmi_ctsa_hdlr
 * DESCRIPTION
 *  Touch event simulation from AT
 * PARAMETERS
 *  source_string_ptr        [IN]       At cmd string
 * RETURNS
 *  void
******************************************************************************/
void rmmi_ctsa_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_uint8 action;
    kal_uint8 error_cause = 0;
    kal_uint16 x_coords;
    kal_uint16 y_coords;
    l4c_context_struct *l4c_ptr = L4C_PTR;
    

    kal_trace(TRACE_FUNC, FUNC_RMMI_CTSA_HDLR_ENTRY);

    switch(source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            /* <action> must be interger type and between 0~3 */
            action = (kal_uint8)rmmi_int_validator_range_check(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA, 3);
            if(error_cause != RMMI_PARSE_OK)
            {
                break;
            }
            /* <x_coords> must be interger type */
            x_coords = (kal_uint16)rmmi_int_validator_range_check(&error_cause, source_string_ptr, (kal_uint8)RMMI_COMMA, 0xFFFF);
            if(error_cause != RMMI_PARSE_OK)
            {
                break;
            }
            /* <y_coords> must be interger type */
            y_coords = (kal_uint16)rmmi_int_validator_range_check(&error_cause, source_string_ptr, RMMI_PTR->s_reg.s3, 0xFFFF);
            if(error_cause != RMMI_PARSE_OK)
            {
                break;
            }

            /* send message to MMI and final response will be write to user in screen_touch_res_req */
            l4c_eq_screen_touch_req_lind(action, x_coords, y_coords);
            l4c_ptr->route_thru_lmmi = KAL_TRUE; 
            l4c_ptr->route_thru_lmmi_user = source_string_ptr->src_id;		
            return;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, KAL_FALSE, NULL, 0);
    return;
} /* End of rmmi_ctsa_hdlr */
#endif /* defined(TOUCH_PANEL_SUPPORT)*/


/*****************************************************************************
 * FUNCTION
 *  rmmi_ecscn_hdlr
 * DESCRIPTION
 *  Take screen shot
 * PARAMETERS
 *  source_string_ptr        [IN]       At cmd string
 * RETURNS
 *  void
******************************************************************************/
void rmmi_ecscn_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_uint8 op;
    kal_uint8 error_cause;
    l4c_context_struct *l4c_ptr = L4C_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_ECSCN_HDLR_ENTRY);
    switch(source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            /* Send message to MMI and response in l4c_eq_screen_shot_res_req */
            op = (kal_uint8)rmmi_int_validator_range_check(&error_cause,
                                                           source_string_ptr,
                                                           RMMI_PTR->s_reg.s3,
                                                           3);
            if(error_cause != RMMI_PARSE_OK)
            {
                break;
            }
            l4c_eq_screen_shot_req_lind(op);
            l4c_ptr->route_thru_lmmi = KAL_TRUE; 
            l4c_ptr->route_thru_lmmi_user = source_string_ptr->src_id;
            return;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }

    
    rmmi_final_rsp_generator(source_string_ptr->src_id, KAL_FALSE, NULL, 0);
    return;
}

#endif /* defined(PLUTO_MMI) */
#endif /* __MOD_UEM__ */

