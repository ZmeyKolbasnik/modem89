/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 * RMMI_VALIDATOR_SMS.C
 *
 * Project:
 * --------
 *   MAUI
 *
 * Description:
 * ------------
 *   This file is intends for ???K.
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
#include <stdio.h>
#include <string.h>
//#include "kal_release.h"
//#include "stack_common.h"
//#include "stack_msgs.h"
//#include "app_ltlcom.h" /* Task message communiction */
//#include "stacklib.h"   /* Basic type for dll, evshed, stacktimer */
//#include "app_buff_alloc.h"
//#include "stack_timer.h"
//#include "event_shed.h"
//#include "nvram_editor_data_item.h"
//#include "custom_nvram_editor_data_item.h"

#ifdef __MOD_SMU__
//#include "ps2sim_struct.h"
//#include "sim_common_enums.h"
#include "smu_common_enums.h"
#endif /* __MOD_SMU__ */ 
//#include "device.h"
//#include "csmss_common_enums.h"

//#include "mcd_l3_inc_struct.h"
//#include "mcd_l3_inc_gprs_struct.h"
#include "l3_inc_enums.h"

//#include "mcd_l4_common.h"
#include "l4c_common_enum.h"
#include "rmmi_common_enum.h"
#include "rmmi_context.h"
#include "l4c_context.h"
#include "layer4_context.h"
//#include "l4c_rspfmttr.h"
//#include "l4c_msghdlr.h"
#include "l4_trc.h"
//#include "dcl.h"
#include "l4_defs.h"
#include "csmcc_atfunc.h"
#include "csmss_atfunc.h"
#include "l4c_aux_struct.h"
#include "l4c_ss_parse.h"
//#include "uart_sw.h"
//#include "l4_defs.h"
//#include "csmcc_atfunc.h"
//#include "csmss_atfunc.h"
//#include "l4c_aux_struct.h"
//#include "l4c_ss_parse.h"
#include "atci_trc.h"

//#include "uart_sw.h"
#include "dcl.h"
#include "l4_defs.h"
#include "csmcc_atfunc.h"
#include "csmss_atfunc.h"
#include "l4c_aux_struct.h"
#include "l4c_ss_parse.h"

#ifdef __MOD_CSM__
//#include "mcd_ss_parameters.h"
//#include "mcd_ss_tcapmessages.h"
#include "l4c_common_enum.h"
//#include "csmcc_enums.h"
//#include "csmcc_common_enums.h"
//#include "ps2sat_struct.h"
//#include "l4c2csm_cc_struct.h"

//#include "l4c_ciss_cmd.h"
//#include "l4c2csm_ss_struct.h"
//#include "l4c_cc_cmd.h"
#endif /* __MOD_CSM__ */ 

#if defined (VM_SUPPORT)
//#include "med_struct.h"
#endif 
#ifdef __MOD_UEM__
//#include "device.h"
//#include "l4c2uem_struct.h"
//#include "uem_at_cmd.h"
//#include "custom_em.h"
//#include "l4c_eq_cmd.h"
#endif /* __MOD_UEM__ */ 
#ifdef __MOD_RAC__
//#include "l4crac_func.h"
//#include "l4c_nw_cmd.h"
//#include "l4crac_enums.h"
#endif /* __MOD_RAC__ */ 
#ifdef __MOD_PHB__
//#include "sim_common_enums.h"
//#include "l4c2phb_enums.h"
//#include "l4c2phb_struct.h"
//#include "phb_sap.h"
//#include "l4c_phb_cmd.h"
//#include "phb_defs.h"
//#include "phb_config.h"
#endif /* __MOD_PHB__ */ 
#ifdef __MOD_SMSAL__
#include "l4c2smsal_struct.h"
#include "smsal_l4c_defs.h"
#include "smsal_l4c_funcs.h"
#include "smsal_l4c_enum.h"
//#include "smsal_defs.h"
#include "l4c_sms_cmd.h"
#endif /* __MOD_SMSAL__ */ 
#ifdef __MOD_SMU__
//#include "ps2sat_struct.h"
//#include "mcd_ps2sat_peer.h"
//#include "l4c_sim_cmd.h"
#endif /* __MOD_SMU__ */ 
#ifdef __MOD_TCM__
//#include "mmi_l3_enums.h"
//#include "mmi_sm_enums.h"
//#include "ppp_l4_enums.h"
//#include "tcm_common_enums.h"
//#include "tcm_common.h"
//#include "custom_nvram_editor_data_item.h"
//#include "l4c2abm_struct.h"
//#include "abm2l4c_struct.h"
//#include "l4c2tcm_struct.h"
//#include "l4c2tcm_func.h"
//#ifdef __TCPIP__
//#include "l4c2abm_struct.h"
//#endif /* __TCPIP__ */
//#include "l4c_gprs_cmd.h"
#endif /* __MOD_TCM__ */ 

#include "l4c_utility.h"
#include "rmmi_rspfmttr.h"
#include "rmmi_utility.h"
//#include "rmmi_rsp.h"
#include "rmmi_validator.h"
//#include "nvram_data_items.h"
//#include "custom_hw_default.h"
//#include "l4c_table.h"
#include "rmmi_parser.h"
//#include "resource_verno.h"     // for +EGMR read MMI resource version

#ifdef __CSD_FAX__
//#include "csm_data_enums.h"
//#include "l4c2t30_struct.h"
//#include "l4c_t30_cmd.h"
//#include "l4c2t30_enums.h"
#endif /* __CSD_FAX__ */ 
#include "rmmi_parser.h"
#ifndef MED_NOT_PRESENT
//#include "med_global.h"
//#include "med_main.h"
#endif /* MED_NOT_PRESENT */ 
//#ifdef __J2ME__
//#include "jam_msg_handler.h"
//#endif 

#if defined(__BT_SUPPORT__)
//#include "bluetooth_struct.h"
#endif 

#ifdef __CTM_SUPPORT__
//#include "med_struct.h"
#endif 
//#include "l4c_sendmsg.h"

#ifdef __CUST_NEW__
//#include "gpio_sw.h"
#endif 

/* for data item NVRAM_EF_IMEI_IMEISV_LID move */
//#include "nvram_user_defs.h"
//#include "csmcc_defs.h"

//#include "keypad_sw.h"
//#include "l4c2smu_struct.h"
#include "lmmi_ind.h"

//#include "csmcc_common_enums.h"

//#include "mncc_struct.h"
//#include "csmcc_bc_types.h"
//#include "csmcc_types.h"
//#include "custom_em.h"
//#include "L4c_ctm_cmd.h"
//#include "csmcc_utility.h"

//#include "sat_def.h"

//#include "uem_proc_cmd.h"

//#include "rmmi_msghdlr.h"

//#include "kal_non_specific_general_types.h"
//#include "ps_trace.h"
#include "kal_trace.h"
#include "kal_general_types.h"
#include "kal_public_api.h"
#include "ps_public_enum.h"
#include "ps_public_struct.h"
    
#ifdef __MOD_SMSAL__
extern kal_bool custom_remove_cgsms_constraint(void);
extern void rmmi_header_rrsp(kal_char *);
extern void rmmi_tail_int_space_rrsp(kal_uint32);

#if !defined(__SLIM_AT__)

/*****************************************************************************
 * FUNCTION
 *  rmmi_csms_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_csms_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 service;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    smsal_service_mode_struct info;
    l4c_context_struct *l4c_ptr = L4C_PTR;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CSMS_HDLR_ENTRY);
	
    if (l4c_ptr->sms_ready_flag == KAL_FALSE)
    {
        rmmi_ptr->cmee_err = OPERATION_NOT_ALLOWED_ERR;
    }
    else
    {
    	    switch (source_string_ptr->cmd_mode)
	    {
	    #ifdef __test_mode__
	        case RMMI_TEST_MODE:
	        {
	            smsal_csms_test(&rsp_str);
	            string_length = strlen((char*)rsp_str);
	            ret_val = KAL_TRUE;
	            break;
	        }
	    #endif /* __test_mode__ */ 
	        case RMMI_READ_MODE:
	        {
	            l4c_sms_get_service_mode_req(source_string_ptr->src_id, &service, &info);
	            
	            /* convert storage back to storage_code */
	            rmmi_ptr->arg_list[0] = (void*)&service;
	            rmmi_ptr->arg_list[1] = (void*)&info.mt;
	            rmmi_ptr->arg_list[2] = (void*)&info.mo;
	            rmmi_ptr->arg_list[3] = (void*)&info.bm;
	            string_length = rmmi_fast_string_print(
	                                    buffer,
	                                    (kal_uint8*) "+CSMS: %d, %d, %d, %d",
	                                    rmmi_ptr->arg_list,
	                                    4);
	            rsp_str = &buffer[0];
	            ret_val = KAL_TRUE;
	            break;
	        }
	        case RMMI_SET_OR_EXECUTE_MODE:
	        {
	            service = (kal_uint8) rmmi_int_validator_range_check(
	                                NULL,
	                                source_string_ptr,
	                                rmmi_ptr->s_reg.s3,
	                                1);  
		     if (service == RMMI_VALIDATOR_ERROR)
	            {
	                break;       
	            }

	            ret_val = l4c_sms_set_service_mode_req(source_string_ptr->src_id, service);
	            if (ret_val == KAL_TRUE)
	            {
	                l4c_sms_get_service_mode_req(source_string_ptr->src_id, &service, &info);
	                
	                rmmi_ptr->arg_list[0] = (void*)&info.mt;
	                rmmi_ptr->arg_list[1] = (void*)&info.mo;
	                rmmi_ptr->arg_list[2] = (void*)&info.bm;
	                string_length = rmmi_fast_string_print(
	                                        buffer,
	                                        (kal_uint8*) "+CSMS: %d, %d, %d",
	                                        rmmi_ptr->arg_list,
	                                        3);
	                rsp_str = &buffer[0];
	            }
	            break;
	        }
	        default:
	        {
	            /* unrecognized format of AT command line */
	            break;
	        }
	    }   /* end of the switch */
    }
    rmmi_sms_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_cmgl_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cmgl_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 result;
    kal_uint8 status;
    kal_uint8 const *rsp_str = NULL;
    kal_uint16 string_length = 0;
    kal_uint8 msg_format;
    kal_uint8 status_str[11];
    l4c_context_struct *l4c_ptr = L4C_PTR;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CMGL_HDLR_ENTRY);

    if (l4c_ptr->sms_ready_flag == KAL_FALSE)
    {
        rmmi_ptr->cmee_err = OPERATION_NOT_ALLOWED_ERR;
    }
    else
    {
           switch (source_string_ptr->cmd_mode)
	    {
	        case RMMI_TEST_MODE:
	        {
	            smsal_cmgl_test(&rsp_str);
	            string_length = (kal_uint16)strlen((char*)rsp_str);
	            ret_val = KAL_TRUE;
	            break;
	        }
	        case RMMI_ACTIVE_MODE:
	        {
	            l4c_sms_get_msg_format_req(source_string_ptr->src_id, &msg_format);
	            status = 0; //default for recive unread
	            ret_val = l4c_sms_exe_read_msg_list_req(source_string_ptr->src_id, KAL_TRUE, status, 0, 0);
	            if (ret_val == KAL_TRUE)
	            {
	                return;
	            }
	            break;
	        }
	        case RMMI_SET_OR_EXECUTE_MODE:
	        {
	            l4c_sms_get_msg_format_req(source_string_ptr->src_id, &msg_format);
	            if (msg_format == SMSAL_TEXT_MODE)
	            {
	                result = rmmi_string_validator(source_string_ptr, rmmi_ptr->s_reg.s3, 11, (kal_uint8*) status_str);
	                if (result == RMMI_VALIDATOR_ERROR)     //check if status str exist and valid
	                {
	                    break;
	                }
	                status = check_sms_status_code((kal_uint8*) status_str);
	                if (status == 0xff)     //check if code is find otherwise we should break
	                {
	                    break;
	                }
	            }
	            else
	            {
	                status = (kal_uint8) rmmi_int_validator_range_check(
	                                NULL,
	                                source_string_ptr,
	                                rmmi_ptr->s_reg.s3,
	                                4); 
	            	if (status == RMMI_VALIDATOR_ERROR)
	                {
	                    	break;
	            	}
	            }
	            ret_val = l4c_sms_exe_read_msg_list_req(source_string_ptr->src_id, KAL_TRUE, status, 0, 0);
	            if (ret_val == KAL_TRUE)
	            {
	                return;
	            }
	            break;
	        }
	        default:
	        {
	            /* unrecognized format of AT command line */
	            break;
	        }
	    }   /* end of the switch */
    }
    rmmi_sms_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_csas_hdlr
 * DESCRIPTION
 *  This is to save active message settings to a non-volatile memory(07.05 3.3.5)
 *  mtk00714 add on 2004/04/01
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_csas_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint16 string_length = 0;   /* string length variable */
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 error_cause;
    l4c_context_struct *l4c_ptr = L4C_PTR;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CSAS_HDLR_ENTRY);

    if (l4c_ptr->sms_ready_flag == KAL_FALSE)
    {
        rmmi_ptr->cmee_err = OPERATION_NOT_ALLOWED_ERR;
    }
    else
    {
    	    switch (source_string_ptr->cmd_mode)
	    {
	        case RMMI_TEST_MODE:    /* at*csma active command mode without para. */
	        {
	            smsal_csas_test(&rsp_str);
	            string_length = (kal_uint16)strlen((char*)rsp_str);
	            ret_val = KAL_TRUE;
	            break;
	        }
	        case RMMI_ACTIVE_MODE:
	        {
	            l4c_sms_exe_save_settings_req(source_string_ptr->src_id, SMSAL_PROFILE_1);

	            return;
	        }
	        case RMMI_SET_OR_EXECUTE_MODE:  /* at*csma active command mode without para. */
	        {
	            kal_uint8 profile;

	            /* get <profile> */
	            profile = rmmi_int_validator_u8_check(
	                                    &error_cause,
	                                    source_string_ptr,
	                                    rmmi_ptr->s_reg.s3);

	            if (profile == RMMI_VALIDATOR_ERROR)
	            {
	            		if (error_cause != RMMI_PARSE_OK)
	            		{
	                    		break;
	            		}
	            }

	            l4c_sms_exe_save_settings_req(source_string_ptr->src_id, profile);

	            return;
	        }
	        default:
	        {
	            /* unrecognized format of AT command line */
	            break;
	        }
	    }   /* end of the switch */
    }
    rmmi_sms_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_cres_hdlr
 * DESCRIPTION
 *  This is to restore message settings from non-volatile memory to active memory(07.05 3.3.6)
 *  mtk00714 add on 2004/04/01
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cres_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint16 string_length = 0;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 error_cause;
    l4c_context_struct *l4c_ptr = L4C_PTR;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CRES_HDLR_ENTRY);

    if (l4c_ptr->sms_ready_flag == KAL_FALSE)
    {
        rmmi_ptr->cmee_err = OPERATION_NOT_ALLOWED_ERR;
    }
    else
    {
    	    switch (source_string_ptr->cmd_mode)
	    {
	        case RMMI_TEST_MODE:    /* at*csma active command mode without para. */
	        {
	            smsal_cres_test(&rsp_str);
	            string_length = (kal_uint16)strlen((char*)rsp_str);
	            ret_val = KAL_TRUE;
	            break;
	        }
	        case RMMI_ACTIVE_MODE:
	        {
	            l4c_sms_exe_restore_settings_req(source_string_ptr->src_id, SMSAL_PROFILE_1);

	            return;
	        }
	        case RMMI_SET_OR_EXECUTE_MODE:  /* at*csma active command mode without para. */
	        {
	            kal_uint8 profile;

	            /* get <profile> */
	            profile = rmmi_int_validator_u8_check(
	                                    &error_cause,
	                                    source_string_ptr,
	                                    rmmi_ptr->s_reg.s3);

	            if (profile == RMMI_VALIDATOR_ERROR)
	            {
	            		if (error_cause != RMMI_PARSE_OK)
	            		{
	                    		break;
	            		}
	            }

	            l4c_sms_exe_restore_settings_req(source_string_ptr->src_id, profile);

	            return;
	        }
	        default:
	        {
	            /* unrecognized format of AT command line */
	            break;
	        }
	    }   /* end of the switch */
    }
    rmmi_sms_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_csmp_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_csmp_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 fo, vp, pid, dcs, error_cause;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    kal_uint8 para_ind = 0;
    l4c_context_struct *l4c_ptr = L4C_PTR;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CSMP_HDLR_ENTRY);

    if (l4c_ptr->sms_ready_flag == KAL_FALSE)
    {
        rmmi_ptr->cmee_err = OPERATION_NOT_ALLOWED_ERR;
    }
    else
    {
    	    switch (source_string_ptr->cmd_mode)
	    {
	    #ifdef __test_mode__
	        case RMMI_TEST_MODE:
	        {
	            ret_val = KAL_TRUE;
	            break;
	        }
	    #endif /* __test_mode__ */ 
	        case RMMI_READ_MODE:
	        {
	            l4c_sms_get_post_params_req(source_string_ptr->src_id, SMSAL_PROFILE_NONE, &fo, &pid, &dcs, &vp, NULL);   //Profile id is not used anymore : dummy 
	            
	            rmmi_ptr->arg_list[0] = (void*)&fo;
	            rmmi_ptr->arg_list[1] = (void*)&vp;
	            rmmi_ptr->arg_list[2] = (void*)&pid;
	            rmmi_ptr->arg_list[3] = (void*)&dcs;
	            string_length = rmmi_fast_string_print(
	                                    buffer,
	                                    (kal_uint8*) "+CSMP: %d, %d, %d, %d",
	                                    rmmi_ptr->arg_list,
	                                    4);
	            ret_val = KAL_TRUE;
	            break;

	        }
	        case RMMI_SET_OR_EXECUTE_MODE:
	        {
	            fo = (kal_uint8) rmmi_int_validator_ext(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);
	            if (fo != RMMI_VALIDATOR_ERROR)
	            {
	                para_ind |= SMSAL_PARA_FO;
	            }
	            else
	            {
	                if (error_cause != RMMI_PARSE_NOT_FOUND)
	                {
	                    break;
	                }
	            }

	            vp = rmmi_int_validator_u8_check(
	                                    &error_cause,
	                                    source_string_ptr,
	                                    (kal_uint8) RMMI_COMMA);
				
		     if (vp == RMMI_VALIDATOR_ERROR)
	            {
			  if (error_cause == RMMI_PARSE_ERROR)
			  {
			  	break;
			  }
			  else if (error_cause != RMMI_PARSE_NOT_FOUND)
			  {
			  	para_ind |= SMSAL_PARA_VP;
			  }
	            }
	            else
	            {
	            	  para_ind |= SMSAL_PARA_VP;
	            }

	            pid = (kal_uint8) rmmi_int_validator_ext(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);
	            if (pid != RMMI_VALIDATOR_ERROR)
	            {
	                para_ind |= SMSAL_PARA_PID;
	            }
	            else
	            {
	                if (error_cause != RMMI_PARSE_NOT_FOUND)
	                {
	                    break;
	                }
	            }

	            dcs = (kal_uint8) rmmi_int_validator_ext(&error_cause, source_string_ptr, rmmi_ptr->s_reg.s3);
	            if (dcs != RMMI_VALIDATOR_ERROR)
	            {
	                para_ind |= SMSAL_PARA_DCS;
	            }
	            else
	            {
	                if (error_cause != RMMI_PARSE_NOT_FOUND)
	                {
	                    break;
	                }
	            }

	            ret_val = l4c_sms_set_rmmi_post_params_req(
	                        source_string_ptr->src_id,
	                        SMSAL_PROFILE_NONE,
	                        para_ind,
	                        fo,
	                        pid,
	                        dcs,
	                        vp);
	            break;
	        }
	        default:
	        {
	            /* unrecognized format of AT command line */
	            break;
	        }
	    }   /* end of the switch */
    }
    rmmi_sms_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) buffer, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_csdh_hdlr
 * DESCRIPTION
 *  This is to show/hide Text mode detail parameters (07.05 3.3.3)
 *  mtk00714 add on 2004/02/26
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_csdh_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 format;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    l4c_context_struct *l4c_ptr = L4C_PTR;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CSDH_HDLR_ENTRY);

    if (l4c_ptr->sms_ready_flag == KAL_FALSE)
    {
        rmmi_ptr->cmee_err = OPERATION_NOT_ALLOWED_ERR;
    }
    else
    {
    	    switch (source_string_ptr->cmd_mode)
	    {
	    #ifdef __test_mode__
	        case RMMI_TEST_MODE:
	        {
	            kal_sprintf((char*)buffer, "+CSDH: (0, 1)");
	            string_length = strlen((char*)buffer);
	            ret_val = KAL_TRUE;
	            break;
	        }
	    #endif /* __test_mode__ */ 
	        case RMMI_READ_MODE:
	        {
	            if (rmmi_ptr->csdh_show == KAL_TRUE)
	            {
	                kal_sprintf((char*)buffer, "+CSDH: 1");
	            }
	            else        //KAL_FALSE
	            {
	                kal_sprintf((char*)buffer, "+CSDH: 0");
	            }
	            string_length = (kal_uint16)strlen((char*)buffer);
	            ret_val = KAL_TRUE;
	            break;
	        }
	        case RMMI_SET_OR_EXECUTE_MODE:
	        {
	            kal_uint8 error_cause;

		     format = (kal_uint8) rmmi_int_validator_range_check(
	                                &error_cause,
	                                source_string_ptr,
	                                rmmi_ptr->s_reg.s3,
	                                1);  
		     if (format == RMMI_VALIDATOR_ERROR)
	            {
	                if (error_cause == RMMI_PARSE_NOT_FOUND)
	                {
	                    rmmi_ptr->csdh_show = KAL_FALSE;
	                    ret_val = KAL_TRUE;
			      break;
	                }
	                else
	                {
	                    break;
	                }
	            }
	            else
	            {
	                if (format == 0)
	            	{
	                 	rmmi_ptr->csdh_show = KAL_FALSE;
	                }
	            	else //format = 1
	            	{
	                 	rmmi_ptr->csdh_show = KAL_TRUE;
	            	}
	            }  
			 
	            ret_val = KAL_TRUE;
	         
	            break;
	        }
	        default:
	        {
	            /* unrecognized format of AT command line */
	            break;
	        }
	    }   /* end of the switch */
    }
    rmmi_sms_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) buffer, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_cnmi_hdlr
 * DESCRIPTION
 *  This cmd do not  need to be blocked when SIM PIN is not verified
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cnmi_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 mode, mt, bm, ds, bfr;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    l4c_context_struct *l4c_ptr = L4C_PTR;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CNMI_HDLR_ENTRY);

    if (l4c_ptr->sms_ready_flag == KAL_FALSE)
    {
        rmmi_ptr->cmee_err = OPERATION_NOT_ALLOWED_ERR;
    }
    else
    {
    	    switch (source_string_ptr->cmd_mode)
	    {
	    #ifdef __test_mode__
	        case RMMI_TEST_MODE:
	        {
	            smsal_cnmi_test(&rsp_str);
	            string_length = strlen((char*)rsp_str);
	            ret_val = KAL_TRUE;
	            break;
	        }
	    #endif /* __test_mode__ */ 
	        case RMMI_READ_MODE:
	        {
	            l4c_sms_get_msg_ind_mode_req(source_string_ptr->src_id, &mode, &mt, &bm, &ds);
	            
	            rmmi_ptr->arg_list[0] = (void*)&mode;
	            rmmi_ptr->arg_list[1] = (void*)&mt;
	            rmmi_ptr->arg_list[2] = (void*)&bm;
	            rmmi_ptr->arg_list[3] = (void*)&ds;
	            rmmi_ptr->arg_list[4] = (void*)&rmmi_ptr->smsal_bfr;
	            string_length = rmmi_fast_string_print(
	                                    buffer,
	                                    (kal_uint8*) "+CNMI: %d, %d, %d, %d, %d",
	                                    rmmi_ptr->arg_list,
	                                    5);
	            rsp_str = &buffer[0];
	            ret_val = KAL_TRUE;
	            break;
	        }
	        case RMMI_SET_OR_EXECUTE_MODE:
	        {
	            kal_uint8 error_cause;

	            /* get <mode> */
                    mode = (kal_uint8) rmmi_int_validator_range_check(
                                &error_cause,
                                source_string_ptr,
                                (kal_uint8) RMMI_COMMA,
                                3);
					
	            if (mode == RMMI_VALIDATOR_ERROR)
	            {
	                if (error_cause == RMMI_PARSE_NOT_FOUND)
	                {
	                    mode = 0;
	                }
	                else
	                {
	                    break;
	                }
	            }

	            /* get <mt> */
                    mt = (kal_uint8) rmmi_int_validator_range_check(
                                &error_cause,
                                source_string_ptr,
                                (kal_uint8) RMMI_COMMA,
                                3);
	
	            if (mt == RMMI_VALIDATOR_ERROR)
	            {
	                if (error_cause == RMMI_PARSE_NOT_FOUND)
	                {
	                    mt = 0;
	                }
	                else
	                {
	                    break;
	                }
	            }

	            /* get <bm> */
                    bm = (kal_uint8) rmmi_int_validator_range_check(
                                &error_cause,
                                source_string_ptr,
                                (kal_uint8) RMMI_COMMA,
                                3);
			
	            if (bm == RMMI_VALIDATOR_ERROR)
	            {
	                if (error_cause == RMMI_PARSE_NOT_FOUND)
	                {
	                    bm = 0;
	                }
	                else
	                {
	                    break;
	                }
	            }

	            /* get <ds> */
                    ds = (kal_uint8) rmmi_int_validator_range_check(
                                &error_cause,
                                source_string_ptr,
                                (kal_uint8) RMMI_COMMA,
                                1);
	            if (ds == RMMI_VALIDATOR_ERROR)
	            {
	                if (error_cause == RMMI_PARSE_NOT_FOUND)
	                {
	                    ds = 0;
	                }
	                else
	                {
	                    break;
	                }
	            }

	            /* get <bfr> */
                    bfr = (kal_uint8) rmmi_int_validator_range_check(
                                &error_cause,
                                source_string_ptr,
                                rmmi_ptr->s_reg.s3,
                                1);
	            if (bfr == RMMI_VALIDATOR_ERROR)
	            {
	                if (error_cause == RMMI_PARSE_NOT_FOUND)
	                {
	                    rmmi_ptr->smsal_bfr = 0;
	                }
	                else
	                {
	                    break;
	                }
	            }
	            else
	            {
	                rmmi_ptr->smsal_bfr = bfr;
	            }

	            ret_val = l4c_sms_set_msg_ind_mode_req(source_string_ptr->src_id, mode, mt, bm, ds);

	            if (ret_val == KAL_FALSE)
	            {
	                break;
	            }
	            else
	            {
	                rmmi_ptr->CNMI_mode = mode;
	                rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
	                if (mode >= 1)
	                {
	                    if (rmmi_ptr->smsal_bfr == 1)
	                    {
	                        rmmi_flush_ResultCodeBuffer((void*)&rmmi_ptr->CNMI_ResultCodeBuffer, KAL_FALSE);
	                    }
	                    else //rmmi_ptr->smsal_bfr = 0
	                    {
	                        rmmi_flush_ResultCodeBuffer((void*)&rmmi_ptr->CNMI_ResultCodeBuffer, KAL_FALSE);
	                    }
	                    //mtk01616_070530: need modify ,assert will happen when flush is set
	                }
	                return;
	            }
	        }
	        default:
	        {
	            /* unrecognized format of AT command line */
	            break;
	        }
	    }   /* end of the switch */
    }
    rmmi_sms_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_cmms_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cmms_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 mode;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    kal_uint8 error_cause; 
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CMMS_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            smsal_cmms_test(&rsp_str);
            string_length = strlen((char*)rsp_str);
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_READ_MODE:
        {
            l4c_sms_get_more_req(source_string_ptr->src_id, &mode);
            
            rmmi_ptr->arg_list[0] = (void*)&mode;
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CMMS: %d", rmmi_ptr->arg_list, 1);
            rsp_str = &buffer[0];
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
	     mode = (kal_uint8) rmmi_int_validator_range_check(
                                &error_cause,
                                source_string_ptr,
                                rmmi_ptr->s_reg.s3,
                                2);
					
	     if (mode == RMMI_VALIDATOR_ERROR)
            {
                	if (error_cause == RMMI_PARSE_NOT_FOUND)
                	{
                	       ret_val = KAL_TRUE;
                	}
			break;
            }

            ret_val = l4c_sms_set_more_req(source_string_ptr->src_id, mode);
            break;
        }

        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_sms_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_cmss_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cmss_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_bool addr_present = KAL_TRUE;
    kal_uint16 index;
    l4c_number_struct da;
    l4c_context_struct *l4c_ptr = L4C_PTR;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CMSS_HDLR_ENTRY);

    if (l4c_ptr->sms_ready_flag == KAL_FALSE)
    {
        rmmi_ptr->cmee_err = OPERATION_NOT_ALLOWED_ERR;
    }
    else
    {
    	    switch (source_string_ptr->cmd_mode)
	    {
	    #ifdef __test_mode__
	        case RMMI_TEST_MODE:
	        {
	            ret_val = KAL_TRUE;
	            break;
	        }
	    #endif /* __test_mode__ */ 
	        case RMMI_SET_OR_EXECUTE_MODE:
	        {
	            kal_uint8 len;
	            kal_uint8 temp_num[MAX_CC_ADDR_LEN];
	            kal_uint8 error_cause;

	            if (is_nw_registered() == KAL_FALSE)
	            {
	                return;
	            }

	            index = (kal_uint16) rmmi_int_validator_ext(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);
	            if (index == 0)
	            {
	                break;
	            }
	            else
	            {
	                index--;        // convert index , start from 1 not 0 
	            }

	            rmmi_string_validator_ext(
	                        &error_cause,
	                        source_string_ptr,
	                        (kal_uint8) RMMI_COMMA,
	                        MAX_CC_ADDR_LEN,
	                        (kal_uint8*) da.number);
	            if (error_cause == RMMI_PARSE_NOT_FOUND)
	            {
	                addr_present = KAL_FALSE;
	            }
	            else if (error_cause != RMMI_PARSE_OK)
	            {
	                break;
	            }
	            else
	            {
	                da.type = (kal_uint8) rmmi_int_validator_ext(&error_cause, source_string_ptr, rmmi_ptr->s_reg.s3);
	                if (error_cause == RMMI_PARSE_NOT_FOUND)
	                {
	                    da.type = 129;      //default value
	                }
	                else if (error_cause != RMMI_PARSE_OK)
	                {
	                    break;
	                }
	                else if ((da.type != 145) && (da.type != 129))
	                {
	                    break;
	                }

	                if (da.number[0] == RMMI_CHAR_PLUS)
	                {
	                    len = (kal_uint8)strlen((char*)da.number);
	                    kal_mem_cpy((kal_uint8*) temp_num, (kal_uint8*) & da.number[1], len - 1);
	                    kal_mem_cpy((kal_uint8*) da.number, (kal_uint8*) temp_num, len - 1);
	                    da.number[len - 1] = 0;
	                    da.type = 145;
	                }
	                if (!(rmmi_is_number_string(da.number)))
	                {
	                    break;
	                }
	            }

	            da.length = (kal_uint8)strlen((char*)da.number);
	            ret_val = l4c_sms_exe_storage_post_req(
	                        source_string_ptr->src_id,
	                        index,
	                        SMSAL_INVALID_INDEX,
	                        addr_present,
	                        da,
	                        KAL_FALSE,
	                        0);

	            if (ret_val == KAL_FALSE)
	            {
	                break;
	            }
	            return;

	        }

	        default:
	        {
	            /* unrecognized format of AT command line */
	            break;
	        }
	    }   /* end of the switch */
    }
    rmmi_sms_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}

/*****************************************************************************
 * FUNCTION
 *  rmmi_esmss_hdlr
 * DESCRIPTION
 *  this is proprietary AT command to enable/disable SMS Status change when +CMGR and +CMGL
 *  mtk00714 add on 2004/06/14
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_esmss_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint8 const *rsp_str = NULL;
    kal_uint16 string_length = 0;
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 mode;
#if defined(__SMS_STORAGE_BY_MMI__)
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;
#endif

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            #if defined(__SMS_STORAGE_BY_MMI__) 
            {              
                string_length = rmmi_fast_string_print(
	                                   buffer,
	                                   (kal_uint8*) "+ESMSS: (0-1)",
	                                   rmmi_ptr->arg_list,
	                                   0);
                rsp_str = &buffer[0];
            }
            #else
            {
                smsal_esmss_test(&rsp_str);
                string_length = strlen((char*)rsp_str);
            }
            #endif
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_READ_MODE:
        {
            #if defined(__SMS_STORAGE_BY_MMI__) 
            {
                rmmi_ptr->arg_list[0] = (void*)&rmmi_ptr->esmss_mode;	
                string_length = rmmi_fast_string_print(
                                   buffer,
                                   (kal_uint8*) "+ESMSS: %d",
                                   rmmi_ptr->arg_list,
                                   1);
            }
            #else
            {               
                smsal_esmss_query(&mode);
                kal_sprintf((char*)buffer, "+ESMSS: %d", mode);
                string_length = (kal_uint16)strlen((char*)buffer);
            }
            #endif
            ret_val = KAL_TRUE;
            rsp_str = &buffer[0];
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;

	     mode = (kal_uint8) rmmi_int_validator_range_check(
                                &error_cause,
                                source_string_ptr,
                                (kal_uint8) RMMI_COMMA,
                                1);
            if (mode == RMMI_VALIDATOR_ERROR)
            {
                break;
            }

            #if defined(__SMS_STORAGE_BY_MMI__) 
            {
                rmmi_ptr->esmss_mode = mode;
            }
            #else
            {
                smsal_esmss_set(mode);
            }
            #endif
            
            ret_val = KAL_TRUE;
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


#ifdef __SMS_AT_DIRECT_INPUT_SUPPORT__ 


/*****************************************************************************
 * FUNCTION
 *  rmmi_cmgc_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cmgc_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 format;
    kal_uint8 result;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CMGC_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            rmmi_ptr->cmee_err = RMMI_ERR_SYNTEX_ERROR;

            l4c_sms_get_msg_format_req(source_string_ptr->src_id, &format);
            if (format == SMSAL_TEXT_MODE)
            {
                kal_uint8 fo, ct, mn = 0, pid = 0;
                kal_uint8 length;
                kal_uint8 command[SMSAL_MAX_CMD_LEN * 2];
                kal_uint8 pdu[SMSAL_MAX_CMD_LEN];
                l4c_number_struct da;
                kal_uint8 error_cause;

                fo = (kal_uint8) rmmi_int_validator_ext(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);
                if (fo == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }

                ct = (kal_uint8) rmmi_int_validator_ext(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);
                if (ct == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }

                pid = (kal_uint8) rmmi_int_validator_ext(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);
                if (pid == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }

                mn = (kal_uint8) rmmi_int_validator_ext(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);
                if (mn == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }

                result = rmmi_string_validator_ext(
                            &error_cause,
                            source_string_ptr,
                            (kal_uint8) RMMI_COMMA,
                            MAX_CC_ADDR_LEN,
                            (kal_uint8*) da.number);
                if (result == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }

                da.type = (kal_uint8) rmmi_int_validator_ext(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);
                if (da.type == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }

                //result = rmmi_sms_text_validator(
                //            source_string_ptr,
                //            rmmi_ptr->s_reg.s3,
                //            SMSAL_MAX_CMD_LEN*2,
                //            (kal_uint8 *)command
                //           );

                result = rmmi_string_validator_ext(
                            &error_cause,
                            source_string_ptr,
                            rmmi_ptr->s_reg.s3,
                            SMSAL_MAX_CMD_LEN * 2,
                            (kal_uint8*) command);

                if (result == RMMI_VALIDATOR_ERROR)
                {
                    command[0] = RMMI_END_OF_STRING_CHAR;
                    length = 0;
                }
                else
                {
                    check_hex_value((kal_uint8*) command, (kal_uint8*) pdu);
                    length = (kal_uint8)(strlen((char*)command) >> 1);
                }
                da.length = (kal_uint8)strlen((char*)da.number);
                ret_val = l4c_sms_exe_post_command_req(source_string_ptr->src_id, fo, ct, mn, pid, da, length, pdu);
            }
            else
            {
                kal_uint16 data_len;
                kal_uint16 length;
                kal_uint8 command[SMSAL_MAX_TPDU_SIZE * 2];
                kal_uint8 pdu[SMSAL_MAX_TPDU_SIZE];
                kal_uint8 error_cause;

                data_len = (kal_uint16) rmmi_int_validator(source_string_ptr, (kal_uint8) RMMI_COMMA);
                if (data_len == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }

                //result = rmmi_sms_text_validator(
                //            source_string_ptr,
                //            rmmi_ptr->s_reg.s3,
                //            SMSAL_MAX_TPDU_SIZE*2,
                //            (kal_uint8 *)command
                //           );

                result = rmmi_string_validator_ext(
                            &error_cause,
                            source_string_ptr,
                            rmmi_ptr->s_reg.s3,
                            SMSAL_MAX_TPDU_SIZE * 2,
                            (kal_uint8*) command);

                if (result == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }

                check_hex_value((kal_uint8*) command, (kal_uint8*) pdu);
                length = (kal_uint16)(strlen((char*)command) >> 1);

                if (length == 0)        // length should never equals 0
                {
                    break;
                }
                else if (length < (pdu[0] + 1)) //length should be long enough to contain SC address.
                {
                    break;
                }
                else if ((length - (pdu[0] + 1)) != data_len)   //data_len should be the length without SC address.
                {
                    break;
                }

                ret_val = l4c_sms_exe_post_command_pdu_req(source_string_ptr->src_id, data_len, length, pdu);
            }
            if (ret_val == KAL_FALSE)
            {
                rmmi_ptr->cmee_err = RMMI_ERR_UNKNOWN;
                break;
            }
            else
            {
                return;
            }
        }
        default:
        {
            /* unrecognized format of AT command line */
            rmmi_ptr->cmee_err = RMMI_ERR_UNSPECIFIED;
            break;
        }
    }   /* end of the switch */
    rmmi_sms_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_cnma_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cnma_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 result;
    kal_uint8 mode;
    kal_uint16 length, data_len;
    kal_uint8 const *rsp_str = NULL;
    kal_uint16 string_length = 0;
    kal_uint8 service;
    smsal_service_mode_struct info;
    kal_uint8 format;
    kal_uint8 error_cause;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CNMA_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_TEST_MODE:
        {
            smsal_cnma_test(&rsp_str);
            string_length = (kal_uint16)strlen((char*)rsp_str);
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_ACTIVE_MODE:
        {
            l4c_sms_get_service_mode_req(source_string_ptr->src_id, &service, &info);
            if (service != 1)
            {
                break;  //only when +CSMS=1, this command works
            }

            ret_val = l4c_sms_exe_send_ack_req(source_string_ptr->src_id, CNMA_MODE_TEXT_MODE, 0, NULL);
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 ack[SMSAL_MAX_TPDU_SIZE * 2];
            kal_uint8 pdu[SMSAL_MAX_TPDU_SIZE];

            l4c_sms_get_service_mode_req(source_string_ptr->src_id, &service, &info);
            if (service != 1)
            {
                break;  //only when +CSMS=1, this command works
            }

            l4c_sms_get_msg_format_req(source_string_ptr->src_id, &format);
            if (format == 0)    //PDU mode
            {
                mode = (kal_uint8) rmmi_int_validator_ext(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);
                if (mode > 2)
                {
                    break;      //0-2
                }

                data_len = (kal_uint16) rmmi_int_validator_ext(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);
                if ((data_len == RMMI_VALIDATOR_ERROR) && (error_cause == RMMI_PARSE_NOT_FOUND))        //no <length>,<pdu>
                {
                    length = 0;
                }
                else if ((data_len == RMMI_VALIDATOR_ERROR) && (error_cause == RMMI_PARSE_ERROR))       //invalid length
                {
                    break;
                }
                else    //get <pdu>
                {
                    //result = rmmi_sms_text_validator(
                    //                source_string_ptr,
                    //                rmmi_ptr->s_reg.s3,
                    //                SMSAL_MAX_TPDU_SIZE*2,
                    //                (kal_uint8 *)ack);

                    result = rmmi_string_validator_ext(
                                &error_cause,
                                source_string_ptr,
                                rmmi_ptr->s_reg.s3,
                                SMSAL_MAX_TPDU_SIZE * 2,
                                (kal_uint8*) ack);

                    if (result == RMMI_VALIDATOR_ERROR)
                    {
                        break;
                    }

                    check_hex_value((kal_uint8*) ack, (kal_uint8*) pdu);
                    length = (kal_uint16)(strlen((char*)ack) >> 1);
                }
                ret_val = l4c_sms_exe_send_ack_req(source_string_ptr->src_id, mode, length, (kal_uint8*) pdu);
            }
            break;
        }
        default:
            break;
    }   /* end of the switch */
    rmmi_sms_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


#else


/*****************************************************************************
 * FUNCTION
 *  rmmi_cmgc_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cmgc_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 format;
    kal_uint8 result;
    kal_uint8 indexofCR = 0;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CMGC_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            rmmi_ptr->cmee_err = RMMI_ERR_SYNTEX_ERROR;

            /* find the first <LF> in the string, which is the original <CR> */
            while ((source_string_ptr->string_ptr[indexofCR] != rmmi_ptr->s_reg.s4) &&
                   (source_string_ptr->string_ptr[indexofCR] != rmmi_ptr->s_reg.s3))
            {
                indexofCR++;
            }
            if (source_string_ptr->string_ptr[indexofCR] == rmmi_ptr->s_reg.s3)
            {
                break;
            }
            else        // == s_reg.s4 (LF)
            {
                source_string_ptr->string_ptr[indexofCR] = rmmi_ptr->s_reg.s3;
            }

            l4c_sms_get_msg_format_req(source_string_ptr->src_id, &format);
            if (format == SMSAL_TEXT_MODE)
            {
                kal_uint8 fo, ct, mn = 0, pid = 0;
                kal_uint8 length;
                kal_uint8 command[SMSAL_MAX_CMD_LEN * 2];
                kal_uint8 pdu[SMSAL_MAX_CMD_LEN];
                l4c_number_struct da;
                kal_uint8 error_cause;

                fo = (kal_uint8) rmmi_int_validator_ext(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);
                if (fo == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }

                ct = (kal_uint8) rmmi_int_validator_ext(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);
                if (ct == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }

                if (source_string_ptr->index < indexofCR)
                {
                    pid = (kal_uint8) rmmi_int_validator_ext(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);
                    if (pid == RMMI_VALIDATOR_ERROR)
                    {
                        break;
                    }
                }

                if (source_string_ptr->index < indexofCR)
                {
                    mn = (kal_uint8) rmmi_int_validator_ext(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);
                    if (mn == RMMI_VALIDATOR_ERROR)
                    {
                        break;
                    }
                }

                if (source_string_ptr->index < indexofCR)
                {
                    result = rmmi_string_validator_ext(
                                &error_cause,
                                source_string_ptr,
                                (kal_uint8) RMMI_COMMA,
                                MAX_CC_ADDR_LEN,
                                (kal_uint8*) da.number);
                    if (result == RMMI_VALIDATOR_ERROR)
                    {
                        break;
                    }
                }

                if (source_string_ptr->index < indexofCR)
                {
                    da.type = (kal_uint8) rmmi_int_validator_ext(
                                            &error_cause,
                                            source_string_ptr,
                                            (kal_uint8) RMMI_COMMA);
                    if (da.type == RMMI_VALIDATOR_ERROR)
                    {
                        break;
                    }
                }

                source_string_ptr->index = indexofCR + 1;
                result = rmmi_sms_text_validator(
                            source_string_ptr,
                            rmmi_ptr->s_reg.s3,
                            SMSAL_MAX_CMD_LEN * 2,
                            (kal_uint8*) command);
                if (result == RMMI_VALIDATOR_ERROR)
                {
                    command[0] = RMMI_END_OF_STRING_CHAR;
                    length = 0;
                }
                else
                {
                    check_hex_value((kal_uint8*) command, (kal_uint8*) pdu);
                    length = strlen((char*)command) >> 1;
                }
                da.length = strlen((char*)da.number);
                ret_val = l4c_sms_exe_post_command_req(source_string_ptr->src_id, fo, ct, mn, pid, da, length, pdu);
            }
            else
            {
                kal_uint16 data_len;
                kal_uint16 length;
                kal_uint8 command[SMSAL_MAX_TPDU_SIZE * 2];
                kal_uint8 pdu[SMSAL_MAX_TPDU_SIZE];

                data_len = (kal_uint16) rmmi_int_validator(source_string_ptr, (kal_uint8) RMMI_COMMA);
                if (data_len == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }

                source_string_ptr->index = indexofCR + 1;
                result = rmmi_sms_text_validator(
                            source_string_ptr,
                            rmmi_ptr->s_reg.s3,
                            SMSAL_MAX_TPDU_SIZE * 2,
                            (kal_uint8*) command);
                if (result == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }

                check_hex_value((kal_uint8*) command, (kal_uint8*) pdu);
                length = strlen((char*)command) >> 1;

                if (length == 0)        // length should never equals 0
                {
                    break;
                }
                else if (length < (pdu[0] + 1)) //length should be long enough to contain SC address.
                {
                    break;
                }
                else if ((length - (pdu[0] + 1)) != data_len)   //data_len should be the length without SC address.
                {
                    break;
                }

                ret_val = l4c_sms_exe_post_command_pdu_req(source_string_ptr->src_id, data_len, length, pdu);
            }
            if (ret_val == KAL_FALSE)
            {
                rmmi_ptr->cmee_err = RMMI_ERR_UNKNOWN;
                break;
            }
            else
            {
                return;
            }
        }
        default:
        {
            /* unrecognized format of AT command line */
            rmmi_ptr->cmee_err = RMMI_ERR_UNSPECIFIED;
            break;
        }
    }   /* end of the switch */
    rmmi_sms_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_cnma_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cnma_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 result;
    kal_uint8 mode;
    kal_uint16 length, data_len;
    kal_uint8 const *rsp_str = NULL;
    kal_uint16 string_length = 0;
    kal_uint8 service;
    smsal_service_mode_struct info;
    kal_uint8 format;
    kal_uint8 error_cause;
    kal_uint8 indexofCR = 0;   
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CNMA_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_TEST_MODE:
        {
            smsal_cnma_test(&rsp_str);
            string_length = strlen((char*)rsp_str);
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_ACTIVE_MODE:
        {
            l4c_sms_get_service_mode_req(source_string_ptr->src_id, &service, &info);
            if (service != 1)
            {
                break;  //only when +CSMS=1, this command works
            }

            ret_val = l4c_sms_exe_send_ack_req(source_string_ptr->src_id, CNMA_MODE_TEXT_MODE, 0, NULL);
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 ack[SMSAL_MAX_TPDU_SIZE * 2];
            kal_uint8 pdu[SMSAL_MAX_TPDU_SIZE];

            l4c_sms_get_service_mode_req(source_string_ptr->src_id, &service, &info);
            if (service != 1)
            {
                break;  //only when +CSMS=1, this command works
            }

            l4c_sms_get_msg_format_req(source_string_ptr->src_id, &format);
            if (format == 0)    //PDU mode
            {
                /* find the first <LF> in the string, which is the original <CR> */
                while ((source_string_ptr->string_ptr[indexofCR] != rmmi_ptr->s_reg.s4) &&
                       (source_string_ptr->string_ptr[indexofCR] != rmmi_ptr->s_reg.s3))
                {
                    indexofCR++;
                }
                if (source_string_ptr->string_ptr[indexofCR] == rmmi_ptr->s_reg.s3)
                {
                    break;
                }
                else    // == s_reg.s4 (LF)
                {
                    source_string_ptr->string_ptr[indexofCR] = rmmi_ptr->s_reg.s3;
                }

		mode = (kal_uint8) rmmi_int_validator_range_check(
                                NULL,
                                source_string_ptr,
                                (kal_uint8) RMMI_COMMA,
                                2);  
                if (mode == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }

                if (source_string_ptr->index < indexofCR)
                {
                    data_len = (kal_uint16) rmmi_int_validator_ext(
                                                &error_cause,
                                                source_string_ptr,
                                                (kal_uint8) RMMI_COMMA);
                    if ((data_len == RMMI_VALIDATOR_ERROR) && (error_cause == RMMI_PARSE_NOT_FOUND))    //no <length>,<pdu>
                    {
                        kal_trace(TRACE_INFO, INFO_NO_LENGH_INPUT);
                        length = 0;
                    }
                    else if ((data_len == RMMI_VALIDATOR_ERROR) && (error_cause == RMMI_PARSE_ERROR))   //invalid length
                    {
                        kal_trace(TRACE_INFO, INFO_INVALID_LENGH_INPUT);

                        break;
                    }
                    else        //get <pdu>
                    {
                        result = rmmi_sms_text_validator(
                                    source_string_ptr,
                                    rmmi_ptr->s_reg.s3,
                                    SMSAL_MAX_TPDU_SIZE * 2,
                                    (kal_uint8*) ack);
                        if (result == RMMI_VALIDATOR_ERROR)
                        {
                            break;
                        }

                        check_hex_value((kal_uint8*) ack, (kal_uint8*) pdu);
                        length = strlen((char*)ack) >> 1;
                    }
                }
                else
                {
                    // need modify !!?
                    length = 0;
                }

                /* point to where pdu data starts */
                source_string_ptr->index = indexofCR + 1;

                ret_val = l4c_sms_exe_send_ack_req(source_string_ptr->src_id, mode, length, (kal_uint8*) pdu);
            }
            break;
        }
        default:
            break;
    }   /* end of the switch */
    rmmi_sms_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


#endif


#ifdef __CB__


/*****************************************************************************
 * FUNCTION
 *  rmmi_cscb_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cscb_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 result_mid;
    kal_uint8 mode;
    kal_uint8 mid_str[256], dcs_str[256], mir_str[256];
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[256];
    kal_uint8 buf[11];
    kal_uint8 total_mid_num, total_mir_num, total_dcs_num;
    kal_uint8 used_mid_num = 0, used_mir_num = 0;
    kal_uint16 string_length = 0;
    rmmi_string_struct temp;
    l4c_cb_info_struct *info = NULL;
    kal_uint16 temp_mid[SMSAL_MMI_CBMI_MAX_ENTRY];
    kal_uint16 temp_mir[SMSAL_CB_MAX_ENTRY*2];
    kal_uint16 i;
    kal_uint16 counter=0;
    kal_uint8 used_dcs_num = 0;
    kal_uint8 count;
    kal_uint8 result_dcs;
    l4c_context_struct *l4c_ptr = L4C_PTR;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CSCB_HDLR_ENTRY);

    if (l4c_ptr->sms_ready_flag == KAL_FALSE)
    {
        rmmi_ptr->cmee_err = OPERATION_NOT_ALLOWED_ERR;
    }
    else
    {
        info = (l4c_cb_info_struct*) get_ctrl_buffer(sizeof(l4c_cb_info_struct));

        kal_mem_set(info->mid, 0xff, SMSAL_MMI_CBMI_MAX_ENTRY * 2); /* 2 bytes one element */
        kal_mem_set(info->mir, 0xff, SMSAL_CB_MAX_ENTRY * 4);   /* 4 byte one emelment */

        for( i=0 ; i<SMSAL_CB_MAX_ENTRY ; i++)  
        {
            info->dcs[i] = SMSAL_CB_UNUSED_DCS;
        }

        kal_mem_set(info->mid_mask, 0, SMSAL_MMI_CBMI_MAX_ENTRY);
        kal_mem_set(info->mir_mask, 0, SMSAL_CB_MAX_ENTRY);
        kal_mem_set(info->dcs_mask, 0, SMSAL_CB_MAX_ENTRY);

        info->is_all_language_on = KAL_FALSE;

        switch (source_string_ptr->cmd_mode)
        {
        #ifdef __test_mode__
            case RMMI_TEST_MODE:
            {
                kal_sprintf((char*)buffer, "+CSCB: (0, 1)");

                rsp_str = &buffer[0];

                string_length = strlen((char*)rsp_str);

                ret_val = KAL_TRUE;

                break;
            }
        #endif /* __test_mode__ */ 

            case RMMI_READ_MODE:
            {
                kal_uint8 j;
                kal_uint8 i;
                kal_uint16 len = 0;
                kal_uint8 cb_on_off;

                info->para_ind = 0; //using zero for get all info

                /* make sure output string is clear */
                kal_mem_set(mid_str,0, sizeof(mid_str));
                kal_mem_set(mir_str,0, sizeof(mir_str));
                kal_mem_set(dcs_str,0, sizeof(dcs_str));

                ret_val = l4c_sms_get_cb_mode_req(
                                    source_string_ptr->src_id,
                                    &cb_on_off,
                                    &total_mid_num,
                                    &total_mir_num,
                                    &total_dcs_num,
                                    info);

                kal_trace(TRACE_GROUP_3, RMMI_CB_INFO, cb_on_off, total_mid_num, total_mir_num, total_dcs_num);

                if (ret_val == KAL_FALSE)
                {
                    break;
                }

                for (j = 0; j < total_mid_num; j++) /* calculate mid used number */
                {
                    if ((info->mid[j] != 0xffff) && (info->mid_mask[j] == 1))       // mid exists and is enabled.
                    {
                        temp_mid[used_mid_num] = info->mid[j];
                        used_mid_num++;
                    }
                }
                for (j = 0; j < total_mir_num; j++)   /* check used mir entry */
                {
                    if (((info->mir[ j * 2] != 0xffff) && (info->mir[j * 2 + 1] != 0xffff)) && (info->mir_mask[j] == 1))     // mir exists and is enabled.
                    {
                        temp_mir[used_mir_num * 2] = info->mir[j * 2];
                        temp_mir[used_mir_num * 2 + 1] = info->mir[j * 2 + 1];
                        used_mir_num++;
                    }
                }

                for (i = 0; i < used_mid_num; i++)
                {
                    kal_sprintf((char*)buf, "%u", temp_mid[i]);
                    if (i != 0)     // we have to add comma between two value and the number is total - 1
                    {
                        strcat((kal_char*) mid_str, ",");
                    }
                    len = (kal_uint16)strlen((kal_char*) mid_str);
                    kal_sprintf((char*)mid_str + len, "%s", buf);
                }
                for (i = 0; i < used_mir_num; i++)
                {
                    kal_sprintf((char*)buf, "%u-%u", temp_mir[2 * i], temp_mir[2 * i + 1]);
                    if (i != 0)
                    {
                        strcat((kal_char*) mir_str, ",");
                    }
                    len = (kal_uint16)strlen((kal_char*) mir_str);
                    kal_sprintf((char*)mir_str + len, "%s", buf);
                }

                if (strlen((kal_char*) mir_str) != 0 && strlen((kal_char*) mid_str) != 0)
                {
                    strcat((kal_char*) mid_str, ",");
                    strcat((kal_char*) mid_str, (kal_char*) mir_str);
                }
                else if (strlen((kal_char*) mir_str) != 0)
                {
                    strcpy((kal_char*) mid_str, (kal_char*) mir_str);
                }

                //#if 0 /* mtk00714 marked on 20050201 (smsal don't support dcs) */
                for (j = 0; j < total_dcs_num; j++) /* check used dcs entry */
                {
                    /*
                    * if(info.dcs[j] !=0x0080)
                    * used_dcs_num++; 
                    */
                    if ((info->dcs[j] == 0x0080) || (info->dcs[j] == 0xffff) || (info->dcs[j] == 0x8080))
                    {
                        //empty 

                        if (info->dcs[j] == 0x0080)
                        {
                            used_dcs_num++;
                        }

                    }
                    else
                    {
                        used_dcs_num++;
                    }
                }

                if (total_dcs_num != 0) /* dcs support */
                {
                    for (i = 0; i < used_dcs_num; i++)
                    {
                        if (info->dcs_mask[i] == KAL_TRUE)
                        {
                            if( info->dcs[i] & 0xff00 )
                            {
                                info->dcs[i] = smsal_cb_conver_ISO639_to_CBDCS(info->dcs[i]);
                                if( info->dcs[i] == SMSAL_CB_UNUSED_DCS )
                                {
                                    continue;
                                }
                            }

                            if (counter != 0)
                            {
                                strcat((kal_char*) dcs_str, ",");
                            }
                            len = (kal_uint16)strlen((kal_char*) dcs_str);
                            rmmi_ptr->arg_list[0] = (void*)&(info->dcs[i]);
                            string_length = rmmi_fast_string_print(buf, (kal_uint8*) "%u", rmmi_ptr->arg_list, 1);
                            kal_sprintf((char*)dcs_str + len, "%s", buf);  /* output value */
                            counter++;
                        }
                    }
                }

                if (cb_on_off == KAL_TRUE) 
                {
                    mode = 0;
                }
                else
                {
                    mode = 1;
                }

            #ifndef __CSCB_ALL_LANGUAGE_ON__
                kal_sprintf((char*)buffer, "+CSCB: %d,\"%s\",\"%s\"", mode, mid_str, dcs_str);
            #else		
                kal_sprintf((char*)buffer, "+CSCB: %d,\"%s\",\"%s\",%d", mode, mid_str, dcs_str, info->is_all_language_on);
            #endif

                string_length = (kal_uint16)strlen((char*)buffer);
                rsp_str = &buffer[0];

                break;
            }
            case RMMI_SET_OR_EXECUTE_MODE:
            {
                kal_uint8 dummy_mode;
                l4c_cb_info_struct *dummy_info;
                kal_uint8 error_cause;    
            #ifndef __SP_RIL_SUPPORT__
                kal_uint8 i;
            #endif
                kal_bool is_all_language_on = 0;
                l4c_cb_set_type_enum set_type = L4C_NORMAL_CB_UPDATE;

                /* make sure output string is clear */
                kal_mem_set(mid_str,0, sizeof(mid_str));
                kal_mem_set(mir_str,0, sizeof(mir_str));
                kal_mem_set(dcs_str,0, sizeof(dcs_str));

                mode = (kal_uint8) rmmi_int_validator_range_check(
                                            &error_cause,
                                            source_string_ptr,
                                            (kal_uint8) RMMI_COMMA,
                                            1);  

                if (mode == RMMI_VALIDATOR_ERROR)
                {
                    if (error_cause == RMMI_PARSE_NOT_FOUND)
                    {
                        ret_val = KAL_TRUE;
                    }
                    break;       
                }
                else
                {
                    if (mode == 0)
                    {
                        mode = KAL_TRUE;
                    }
                    else //mode = 1
                    {
                        mode = KAL_FALSE;
                    }
                }

                rmmi_ptr->cb_mode = (kal_bool) mode;        //save mode so that we can active it after update confiirm

                info->para_ind = 0; //using zero for get all info

                dummy_info = (l4c_cb_info_struct*) get_ctrl_buffer(sizeof(l4c_cb_info_struct));

                ret_val = l4c_sms_get_cb_mode_req(
                                    source_string_ptr->src_id,
                                    &dummy_mode,
                                    &total_mid_num,
                                    &total_mir_num,
                                    &total_dcs_num,
                                    dummy_info);

                kal_trace(TRACE_GROUP_3, RMMI_CB_INFO, dummy_mode, total_mid_num, total_mir_num, total_dcs_num);

                free_ctrl_buffer(dummy_info);

                if (ret_val == KAL_FALSE)
                {
                    break;
                }

                ret_val = KAL_FALSE;        //reset

                result_mid = rmmi_string_validator_ext(
                                        &error_cause, 
                                        source_string_ptr,
                                        (kal_uint8) RMMI_COMMA,
                                        512, 
                                        (kal_uint8*) mid_str);

                if ((result_mid == RMMI_VALIDATOR_ERROR && error_cause == RMMI_PARSE_OK) || 
                    result_mid != RMMI_VALIDATOR_ERROR)
                {
                    temp.index = 0;
                    temp.string_ptr = (kal_uint8*) mid_str;
                    ret_val = parse_int_list((kal_bool) mode, total_mid_num, total_mir_num, &temp, info);

                    if (ret_val == KAL_FALSE)
                    {
                        break;
                    }

                    result_dcs = rmmi_string_validator_ext(
                                            &error_cause,
                                            source_string_ptr,
                                            (kal_uint8) RMMI_COMMA,
                                            256,
                                            (kal_uint8*) dcs_str);

                    if (result_dcs == RMMI_VALIDATOR_ERROR) 
                    {
                        if (error_cause != RMMI_PARSE_NOT_FOUND && error_cause != RMMI_PARSE_OK)
                        {
                            ret_val = KAL_FALSE;
                            break;
                        }
                    }

                    temp.index = 0;
                    temp.string_ptr = (kal_uint8*) dcs_str;
                    count = parse_dcs_list(&temp, info->dcs);

                    /* check if does not exist or overflow */
                    if (count == 0xff || count > total_dcs_num)
                    {
                        ret_val = KAL_FALSE;
                        break;
                    }
                    else
                    {
                        kal_mem_set(info->dcs_mask, mode, count);
                    }

                #ifndef __SP_RIL_SUPPORT__
                    for (i = 0; i < count; i++)
                    {
                        if( (info->dcs[i]>15 && info->dcs[i]<32) || info->dcs[i]>36)
                        {
                            ret_val = KAL_FALSE;
                            break;
                        }
                    }
                #endif

                    if (ret_val == KAL_FALSE)
                    {
                        break;
                    }

                    is_all_language_on = (kal_uint8) rmmi_int_validator_range_check(
                                                                &error_cause,
                                                                source_string_ptr,
                                                                (kal_uint8) RMMI_COMMA,
                                                                1);
                    if (is_all_language_on == RMMI_VALIDATOR_ERROR)
                    {
                        if (error_cause != RMMI_PARSE_NOT_FOUND)
                        {
                            ret_val = KAL_FALSE;
                            break;
                        }
                    }
                    else
                    {
                        if (is_all_language_on == 1)
                        {
                            info->is_all_language_on = KAL_TRUE;
                        }
                    }

                    /* Get set_type for ETWS 2.0, we should be able to handle AT+CSCB that not input this value 
                    set_type default value is L4C_NORMAL_CB_UPDATE for CB general configuration */   
                    set_type = (kal_uint8) rmmi_int_validator_range_check(
                                                        &error_cause,
                                                        source_string_ptr,
                                                        rmmi_ptr->s_reg.s3,
                                                        2);

                #if defined(__GEMINI__) && defined(__ETWS_SUPPORT__) 
                    if (set_type == RMMI_VALIDATOR_ERROR)
                    {
                        if (error_cause != RMMI_PARSE_NOT_FOUND)
                        {
                            ret_val = KAL_FALSE;

                            break;
                        }
                        else
                        {
                            set_type = L4C_NORMAL_CB_UPDATE;
                        }
                    }
                #else    
                    set_type = L4C_NORMAL_CB_UPDATE;
                #endif

                }
                else if (error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    // AT+CSCB=1, ""<CR>  or AT+CSCB=1<CR>
                    // all mid => 0xffff, mid_mask => 0
                }
                else
                {
                    break;
                }

                if (total_mid_num != 0)
                {
                    info->para_ind = (SMSAL_CB_MI | SMSAL_CB_MI_MASK);
                }
                if (total_mir_num != 0)
                {
                    info->para_ind |= (SMSAL_CB_MIR | SMSAL_CB_MIR_MASK);
                }

                //#if 0 /* mtk00714 marked on 20050201 (smsal don't support dcs) */
                if (strlen((kal_char*) mid_str) == 0 && strlen((kal_char*) dcs_str) == 0) /* only change the mask of MID MIR and DCS */
                {
                    info->para_ind = SMSAL_CB_MI_MASK | SMSAL_CB_MIR_MASK | SMSAL_CB_DCS_MASK;
                }
                else if (strlen((kal_char*) dcs_str) == 0)  /* change mid or mir only */
                {
                    if (total_mid_num != 0)
                    {
                        info->para_ind = (SMSAL_CB_MI | SMSAL_CB_MI_MASK);
                    }
                    if (total_mir_num != 0)
                    {
                        info->para_ind |= (SMSAL_CB_MIR | SMSAL_CB_MIR_MASK);
                    }
                }
                else if (strlen((kal_char*) mid_str) == 0)  /* change dcs */
                {
                    if (total_dcs_num != 0)
                    {
                        info->para_ind = (SMSAL_CB_DCS | SMSAL_CB_DCS_MASK);
                    }
                }
                else
                {
                    if (total_mid_num != 0)
                    {
                        info->para_ind = (SMSAL_CB_MI | SMSAL_CB_MI_MASK);
                    }
                    if (total_mir_num != 0)
                    {
                        info->para_ind |= (SMSAL_CB_MIR | SMSAL_CB_MIR_MASK);
                    }
                    if (total_dcs_num != 0)
                    {
                        info->para_ind |= (SMSAL_CB_DCS | SMSAL_CB_DCS_MASK);
                    }
                }

                if (is_all_language_on == 1)
                {
                    info->para_ind = SMSAL_CB_ALL_LANG;
                }

                info->set_type = set_type;

                ret_val = l4c_sms_set_cb_mode_req(source_string_ptr->src_id, info);

                // ret_val = l4c_cb_subscribe_req (source_string_ptr->src_id, mode);

                if (ret_val == KAL_TRUE)
                {
                    free_ctrl_buffer(info);
                    return;
                }

                break;
            }
            default:
            {
                /* unrecognized format of AT command line */
                break;
            }
        }

        free_ctrl_buffer(info);
    }

    rmmi_sms_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);

    return;
}


#endif /* __CB__ */ 

/*****************************************************************************
 * FUNCTION
 *  rmmi_csma_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for send sms abort.
 *  mtk00468 add on 04/01
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_csma_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 seq_num;
    kal_uint8 format;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;
    
    kal_trace(TRACE_FUNC, FUNC_RMMI_CSMA_HDLR_ENTRY);
    
    /* checking the command mode */
    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_ACTIVE_MODE:  /* at*csma active command mode without para. */
        {
            seq_num = 1;
            l4c_sms_exe_abort_req(source_string_ptr->src_id, seq_num); /* call l4c function to SMSAL */
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:  
        {
            kal_uint8 error_cause;

            format = (kal_uint8) rmmi_int_validator_range_check(
                                &error_cause,
                                source_string_ptr,
                                rmmi_ptr->s_reg.s3,
                                0);
	     if (format == RMMI_VALIDATOR_ERROR)
            {
                break;
            }
         
            seq_num = 2;          
            l4c_sms_exe_abort_req(source_string_ptr->src_id, seq_num); /* call l4c function to SMSAL */
            ret_val = KAL_TRUE;
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}

#endif /* !defined(__SLIM_AT__) */


#if !defined(__ULC_AT__)

/*****************************************************************************
 * FUNCTION
 *  rmmi_cgsms_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cgsms_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 service;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    kal_uint8 error_cause;
    l4c_context_struct *l4c_ptr = L4C_PTR;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;
    
    kal_trace(TRACE_FUNC, FUNC_RMMI_CGSMS_HDLR_ENTRY);
    
    if (l4c_ptr->sms_ready_flag == KAL_FALSE)
    {
        rmmi_ptr->cmee_err = OPERATION_NOT_ALLOWED_ERR;
    }
    else
    {
    	    switch (source_string_ptr->cmd_mode)
	    {
	        case RMMI_TEST_MODE:
	        {
	            smsal_cgsms_test(&rsp_str);
	            kal_sprintf((char*)buffer, "+CGSMS: %s", (char*)rsp_str);
	            string_length = (kal_uint16)strlen((char*)buffer);
	            ret_val = KAL_TRUE;
	            break;
	        }
	        case RMMI_READ_MODE:
	        {
	            l4c_sms_get_bearer_service_req(source_string_ptr->src_id, &service);

	            /* convert storage back to storage_code */
	            rmmi_ptr->arg_list[0] = (void*)&service;
	            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CGSMS: %d", rmmi_ptr->arg_list, 1);
	            ret_val = KAL_TRUE;
	            break;
	        }
	        case RMMI_SET_OR_EXECUTE_MODE:
	        {
		     service = (kal_uint8) rmmi_int_validator_range_check(
	                                &error_cause,
	                                source_string_ptr,
	                                rmmi_ptr->s_reg.s3,
	                                3); 
						
		     if (service == RMMI_VALIDATOR_ERROR)
	            {
	                	if (error_cause == RMMI_PARSE_NOT_FOUND)
	                	{
	                	       ret_val = KAL_TRUE;
	                	}
				break;
	            }

                   if ((custom_remove_cgsms_constraint() == KAL_FALSE) && ((l4c_is_test_sim() == KAL_FALSE) && (service == 0)))
                   {
                       break;
                   }

                   #ifndef __MOD_TCM__
                       if (service != 1) //if service is not CS
                       {
                           break;
                       }
                   #else 
                       #if !defined(__SMS_OVER_PS_SUPPORT__) //if gsm only, only allow at+cgsms=1 and return OK directly, others return ERROR.
                           if (service == 1)
                           {
                               ret_val = KAL_TRUE;
                           }
                           break;
                       #endif			
                   #endif

	            ret_val = l4c_sms_set_bearer_service_req(source_string_ptr->src_id, service);
	            if (ret_val == KAL_FALSE)
	            {
	                break;
	            }
	            return;
	        }
	        default:
	        {
	            /* unrecognized format of AT command line */
	            break;
	        }
	    }   /* end of the switch */
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) buffer, string_length);
    return;
}

#ifdef __SMS_AT_DIRECT_INPUT_SUPPORT__ 


/*****************************************************************************
 * FUNCTION
 *  rmmi_cmgs_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cmgs_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 result;
    kal_uint16 length;
    kal_uint16 data_len;
    kal_uint8 format;
    l4c_number_struct da, sca;
    kal_uint8 temp_num[MAX_CC_ADDR_LEN];
    kal_uint8 len;
    kal_uint8 i;
    kal_bool error_format = KAL_FALSE;
    kal_uint8 fo, vp, pid, dcs;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CMGS_HDLR_ENTRY);

    smsal_csmp_query(SMSAL_PROFILE_NONE, &fo, &vp, &pid, &dcs);
    kal_mem_set(&sca, 0, sizeof(l4c_number_struct));
    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;

            l4c_sms_get_msg_format_req(source_string_ptr->src_id, &format);

            if (format == SMSAL_TEXT_MODE)
            {
                kal_uint8 msg[280];
                kal_uint8 final_msg[280];

                kal_mem_set(final_msg, 0, SMSAL_ONE_MSG_LEN);

                result = rmmi_string_validator_ext(
                            &error_cause,
                            source_string_ptr,
                            (kal_uint8) RMMI_COMMA,
                            MAX_CC_ADDR_LEN,
                            (kal_uint8*) da.number);
                if (result == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }

                /* get da.type */
                da.type = (kal_uint8) rmmi_int_validator_ext(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);

                if (da.type == RMMI_VALIDATOR_ERROR)
                {
                    if (error_cause == RMMI_PARSE_NOT_FOUND)
                    {
                        da.type = 129;
                    }
                    else
                    {
                        break;
                    }
                }
                else
                {
                    if ((da.type != 129) && (da.type != 145))
                    {
                        break;
                    }
                }

                /* if '+' is present in <number>, type is forced to be 145 ,and '+' is removed. */
                if (da.number[0] == RMMI_CHAR_PLUS)
                {
                    da.type = 145;
                    len = (kal_uint8)strlen((char*)da.number);
                    kal_mem_cpy((kal_uint8*) temp_num, (kal_uint8*) & da.number[1], len - 1);
                    kal_mem_cpy((kal_uint8*) da.number, (kal_uint8*) temp_num, len - 1);
                    da.number[len - 1] = 0;
                }

                if (!(rmmi_is_number_string(da.number)))
                {
                    break;
                }

                /* get <text> */
                //result = rmmi_sms_text_validator(
                //                         source_string_ptr,
                //                            rmmi_ptr->s_reg.s3,
                //                             SMSAL_ONE_MSG_LEN,
                //                          (kal_uint8 *)msg
                //                          );

	        if (rmmi_ptr->char_set == RMMI_CHSET_UCS2)
		{
                result = rmmi_string_validator_ext(
                            &error_cause,
                            source_string_ptr,
                            rmmi_ptr->s_reg.s3,
                            280+1, 
                            (kal_uint8*) msg);
		}
		else
		{
                result = rmmi_string_validator_ext(
                            &error_cause,
                            source_string_ptr,
                            rmmi_ptr->s_reg.s3,
                            SMSAL_ONE_MSG_LEN+1, 
                            (kal_uint8*) msg);
		}
                if (result == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }

                length = check_dcs_toGsm7bit(msg, final_msg);

                if (rmmi_ptr->char_set == RMMI_CHSET_GSM)
                {
                    for (i = 0; i < length; i++)
                    {
                        if (final_msg[i] >= 0x7f)
                        {
                            error_format = KAL_TRUE;
                        }
                    }
                    if (error_format == KAL_TRUE)
                    {
                        break;
                    }
                }

                if (rmmi_ptr->char_set == RMMI_CHSET_UCS2)
                {
                    ret_val = l4c_sms_exe_post_msg_req(source_string_ptr->src_id, SMSAL_PROFILE_1, SMSAL_INVALID_INDEX, da, SMSAL_PARA_DCS|SMSAL_PARA_VP,     //para_ind 
                                                       sca, vp, 0, 0,
                                                       SMSAL_UCS2_DCS, length, (kal_uint8*) final_msg, 0, 0,0,0);
                }
                else
                {
                    ret_val = l4c_sms_exe_post_msg_req(source_string_ptr->src_id, SMSAL_PROFILE_1, SMSAL_INVALID_INDEX, da, SMSAL_PARA_DCS|SMSAL_PARA_VP,     //para_ind 
                                                       sca, vp, 0, 0,
                                                       SMSAL_DEFAULT_DCS, length, (kal_uint8*) final_msg, 0, 0,0,0);
                }
            }
            else
            {
                kal_uint8 msg[SMSAL_MAX_TPDU_SIZE * 2];
                kal_uint8 pdu[SMSAL_MAX_TPDU_SIZE];

                data_len = (kal_uint16) rmmi_int_validator(source_string_ptr, (kal_uint8) RMMI_COMMA);

                //result = rmmi_sms_text_validator(
                //                                               source_string_ptr,
                //                                               rmmi_ptr->s_reg.s3,
                //                                               SMSAL_MAX_TPDU_SIZE*2,
                //                                               (kal_uint8 *)msg
                //                                              );

                result = rmmi_string_validator_ext(
                            &error_cause,
                            source_string_ptr,
                            rmmi_ptr->s_reg.s3,
                            SMSAL_MAX_TPDU_SIZE * 2,
                            (kal_uint8*) msg);

                if (result == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }

                if ((strlen((char*)msg) % 2) != 0)
                {
                    break;
                }

                check_hex_value((kal_uint8*) msg, (kal_uint8*) pdu);
                length = (kal_uint16)(strlen((char*)msg) >> 1);

                if (length == 0)        // length should never equals 0
                {
                    break;
                }
                else if (length < (pdu[0] + 1)) //length should be long enough to contain SC address.
                {
                    break;
                }
                else if ((length - (pdu[0] + 1)) != data_len)   //data_len should be the length without SC address.
                {
                    break;
                }

                ret_val = l4c_sms_exe_post_pdu_req(source_string_ptr->src_id, SMSAL_INVALID_INDEX, data_len, source_string_ptr->src_id, 0, 0,   //length without SC address
                                                   length,      // total pdu length
                                                   (kal_uint8*) pdu);
            }

            if (ret_val == KAL_TRUE)
            {
                return;
            }
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }
    rmmi_sms_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_cmgw_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cmgw_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 result;
    kal_uint8 format;
    kal_uint8 state = 0xff;
    kal_uint16 length;
    kal_uint16 data_len;
    l4c_number_struct da, sca;
    kal_uint8 temp_num[MAX_CC_ADDR_LEN];
    kal_uint8 len;
    kal_uint8 state_str[11];
    kal_uint8 i;
    kal_bool error_format = KAL_FALSE;
    kal_uint8 scts[7];
    kal_uint8 fo, vp, pid, dcs;
    l4c_context_struct *l4c_ptr = L4C_PTR;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CMGW_HDLR_ENTRY);

    if (l4c_ptr->sms_ready_flag == KAL_FALSE)
    {
        rmmi_ptr->cmee_err = OPERATION_NOT_ALLOWED_ERR;
    }
    else
    {
	    smsal_csmp_query(SMSAL_PROFILE_NONE, &fo, &vp, &pid, &dcs);
	    rmmi_ptr->cmee_err = RMMI_ERR_SYNTEX_ERROR;
	    kal_mem_set(scts, 0xff, sizeof(scts));

	    switch (source_string_ptr->cmd_mode)
	    {
	    #ifdef __test_mode__
	        case RMMI_TEST_MODE:
	        {
	            ret_val = KAL_TRUE;
	            break;
	        }
	    #endif /* __test_mode__ */ 
	        case RMMI_ACTIVE_MODE:
	        {
	            source_string_ptr->index++;
	            l4c_sms_get_msg_format_req(source_string_ptr->src_id, &format);
	            if (format == SMSAL_TEXT_MODE)
	            {
	                kal_uint8 msg[280];
	                kal_uint8 final_msg[280];

	                kal_mem_set(final_msg, 0, SMSAL_ONE_MSG_LEN);

			if (rmmi_ptr->char_set == RMMI_CHSET_UCS2)
			{
	                    result = rmmi_sms_text_validator(
	                            source_string_ptr,
	                            rmmi_ptr->s_reg.s3,
	                            280+1, 
	                            (kal_uint8*) msg);
			}
			else
			{
	                result = rmmi_sms_text_validator(
	                            source_string_ptr,
	                            rmmi_ptr->s_reg.s3,
	                            SMSAL_ONE_MSG_LEN+1,
	                            (kal_uint8*) msg);
			}
	                if (result == RMMI_VALIDATOR_ERROR)
	                {
	                    break;
	                }

	                state = SMSAL_STO_UNSENT;
	                length = check_dcs_toGsm7bit(msg, final_msg);

	                if (rmmi_ptr->char_set == RMMI_CHSET_GSM)
	                {
	                    for (i = 0; i < length; i++)
	                    {
	                        if (final_msg[i] >= 0x7f)
	                        {
	                            error_format = KAL_TRUE;
	                        }
	                    }
	                    if (error_format == KAL_TRUE)
	                    {
	                        break;
	                    }
	                }

	                kal_mem_set(&sca, 0, sizeof(l4c_number_struct));        //set zero when not exist
	                kal_mem_set(&da, 0, sizeof(l4c_number_struct)); //set zero when not exist
	                if (rmmi_ptr->char_set == RMMI_CHSET_UCS2)
	                {
	                    ret_val = l4c_sms_exe_write_msg_req(source_string_ptr->src_id, SMSAL_PROFILE_1, state, da, SMSAL_PARA_DCS|SMSAL_PARA_VP,  //para_ind 
	                                                        sca, scts, vp, 0, 0,
	                                                        SMSAL_UCS2_DCS, 0xffff, length, (kal_uint8*) final_msg, 0, 0, 0, 0);
	                }
	                else
	                {
	                    ret_val = l4c_sms_exe_write_msg_req(source_string_ptr->src_id, SMSAL_PROFILE_1, state, da, SMSAL_PARA_DCS|SMSAL_PARA_VP,  //para_ind 
	                                                        sca, scts, vp, 0, 0,
	                                                        SMSAL_DEFAULT_DCS, 0xffff, length, (kal_uint8*) final_msg, 0, 0, 0, 0);
	                }

	                if (ret_val == KAL_TRUE)
	                {
	                    return;
	                }
	                else
	                {
	                    rmmi_ptr->cmee_err = RMMI_ERR_UNKNOWN;
	                }
	            }
	            //else : PDU mode no active mode
	            break;
	        }
	        case RMMI_SET_OR_EXECUTE_MODE:
	        {
	            kal_uint8 error_cause;

	            kal_mem_set(&sca, 0, sizeof(l4c_number_struct));
	            l4c_sms_get_msg_format_req(source_string_ptr->src_id, &format);

	            if (format == SMSAL_TEXT_MODE)
	            {
	                kal_uint8 msg[280];
	                kal_uint8 final_msg[280];

	                kal_mem_set(final_msg, 0, SMSAL_ONE_MSG_LEN);

	                /* get <number> */
	                result = rmmi_string_validator_ext(
	                            &error_cause,
	                            source_string_ptr,
	                            (kal_uint8) RMMI_COMMA,
	                            MAX_CC_ADDR_LEN,
	                            (kal_uint8*) da.number);

	                if (result == RMMI_VALIDATOR_ERROR)
	                {
	                    break;
	                }

	                /* get da.type */
	                da.type = (kal_uint8) rmmi_int_validator_ext(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);

	                if (da.type == RMMI_VALIDATOR_ERROR)
	                {
	                    if (error_cause == RMMI_PARSE_NOT_FOUND)
	                    {
	                        da.type = 129;
	                    }
	                    else
	                    {
	                        break;
	                    }
	                }
	                else
	                {
	                    if ((da.type != 129) && (da.type != 145))
	                    {
	                        break;
	                    }
	                }

	                /* if '+' is present in <number>, type is forced to be 145 , and '+' is removed. */
	                if (da.number[0] == RMMI_CHAR_PLUS)
	                {
	                    da.type = 145;
	                    len = (kal_uint8)strlen((char*)da.number);
	                    kal_mem_cpy((kal_uint8*) temp_num, (kal_uint8*) & da.number[1], len - 1);
	                    kal_mem_cpy((kal_uint8*) da.number, (kal_uint8*) temp_num, len - 1);
	                    da.number[len - 1] = 0;
	                }

	                if (!(rmmi_is_number_string(da.number)))
	                {
	                    break;
	                }

	                /* get state */
	                result = rmmi_string_validator_ext(
	                            &error_cause,
	                            source_string_ptr,
	                            (kal_uint8) RMMI_COMMA,
	                            11,
	                            (kal_uint8*) state_str);
	                if (result == RMMI_VALIDATOR_ERROR)
	                {
	                    if (error_cause == RMMI_PARSE_NOT_FOUND)
	                    {
	                        state = SMSAL_STO_UNSENT;
	                    }
	                    else
	                    {
	                        break;
	                    }
	                }
	                else
	                {
	                    state = check_sms_status_code(state_str);

	                    if ((state != SMSAL_STO_SENT) && (state != SMSAL_STO_UNSENT))
	                    {
	                        break;
	                    }
	                }

	                /* get <text> */
	                //result = rmmi_sms_text_validator( source_string_ptr, rmmi_ptr->s_reg.s3,
	                //                                                          SMSAL_ONE_MSG_LEN, (kal_uint8 *)msg);
			if (rmmi_ptr->char_set == RMMI_CHSET_UCS2)
			{
	                    result = rmmi_string_validator_ext(
	                            &error_cause,
	                            source_string_ptr,
	                            rmmi_ptr->s_reg.s3,
	                            280+1,
	                            (kal_uint8*) msg);
			}
			else
			{
	                result = rmmi_string_validator_ext(
	                            &error_cause,
	                            source_string_ptr,
	                            rmmi_ptr->s_reg.s3,
	                            SMSAL_ONE_MSG_LEN+1,
	                            (kal_uint8*) msg);
			}
	                if (result == RMMI_VALIDATOR_ERROR)
	                {
	                    break;
	                }

	                length = check_dcs_toGsm7bit(msg, final_msg);

	                if (rmmi_ptr->char_set == RMMI_CHSET_GSM)
	                {
	                    for (i = 0; i < length; i++)
	                    {
	                        if (final_msg[i] >= 0x7f)
	                        {
	                            error_format = KAL_TRUE;
	                        }
	                    }
	                    if (error_format == KAL_TRUE)
	                    {
	                        break;
	                    }
	                }

	                if (rmmi_ptr->char_set == RMMI_CHSET_UCS2)
	                {
	                    ret_val = l4c_sms_exe_write_msg_req(source_string_ptr->src_id, SMSAL_PROFILE_1, state, da, SMSAL_PARA_DCS|SMSAL_PARA_VP,  //para_ind 
	                                                        sca, scts, vp, 0, 0,
	                                                        SMSAL_UCS2_DCS, 0xffff, length, (kal_uint8*) final_msg, 0, 0, 0, 0);
	                }
	                else
	                {
	                    ret_val = l4c_sms_exe_write_msg_req(source_string_ptr->src_id, SMSAL_PROFILE_1, state, da, SMSAL_PARA_DCS|SMSAL_PARA_VP,  //para_ind 
	                                                        sca, scts, vp, 0, 0,
	                                                        SMSAL_DEFAULT_DCS, 0xffff, length, (kal_uint8*) final_msg, 0, 0, 0, 0);
	                }
	            }
	            else        //PDU mode
	            {
	                kal_uint8 msg[SMSAL_MAX_TPDU_SIZE * 2];
	                kal_uint8 pdu[SMSAL_MAX_TPDU_SIZE];

	                data_len = (kal_uint16) rmmi_int_validator(source_string_ptr, (kal_uint8) RMMI_COMMA);

	                if (data_len == RMMI_VALIDATOR_ERROR)
	                {
	                    break;
	                }

	                state = (kal_uint8) rmmi_int_validator_ext(
	                                        (kal_uint8*) & error_cause,
	                                        source_string_ptr,
	                                        (kal_uint8) RMMI_COMMA);

	                if (state == RMMI_VALIDATOR_ERROR)
	                {
	                    if (error_cause == RMMI_PARSE_NOT_FOUND)
	                    {
	                        state = SMSAL_STO_UNSENT;
	                    }
	                    else
	                    {
	                        break;
	                    }
	                }
	                else
	                {
	                    if ((state != SMSAL_STO_SENT) && (state != SMSAL_STO_UNSENT) &&
	                        (state != SMSAL_REC_READ) && (state != SMSAL_REC_UNREAD))
	                    {
	                        break;  //  state is not allowed                                                 
	                    }
	                }

	                /* get <pdu> data */
	                //result = rmmi_sms_text_validator(
	                //          source_string_ptr,
	                //          rmmi_ptr->s_reg.s3,
	                //          SMSAL_MAX_TPDU_SIZE*2,
	                //          (kal_uint8 *)msg
	                //         );

	                result = rmmi_string_validator_ext(
	                            &error_cause,
	                            source_string_ptr,
	                            rmmi_ptr->s_reg.s3,
	                            SMSAL_MAX_TPDU_SIZE * 2,
	                            (kal_uint8*) msg);

	                if (result == RMMI_VALIDATOR_ERROR)
	                {
	                    break;
	                }

	                check_hex_value((kal_uint8*) msg, (kal_uint8*) pdu);
	                length = (kal_uint16)(strlen((char*)msg) >> 1);

	                if (length == 0)        // length should never equals 0
	                {
	                    break;
	                }
	                else if (length < (pdu[0] + 1)) //length should be long enough to contain SC address.
	                {
	                    break;
	                }
	                else if ((length - (pdu[0] + 1)) != data_len)   //data_len should be the length without SC address.
	                {
	                    break;
	                }

	                ret_val = l4c_sms_exe_write_pdu_req(
	                            source_string_ptr->src_id,
	                            state,
	                            data_len,
	                            length,
	                            (kal_uint8*) pdu);
	            }

	            if (ret_val == KAL_TRUE)
	            {
	                return;
	            }
	            else
	            {
	                rmmi_ptr->cmee_err = RMMI_ERR_UNKNOWN;
	                break;
	            }
	        }
	        default:
	        {
	            /* unrecognized format of AT command line */
	            rmmi_ptr->cmee_err = RMMI_ERR_UNSPECIFIED;
	            break;
	        }
	    }   /* end of the switch */
    }
    rmmi_sms_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}


#else /* __SMS_AT_DIRECT_INPUT_SUPPORT__ */ 


/*****************************************************************************
 * FUNCTION
 *  rmmi_cmgs_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cmgs_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 result;
    kal_uint16 length;
    kal_uint16 data_len;
    kal_uint8 format;
    l4c_number_struct da, sca;
    kal_uint8 temp_num[MAX_CC_ADDR_LEN];
    kal_uint8 len;
    kal_uint8 indexofCR = 0;
    kal_uint8 i;
    kal_bool error_format = KAL_FALSE;
    kal_uint8 fo, vp, pid, dcs;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CMGS_HDLR_ENTRY);

    smsal_csmp_query(SMSAL_PROFILE_NONE, &fo, &vp, &pid, &dcs);
    kal_mem_set(&sca, 0, sizeof(l4c_number_struct));
    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;

            //if (is_nw_registered() == KAL_FALSE )
            //return;
            /*
             * if (rmmi_ptr->cops_mode == DEREG)
             * break;
             */

            l4c_sms_get_msg_format_req(source_string_ptr->src_id, &format);

            /* find the first <LF> in the string, which is the original <CR> */
            while ((source_string_ptr->string_ptr[indexofCR] != rmmi_ptr->s_reg.s4) &&
                   (source_string_ptr->string_ptr[indexofCR] != rmmi_ptr->s_reg.s3))
            {
                indexofCR++;
            }
            if (source_string_ptr->string_ptr[indexofCR] == rmmi_ptr->s_reg.s3)
            {
                break;
            }
            else        // == s_reg.s4 (LF)
            {
                source_string_ptr->string_ptr[indexofCR] = rmmi_ptr->s_reg.s3;
            }

            if (format == SMSAL_TEXT_MODE)
            {
                kal_uint8 msg[280];
                kal_uint8 final_msg[280];

                kal_mem_set(final_msg, 0, SMSAL_ONE_MSG_LEN);

                result = rmmi_string_validator_ext(
                            &error_cause,
                            source_string_ptr,
                            (kal_uint8) RMMI_COMMA,
                            MAX_CC_ADDR_LEN,
                            (kal_uint8*) da.number);
                if (result == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }

                /* get da.type */
                if (source_string_ptr->index < indexofCR)
                {
                    da.type = (kal_uint8) rmmi_int_validator_ext(
                                            &error_cause,
                                            source_string_ptr,
                                            (kal_uint8) RMMI_COMMA);
                    if ((da.type != 129) && (da.type != 145))   //we only accept 
                    {
                        break;
                    }
                }
                else
                {
                    da.type = 129;  /* if da.type is not assigned, use default */
                }

                /* if '+' is present in <number>, type is forced to be 145 ,
                   and '+' is removed. */
                if (da.number[0] == RMMI_CHAR_PLUS)
                {
                    da.type = 145;
                    len = strlen((char*)da.number);
                    kal_mem_cpy((kal_uint8*) temp_num, (kal_uint8*) & da.number[1], len - 1);
                    kal_mem_cpy((kal_uint8*) da.number, (kal_uint8*) temp_num, len - 1);
                    da.number[len - 1] = 0;
                }

                if (!(rmmi_is_number_string(da.number)))
                {
                    break;
                }

                /* point to where text data starts */
                source_string_ptr->index = indexofCR + 1;

                /* get <text> */
		if (rmmi_ptr->char_set == RMMI_CHSET_UCS2)
		{
                result = rmmi_sms_text_validator(
                            source_string_ptr,
                            rmmi_ptr->s_reg.s3,
                            280+1, 
                            (kal_uint8*) msg);
		}
		else
		{
                result = rmmi_sms_text_validator(
                            source_string_ptr,
                            rmmi_ptr->s_reg.s3,
                            SMSAL_ONE_MSG_LEN+1, 
                            (kal_uint8*) msg);
		}
                if (result == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }

                length = check_dcs_toGsm7bit(msg, final_msg);

                if (rmmi_ptr->char_set == RMMI_CHSET_GSM)
                {
                    for (i = 0; i < length; i++)
                    {
                        if (final_msg[i] >= 0x7f)
                        {
                            error_format = KAL_TRUE;
                        }
                    }
                    if (error_format == KAL_TRUE)
                    {
                        break;
                    }
                }

                if (rmmi_ptr->char_set == RMMI_CHSET_UCS2)
                {
                    ret_val = l4c_sms_exe_post_msg_req(source_string_ptr->src_id, SMSAL_PROFILE_1, SMSAL_INVALID_INDEX, da, SMSAL_PARA_DCS|SMSAL_PARA_VP,     //para_ind 
                                                       sca, vp, (smsal_pid_enum)0, 0,
                                                       SMSAL_UCS2_DCS, length, (kal_uint8*) final_msg, 0, 0,0,0);
                }
                else
                {
                    ret_val = l4c_sms_exe_post_msg_req(source_string_ptr->src_id, SMSAL_PROFILE_1, SMSAL_INVALID_INDEX, da, SMSAL_PARA_DCS|SMSAL_PARA_VP,     //para_ind 
                                                       sca, vp, (smsal_pid_enum)0, 0,
                                                       SMSAL_DEFAULT_DCS, length, (kal_uint8*) final_msg, 0, 0,0,0);
                }
            }
            else
            {
                kal_uint8 msg[SMSAL_MAX_TPDU_SIZE * 2];
                kal_uint8 pdu[SMSAL_MAX_TPDU_SIZE];

                data_len = (kal_uint16) rmmi_int_validator(source_string_ptr, (kal_uint8) RMMI_COMMA);

                /* point to where text data starts */
                source_string_ptr->index = indexofCR + 1;

                result = rmmi_sms_text_validator(
                            source_string_ptr,
                            rmmi_ptr->s_reg.s3,
                            SMSAL_MAX_TPDU_SIZE * 2,
                            (kal_uint8*) msg);

                if (result == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }

                check_hex_value((kal_uint8*) msg, (kal_uint8*) pdu);
                length = strlen((char*)msg) >> 1;

                if (length == 0)        // length should never equals 0
                {
                    break;
                }
                else if (length < (pdu[0] + 1)) //length should be long enough to contain SC address.
                {
                    break;
                }
                else if ((length - (pdu[0] + 1)) != data_len)   //data_len should be the length without SC address.
                {
                    break;
                }

                ret_val = l4c_sms_exe_post_pdu_req(source_string_ptr->src_id, SMSAL_INVALID_INDEX, data_len, source_string_ptr->src_id, 0, 0,   //length without SC address
                                                   length,      // total pdu length
                                                   (kal_uint8*) pdu);
            }

            if (ret_val == KAL_TRUE)
            {
                return;
            }
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }
    rmmi_sms_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_cmgw_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cmgw_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 result;
    kal_uint8 format;
    kal_uint8 state = 0xff;
    kal_uint16 length;
    kal_uint16 data_len;
    l4c_number_struct da, sca;
    kal_uint8 temp_num[MAX_CC_ADDR_LEN];
    kal_uint8 len;
    kal_uint8 state_str[11];
    kal_uint8 indexofCR = 0;

    kal_uint8 i;
    kal_bool error_format = KAL_FALSE;
    kal_uint8 scts[7];
    kal_uint8 fo, vp, pid, dcs;
    l4c_context_struct *l4c_ptr = L4C_PTR;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CMGW_HDLR_ENTRY);

    if (l4c_ptr->sms_ready_flag == KAL_FALSE)
    {
        rmmi_ptr->cmee_err = OPERATION_NOT_ALLOWED_ERR;
    }
    else
    {
	    smsal_csmp_query(SMSAL_PROFILE_NONE, &fo, &vp, &pid, &dcs);
	    rmmi_ptr->cmee_err = RMMI_ERR_SYNTEX_ERROR;
	    kal_mem_set(scts, 0xff, sizeof(scts));

	    switch (source_string_ptr->cmd_mode)
	    {
	    #ifdef __test_mode__
	        case RMMI_TEST_MODE:
	        {
	            ret_val = KAL_TRUE;
	            break;
	        }
	    #endif /* __test_mode__ */ 
	        case RMMI_ACTIVE_MODE:
	        {
	            source_string_ptr->index++;
	            l4c_sms_get_msg_format_req(source_string_ptr->src_id, &format);
	            if (format == SMSAL_TEXT_MODE)
	            {
	                kal_uint8 msg[280];
	                kal_uint8 final_msg[280];

	                kal_mem_set(final_msg, 0, SMSAL_ONE_MSG_LEN);

			if (rmmi_ptr->char_set == RMMI_CHSET_UCS2)
			{
	                    result = rmmi_sms_text_validator(
	                            source_string_ptr,
	                            rmmi_ptr->s_reg.s3,
	                            280+1, 
	                            (kal_uint8*) msg);
			}
			else
			{
	                result = rmmi_sms_text_validator(
	                            source_string_ptr,
	                            rmmi_ptr->s_reg.s3,
	                            SMSAL_ONE_MSG_LEN+1,
	                            (kal_uint8*) msg);
			}
	                if (result == RMMI_VALIDATOR_ERROR)
	                {
	                    break;
	                }

	                state = SMSAL_STO_UNSENT;
	                length = check_dcs_toGsm7bit(msg, final_msg);

	                if (rmmi_ptr->char_set == RMMI_CHSET_GSM)
	                {
	                    for (i = 0; i < length; i++)
	                    {
	                        if (final_msg[i] >= 0x7f)
	                        {
	                            error_format = KAL_TRUE;
	                        }
	                    }
	                    if (error_format == KAL_TRUE)
	                    {
	                        break;
	                    }
	                }

	                kal_mem_set(&sca, 0, sizeof(l4c_number_struct));        //set zero when not exist
	                kal_mem_set(&da, 0, sizeof(l4c_number_struct)); //set zero when not exist
	                if (rmmi_ptr->char_set == RMMI_CHSET_UCS2)
	                {
	                    ret_val = l4c_sms_exe_write_msg_req(source_string_ptr->src_id, SMSAL_PROFILE_1, state, da, SMSAL_PARA_DCS|SMSAL_PARA_VP,  //para_ind 
	                                                        sca, scts, vp, 0, 0,
	                                                        SMSAL_UCS2_DCS, 0xffff, length, (kal_uint8*) final_msg, 0, 0, 0, 0);
	                }
	                else
	                {
	                    ret_val = l4c_sms_exe_write_msg_req(source_string_ptr->src_id, SMSAL_PROFILE_1, state, da, SMSAL_PARA_DCS|SMSAL_PARA_VP,  //para_ind 
	                                                        sca, scts, vp, 0, 0,
	                                                        SMSAL_DEFAULT_DCS, 0xffff, length, (kal_uint8*) final_msg, 0, 0, 0, 0);
	                }

	                if (ret_val == KAL_TRUE)
	                {
	                    return;
	                }
	                else
	                {
	                    rmmi_ptr->cmee_err = RMMI_ERR_UNKNOWN;
	                }
	            }
	            //else : PDU mode no active mode
	            break;
	        }
	        case RMMI_SET_OR_EXECUTE_MODE:
	        {
	            kal_uint8 error_cause;

	            kal_mem_set(&sca, 0, sizeof(l4c_number_struct));
	            l4c_sms_get_msg_format_req(source_string_ptr->src_id, &format);

	            /* find the first <LF> in the string, which is the original <CR> */
	            while ((source_string_ptr->string_ptr[indexofCR] != rmmi_ptr->s_reg.s4) &&
	                   (source_string_ptr->string_ptr[indexofCR] != rmmi_ptr->s_reg.s3))
	            {
	                indexofCR++;
	            }
	            if (source_string_ptr->string_ptr[indexofCR] == rmmi_ptr->s_reg.s3)
	            {
	                break;
	            }
	            else        // == s_reg.s4 (LF)
	            {
	                source_string_ptr->string_ptr[indexofCR] = rmmi_ptr->s_reg.s3;
	            }

	            if (format == SMSAL_TEXT_MODE)
	            {
	                kal_uint8 msg[280];
	                kal_uint8 final_msg[280];

	                kal_mem_set(final_msg, 0, SMSAL_ONE_MSG_LEN);

	                /* get <number> */
	                result = rmmi_string_validator_ext(
	                            &error_cause,
	                            source_string_ptr,
	                            (kal_uint8) RMMI_COMMA,
	                            MAX_CC_ADDR_LEN,
	                            (kal_uint8*) da.number);
	                if (result == RMMI_VALIDATOR_ERROR)
	                {
	                    break;
	                }

	                /* get da.type */
	                if (source_string_ptr->index < indexofCR)
	                {
	                    da.type = (kal_uint8) rmmi_int_validator_ext(
	                                            &error_cause,
	                                            source_string_ptr,
	                                            (kal_uint8) RMMI_COMMA);

	                    if ((error_cause == RMMI_PARSE_OK) && (da.type != 129) && (da.type != 145)) //we only accept 
	                    {
	                        break;
	                    }
	                    else if (error_cause == RMMI_PARSE_NOT_FOUND)
	                    {
	                        da.type = 129;
	                    }
		            else if (error_cause == RMMI_PARSE_ERROR) 
		            {
                                break;  
		            }
	                }
	                else
	                {
	                    da.type = 129;  /* if da.type is not assigned, use default */
	                }

	                /* if '+' is present in <number>, type is forced to be 145 , and '+' is removed. */
	                if (da.number[0] == RMMI_CHAR_PLUS)
	                {
	                    da.type = 145;
	                    len = strlen((char*)da.number);
	                    kal_mem_cpy((kal_uint8*) temp_num, (kal_uint8*) & da.number[1], len - 1);
	                    kal_mem_cpy((kal_uint8*) da.number, (kal_uint8*) temp_num, len - 1);
	                    da.number[len - 1] = 0;
	                }

	                if (!(rmmi_is_number_string(da.number)))
	                {
	                    break;
	                }

	                /* get state */
	                if (source_string_ptr->index < indexofCR)
	                {
	                    result = rmmi_string_validator_ext(
	                                &error_cause,
	                                source_string_ptr,
	                                (kal_uint8) RMMI_COMMA,
	                                11,
	                                (kal_uint8*) state_str);
	                    state = check_sms_status_code(state_str);
	                    /* check state is allowed */
	                    if ((state != SMSAL_STO_SENT) && (state != SMSAL_STO_UNSENT))
	                    {
	                        break;
	                    }
	                }
	                /* if state is not assigned, use default */
	                if (state == 0xff)
	                {
	                    state = SMSAL_STO_UNSENT;
	                }

	                /* point to where text data starts */
	                source_string_ptr->index = indexofCR + 1;

	                /* get <text> */
			if (rmmi_ptr->char_set == RMMI_CHSET_UCS2)
			{
	                    result = rmmi_sms_text_validator(
	                            source_string_ptr,
	                            rmmi_ptr->s_reg.s3,
	                            280+1, 
	                            (kal_uint8*) msg);
			}
			else
			{
	                result = rmmi_sms_text_validator(
	                            source_string_ptr,
	                            rmmi_ptr->s_reg.s3,
	                            SMSAL_ONE_MSG_LEN+1,
	                            (kal_uint8*) msg);
			}
	                if (result == RMMI_VALIDATOR_ERROR)
	                {
	                    break;
	                }

	                length = check_dcs_toGsm7bit(msg, final_msg);

	                if (rmmi_ptr->char_set == RMMI_CHSET_GSM)
	                {
	                    for (i = 0; i < length; i++)
	                    {
	                        if (final_msg[i] >= 0x7f)
	                        {
	                            error_format = KAL_TRUE;
	                        }
	                    }
	                    if (error_format == KAL_TRUE)
	                    {
	                        break;
	                    }
	                }

	                if (rmmi_ptr->char_set == RMMI_CHSET_UCS2)
	                {
	                    ret_val = l4c_sms_exe_write_msg_req(source_string_ptr->src_id, SMSAL_PROFILE_1, state, da, SMSAL_PARA_DCS|SMSAL_PARA_VP,  //para_ind 
	                                                        sca, scts, vp, 0, 0,
	                                                        SMSAL_UCS2_DCS, 0xffff, length, (kal_uint8*) final_msg, 0, 0, 0, 0);
	                }
	                else
	                {
	                    ret_val = l4c_sms_exe_write_msg_req(source_string_ptr->src_id, SMSAL_PROFILE_1, state, da, SMSAL_PARA_DCS|SMSAL_PARA_VP,  //para_ind 
	                                                        sca, scts, vp, 0, 0,
	                                                        SMSAL_DEFAULT_DCS, 0xffff, length, (kal_uint8*) final_msg, 0, 0, 0, 0);
	                }
	            }
	            else        //PDU mode
	            {
	                kal_uint8 msg[SMSAL_MAX_TPDU_SIZE * 2];
	                kal_uint8 pdu[SMSAL_MAX_TPDU_SIZE];

	                data_len = (kal_uint16) rmmi_int_validator(source_string_ptr, (kal_uint8) RMMI_COMMA);
	                if (data_len == RMMI_VALIDATOR_ERROR)
	                {
	                    break;
	                }

	                if (source_string_ptr->index < indexofCR)
	                {
	                        state = (kal_uint8) rmmi_int_validator_range_check(
	                                &error_cause,
	                                source_string_ptr,
	                                (kal_uint8) RMMI_COMMA,
	                                7); 
						
				if (state == RMMI_VALIDATOR_ERROR)
	            		{
	                		if (error_cause == RMMI_PARSE_NOT_FOUND)
	                		{
						state = SMSAL_STO_UNSENT;
			      			//break;
	                		}
	                		else
	                		{
	                    			break;
	                		}
	            		}  
	 
	                    /* change for write to inbox. */
	                    if ((state != SMSAL_STO_SENT) && (state != SMSAL_STO_UNSENT) &&
	                        (state != SMSAL_REC_READ) && (state != SMSAL_REC_UNREAD) &&
                                (state != SMSAL_STO_DRAFT))
	                    {
	                        break;  //  state is not allowed 
	                    }
	                }
	                else
	                {
	                    state = SMSAL_STO_UNSENT;
	                }

	                /* point to where pdu data starts */
	                source_string_ptr->index = indexofCR + 1;

	                /* get <pdu> data */
	                result = rmmi_sms_text_validator(
	                            source_string_ptr,
	                            rmmi_ptr->s_reg.s3,
	                            SMSAL_MAX_TPDU_SIZE * 2,
	                            (kal_uint8*) msg);
	                if (result == RMMI_VALIDATOR_ERROR)
	                {
	                    break;
	                }

	                check_hex_value((kal_uint8*) msg, (kal_uint8*) pdu);
	                length = strlen((char*)msg) >> 1;

	                if (length == 0)        // length should never equals 0
	                {
	                    break;
	                }
	                else if (length < (pdu[0] + 1)) //length should be long enough to contain SC address.
	                {
	                    break;
	                }
	                else if ((length - (pdu[0] + 1)) != data_len)   //data_len should be the length without SC address.
	                {
	                    break;
	                }

	                ret_val = l4c_sms_exe_write_pdu_req(
	                            source_string_ptr->src_id,
	                            state,
	                            data_len,
	                            length,
	                            (kal_uint8*) pdu);
	            }

	            if (ret_val == KAL_TRUE)
	            {
	                return;
	            }
	            else
	            {
	                rmmi_ptr->cmee_err = RMMI_ERR_UNKNOWN;
	                break;
	            }
	        }
	        default:
	        {
	            /* unrecognized format of AT command line */
	            rmmi_ptr->cmee_err = RMMI_ERR_UNSPECIFIED;
	            break;
	        }
	    }   /* end of the switch */
    }
    rmmi_sms_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}


#endif /* __SMS_AT_DIRECT_INPUT_SUPPORT__ */ 
/*****************************************************************************
 * FUNCTION
 *  rmmi_cmgc_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_emgc_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 format;
    kal_uint8 result;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_EMGC_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            rmmi_ptr->cmee_err = RMMI_ERR_SYNTEX_ERROR;

            l4c_sms_get_msg_format_req(source_string_ptr->src_id, &format);
            if (format == SMSAL_TEXT_MODE)
            {
                kal_uint8 fo, ct, mn = 0, pid = 0;
                kal_uint8 length;
                kal_uint8 command[SMSAL_MAX_CMD_LEN * 2];
                kal_uint8 pdu[SMSAL_MAX_CMD_LEN];
                l4c_number_struct da;
                kal_uint8 error_cause;

                fo = (kal_uint8) rmmi_int_validator_ext(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);
                if (fo == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }

                ct = (kal_uint8) rmmi_int_validator_ext(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);
                if (ct == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }

                pid = (kal_uint8) rmmi_int_validator_ext(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);
                if (pid == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }

                mn = (kal_uint8) rmmi_int_validator_ext(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);
                if (mn == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }

                result = rmmi_string_validator_ext(
                            &error_cause,
                            source_string_ptr,
                            (kal_uint8) RMMI_COMMA,
                            MAX_CC_ADDR_LEN,
                            (kal_uint8*) da.number);
                if (result == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }

                da.type = (kal_uint8) rmmi_int_validator_ext(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);
                if (da.type == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }

                //result = rmmi_sms_text_validator(
                //            source_string_ptr,
                //            rmmi_ptr->s_reg.s3,
                //            SMSAL_MAX_CMD_LEN*2,
                //            (kal_uint8 *)command
                //           );

                result = rmmi_string_validator_ext(
                            &error_cause,
                            source_string_ptr,
                            rmmi_ptr->s_reg.s3,
                            SMSAL_MAX_CMD_LEN * 2,
                            (kal_uint8*) command);

                if (result == RMMI_VALIDATOR_ERROR)
                {
                    command[0] = RMMI_END_OF_STRING_CHAR;
                    length = 0;
                }
                else
                {
                    check_hex_value((kal_uint8*) command, (kal_uint8*) pdu);
                    length = (kal_uint8)(strlen((char*)command) >> 1);
                }
                da.length = (kal_uint8)strlen((char*)da.number);
                ret_val = l4c_sms_exe_post_command_req(source_string_ptr->src_id, fo, ct, mn, pid, da, length, pdu);
            }
            else
            {
                kal_uint16 data_len;
                kal_uint16 length;
                kal_uint8 command[SMSAL_MAX_TPDU_SIZE * 2];
                kal_uint8 pdu[SMSAL_MAX_TPDU_SIZE];
                kal_uint8 error_cause;

                data_len = (kal_uint16) rmmi_int_validator(source_string_ptr, (kal_uint8) RMMI_COMMA);
                if (data_len == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }

                //result = rmmi_sms_text_validator(
                //            source_string_ptr,
                //            rmmi_ptr->s_reg.s3,
                //            SMSAL_MAX_TPDU_SIZE*2,
                //            (kal_uint8 *)command
                //           );

                result = rmmi_string_validator_ext(
                            &error_cause,
                            source_string_ptr,
                            rmmi_ptr->s_reg.s3,
                            SMSAL_MAX_TPDU_SIZE * 2,
                            (kal_uint8*) command);

                if (result == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }

                check_hex_value((kal_uint8*) command, (kal_uint8*) pdu);
                length = (kal_uint16)(strlen((char*)command) >> 1);

                if (length == 0)        // length should never equals 0
                {
                    break;
                }
                else if (length < (pdu[0] + 1)) //length should be long enough to contain SC address.
                {
                    break;
                }
                else if ((length - (pdu[0] + 1)) != data_len)   //data_len should be the length without SC address.
                {
                    break;
                }

                ret_val = l4c_sms_exe_post_command_pdu_req(source_string_ptr->src_id, data_len, length, pdu);
            }
            if (ret_val == KAL_FALSE)
            {
                rmmi_ptr->cmee_err = RMMI_ERR_UNKNOWN;
                break;
            }
            else
            {
                return;
            }
        }
        default:
        {
            /* unrecognized format of AT command line */
            rmmi_ptr->cmee_err = RMMI_ERR_UNSPECIFIED;
            break;
        }
    }   /* end of the switch */
    rmmi_sms_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_cnma_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_enma_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 result;
    kal_uint8 mode;
    kal_uint16 length, data_len;
    kal_uint8 const *rsp_str = NULL;
    kal_uint16 string_length = 0;
    kal_uint8 service;
    smsal_service_mode_struct info;
    kal_uint8 format;
    kal_uint8 error_cause;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_ENMA_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_TEST_MODE:
        {
            smsal_cnma_test(&rsp_str);
            string_length = (kal_uint16)strlen((char*)rsp_str);
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_ACTIVE_MODE:
        {
            l4c_sms_get_service_mode_req(source_string_ptr->src_id, &service, &info);
            if (service != 1)
            {
                break;  //only when +CSMS=1, this command works
            }

            ret_val = l4c_sms_exe_send_ack_req(source_string_ptr->src_id, CNMA_MODE_TEXT_MODE, 0, NULL);
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 ack[SMSAL_MAX_TPDU_SIZE * 2];
            kal_uint8 pdu[SMSAL_MAX_TPDU_SIZE];

            l4c_sms_get_service_mode_req(source_string_ptr->src_id, &service, &info);
            if (service != 1)
            {
                break;  //only when +CSMS=1, this command works
            }

            l4c_sms_get_msg_format_req(source_string_ptr->src_id, &format);
            if (format == 0)    //PDU mode
            {
                mode = (kal_uint8) rmmi_int_validator_ext(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);
                if (mode > 2)
                {
                    break;      //0-2
                }

                data_len = (kal_uint16) rmmi_int_validator_ext(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);
                if ((data_len == RMMI_VALIDATOR_ERROR) && (error_cause == RMMI_PARSE_NOT_FOUND))        //no <length>,<pdu>
                {
                    length = 0;
                }
                else if ((data_len == RMMI_VALIDATOR_ERROR) && (error_cause == RMMI_PARSE_ERROR))       //invalid length
                {
                    break;
                }
                else    //get <pdu>
                {
                    //result = rmmi_sms_text_validator(
                    //                source_string_ptr,
                    //                rmmi_ptr->s_reg.s3,
                    //                SMSAL_MAX_TPDU_SIZE*2,
                    //                (kal_uint8 *)ack);

                    result = rmmi_string_validator_ext(
                                &error_cause,
                                source_string_ptr,
                                rmmi_ptr->s_reg.s3,
                                SMSAL_MAX_TPDU_SIZE * 2,
                                (kal_uint8*) ack);

                    if (result == RMMI_VALIDATOR_ERROR)
                    {
                        break;
                    }

                    check_hex_value((kal_uint8*) ack, (kal_uint8*) pdu);
                    length = (kal_uint16)(strlen((char*)ack) >> 1);
                }
                ret_val = l4c_sms_exe_send_ack_req(source_string_ptr->src_id, mode, length, (kal_uint8*) pdu);
            }
            break;
        }
        default:
            break;
    }   /* end of the switch */
    rmmi_sms_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/* AT+EMGS and AT+EMGW is the same as Smart Phone's AT+CMGS and AT+CMGW.
   In order to let UK FAT test or Machine test (ex: FTA/GCF) more convenient, 
   we provide the two commands for all platforms. (SP/FP/Data Card)

   AT+EMGS:
   If text mode (+CMGF=1):
   +EMGS = <da>[, <toda>], text is entered <CR>
   
   If PDU mode (+CMGF=0):
   +EMGS=<length>, pdu is given <CR>
   
   
   AT+EMGW:
   If text mode (+CMGF=1):
   +EMGW = <da>[, <toda>][,<stat>], text is entered <CR>
   
   If PDU mode (+CMGF=0):
   +EMGW=<length>, [,<stat>], pdu is given <CR> */

void rmmi_emgs_hdlr(rmmi_string_struct *source_string_ptr)
{
        kal_bool ret_val = KAL_FALSE;
        kal_uint8 result;
        kal_uint16 length;
        kal_uint16 data_len;
        kal_uint8 format;
        l4c_number_struct da, sca;
        kal_uint8 temp_num[MAX_CC_ADDR_LEN];
        kal_uint8 len;
        kal_uint8 i;
        kal_bool error_format = KAL_FALSE;
        kal_uint8 fo, vp, pid, dcs;
        rmmi_context_struct* rmmi_ptr = RMMI_PTR;
    
        kal_trace(TRACE_FUNC, FUNC_RMMI_EMGS_HDLR_ENTRY);
    
        smsal_csmp_query(SMSAL_PROFILE_NONE, &fo, &vp, &pid, &dcs);
        kal_mem_set(&sca, 0, sizeof(l4c_number_struct));
        switch (source_string_ptr->cmd_mode)
        {
    #ifdef __test_mode__
            case RMMI_TEST_MODE:
            {
                ret_val = KAL_TRUE;
                break;
            }
    #endif /* __test_mode__ */ 
            case RMMI_SET_OR_EXECUTE_MODE:
            {
                kal_uint8 error_cause;
    
                l4c_sms_get_msg_format_req(source_string_ptr->src_id, &format);
    
                if (format == SMSAL_TEXT_MODE)
                {
                    kal_uint8 msg[280];
                    kal_uint8 final_msg[280];
    
                    kal_mem_set(final_msg, 0, SMSAL_ONE_MSG_LEN);
    
                    result = rmmi_string_validator_ext(
                                &error_cause,
                                source_string_ptr,
                                (kal_uint8) RMMI_COMMA,
                                MAX_CC_ADDR_LEN,
                                (kal_uint8*) da.number);
                    if (result == RMMI_VALIDATOR_ERROR)
                    {
                        break;
                    }
    
                    /* get da.type */
                    da.type = (kal_uint8) rmmi_int_validator_ext(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);
    
                    if (da.type == RMMI_VALIDATOR_ERROR)
                    {
                        if (error_cause == RMMI_PARSE_NOT_FOUND)
                        {
                            da.type = 129;
                        }
                        else
                        {
                            break;
                        }
                    }
                    else
                    {
                        if ((da.type != 129) && (da.type != 145))
                        {
                            break;
                        }
                    }
    
                    /* if '+' is present in <number>, type is forced to be 145 ,and '+' is removed. */
                    if (da.number[0] == RMMI_CHAR_PLUS)
                    {
                        da.type = 145;
                        len = strlen((char*)da.number);
                        kal_mem_cpy((kal_uint8*) temp_num, (kal_uint8*) & da.number[1], len - 1);
                        kal_mem_cpy((kal_uint8*) da.number, (kal_uint8*) temp_num, len - 1);
                        da.number[len - 1] = 0;
                    }
    
                    if (!(rmmi_is_number_string(da.number)))
                    {
                        break;
                    }
    
                    /* get <text> */
                    //result = rmmi_sms_text_validator(
                    //                         source_string_ptr,
                    //                            rmmi_ptr->s_reg.s3,
                    //                             SMSAL_ONE_MSG_LEN,
                    //                          (kal_uint8 *)msg
                    //                          );
    
                    if (rmmi_ptr->char_set == RMMI_CHSET_UCS2)
                    {
                        result = rmmi_string_validator_ext(
                                &error_cause,
                                source_string_ptr,
                                rmmi_ptr->s_reg.s3,
                                280+1, 
                                (kal_uint8*) msg);
                    }
                    else
                    {
                        result = rmmi_string_validator_ext(
                                &error_cause,
                                source_string_ptr,
                                rmmi_ptr->s_reg.s3,
                                SMSAL_ONE_MSG_LEN+1, 
                                (kal_uint8*) msg);
                    }
					
                    if (result == RMMI_VALIDATOR_ERROR)
                    {
                        break;
                    }
    
                    length = check_dcs_toGsm7bit(msg, final_msg);
    
                    if (rmmi_ptr->char_set == RMMI_CHSET_GSM)
                    {
                        for (i = 0; i < length; i++)
                        {
                            if (final_msg[i] >= 0x7f)
                            {
                                error_format = KAL_TRUE;
                            }
                        }
                        if (error_format == KAL_TRUE)
                        {
                            break;
                        }
                    }
    
                    if (rmmi_ptr->char_set == RMMI_CHSET_UCS2)
                    {
                        ret_val = l4c_sms_exe_post_msg_req(source_string_ptr->src_id, SMSAL_PROFILE_1, SMSAL_INVALID_INDEX, da, SMSAL_PARA_DCS|SMSAL_PARA_VP,     //para_ind 
                                                           sca, vp, 0, 0,
                                                           SMSAL_UCS2_DCS, length, (kal_uint8*) final_msg, 0, 0,0,0);
                    }
                    else
                    {
                        ret_val = l4c_sms_exe_post_msg_req(source_string_ptr->src_id, SMSAL_PROFILE_1, SMSAL_INVALID_INDEX, da, SMSAL_PARA_DCS|SMSAL_PARA_VP,     //para_ind 
                                                           sca, vp, 0, 0,
                                                           SMSAL_DEFAULT_DCS, length, (kal_uint8*) final_msg, 0, 0,0,0);
                    }
                }
                else
                {
                    kal_uint8 msg[SMSAL_MAX_TPDU_SIZE * 2];
                    kal_uint8 pdu[SMSAL_MAX_TPDU_SIZE];
    
                    data_len = (kal_uint16) rmmi_int_validator(source_string_ptr, (kal_uint8) RMMI_COMMA);
    
                    //result = rmmi_sms_text_validator(
                    //                                               source_string_ptr,
                    //                                               rmmi_ptr->s_reg.s3,
                    //                                               SMSAL_MAX_TPDU_SIZE*2,
                    //                                               (kal_uint8 *)msg
                    //                                              );
    
                    result = rmmi_string_validator_ext(
                                &error_cause,
                                source_string_ptr,
                                rmmi_ptr->s_reg.s3,
                                SMSAL_MAX_TPDU_SIZE * 2,
                                (kal_uint8*) msg);
    
                    if (result == RMMI_VALIDATOR_ERROR)
                    {
                        break;
                    }
    
                    if ((strlen((char*)msg) % 2) != 0)
                    {
                        break;
                    }
    
                    check_hex_value((kal_uint8*) msg, (kal_uint8*) pdu);
                    length = strlen((char*)msg) >> 1;
    
                    if (length == 0)        // length should never equals 0
                    {
                        break;
                    }
                    else if (length < (pdu[0] + 1)) //length should be long enough to contain SC address.
                    {
                        break;
                    }
                    else if ((length - (pdu[0] + 1)) != data_len)   //data_len should be the length without SC address.
                    {
                        break;
                    }
    
                    ret_val = l4c_sms_exe_post_pdu_req(source_string_ptr->src_id, SMSAL_INVALID_INDEX, data_len, source_string_ptr->src_id, 0, 0,   //length without SC address
                                                       length,      // total pdu length
                                                       (kal_uint8*) pdu);
                }
    
                if (ret_val == KAL_TRUE)
                {
                    return;
                }
                break;
            }
            default:
            {
                /* unrecognized format of AT command line */
                break;
            }
        }
        rmmi_sms_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
        return;
}

void rmmi_emgw_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 result;
    kal_uint8 format;
    kal_uint8 state = 0xff;
    kal_uint16 length;
    kal_uint16 data_len;
    l4c_number_struct da, sca;
    kal_uint8 temp_num[MAX_CC_ADDR_LEN];
    kal_uint8 len;
    kal_uint8 state_str[11];
    kal_uint8 i;
    kal_bool error_format = KAL_FALSE;
    kal_uint8 scts[7];
    kal_uint8 fo, vp, pid, dcs;
    l4c_context_struct *l4c_ptr = L4C_PTR;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_EMGW_HDLR_ENTRY);

    if (l4c_ptr->sms_ready_flag == KAL_FALSE)
    {
        rmmi_ptr->cmee_err = OPERATION_NOT_ALLOWED_ERR;
    }
    else
    {
	    smsal_csmp_query(SMSAL_PROFILE_NONE, &fo, &vp, &pid, &dcs);
	    rmmi_ptr->cmee_err = RMMI_ERR_SYNTEX_ERROR;
	    kal_mem_set(scts, 0xff, sizeof(scts));

	    switch (source_string_ptr->cmd_mode)
	    {
	    #ifdef __test_mode__
	        case RMMI_TEST_MODE:
	        {
	            ret_val = KAL_TRUE;
	            break;
	        }
	    #endif /* __test_mode__ */ 
	        case RMMI_ACTIVE_MODE:
	        {
	            source_string_ptr->index++;
	            l4c_sms_get_msg_format_req(source_string_ptr->src_id, &format);
	            if (format == SMSAL_TEXT_MODE)
	            {
	                kal_uint8 msg[280];
	                kal_uint8 final_msg[280];

	                kal_mem_set(final_msg, 0, SMSAL_ONE_MSG_LEN);

			        if (rmmi_ptr->char_set == RMMI_CHSET_UCS2)
			        {
	                    result = rmmi_sms_text_validator(
	                            source_string_ptr,
	                            rmmi_ptr->s_reg.s3,
	                            280+1, 
	                            (kal_uint8*) msg);
			        }
			        else
			        {
	                    result = rmmi_sms_text_validator(
	                            source_string_ptr,
	                            rmmi_ptr->s_reg.s3,
	                            SMSAL_ONE_MSG_LEN+1,
	                            (kal_uint8*) msg);
			        }
					
	                if (result == RMMI_VALIDATOR_ERROR)
	                {
	                    break;
	                }

	                state = SMSAL_STO_UNSENT;
	                length = check_dcs_toGsm7bit(msg, final_msg);

	                if (rmmi_ptr->char_set == RMMI_CHSET_GSM)
	                {
	                    for (i = 0; i < length; i++)
	                    {
	                        if (final_msg[i] >= 0x7f)
	                        {
	                            error_format = KAL_TRUE;
	                        }
	                    }
	                    if (error_format == KAL_TRUE)
	                    {
	                        break;
	                    }
	                }

	                kal_mem_set(&sca, 0, sizeof(l4c_number_struct));        //set zero when not exist
	                kal_mem_set(&da, 0, sizeof(l4c_number_struct)); //set zero when not exist
	                if (rmmi_ptr->char_set == RMMI_CHSET_UCS2)
	                {
	                    ret_val = l4c_sms_exe_write_msg_req(source_string_ptr->src_id, SMSAL_PROFILE_1, state, da, SMSAL_PARA_DCS|SMSAL_PARA_VP,  //para_ind 
	                                                        sca, scts, vp, 0, 0,
	                                                        SMSAL_UCS2_DCS, 0xffff, length, (kal_uint8*) final_msg, 0, 0, 0, 0);
	                }
	                else
	                {
	                    ret_val = l4c_sms_exe_write_msg_req(source_string_ptr->src_id, SMSAL_PROFILE_1, state, da, SMSAL_PARA_DCS|SMSAL_PARA_VP,  //para_ind 
	                                                        sca, scts, vp, 0, 0,
	                                                        SMSAL_DEFAULT_DCS, 0xffff, length, (kal_uint8*) final_msg, 0, 0, 0, 0);
	                }

	                if (ret_val == KAL_TRUE)
	                {
	                    return;
	                }
	                else
	                {
	                    rmmi_ptr->cmee_err = RMMI_ERR_UNKNOWN;
	                }
	            }
	            //else : PDU mode no active mode
	            break;
	        }
	        case RMMI_SET_OR_EXECUTE_MODE:
	        {
	            kal_uint8 error_cause;

	            kal_mem_set(&sca, 0, sizeof(l4c_number_struct));
	            l4c_sms_get_msg_format_req(source_string_ptr->src_id, &format);

	            if (format == SMSAL_TEXT_MODE)
	            {
	                kal_uint8 msg[280];
	                kal_uint8 final_msg[280];

	                kal_mem_set(final_msg, 0, SMSAL_ONE_MSG_LEN);

	                /* get <number> */
	                result = rmmi_string_validator_ext(
	                            &error_cause,
	                            source_string_ptr,
	                            (kal_uint8) RMMI_COMMA,
	                            MAX_CC_ADDR_LEN,
	                            (kal_uint8*) da.number);

	                if (result == RMMI_VALIDATOR_ERROR)
	                {
	                    break;
	                }

	                /* get da.type */
	                da.type = (kal_uint8) rmmi_int_validator_ext(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);

	                if (da.type == RMMI_VALIDATOR_ERROR)
	                {
	                    if (error_cause == RMMI_PARSE_NOT_FOUND)
	                    {
	                        da.type = 129;
	                    }
	                    else
	                    {
	                        break;
	                    }
	                }
	                else
	                {
	                    if ((da.type != 129) && (da.type != 145))
	                    {
	                        break;
	                    }
	                }

	                /* if '+' is present in <number>, type is forced to be 145 , and '+' is removed. */
	                if (da.number[0] == RMMI_CHAR_PLUS)
	                {
	                    da.type = 145;
	                    len = strlen((char*)da.number);
	                    kal_mem_cpy((kal_uint8*) temp_num, (kal_uint8*) & da.number[1], len - 1);
	                    kal_mem_cpy((kal_uint8*) da.number, (kal_uint8*) temp_num, len - 1);
	                    da.number[len - 1] = 0;
	                }

	                if (!(rmmi_is_number_string(da.number)))
	                {
	                    break;
	                }

	                /* get state */
	                result = rmmi_string_validator_ext(
	                            &error_cause,
	                            source_string_ptr,
	                            (kal_uint8) RMMI_COMMA,
	                            11,
	                            (kal_uint8*) state_str);
	                if (result == RMMI_VALIDATOR_ERROR)
	                {
	                    if (error_cause == RMMI_PARSE_NOT_FOUND)
	                    {
	                        state = SMSAL_STO_UNSENT;
	                    }
	                    else
	                    {
	                        break;
	                    }
	                }
	                else
	                {
	                    state = check_sms_status_code(state_str);

	                    if ((state != SMSAL_STO_SENT) && (state != SMSAL_STO_UNSENT))
	                    {
	                        break;
	                    }
	                }

	                /* get <text> */
	                //result = rmmi_sms_text_validator( source_string_ptr, rmmi_ptr->s_reg.s3,
	                //                                                          SMSAL_ONE_MSG_LEN, (kal_uint8 *)msg);
			        if (rmmi_ptr->char_set == RMMI_CHSET_UCS2)
			        {
	                    result = rmmi_string_validator_ext(
	                            &error_cause,
	                            source_string_ptr,
	                            rmmi_ptr->s_reg.s3,
	                            280+1,
	                            (kal_uint8*) msg);
			        }
			        else
			        {
	                    result = rmmi_string_validator_ext(
	                            &error_cause,
	                            source_string_ptr,
	                            rmmi_ptr->s_reg.s3,
	                            SMSAL_ONE_MSG_LEN+1,
	                            (kal_uint8*) msg);
			        }
					
	                if (result == RMMI_VALIDATOR_ERROR)
	                {
	                    break;
	                }

	                length = check_dcs_toGsm7bit(msg, final_msg);

	                if (rmmi_ptr->char_set == RMMI_CHSET_GSM)
	                {
	                    for (i = 0; i < length; i++)
	                    {
	                        if (final_msg[i] >= 0x7f)
	                        {
	                            error_format = KAL_TRUE;
	                        }
	                    }
	                    if (error_format == KAL_TRUE)
	                    {
	                        break;
	                    }
	                }

	                if (rmmi_ptr->char_set == RMMI_CHSET_UCS2)
	                {
	                    ret_val = l4c_sms_exe_write_msg_req(source_string_ptr->src_id, SMSAL_PROFILE_1, state, da, SMSAL_PARA_DCS|SMSAL_PARA_VP,  //para_ind 
	                                                        sca, scts, vp, 0, 0,
	                                                        SMSAL_UCS2_DCS, 0xffff, length, (kal_uint8*) final_msg, 0, 0, 0, 0);
	                }
	                else
	                {
	                    ret_val = l4c_sms_exe_write_msg_req(source_string_ptr->src_id, SMSAL_PROFILE_1, state, da, SMSAL_PARA_DCS|SMSAL_PARA_VP,  //para_ind 
	                                                        sca, scts, vp, 0, 0,
	                                                        SMSAL_DEFAULT_DCS, 0xffff, length, (kal_uint8*) final_msg, 0, 0, 0, 0);
	                }
	            }
	            else        //PDU mode
	            {
	                kal_uint8 msg[SMSAL_MAX_TPDU_SIZE * 2];
	                kal_uint8 pdu[SMSAL_MAX_TPDU_SIZE];

	                data_len = (kal_uint16) rmmi_int_validator(source_string_ptr, (kal_uint8) RMMI_COMMA);

	                if (data_len == RMMI_VALIDATOR_ERROR)
	                {
	                    break;
	                }

	                state = (kal_uint8) rmmi_int_validator_ext(
	                                        (kal_uint8*) & error_cause,
	                                        source_string_ptr,
	                                        (kal_uint8) RMMI_COMMA);

	                if (state == RMMI_VALIDATOR_ERROR)
	                {
	                    if (error_cause == RMMI_PARSE_NOT_FOUND)
	                    {
	                        state = SMSAL_STO_UNSENT;
	                    }
	                    else
	                    {
	                        break;
	                    }
	                }
	                else
	                {
	                    if ((state != SMSAL_STO_SENT) && (state != SMSAL_STO_UNSENT) &&
	                        (state != SMSAL_REC_READ) && (state != SMSAL_REC_UNREAD))
	                    {
	                        break;  //  state is not allowed                                                 
	                    }
	                }

	                /* get <pdu> data */
	                //result = rmmi_sms_text_validator(
	                //          source_string_ptr,
	                //          rmmi_ptr->s_reg.s3,
	                //          SMSAL_MAX_TPDU_SIZE*2,
	                //          (kal_uint8 *)msg
	                //         );

	                result = rmmi_string_validator_ext(
	                            &error_cause,
	                            source_string_ptr,
	                            rmmi_ptr->s_reg.s3,
	                            SMSAL_MAX_TPDU_SIZE * 2,
	                            (kal_uint8*) msg);

	                if (result == RMMI_VALIDATOR_ERROR)
	                {
	                    break;
	                }

	                check_hex_value((kal_uint8*) msg, (kal_uint8*) pdu);
	                length = strlen((char*)msg) >> 1;

	                if (length == 0)        // length should never equals 0
	                {
	                    break;
	                }
	                else if (length < (pdu[0] + 1)) //length should be long enough to contain SC address.
	                {
	                    break;
	                }
	                else if ((length - (pdu[0] + 1)) != data_len)   //data_len should be the length without SC address.
	                {
	                    break;
	                }

	                ret_val = l4c_sms_exe_write_pdu_req(
	                            source_string_ptr->src_id,
	                            state,
	                            data_len,
	                            length,
	                            (kal_uint8*) pdu);
	            }

	            if (ret_val == KAL_TRUE)
	            {
	                return;
	            }
	            else
	            {
	                rmmi_ptr->cmee_err = RMMI_ERR_UNKNOWN;
	                break;
	            }
	        }
	        default:
	        {
	            /* unrecognized format of AT command line */
	            rmmi_ptr->cmee_err = RMMI_ERR_UNSPECIFIED;
	            break;
	        }
	    }   /* end of the switch */
    }
    rmmi_sms_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}


#ifdef __SP_RIL_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  rmmi_emems_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_emems_hdlr(rmmi_string_struct *source_string_ptr)
{

    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    kal_uint32      mem;
    kal_uint32 	    status;
    kal_uint8 	    status_sm;
    kal_uint8 	    status_me;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_EMEMS_HDLR_ENTRY);
	
    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_TEST_MODE:
        {
	     rsp_str = (kal_uint8 const*)"+EMEMS: (1), (0, 1)";   /* prepare the response string */
            string_length = (kal_uint16)strlen((char*)rsp_str);     /* type casting */
            ret_val = KAL_TRUE;
            break;     
        }
	 case RMMI_READ_MODE:
        {
	     smsal_emems_query(SMSAL_SM, &status_sm);
	     smsal_emems_query(SMSAL_ME, &status_me);	 

            rmmi_ptr->arg_list[0] = (void*)&status_sm;	
            rmmi_ptr->arg_list[1] = (void*)&status_me;	
            string_length = rmmi_fast_string_print(
                                   buffer,
                                   (kal_uint8*) "+EMEMS: 0, %d, 1, %d",
                                   rmmi_ptr->arg_list,
                                   2);
            rsp_str = &buffer[0];

	     ret_val = KAL_TRUE;
            break;
	 }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
	     kal_uint8 error_cause;

	     //get mem	 
	     mem = rmmi_int_validator_ext(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);
	     if (mem != 1)
            {
                break;
            }		 
            if (mem == RMMI_VALIDATOR_ERROR)
            {
                break;
            }

            //get status
            status = rmmi_int_validator_ext(&error_cause, source_string_ptr, rmmi_ptr->s_reg.s3);
            if (status > 1)
            {
                break;
            }
            if (status == RMMI_VALIDATOR_ERROR)
            {
                break;
            }

            smsal_emems_set((kal_uint8)mem, (kal_uint8)status);

	     ret_val = KAL_TRUE;		
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_sms_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}
#endif /* __SP_RIL_SUPPORT__ */


/*
 * Service Centre Address +CSCA
 * *Parameter Command Syntax
 * *Command Possible response(s)
 * *+CSCA=<sca>[,<tosca>]
 * *+CSCA? +CSCA: <sca>,<tosca>
 * *+CSCA=?
 * *Description:
 * *Set command updates the SMSC address, through which mobile originated SMs are transmitted. 
 * *In text mode, setting is used by send and write commands. In PDU mode, setting is used by 
 * *the same commands, but only when the length of the SMSC address coded into <pdu> parameter 
 * *equals zero. 
 */

/*****************************************************************************
 * FUNCTION
 *  rmmi_csca_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_csca_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 result;
    kal_uint8 len;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    kal_uint8 temp_num[MAX_CC_ADDR_LEN];
    l4c_number_struct sca;
    kal_uint8 tosca;
    l4c_context_struct *l4c_ptr = L4C_PTR;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CSCA_HDLR_ENTRY);

    if (l4c_ptr->sms_ready_flag == KAL_FALSE)
    {
        rmmi_ptr->cmee_err = OPERATION_NOT_ALLOWED_ERR;
    }
    else
    {
           switch (source_string_ptr->cmd_mode)
	    {
	    #ifdef __test_mode__
	        case RMMI_TEST_MODE:
	        {
	            ret_val = KAL_TRUE;
	            break;
	        }
	    #endif /* __test_mode__ */ 
	        case RMMI_READ_MODE:
	        {
	            l4c_sms_get_sc_addr_req(source_string_ptr->src_id, SMSAL_PROFILE_NONE, &sca);     // profile id is not used: dummy
	            
	                rmmi_ptr->arg_list[0] = (void*)&sca.number;
	                rmmi_ptr->arg_list[1] = (void*)&sca.type;
#ifdef __CSCA_PLUS_SUPPORT__
	                if(sca.type == 145)
	                {
	                    string_length = rmmi_fast_string_print(
	                                        buffer,
	                                        (kal_uint8*) "+CSCA: \"+%s\", %d",
	                                        rmmi_ptr->arg_list,
	                                        2);
	                }
	                else
#endif
	                {
	                    string_length = rmmi_fast_string_print(
	                                        buffer,
	                                        (kal_uint8*) "+CSCA: \"%s\", %d",
	                                        rmmi_ptr->arg_list,
	                                        2);
	                }
	            ret_val = KAL_TRUE;
	            break;

	        }
	        case RMMI_SET_OR_EXECUTE_MODE:
	        {
	            kal_uint8 error_cause;

	            result = rmmi_string_validator_ext(
	                        &error_cause,
	                        source_string_ptr,
	                        (kal_uint8) RMMI_COMMA,
	                        (SMSAL_ADDR_LEN - 1) * 2 + 1,
	                        sca.number);

	            if (result == RMMI_VALIDATOR_ERROR && error_cause != RMMI_PARSE_OK)
	            {
	                break;
	            }

	            tosca = (kal_uint8) rmmi_int_validator_ext(&error_cause, source_string_ptr, rmmi_ptr->s_reg.s3);
	            if (tosca == RMMI_VALIDATOR_ERROR)
	            {
	                if (error_cause != RMMI_PARSE_NOT_FOUND)
	                {
	                    break;
	                }
	                else    //tosca is not given
	                {
	                    sca.type = 129;
	                }
	            }
	            else
	            {
	                if ((tosca != 129) && (tosca != 145) && (tosca != 128))
                    {
	                    break;
                    }
	                else
	                {
	                    sca.type = tosca;
	                }
	            }

	            if (sca.number[0] == RMMI_CHAR_PLUS)
	            {
	                len = (kal_uint8)strlen((char*)sca.number);
	                kal_mem_cpy((kal_uint8*) temp_num, (kal_uint8*) & sca.number[1], len - 1);
	                kal_mem_cpy((kal_uint8*) sca.number, (kal_uint8*) temp_num, len - 1);
	                sca.number[len - 1] = 0;
	                sca.type = 145;
	            }
	            if (!(rmmi_is_number_string(sca.number)))
	            {
	                break;
	            }
	            sca.length = (kal_uint8)strlen((char*)sca.number);

	            l4c_sms_set_rmmi_sc_addr_req(source_string_ptr->src_id, sca);
		        ret_val = KAL_TRUE;
	            break;
	        }
	        default:
	        {
	            /* unrecognized format of AT command line */
	            break;
	        }
	    }   /* end of the switch */
    }
    rmmi_sms_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) buffer, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_cmgd_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cmgd_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint16 index;
    kal_uint8 del_flag;
    kal_uint8 const *rsp_str = NULL;
    kal_uint16 string_length = 0;
    #if defined(__SMS_STORAGE_BY_MMI__) && !defined(WISDOM_MMI) 
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    #endif
    l4c_context_struct *l4c_ptr = L4C_PTR;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CMGD_HDLR_ENTRY);

    if (l4c_ptr->sms_ready_flag == KAL_FALSE)
    {
        rmmi_ptr->cmee_err = OPERATION_NOT_ALLOWED_ERR;
    }
    else
    {
           switch (source_string_ptr->cmd_mode)
	    {
	        case RMMI_TEST_MODE:
	        {
	            	#if defined(__SMS_STORAGE_BY_MMI__) && !defined(WISDOM_MMI) 
		     	{
				smsal_prefer_storage_struct mem;
			
				l4c_sms_get_preferred_mem_req(source_string_ptr->src_id, &mem);
				if (mem.mem1 == SMSAL_SM || mem.mem1 == SMSAL_SM_PREFER)
	            		{
	       			   mem.mem1 = RMMI_SMSAL_SM;
	            		}
				else if (mem.mem1 == SMSAL_ME || mem.mem1 == SMSAL_ME_PREFER)
	            		{
	       			   mem.mem1 = RMMI_SMSAL_ME;
	            		}
				else if(mem.mem1 == SMSAL_MT)
	            		{
	       			   mem.mem1 = RMMI_SMSAL_MT;
	       		}
				
				if (l4c_check_sim_status() == SMU_SIM_NOT_READY) //pin lock, sms not ready
				{
				      string_length = rmmi_fast_string_print(
	                                   buffer,
	                                   (kal_uint8*) "+CMGD: (0-0), (0-4)",
	                                   rmmi_ptr->arg_list,
	                                   0);
	       	        	rsp_str = &buffer[0];
					ret_val = KAL_TRUE;
					break;
				}
				else if (l4c_check_sim_status() == SMU_SIM_NO_IMSI) //no SIM, block SIM, IMSI can't be got
				{
					if (mem.mem1 == RMMI_SMSAL_SM)
	       		       {
						string_length = rmmi_fast_string_print(
	                                   	buffer,
	                                   	(kal_uint8*) "+CMGD: (0-0), (0-4)",
	                                   	rmmi_ptr->arg_list,
	                                   	0);
						rsp_str = &buffer[0];
						ret_val = KAL_TRUE;
						break;
					}
					else if(mem.mem1 == RMMI_SMSAL_MT)
	       		       {
	       			   	mem.mem1 = RMMI_SMSAL_ME;
	       		       }				
				}

				l4c_set_user_action(L4C_SMS, source_string_ptr->src_id, CMGD_TEST_EXE);

				l4c_sms_atcmd_eqsi_lind(source_string_ptr->src_id, mem.mem1);

				return;
			}
			#else
			{
			        smsal_cmgd_test(&rsp_str);
	            		string_length = (kal_uint16)strlen((char*)rsp_str);
	            		ret_val = KAL_TRUE;
	            		break;
			}
			#endif
	        }
	        case RMMI_SET_OR_EXECUTE_MODE:
	        {
	            kal_uint8 error_cause;

	            index = (kal_uint16) rmmi_int_validator_ext(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);

	            if (index == RMMI_VALIDATOR_ERROR)
	            {
	                if (error_cause != RMMI_PARSE_OK)
	                {
	                    break;
	                }
	            }

	            del_flag = (kal_uint8) rmmi_int_validator_range_check(
	                                &error_cause,
	                                source_string_ptr,
	                                rmmi_ptr->s_reg.s3,
	                                4);
		     if (del_flag == RMMI_VALIDATOR_ERROR)
	            {
	                if (error_cause == RMMI_PARSE_NOT_FOUND)
	                {
	                    del_flag = 0;
	                }
	                else
	                {
	                    break;
	                }
	            }

	            if (del_flag == 0)
	            {
	                if (index == 0)
	                {
	                    break;
	                }
	                index--;        //convert index: start from 1 not 0 
	            }
			
	            ret_val = l4c_sms_exe_delete_msg_req(source_string_ptr->src_id, del_flag, index, NULL);
	            if (ret_val == KAL_TRUE)
	            {
	                return;
	            }
	            break;
	        }
	        default:
	        {
	            /* unrecognized format of AT command line */
	            break;
	        }
	    }   /* end of the switch */
    }
    rmmi_sms_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_cmgf_hdlr
 * DESCRIPTION
 *  This command do not need to be blocked when SIM PIN is not verified
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cmgf_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 format;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    l4c_context_struct *l4c_ptr = L4C_PTR;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CMGF_HDLR_ENTRY);

    if (l4c_ptr->sms_ready_flag == KAL_FALSE)
    {
        rmmi_ptr->cmee_err = OPERATION_NOT_ALLOWED_ERR;
    }
    else
    {
           switch (source_string_ptr->cmd_mode)
	    {
	    #ifdef __test_mode__
	        case RMMI_TEST_MODE:
	        {
	            smsal_cmgf_test(&rsp_str);
	            string_length = strlen((char*)rsp_str);
	            ret_val = KAL_TRUE;
	            break;
	        }
	    #endif /* __test_mode__ */ 
	        case RMMI_READ_MODE:
	        {
	            l4c_sms_get_msg_format_req(source_string_ptr->src_id, &format);
	            
	            rmmi_ptr->arg_list[0] = (void*)&format;
	            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CMGF: %d", rmmi_ptr->arg_list, 1);
	            rsp_str = &buffer[0];
	            ret_val = KAL_TRUE;
	            break;
	        }
	        case RMMI_SET_OR_EXECUTE_MODE:
	        {

	            kal_uint8 error_cause;

	            format = (kal_uint8) rmmi_int_validator_range_check(
	                                &error_cause,
	                                source_string_ptr,
	                                rmmi_ptr->s_reg.s3,
	                                1);
		    if (format == RMMI_VALIDATOR_ERROR)
	            {
	                if (error_cause == RMMI_PARSE_NOT_FOUND)
	                {
	                	// hogan: 070210 modify for the case parmater mode is not given (return "OK" and do nothing)
	                	ret_val = KAL_TRUE;
			}
	                break;
	            }

	            ret_val = l4c_sms_set_msg_format_req(source_string_ptr->src_id, format);
	            break;
	        }

	        default:
	        {
	            /* unrecognized format of AT command line */
	            break;
	        }
	    }   /* end of the switch */
    }
    rmmi_sms_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_cmgr_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cmgr_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint16 index;
    l4c_context_struct *l4c_ptr = L4C_PTR;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CMGR_HDLR_ENTRY);

    if (l4c_ptr->sms_ready_flag == KAL_FALSE)
    {
        rmmi_ptr->cmee_err = OPERATION_NOT_ALLOWED_ERR;
    }
    else
    {
           switch (source_string_ptr->cmd_mode)
	    {
	    #ifdef __test_mode__
	        case RMMI_TEST_MODE:
	        {
	            ret_val = KAL_TRUE;
	            break;
	        }
	    #endif /* __test_mode__ */ 
	        case RMMI_SET_OR_EXECUTE_MODE:
	        {
	            kal_uint8 error_cause;
	            kal_uint8 msg_format; 

	            index = (kal_uint16) rmmi_int_validator_ext(&error_cause, source_string_ptr, rmmi_ptr->s_reg.s3);
	            if (index == 0)
	            {
	                rmmi_ptr->cmee_err = INVALID_MEM_INDEX; //for module : Maui_sw 9943
	                break;
	            }

	            if (index == RMMI_VALIDATOR_ERROR)
	            {
	                if (error_cause != RMMI_PARSE_OK)
	                {
	                    break;
	                }
	            }

	            index--;

	            if (source_string_ptr->cmd_index == RMMI_CMD_ATEMGR)
	            {		
	    	        smsal_cmgf_query(&msg_format);

	     	        if (msg_format == SMSAL_PDU_MODE)
	     	        {
			    rmmi_ptr->is_emgr = KAL_TRUE;
	     	        }
	            }

	            ret_val = l4c_sms_exe_read_msg_req(source_string_ptr->src_id, index, KAL_TRUE);
	            if (ret_val == KAL_TRUE)
	            {
	                return;
	            }
	            else 
	            {
	 	        rmmi_ptr->is_emgr = KAL_FALSE; 
	            }

	            break;
	        }
	        default:
	        {
	            /* unrecognized format of AT command line */
	            break;
	        }
	    }   /* end of the switch */
    }
    rmmi_sms_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_cpms_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cpms_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 mem1, mem2, mem3;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 mem1_str[5], mem2_str[5], mem3_str[5];
    kal_uint16 string_length = 0;
    smsal_prefer_storage_struct mem;
    l4c_context_struct *l4c_ptr = L4C_PTR;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CPMS_HDLR_ENTRY);

    if (l4c_ptr->sms_ready_flag == KAL_FALSE)
    {
        rmmi_ptr->cmee_err = OPERATION_NOT_ALLOWED_ERR;
    }
    else
    {
    	switch (source_string_ptr->cmd_mode)
    	{
              //#ifdef __test_mode__
        	case RMMI_TEST_MODE:
        	{
            		smsal_cpms_test(&rsp_str);
            		string_length = (kal_uint16)strlen((char*)rsp_str);
            		ret_val = KAL_TRUE;
            		break;
        	}
              //#endif /*__test_mode__*/
        	case RMMI_READ_MODE:
        	{
	     		#if defined(__SMS_STORAGE_BY_MMI__) && defined(WISDOM_MMI) 
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
	     		#elif defined(__SMS_STORAGE_BY_MMI__) 
	     		{
	     			rmmi_ptr->cpms_query = KAL_TRUE;
				l4c_sms_get_mem_status_lind(source_string_ptr->src_id);
        		
				return;
	     		}
	     		#else
	     		{
	     	       	kal_uint8 buffer[RMMI_SHORT_RSP_LEN];

            		l4c_sms_get_preferred_mem_req(source_string_ptr->src_id, &mem);

            		check_sms_storage_name(mem.mem1, mem1_str);
            		check_sms_storage_name(mem.mem2, mem2_str);
            		check_sms_storage_name(mem.mem3, mem3_str);

                	rmmi_ptr->arg_list[0] = (void*)mem1_str;
                	rmmi_ptr->arg_list[1] = (void*)&mem.used1;
                	rmmi_ptr->arg_list[2] = (void*)&mem.total1;
                	rmmi_ptr->arg_list[3] = (void*)mem2_str;
                	rmmi_ptr->arg_list[4] = (void*)&mem.used2;
                	rmmi_ptr->arg_list[5] = (void*)&mem.total2;
                	rmmi_ptr->arg_list[6] = (void*)mem3_str;
                	rmmi_ptr->arg_list[7] = (void*)&mem.used3;
                	rmmi_ptr->arg_list[8] = (void*)&mem.total3;
                	string_length = rmmi_fast_string_print(
                                    	buffer,
                                    	(kal_uint8*) "+CPMS: \"%s\", %u, %u, \"%s\", %u, %u, \"%s\", %u, %u",
                                    	rmmi_ptr->arg_list,
                                    	9);
                	rsp_str = &buffer[0];
                    ret_val = KAL_TRUE;
					
            		break;
	     		}
	     		#endif
        	}
        	case RMMI_SET_OR_EXECUTE_MODE:
        	{
            		kal_uint8 error_cause;

            		l4c_sms_get_preferred_mem_req(source_string_ptr->src_id, &mem);

            		rmmi_string_validator_ext(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA, 5, mem1_str);
            		if (error_cause != RMMI_PARSE_OK)
            		{
                		break;
            		}
            		else
            		{
                		mem1 = check_sms_storage_code(mem1_str);
            		}

            		if (mem1 == 0xff)
            		{
                		break;
            		}

            		/* mtk01616: when the copmile option is on : only storage ME is  okay 
               	so we won't allow change storage setting to value other than "ME" */
            		#ifdef __UNIFIED_MESSAGE_SIMBOX_SUPPORT__
            			if ((mem1 != SMSAL_ME) && (mem1 != SMSAL_SM))
            			{
                			break;
            			}
            		#endif /* __UNIFIED_MESSAGE_SIMBOX_SUPPORT__ */ 

            		if ( !is_sim_verified() ) //no insert sim or blocked sim or pin/puck lock
            		{
            	  		if (mem1 == SMSAL_SM ||mem1 == SMSAL_SM_PREFER || mem1 == SMSAL_MT)
            	  		{
                     			break;
            	  		}
            		}
			
            		rmmi_string_validator_ext(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA, 5, mem2_str);
            		if (error_cause == RMMI_PARSE_NOT_FOUND)
            		{
                		mem2 = mem.mem2;
            		}
            		else if (error_cause != RMMI_PARSE_OK)
            		{
                		break;
            		}
            		else
            		{
                		mem2 = check_sms_storage_code(mem2_str);
            		}

            		if (mem2 == 0xff)
            		{
                		break;
            		}

        		#ifdef __UNIFIED_MESSAGE_SIMBOX_SUPPORT__
            			if (mem2 != SMSAL_ME)
            			{
                			break;
            			}
        		#endif /* __UNIFIED_MESSAGE_SIMBOX_SUPPORT__ */ 

            		if (error_cause != RMMI_PARSE_NOT_FOUND)
            		{
            			if ( !is_sim_verified() ) //no insert sim or blocked sim or pin/puck lock
            			{
            	  			if (mem2 == SMSAL_SM ||mem2 == SMSAL_SM_PREFER || mem2 == SMSAL_MT)
            	  			{
                     			break;
            	  			}
            			}
            		}
			
	            	rmmi_string_validator_ext(&error_cause, source_string_ptr, rmmi_ptr->s_reg.s3, 5, mem3_str);
	            	if (error_cause == RMMI_PARSE_NOT_FOUND)
	            	{
	                	mem3 = mem.mem3;
	            	}
	            	else if (error_cause != RMMI_PARSE_OK)
	            	{
	                	break;
	            	}
	            	else
	            	{
	                	mem3 = check_sms_storage_code(mem3_str);
	            	}

	            	if (mem3 == 0xff)
	            	{
	                	break;
	            	}

		     	#ifdef __UNIFIED_MESSAGE_SIMBOX_SUPPORT__
		            	if (mem3 != SMSAL_ME)
		            	{
		                	break;
		            	}
		     	#endif /* __UNIFIED_MESSAGE_SIMBOX_SUPPORT__ */ 

	            	if (error_cause != RMMI_PARSE_NOT_FOUND)
	            	{
	            		if ( !is_sim_verified() ) //no insert sim or blocked sim or pin/puck lock
	            		{
	            	  		if (mem3 == SMSAL_SM ||mem3 == SMSAL_SM_PREFER || mem3 == SMSAL_MT)
	            	  		{
	                     		break;
	            	  		}
	            		}
	            	}

            		ret_val = l4c_sms_set_preferred_mem_req(source_string_ptr->src_id, mem1, mem2, mem3);

            		if (ret_val == KAL_TRUE)
            		{
                		return;
            		}
            		break;
        	}
        	default:
        	{
           	 	/* unrecognized format of AT command line */
            		break;
        	}
    	}   /* end of the switch */
    }
    rmmi_sms_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_eqsi_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_eqsi_hdlr(rmmi_string_struct *source_string_ptr)
{

    kal_bool ret_val = KAL_FALSE;
    kal_uint8 result;
    kal_uint8 const *rsp_str = NULL;
    kal_uint16 string_length = 0;
    //kal_uint8 msg_format;
    kal_uint8 mem_str[2];
    rmmi_smsal_storage_enum  mem;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;

    //kal_trace(TRACE_FUNC, FUNC_RMMI_CPMS_HDLR_ENTRY);
    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_TEST_MODE:
        {
            smsal_eqsi_test(&rsp_str);
            string_length = (kal_uint16)strlen((char*)rsp_str);
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            //l4c_sms_get_msg_format_req(source_string_ptr->src_id, &msg_format);
			
            //if (msg_format == SMSAL_TEXT_MODE)
            //{

                result = rmmi_string_validator(source_string_ptr, rmmi_ptr->s_reg.s3, 4, (kal_uint8*) mem_str);
                if (result == RMMI_VALIDATOR_ERROR)     //check if mem str exist and valid
                {
                    break;
                }
                mem = (rmmi_smsal_storage_enum)check_sms_mem_code((kal_uint8*) mem_str);
                if (mem == 0xff)     //check if code is find otherwise we should break
                {
                    break;
                }
            //}
            //else
            //{
            //    mem = (kal_uint8) rmmi_int_validator(source_string_ptr, rmmi_ptr->s_reg.s3);
            //    if (mem > 1)
            //    {
            //        break;
            //    }
            //}

		#if defined(__SMS_STORAGE_BY_MMI__) && defined(WISDOM_MMI) 
/* under construction !*/
/* under construction !*/
/* under construction !*/
		#elif defined(__SMS_STORAGE_BY_MMI__) 
		{
			l4c_set_user_action(L4C_SMS, source_string_ptr->src_id, EQSI_EXE);

			l4c_sms_atcmd_eqsi_lind(source_string_ptr->src_id, mem);

			return;
		}
		#else
		{
			kal_uint16 beg_index, end_index, used;
    			kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
				
            ret_val = l4c_smsal_eqsi_query(mem, &beg_index, &end_index, &used);		
            if (ret_val == KAL_TRUE)
            {
		 beg_index++;
		 end_index++;
		 //if (msg_format == SMSAL_TEXT_MODE)
               //{
			check_sms_mem_name(mem, (kal_uint8*)mem_str);
			rmmi_ptr->arg_list[0] = (void*)&mem_str;
		 //}
		 //else
		 //{
		 //	rmmi_ptr->arg_list[0] = (void*)&mem;
		 //}
               rmmi_ptr->arg_list[1] = (void*)&beg_index;
               rmmi_ptr->arg_list[2] = (void*)&end_index;
	        rmmi_ptr->arg_list[3] = (void*)&used;

		 //if (msg_format == SMSAL_TEXT_MODE)
               //{
               	string_length = rmmi_fast_string_print(
                                   buffer,
                                   (kal_uint8*) "+EQSI: %s, %u, %u, %u",
                                   rmmi_ptr->arg_list,
                                   4);
		 //}
		 //else
		 //{
		//	string_length = rmmi_fast_string_print(
              //                     buffer,
              //                     (kal_uint8*) "+EQSI: %d, %d, %d, %d",
               //                    rmmi_ptr->arg_list,
               //                    4);
		 //}
               rsp_str = &buffer[0];
            }
                else 
                {
                    if ( !is_sim_verified() ) //no insert sim or blocked sim or pin/puck lock
                    {
                	      if (mem == RMMI_SMSAL_SM )
                	      {
                                rsp_str = (kal_uint8 const*)"+EQSI: SM, 1, 1, 0";
                                string_length = (kal_uint16)strlen((char*)rsp_str); /* type casting */
                                ret_val = KAL_TRUE;
                	      }
                    }
                }
            break;
		}
		#endif
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_sms_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}

#ifdef __ETWS_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  rmmi_etws_hdlr
 * DESCRIPTION
 *  This function is used to handle AT+ETWS
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_etws_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 error_cause;
    kal_uint8 result;
    l4c_context_struct *l4c_ptr = L4C_PTR;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;
    l4c_common_context_struct *l4c_comm_ptr = L4C_COMM_PTR;


    if (l4c_ptr->sms_ready_flag == KAL_FALSE)
    {
        rmmi_ptr->cmee_err = OPERATION_NOT_ALLOWED_ERR;
    }
    else
    {
        switch (source_string_ptr->cmd_mode)
        {
            /*************************************************
            * The format of AT+ETWS
            * AT+ETWS?
            * +ETWS: <setting>
            * OK
            *
            * AT+ETWS=<setting>
            * OK
            *
            * <setting>: a bit mask value, each bit is corresponding to a setting
            * bit 0: enable ETWS
            * bit 1: enable receiving ETWS with security check
            * bit 2: enable receiving test purpose ETWS
            ***************************************************/
            case RMMI_READ_MODE:
            {
                rmmi_header_rrsp("+ETWS:");
                rmmi_tail_int_space_rrsp(l4c_comm_ptr->etws_setting);
                ret_val = KAL_TRUE;
                break;
            }
            case RMMI_SET_OR_EXECUTE_MODE:
            {
                result = rmmi_int_validator_range_check(
                        &error_cause, 
                        source_string_ptr, 
                        rmmi_ptr->s_reg.s3, 
                        RMMI_ETWS_SETTING_MAX);
                if (error_cause != RMMI_PARSE_OK)
                {
                    break;
                }

                l4c_sms_etws_setting_req(
                        source_string_ptr->src_id, 
                        (result & RMMI_ETWS_IS_NEEDED) >>0, 
                        (result & RMMI_ETWS_IS_SECURITY_NEEDED) >>1,
                        (result & RMMI_ETWS_IS_TESTING_ON) >> 2,
                        KAL_TRUE);
                
                return;
            }
            default:
            {
                /* unrecognized format of AT command line */
                break;
            }
        }
    }
    rmmi_sms_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) NULL, 0);
    return;

}
#endif /* __ETWS_SUPPORT__*/

#endif /* !defined(__ULC_AT__) */


/*mtk01616_100303: we plan to phase out the commands below and they are not used by MTK internally.
   And they don't listed in AT document. So we remove them directly. */
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

#endif  /* __MOD_SMSAL__ */

