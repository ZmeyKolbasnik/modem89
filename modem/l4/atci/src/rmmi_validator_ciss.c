/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 * RMMI_VALIDATOR_CISS.C
 *
 * Project:
 * --------
 *   MAUI
 *
 * Description:
 * ------------
 *   This file is intends for ...
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
#include <stdio.h>
#include <string.h>
//#include "kal_non_specific_general_types.h"
//#include "kal_release.h"
//#include "stack_common.h"
#include "kal_public_defs.h" //MSBB change #include "stack_msgs.h"
//#include "app_ltlcom.h" /* Task message communiction */
//#include "stack_ltlcom.h" /* Task message communiction */
//#include "stacklib.h"   /* Basic type for dll, evshed, stacktimer */
//#include "app_buff_alloc.h"
//#include "stack_timer.h"
//#include "event_shed.h"
//#include "nvram_editor_data_item.h"
//#include "custom_nvram_editor_data_item.h"
//#include "ps_trace.h"
#include "kal_trace.h"
#include "l4_msgid.h"

#ifdef __MOD_SMU__
//#include "ps2sim_struct.h"
#include "sim_common_enums.h"
#include "smu_common_enums.h"
#endif /* __MOD_SMU__ */ 
//#include "device.h"
#include "csmss_common_enums.h"

//#include "mcd_l3_inc_struct.h"
//#include "mcd_l3_inc_gprs_struct.h"
//#include "l3_inc_enums.h"

#include "mcd_l4_common.h"
 
#include "l4c_common_enum.h"
#include "rmmi_common_enum.h"
#include "rmmi_context.h"
#include "l4c_context.h"
#include "layer4_context.h"
//#include "l4c_rspfmttr.h"
//#include "l4c_msghdlr.h"
#include "l4_trc.h"
#include "atci_trc.h"
//#include "uart_sw.h"
//#include "l4_defs.h"
//#include "csmcc_atfunc.h"
//#include "csmss_atfunc.h"
//#include "l4c_aux_struct.h"
//#include "l4c_ss_parse.h"

#ifdef __MOD_CSM__
//#include "mcd_ss_parameters.h"
//#include "mcd_ss_tcapmessages.h"
#include "l4c_common_enum.h"
//#include "csmcc_enums.h"
//#include "csmcc_common_enums.h"
//#include "ps2sat_struct.h"
//#include "l4c2csm_cc_struct.h"

#include "l4c_ciss_cmd.h"
#include "l4c2csm_ss_struct.h"
//#include "l4c_cc_cmd.h"
#endif /* __MOD_CSM__ */ 

#if defined (VM_SUPPORT)
//#include "med_struct.h"
#endif 
#ifdef __MOD_UEM__
//#include "device.h"
//#include "l4c2uem_struct.h"
//#include "uem_at_cmd.h"
//#include "custom_em.h"
//#include "l4c_eq_cmd.h"
#endif /* __MOD_UEM__ */ 
#ifdef __MOD_RAC__
#include "l4crac_func.h"
//#include "l4c_nw_cmd.h"
//#include "l4crac_enums.h"
#endif /* __MOD_RAC__ */ 
#ifdef __MOD_PHB__
#include "sim_common_enums.h"
//#include "l4c2phb_enums.h"
#include "l4c2phb_struct.h"
//#include "phb_sap.h"
//#include "l4c_phb_cmd.h"
//#include "phb_defs.h"
//#include "phb_config.h"
#endif /* __MOD_PHB__ */ 
#ifdef __MOD_SMSAL__
//#include "l4c2smsal_struct.h"
//#include "smsal_l4c_defs.h"
//#include "smsal_l4c_funcs.h"
//#include "smsal_l4c_enum.h"
//#include "smsal_defs.h"
//#include "l4c_sms_cmd.h"
#endif /* __MOD_SMSAL__ */ 
#ifdef __MOD_SMU__
//#include "ps2sat_struct.h"
//#include "mcd_ps2sat_peer.h"
#include "l4c_sim_cmd.h"
#endif /* __MOD_SMU__ */ 
#ifdef __MOD_TCM__
//#include "mmi_l3_enums.h"
//#include "mmi_sm_enums.h"
//#include "ppp_l4_enums.h"
//#include "tcm_common_enums.h"
//#include "tcm_common.h"
//#include "custom_nvram_editor_data_item.h"
//#include "l4c2abm_struct.h"
//#include "abm2l4c_struct.h"
//#include "l4c2tcm_struct.h"
//#include "l4c2tcm_func.h"
//#ifdef __TCPIP__
//#include "l4c2abm_struct.h"
//#endif /* __TCPIP__ */
//#include "l4c_gprs_cmd.h"
#endif /* __MOD_TCM__ */ 
#ifdef __MODEM_EM_MODE__
//#include "em_struct.h"
//#include "l4c_em.h"
//#include "lmmi_rsp.h"
#endif /* __MODEM_EM_MODE__ */ 

#include "l4c_utility.h"
#include "rmmi_rspfmttr.h"
#include "rmmi_utility.h"
//#include "rmmi_rsp.h"
//#include "rmmi_validator.h"
//#include "nvram_data_items.h"
//#include "custom_hw_default.h"
//#include "l4c_table.h"
//#include "rmmi_parser.h"
//#include "resource_verno.h"     // for +EGMR read MMI resource version

#ifdef __CSD_FAX__
//#include "csm_data_enums.h"
//#include "l4c2t30_struct.h"
//#include "l4c_t30_cmd.h"
//#include "l4c2t30_enums.h"
#endif /* __CSD_FAX__ */ 
//#include "rmmi_parser.h"
#ifndef MED_NOT_PRESENT
//#include "med_global.h"
//#include "med_main.h"
#endif /* MED_NOT_PRESENT */ 
//#ifdef __J2ME__
//#include "jam_msg_handler.h"
//#endif 

#ifdef __CTM_SUPPORT__
//#include "med_struct.h"
#endif 
#include "l4c_sendmsg.h"

#ifdef __CUST_NEW__
//#include "gpio_sw.h"
#endif 

/* for data item NVRAM_EF_IMEI_IMEISV_LID move */
//#include "nvram_user_defs.h"
//#include "csmcc_defs.h"

//#include "keypad_sw.h"
//#include "l4c2smu_struct.h"
//#include "lmmi_ind.h"

//#include "csmcc_common_enums.h"

//#include "mncc_struct.h"
//#include "csmcc_bc_types.h"
//#include "csmcc_types.h"
//#include "custom_em.h"
//#include "L4c_ctm_cmd.h"
//#include "csmcc_utility.h"
//#include "sat_def.h"
//#include "uem_proc_cmd.h"
#include "rmmi_msghdlr.h"
#include "kal_general_types.h"
#include "ps_public_struct.h"
#include "kal_public_api.h"
#include "ps_public_enum.h"

#ifdef __MOD_CSM__ 
/* ciss group */

extern kal_bool is_chv1_enabled(void);

extern kal_bool custom_phb_xmgnt_approve_fdn (
        kal_uint8 *tel_number, /* BCD coding, include TON/NPI in the first byte */
        kal_uint8 num_length,
        kal_uint8 sim_id,
        l4c_operation_type_enum oper,
        kal_uint16 *cause);

/*****************************************************************************
 * FUNCTION
 *  rmmi_ccwa_hdlr
 * DESCRIPTION
 *  SET cmd need to be blocked when SIM PIN is not verified if is network related.
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_ccwa_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 rep, mode, bs_code;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    kal_uint8 error_cause;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_CCWA_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            ret_val = l4ccsm_ss_test_call_wait(&rsp_str);
            string_length = strlen((char*)rsp_str);
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_READ_MODE:
        {
            rep = rmmi_ptr->report_mode.call_wait;
            ret_val = KAL_TRUE;
            rmmi_ptr->arg_list[0] = (void*)&rep;
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CCWA: %d", rmmi_ptr->arg_list, 1);
            rsp_str = &buffer[0];
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            //AT+CCWA=<CR>
            if (source_string_ptr->string_ptr[source_string_ptr->index] == rmmi_ptr->s_reg.s3)
            {
                rmmi_ptr->report_mode.call_wait = 0;
                ret_val = KAL_TRUE;
                break;
            }

            /* get <n> : 0/1 - disable/enable the unsolicited result code to TE */
            rep = (kal_uint8) rmmi_int_validator_ext(
                                (kal_uint8*) & error_cause,
                                source_string_ptr,
                                (kal_uint8) RMMI_COMMA /* separator */ );
            if (rep != RMMI_VALIDATOR_ERROR)
            {
                if (rep > 1)
                {
                    break;
                }
            #if defined(__L4C_GEMINI_BT_HF__)
                if (source_string_ptr->src_id == RMMI_COMM_PTR->rmmi_hf_src)
                {
                    kal_uint8 sim_id;

                    /* sync all ATCI context */
                    for (sim_id=0; sim_id<RMMI_MAX_SIM_NUM; sim_id++)
                    {
                        (&rmmi_cntxt_g[sim_id])->report_mode.call_wait = rep;
                    }
                }
                else
            #endif
                rmmi_ptr->report_mode.call_wait = rep;
            }
            else        //rep == RMMI_VALIDATOR_ERROR
            {
                if (error_cause == RMMI_PARSE_ERROR)    //Parse Error
                {
                    break;
                }
                /* else <n> is not present */
            }

            mode = (kal_uint8) rmmi_int_validator_ext(
                                (kal_uint8*) & error_cause,
                                source_string_ptr,
                                (kal_uint8) RMMI_COMMA /* delimiter */ );

            if (mode == 0)
            {
                mode = SS_OP_DEACTIVATESS;
            }
            else if (mode == 1)
            {
                mode = SS_OP_ACTIVATESS;
            }
            else if (mode == 2)
            {
                mode = SS_OP_INTERROGATESS;
            }
            else if ((error_cause == RMMI_PARSE_NOT_FOUND) && ((rep == 0) || (rep == 1)))
            {
                ret_val = KAL_TRUE;
                break;
            }
            else
            {
                break;
            }

            bs_code = (kal_uint8) rmmi_int_validator_ext(
                                    (kal_uint8*) & error_cause,
                                    source_string_ptr,
                                    rmmi_ptr->s_reg.s3);
            if (bs_code == RMMI_VALIDATOR_ERROR)
            {
                if (error_cause == RMMI_PARSE_NOT_FOUND)
                    if (mode == SS_OP_INTERROGATESS)
                    {
                        bs_code = 7;
                    }
                    else
                    {
                        bs_code = 7;
                    }
                else
                {
                    break;
                }
            }
            else
            {
                if (bs_code > 63)
                {
                    break;      //we dont support 64(dedicated packet access) and 128(dedicated PAD access)
                }
            }

            //bs_code = check_bscode_L4enum(bs_code);

            /* need to communicate with  network, not allowed when SIM invalid */
            if (is_sim_verified() == KAL_FALSE)
            {
		        rmmi_result_code_fmttr(RMMI_RCODE_ERROR, rmmi_ptr->cmee_err); //MAUI_01769185
                return;
            }

            ret_val =
                /* l4c_ss_exe_call_wait_req */ l4c_ss_exe_repeat_CCWA_req(source_string_ptr->src_id, mode, bs_code);

            if (ret_val == KAL_TRUE)
            {
                return;
            }
            else
            {
                rmmi_ptr->cmee_err = RMMI_ERR_COMMAND_CONFLICT;
            }
            break;
        }
        default:
        {
            break;
        }
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_clip_hdlr
 * DESCRIPTION
 *  READ cmd need to be blocked when SIM PIN is not verified
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_clip_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 rep;
    kal_uint8 const *rsp_str = NULL;
    kal_uint16 string_length = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_CLIP_HDLR_ENTRY);
    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            ret_val = l4ccsm_ss_test_clip_mode(&rsp_str);
            string_length = strlen((char*)rsp_str);

            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_READ_MODE:
        {
            /* need to do network interrogation, doesnot allow when SIM invalid */
            if (is_sim_verified() == KAL_FALSE)
            {
                rmmi_result_code_fmttr(RMMI_RCODE_ERROR, rmmi_ptr->cmee_err);
                return;
            }

            ret_val = l4c_ss_exe_interrogate_req(source_string_ptr->src_id, L4_CLIP);
            if (ret_val == KAL_TRUE)
            {
                return;
            }
        }
            break;
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;

            rep = (kal_uint8) rmmi_int_validator_ext(
                                (kal_uint8*) & error_cause,
                                source_string_ptr,
                                rmmi_ptr->s_reg.s3 /* separator */ );

            if ((rep == 0) || (rep == 1))
            {
            #if defined(__L4C_GEMINI_BT_HF__)
                if (source_string_ptr->src_id == RMMI_COMM_PTR->rmmi_hf_src)
                {
                    kal_uint8 sim_id;

                    /* sync all ATCI context */
                    for (sim_id=0; sim_id<RMMI_MAX_SIM_NUM; sim_id++)
                    {
                        (&rmmi_cntxt_g[sim_id])->report_mode.clip = rep;
                    }
                }
                else
            #endif
                rmmi_ptr->report_mode.clip = rep;
                ret_val = KAL_TRUE;
            }
            else if ((rep == RMMI_VALIDATOR_ERROR) && (error_cause == RMMI_PARSE_NOT_FOUND))
            {
                rmmi_ptr->report_mode.clip = 0; //set to default value
                ret_val = KAL_TRUE;
            }
        }
            break;
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_ccfc_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_ccfc_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_bool sub_addr_flag = KAL_FALSE;
    kal_uint8 result;
    kal_uint8 reason, bs_code, timer, mode;
    kal_uint8 const *rsp_str = NULL;
    kal_uint16 string_length = 0;
    l4c_number_struct dest;
    l4c_sub_addr_struct sub_addr;
    kal_uint8 error_cause, error_cause2;

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_CCFC_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            ret_val = l4ccsm_ss_test_call_forward(&rsp_str);
            string_length = strlen((char*)rsp_str);
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            /* get reason: op_code */
            reason = rmmi_int_validator_u8_check(
                                    NULL,
                                    source_string_ptr,
                                    (kal_uint8) RMMI_COMMA /* separator */ );
            if (reason > 5)
            {
                break;
            }

            /* get mode: ss_code */
            mode = rmmi_int_validator_u8_check(
                                NULL,
                                source_string_ptr,
                                (kal_uint8) RMMI_COMMA /* separator */ );
            if (mode > 4)
            {
                break;
            }

            /* get the number string (optional) */
            result = rmmi_string_validator_ext(
                        (kal_uint8*) & error_cause,
                        source_string_ptr,
                        (kal_uint8) RMMI_COMMA, /* delimiter */
                        MAX_CC_ADDR_LEN,
                        (kal_uint8*) dest.number);

            /* get the type of the number */
            dest.type = rmmi_int_validator_u8_check(
                                        (kal_uint8*) & error_cause2,
                                        source_string_ptr,
                                        (kal_uint8) RMMI_COMMA);

            if (result != RMMI_VALIDATOR_ERROR) //number is present
            {
                if (dest.type != RMMI_VALIDATOR_ERROR)  //type is present
                {
                    if ((dest.type != 145) && (dest.type != 129))
                    {
                        break;
                    }
                }
                else if (error_cause2 == RMMI_PARSE_NOT_FOUND)   //type is not present
                {
                    dest.type = 129;    //default
                }
                else    //type is parsing error
                {
                    break;
                }

                if (dest.number[0] == RMMI_CHAR_PLUS)   //eg. +886 xxxxx => 145
                {
                    kal_uint8 temp_num[MAX_CC_ADDR_LEN];
                    kal_uint8 len;

                    dest.type = 145;
                    len = strlen((char*)dest.number);
                    kal_mem_cpy((kal_uint8*) temp_num, (kal_uint8*) & dest.number[1], len - 1);
                    kal_mem_cpy((kal_uint8*) dest.number, (kal_uint8*) temp_num, len - 1);
                    dest.number[len - 1] = 0;
                }
            }
            else        //result==RMMI_VALIDATOR_ERROR
            {
                if ((error_cause == RMMI_PARSE_ERROR) || (error_cause2 == RMMI_PARSE_ERROR))    //parse Error
                {
                    ret_val = KAL_FALSE;
                    break;
                }
                //else RMMI_PARSE_NOT_FOUND : number is omitted
                dest.type = 0;
            }

            /* get classx */
            bs_code = rmmi_int_validator_u8_check(
                                    (kal_uint8*) & error_cause,
                                    source_string_ptr,
                                    (kal_uint8) RMMI_COMMA);

            if (bs_code == RMMI_VALIDATOR_ERROR)
            {
                if (error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    if(mode == 2) //SS_OP_INTERROGATESS
                    {
                        bs_code= 0;
                    }
                    else
                    {
                        bs_code = 7;
                    }
                }
                else
                {
                    break;
                }
            }
            else
            {
	            if(bs_code == 0) 
                {
                    break; //the sum of class shall be larger than zero
                }
                if (bs_code > 63)
                {
                    break; //we dont support 64(dedicated packet access) and 128(dedicated PAD access)
                }
            }

            /* get subaddr */
            result = rmmi_string_validator_ext(
                        (kal_uint8*) & error_cause,
                        source_string_ptr,
                        (kal_uint8) RMMI_COMMA, /* delimiter */
                        MAX_CC_ADDR_LEN,
                        (kal_uint8*) sub_addr.number);

            if (result != RMMI_VALIDATOR_ERROR)
            {
                sub_addr_flag = KAL_TRUE;
            }
            else if (error_cause == RMMI_PARSE_ERROR)   //Parse error
            {
                break;
            }

            /* get satype */
            sub_addr.type = rmmi_int_validator_u8_check(
                                            (kal_uint8*) & error_cause,
                                            source_string_ptr,
                                            (kal_uint8) RMMI_COMMA);
            if (error_cause == RMMI_PARSE_ERROR)        //Parse Error
            {
                break;
            }
            else if (error_cause == RMMI_PARSE_NOT_FOUND)
            {
                sub_addr.type = 128;
            }

            /* get timer */
            timer = rmmi_int_validator_u8_check(
                                    (kal_uint8*) & error_cause,
                                    source_string_ptr,
                                    RMMI_PTR->s_reg.s3);
            if (timer != RMMI_VALIDATOR_ERROR)
            {
                if ((timer < 1) || (timer > 30))
                {
                    break;
                }
                timer = ((timer - 1) / 5 + 1) * 5;      //round to 5-30,               
            }
            else if (error_cause == RMMI_PARSE_NOT_FOUND)
            {
                if ((reason == 2) && ((mode == 3) || (mode == 2) || (mode == 1))) //SS_OP_REGISTERSS SS_OP_INTERROGATESS or SS_OP_ACTIVATESS
                {
                    timer = 20;
                }
                else
                {
                    timer = 0;
                }
            }
            else
            {
                break;  //Parse Error
            }

            dest.length = strlen((char*)dest.number);
            sub_addr.length = strlen((char*)sub_addr.number);

            ret_val = l4c_ss_exe_repeat_CCFC_req(
                        source_string_ptr->src_id,
                        mode,
                        reason,
                        bs_code,
                        timer,
                        dest,
                        sub_addr_flag,
                        sub_addr);
            if (ret_val == KAL_TRUE)
            {
                return;
            }
        }
            break;
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


#if !defined(__SLIM_AT__) 
/*****************************************************************************
 * FUNCTION
 *  rmmi_caemlpp_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_caemlpp_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 priority = 255;

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_CAEMLPP_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_READ_MODE:
        {
            ret_val = l4c_ss_exe_emlpp_req(source_string_ptr->src_id, SS_OP_INTERROGATESS, priority);
            if (ret_val == KAL_TRUE)
            {
                return;
            }
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            priority = (kal_uint8) rmmi_int_validator(
                                    source_string_ptr,
                                    RMMI_PTR->s_reg.s3 /* separator */ );
            if (priority == RMMI_VALIDATOR_ERROR)
            {
                break;
            }

            ret_val = l4c_ss_exe_emlpp_req(source_string_ptr->src_id, SS_OP_REGISTERSS, priority);
            if (ret_val == KAL_TRUE)
            {
                return;
            }
            break;
        }
        default:
            break;
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_cdip_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cdip_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 rep;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_CDIP_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:
        {
            ret_val = l4c_ss_exe_interrogate_req(source_string_ptr->src_id, L4_CDIP);
            if (ret_val == KAL_FALSE)
            {
                rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_RETURN_ERROR);
            }

            return;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;

            rep = (kal_uint8) rmmi_int_validator_ext(
                                (kal_uint8*) & error_cause,
                                source_string_ptr,
                                rmmi_ptr->s_reg.s3 /* separator */ );

            if ((rep == 0) || (rep == 1))
            {
                rmmi_ptr->report_mode.cdip = rep;
                rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
            }
            else if ((rep == RMMI_VALIDATOR_ERROR) && (error_cause == RMMI_PARSE_NOT_FOUND))
            {
                rmmi_ptr->report_mode.cdip = 0; //set to default value
                rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
            }
            else
            {
                rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_SYNTEX_ERROR);
            }
            return;
        }

        default:
        {
            /* unrecognized format of AT command line */
            rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNSPECIFIED);
            return;
        }
    }   /* end of the switch */
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_clck_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_clck_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 result;
    kal_uint8 mode;
    kal_uint8 bs_code;
    kal_uint8 type;
    kal_uint8 fac[3];
    kal_uint8 passwd[SML_MAX_SUPPORT_KEY_LEN*2+1];
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim
#if !defined(__MMI_FMI__) || defined(__CLCK_FDN_SUPPORT__)
    kal_bool passwd_flag = KAL_FALSE;
#endif

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_CLCK_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            //ret_val = l4ccsm_ss_test_clck_mode (&rsp_str);
            kal_sprintf((kal_char*) buffer, "+CLCK: (\"PF\",\"SC\",\"AO\",\"OI\",\"OX\",\"AI\",\"IR\",\"AB\",\"AG\",\"AC\",\"PN\",\"PU\",\"PP\",\"PC\")";
            rsp_str = &buffer[0];
            string_length = strlen((char*)rsp_str);
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;

    	    rmmi_ptr->last_executed_P2_fail = RMMI_NO_ERR; // [MAUI_01296349] mtk02480 27.007

            result = rmmi_string_validator(
                        source_string_ptr,
                        (kal_uint8) RMMI_COMMA, /* separator */
                        3,
                        (kal_uint8*) fac);
            if (result == RMMI_VALIDATOR_ERROR)
            {
                break;
            }

            mode = (kal_uint8) rmmi_int_validator(
                                source_string_ptr,
                                (kal_uint8) RMMI_COMMA /* delimiter */ );
            if (mode == RMMI_VALIDATOR_ERROR)   //we will return ERROR for <mode> > 2 later!
            {
                break;
            }

            /* not allowed when SIM PIN is not inserted
             * [DUMA00114927] mtk02480, allow AT+CLCK="SC",2 to query status even SIM enter PUK state
             */	
            if (is_sim_verified() == KAL_FALSE && mode!=2)
            {
                rmmi_result_code_fmttr(RMMI_RCODE_ERROR, rmmi_ptr->cmee_err);
                return;
            }

            result = rmmi_string_validator_ext(
                        &error_cause,
                        source_string_ptr,
                        (kal_uint8) RMMI_COMMA, /* separator */
                        SML_MAX_SUPPORT_KEY_LEN*2+1,
                        (kal_uint8*) passwd);
            if (result == RMMI_VALIDATOR_ERROR)
            {
                if (error_cause != RMMI_PARSE_NOT_FOUND)
                {
                    break;
                }
            }
            else
            {
                if (rmmi_is_number_string(passwd) == KAL_FALSE)
                {		      
                    break;
                }
            #if !defined(__MMI_FMI__) || defined(__CLCK_FDN_SUPPORT__)
                passwd_flag = KAL_TRUE;
            #endif
            }

            bs_code = (kal_uint8) rmmi_int_validator_ext(
                                    &error_cause,
                                    source_string_ptr,
                                    rmmi_ptr->s_reg.s3 /* delimiter */ );
            if (bs_code == RMMI_VALIDATOR_ERROR)
            {
                if (error_cause != RMMI_PARSE_NOT_FOUND)
                {
                    break;
                }
                else
                {
                    bs_code = 7;
                }
            }
            else
            {
                if (bs_code > 63)
                {
                    break;      //we dont support 64(dedicated packet access) and 128(dedicated PAD access)
                }
            }
            //mtk00924: +CLCK support FD
            toUpper(fac);
            //bs_code = check_bscode_L4enum(bs_code);
            type = check_facility_type((kal_uint8*) fac);

            if ((type >= SS_FAC_BEGIN) && (type <= SS_FAC_END))
            {
                if (is_sim_verified() == KAL_FALSE) 
                {
                    break;
                }
                if (mode == 0)
                {
                    mode = SS_OP_DEACTIVATESS;
                }
                else if (mode == 1)
                {
                    mode = SS_OP_ACTIVATESS;
                }
                else if (mode == 2)
                {
                    mode = SS_OP_INTERROGATESS;
                }
                else
                {
                    break;
                }

            #if defined(__SP_RIL_SUPPORT__)
                if (type == L4_BOIC)
                {
                    bs_code = 0;
                }
            #endif /* __SP_RIL_SUPPORT__ */ 
                ret_val = l4c_ss_exe_repeat_CLCK_SS_req(
                                    source_string_ptr->src_id,
                                    mode,
                                    type,
                                    bs_code,
                                    (kal_uint8*) passwd);
                if (ret_val == KAL_TRUE)
                {
                    return;
                }
            }
            else if ((type >= SIM_FAC_BEGIN) && (type <= SIM_FAC_END))
            {
            #if !defined(__MMI_FMI__)
                if (type == TYPE_CHV1 && (mode == 0 || mode == 1) && passwd_flag == KAL_FALSE)
                {
                    break;
                }
            #endif /* !defined(__MMI_FMI__) */ 
		        if (type == TYPE_NP || type == TYPE_NSP || type == TYPE_SP || type == TYPE_CP || type == TYPE_IMSI_LOCK)
                {     
                    ret_val = KAL_FALSE;
		            if ((mode == 0) || (mode == 1)) // 0: unlock; 1: lock
                    {
 			            ret_val = l4c_smu_set_personalization_req(source_string_ptr->src_id, 
                                                                  (type - TYPE_NP), 
                                                                  mode, 
                                                                  passwd, 
                                                                  0, 
                                                                  NULL);
                    }
                    else if (mode == 2)
                    {
                        rmmi_ptr->clck_sml_type = type;
                        ret_val = l4c_smu_sml_status_req(source_string_ptr->src_id);
                    }
                    
		            if (ret_val == KAL_FALSE)
		            {
		                rmmi_ptr->clck_sml_type = TYPE_UNSPECIFIED;
		       	        rmmi_result_code_fmttr (RMMI_RCODE_ERROR, OPERATION_NOT_ALLOWED_ERR);
                    }
                    
		            return;
                }
								
                if (mode == 0)
                {
                    mode = DISABLE;
                }
                else if (mode == 1)
                {
                    mode = ENABLE;
                }
                else if (mode == 2)
                {
                    if (type == TYPE_CHV1)
                    {
                        kal_bool enable = is_chv1_enabled();

                        if (enable == KAL_FALSE)
                        {
                            kal_sprintf((kal_char*) buffer, "+CLCK: 0");
                        }
                        else
                        {
                            kal_sprintf((kal_char*) buffer, "+CLCK: 1");
                        }
                        rsp_str = &buffer[0];
                        string_length = strlen((char*)rsp_str);
                        ret_val = KAL_TRUE;
                    }
                    break;
                }
                else
                {
                    break;
                }

                ret_val = l4c_smu_exe_lock_req(source_string_ptr->src_id, mode, type, (kal_uint8*) passwd);
                if (ret_val == KAL_TRUE)
                {
                    return;
                }
            }
        #if !defined(__MMI_FMI__) || defined(__CLCK_FDN_SUPPORT__)
            else if (fac[0] == RMMI_CHAR_F && fac[1] == RMMI_CHAR_D)
            {
                if ((mode == 0 || mode == 1) && passwd_flag == KAL_FALSE)       /* for lock or unlock FDN, PIN2 should be given */
                {
	     	      rmmi_ptr->cmee_err = RMMI_ERR_UNKNOWN; //[MAUI_01296349] mtk02480   
                    break;
                }

                if (mode == 0 || mode == 1)
                {
                    ret_val = l4c_smu_exe_dial_mode_req(source_string_ptr->src_id, TYPE_FDN, mode, (kal_uint8*) passwd);

                    if (ret_val == KAL_FALSE)
                    {
                        break;
                    }

                    return;
                }
                else if (mode == 2)
                {
                    kal_uint8 dn_type;

                    if (L4C_PTR->mmi_info_received == KAL_FALSE)
                    {
                        rmmi_ptr->cmee_err = SIM_BUSY;
                        break;
                    }
                    
                    dn_type = l4csmu_get_dial_mode();

                    if (dn_type == TYPE_FDN || dn_type == TYPE_FDN_BDN)
                    {
                        kal_sprintf((kal_char*) buffer, "+CLCK: 1");
                    }
                    else
                    {
                        kal_sprintf((kal_char*) buffer, "+CLCK: 0");
                    }

                    rsp_str = &buffer[0];
                    string_length = strlen((char*)rsp_str);
                    ret_val = KAL_TRUE;
                    break;
                }
            }
        #endif /* !defined(__MMI_FMI__) || defined(__CLCK_FDN_SUPPORT__) */ 
        }
            break;
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_essp_hdlr
 * DESCRIPTION
 *  SS cfu query setting
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_essp_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    kal_uint32 mode;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:
        {        
            mode = l4c_em_get_essp_req();
            ret_val = KAL_TRUE;
            rmmi_ptr->arg_list[0] = (void*)&mode;
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+ESSP: %d", rmmi_ptr->arg_list, 1);
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;

            mode = rmmi_int_validator_range_check(&error_cause, source_string_ptr, rmmi_ptr->s_reg.s3, 2);
            if (error_cause != RMMI_PARSE_OK)
            {
               break;
            }
            ret_val = l4c_em_set_essp_req(mode);
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, buffer, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_clir_hdlr
 * DESCRIPTION
 *  READ cmd need to be blocked when SIM PIN is not verified
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_clir_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 rep;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_CLIR_HDLR_ENTRY);
    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:
        {
            /* need to do network interrogation, doesnot allow when SIM invalid */
            if (is_sim_verified() == KAL_FALSE)
            {
                rmmi_result_code_fmttr(RMMI_RCODE_ERROR, rmmi_ptr->cmee_err);
                return;
            }

            ret_val = l4c_ss_exe_interrogate_req(source_string_ptr->src_id, L4_CLIR);
            if (ret_val == KAL_FALSE)
            {
                rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNKNOWN);
            }
            return;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;
            kal_uint8 clir_flag;

            rep = (kal_uint8) rmmi_int_validator_ext(
                                (kal_uint8*) & error_cause,
                                source_string_ptr,
                                rmmi_ptr->s_reg.s3 /* separator */ );

            if (rep <= 2)       // ((rep >= 0)&&(rep <= 2))
            {
                rmmi_ptr->report_mode.clir = rep;
                if (rep == 0)
                {
                    clir_flag = CLIR_AUTO;
                }
                else if (rep == 1)
                {
                    clir_flag = CLIR_INVOKE;
                }
                else
                {
                    clir_flag = CLIR_SUPPRESS;
                }

                l4c_ss_set_clir_flag_req(source_string_ptr->src_id, clir_flag);
                rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
            }
            else if ((rep == RMMI_VALIDATOR_ERROR) && (error_cause == RMMI_PARSE_NOT_FOUND))
            {
                rmmi_ptr->report_mode.clir = 0; //set to default value
                rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
            }
            else
            {
                rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_SYNTEX_ERROR);
            }
            return;
        }

        default:
        {
            /* unrecognized format of AT command line */
            rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNSPECIFIED);
            return;
        }
    }   /* end of the switch */
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_colp_hdlr
 * DESCRIPTION
 *  READ cmd need to be blocked when SIM PIN is not verified
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_colp_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 rep;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_COLP_HDLR_ENTRY);
    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:
        {
            /* need to do network interrogation, doesnot allow when SIM invalid */
            if (is_sim_verified() == KAL_FALSE)
            {
                rmmi_result_code_fmttr(RMMI_RCODE_ERROR, rmmi_ptr->cmee_err);
                return;
            }

            ret_val = l4c_ss_exe_interrogate_req(source_string_ptr->src_id, L4_COLP);
            if (ret_val == KAL_FALSE)
            {
                rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNKNOWN);
            }
            return;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;

            rep = (kal_uint8) rmmi_int_validator_ext(
                                (kal_uint8*) & error_cause,
                                source_string_ptr,
                                rmmi_ptr->s_reg.s3 /* separator */ );

            if ((rep == 0) || (rep == 1))
            {
                rmmi_ptr->report_mode.colp = rep;
                rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
            }
            else if ((rep == RMMI_VALIDATOR_ERROR) && (error_cause == RMMI_PARSE_NOT_FOUND))
            {
                rmmi_ptr->report_mode.colp = 0; //set to default value
                rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
            }
            else
            {
                rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_SYNTEX_ERROR);
            }
            return;
        }

        default:
        {
            /* unrecognized format of AT command line */
            rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNSPECIFIED);
            return;
        }
    }   /* end of the switch */
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_cnap_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cnap_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 rep;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_CNAP_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:
        {
            ret_val = l4c_ss_exe_interrogate_req(source_string_ptr->src_id, L4_CNAP);
            if (ret_val == KAL_FALSE)
            {
                rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_RETURN_ERROR);
            }

            return;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            rep = (kal_uint8) rmmi_int_validator(
                                source_string_ptr,
                                rmmi_ptr->s_reg.s3 /* separator */ );
            if (rep != RMMI_VALIDATOR_ERROR)
            {
                rmmi_ptr->report_mode.cnap = rep;
            }
            rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);

            return;
        }

        default:
        {
            /* unrecognized format of AT command line */
            rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNSPECIFIED);
            return;
        }
    }   /* end of the switch */
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_cpwd_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cpwd_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 result;
    kal_uint8 type;
    kal_uint8 fac[3];
    kal_uint8 old_pw[SML_MAX_SUPPORT_KEY_LEN+1];
    kal_uint8 new_pw[SML_MAX_SUPPORT_KEY_LEN+1];
    kal_uint8 const *rsp_str = NULL;
    kal_uint16 string_length = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_CPWD_HDLR_ENTRY);
    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            //ret_val = l4ccsm_ss_test_cpwd_mode (&rsp_str);
            rsp_str =
                (kal_uint8 const*)
                "+CPWD: (\"SC\",8),(\"P2\",8),(\"AO\",4),(\"OI\",4),(\"OX\",4),(\"AI\",4),(\"IR\",4),(\"AB\",4),(\"AG\",4),(\"AC\",4)";
            string_length = strlen((char*)rsp_str);
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            rmmi_ptr->last_executed_P2_fail = RMMI_NO_ERR; // mtk02480 27.007
            
            result = rmmi_string_validator(
                        source_string_ptr,
                        (kal_uint8) RMMI_COMMA, /* separator */
                        3,
                        (kal_uint8*) fac);
            if (result == RMMI_VALIDATOR_ERROR)
            {
                break;
            }

            result = rmmi_string_validator(
                        source_string_ptr,
                        (kal_uint8) RMMI_COMMA, /* separator */
                        SML_MAX_SUPPORT_KEY_LEN+1,
                        (kal_uint8*) old_pw);
            if (result == RMMI_VALIDATOR_ERROR)
            {
                break;
            }

            result = rmmi_string_validator(
                        source_string_ptr,
                        rmmi_ptr->s_reg.s3, /* separator */
                        SML_MAX_SUPPORT_KEY_LEN+1,
                        (kal_uint8*) new_pw);
            if (strlen((char*)new_pw) < 4)     //mtk00924_060215:then passwd at least has to have 4 digits, just like lmmi and reference phone 
            {
                break;
            }
            if (result == RMMI_VALIDATOR_ERROR)
            {
                break;
            }

            type = check_facility_type((kal_uint8*) fac);
            if (type == FAC_NOT_SUPPORTED)
            {
                break;
            }	   
			
            if ((type >= SS_FAC_BEGIN) && (type <= SS_FAC_END))
            {
                if (is_sim_verified()==KAL_FALSE)  // mtk02480, not allow due to didn't attach normal service
                {
                    break;
                }
            
                ret_val = l4c_ss_exe_change_password_req(
                            source_string_ptr->src_id,
                            type,
                            (kal_uint8*) old_pw,
                            (kal_uint8*) new_pw,
                            (kal_uint8*) new_pw);
                if (ret_val == KAL_TRUE)
                {
                    return;
                }
            }
            else if ((type >= SIM_FAC_BEGIN) && (type <= SIM_FAC_END))
            {
                switch(type)
                {
                    case TYPE_NP:
                    case TYPE_NSP:				
                    case TYPE_SP:
                    case TYPE_CP:	
                    case TYPE_IMSI_LOCK:
                    {
                    #ifndef __CHANGE_SML_KEY__					
                        rmmi_result_code_fmttr(RMMI_RCODE_ERROR, OPERATION_NOT_ALLOWED_ERR); 
                        return;
                    #else
                        break;
                    #endif
                    }
                    case TYPE_CHV1:
                    {
                        sim_chv_info_struct chv_info;
                        sim_chv_status_struct chv_status;

                        /* mtk02480, allow change PIN1 when PIN enable and PIN has been verified  */

                        if (is_sim_verified()==KAL_FALSE)
                        {
                            rmmi_result_code_fmttr(RMMI_RCODE_ERROR, OPERATION_NOT_ALLOWED_ERR);
                            return;
                        }

                        l4c_sim_check_pin_status_req(&chv_info, &chv_status);
                        if (chv_info.is_chv1_enabled == 0)
                        { 	//SIM lock should be enabled first
                            rmmi_result_code_fmttr(RMMI_RCODE_ERROR, OPERATION_NOT_ALLOWED_ERR);
                            return;
                        }
                        break;
                    }
                    case TYPE_CHV2:
                        break;
                    default:
                        break;
                }
				
                ret_val = l4c_smu_exe_change_password_req(
                            source_string_ptr->src_id,
                            type,
                            (kal_uint8*) old_pw,
                            (kal_uint8*) new_pw,
                            (kal_uint8*) new_pw);
                if (ret_val == KAL_TRUE)
                {
                    return;
                }
            }
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_cssn_hdlr
 * DESCRIPTION
 *  This function do not need to be blocked when SIM PIN is not verified
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cssn_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 cssi, cssu;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_CSSN_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            ret_val = l4ccsm_ss_test_cssn_mode(&rsp_str);
            string_length = strlen((char*)rsp_str);
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_READ_MODE:
        {
            ret_val = KAL_TRUE;
            rmmi_ptr->arg_list[0] = (void*)&rmmi_ptr->report_mode.ss_mo;
            rmmi_ptr->arg_list[1] = (void*)&rmmi_ptr->report_mode.ss_mt;
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CSSN: %d, %d", rmmi_ptr->arg_list, 2);
            rsp_str = &buffer[0];
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;

            /* get <n> */
            cssi = (kal_uint8) rmmi_int_validator_ext(
                                (kal_uint8*) & error_cause,
                                source_string_ptr,
                                (kal_uint8) RMMI_COMMA);
            if (cssi != RMMI_VALIDATOR_ERROR)
            {
                if (cssi > 1)
                {
                    break;
                }
            }
            else        //cssi == RMMI_VALIDATOR_ERROR
            {
                if (error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    cssi = 0;
                }
                else    //parse Error
                {
                    break;
                }
            }

            /* get <m> */
            cssu = (kal_uint8) rmmi_int_validator_ext(
                                (kal_uint8*) & error_cause,
                                source_string_ptr,
                                rmmi_ptr->s_reg.s3 /* separator */ );
            if (cssu != RMMI_VALIDATOR_ERROR)
            {
                if (cssu > 1)
                {
                    break;
                }
            }
            else        //cssu == RMMI_VALIDATOR_ERROR
            {
                if (error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    cssu = 0;
                }
                else    //parse Error
                {
                    break;
                }
            }

            rmmi_ptr->report_mode.ss_mo = cssi;
            rmmi_ptr->report_mode.ss_mt = cssu;
            rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
            return;

        }

        default:
        {
            /* unrecognized format of AT command line */
            rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNSPECIFIED);
            return;
        }
    }   /* end of the switch */

    if (ret_val == KAL_TRUE)
    {
        rmmi_write_to_uart((kal_uint8*) rsp_str, string_length, KAL_TRUE);
        rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
    }
    else
    {
        rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_SYNTEX_ERROR);
    }

    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_ccbs_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for CCBC interogate and erase.
 *  mtk00468 add on 04/01
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_ccbs_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 ccbs_id;                  /* entry index */
    kal_uint8 const *rsp_str = NULL;    /* response string and initialization */
    kal_uint16 string_length = 0;       /* string length variable */

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_CCBS_HDLR_ENTRY);

    /* checking the command mode */
    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:    /* at+ccbs=? */
        {
            rsp_str = (kal_uint8 const*)"+CCBS: <ccbs_id>"; /* prepare the response string */
            string_length = strlen((char*)rsp_str);         /* type casting */
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_READ_MODE:    /* at+ccbs? it will using CCBS interrogate opcode l4c function */
        {

            ret_val = l4c_ss_exe_ccbs_req(source_string_ptr->src_id, CCBS_Interrotage, 0);      /* get the curret information form UEM releated to the record list */
            if (ret_val == KAL_FALSE)
            {
                rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_COMMAND_CONFLICT);
                return;
            }
            return;
        }
        case RMMI_SET_OR_EXECUTE_MODE:  /* at+ccbs = 1 ccbs erase CC_entry_index 1 */
        {
            ccbs_id = (kal_uint8) rmmi_int_validator(
                                    source_string_ptr,
                                    RMMI_PTR->s_reg.s3 /* separator */ );
            if (ccbs_id == RMMI_VALIDATOR_ERROR)
            {
                break;
            }

            ret_val = l4c_ss_exe_ccbs_req(source_string_ptr->src_id, CCBS_EarseCCEntry, ccbs_id);
            if (ret_val == KAL_FALSE)
            {
                rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_COMMAND_CONFLICT);
            }
            return;
        }
        default:
        {
            /* unrecognized format of AT command line */
            rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNSPECIFIED);
            return;
        }
    }   /* end of the switch */

    if (ret_val == KAL_TRUE)
    {
        rmmi_write_to_uart((kal_uint8*) rsp_str, string_length, KAL_TRUE);
        rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
    }
    else
    {
        rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNSPECIFIED);
    }

    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_cusd_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cusd_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 result;
    kal_uint8 rep;
    kal_uint8 rep_present = KAL_FALSE;
    kal_uint8 dcs;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 ussd_str[MAX_DIGITS_USSD];
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim
    l4c_context_struct *l4c_ptr = L4C_PTR; //for slim
#ifndef __MMI_FMI__
    kal_bool need_approve = KAL_FALSE;
#endif /* __MMI_FMI__ */

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_CUSD_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            ret_val = l4ccsm_ss_test_ussd(&rsp_str);
            string_length = strlen((char*)rsp_str);

            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_READ_MODE:
        {
            rep = rmmi_ptr->report_mode.ussd;

            ret_val = KAL_TRUE;

            rmmi_ptr->arg_list[0] = (void*)&rep;
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CUSD: %d", rmmi_ptr->arg_list, 1);
            rsp_str = &buffer[0];
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;

            //mtk01616_070605   
            kal_uint8 ussd_len = 0;
            kal_uint8 src_id;

            kal_mem_set((kal_uint8*) ussd_str, 0, sizeof(ussd_str));   //set to zero

            //DUMA00209281
            if ((l4c_check_user_action(L4C_SS, L4C_SRC, USSR_FAC_IND) == KAL_TRUE)
        #ifdef __SAT__
        #if !defined(__MMI_FMI__) || defined(__RSAT__)
                || (l4c_check_user_action(L4C_SS, SAT_SRC, USSR_FAC_IND) == KAL_TRUE)
        #endif /* !defined(__MMI_FMI__) || defined(__RSAT__) */
        #endif /* __SAT__ */
                )
            {
               l4c_set_user_action(L4C_SS, source_string_ptr->src_id, USSR_FAC_IND); //we know the respond source now
            }

            rep = (kal_uint8) rmmi_int_validator_ext(
                                &error_cause,
                                source_string_ptr,
                                (kal_uint8) RMMI_COMMA /* separator */ );

            if (rep != RMMI_VALIDATOR_ERROR)
            {
                if (rep > 2)
                {
                    break;
                }
                else if (rep == 2)
                {
                    src_id = source_string_ptr->src_id;
                    l4c_ss_exe_abort_req(src_id);

                    /* mtk01616_071102:if +cusd=2 is in the end of multi cmd ,previous cmd might not finished yet
                       MAUI_02291503: Normally OK for +cusd=2 shall be responded immediately. But if this command
                       is the last in a multi-command, the previous command may not end. Below check prevents 
                       printing OK in this unexpected condition.
                    */
                    if ((l4c_ptr->cc_current_action[src_id] == L4C_NO_ACTION ||
                        l4c_ptr->cc_current_action[src_id] == POWERON_EXE ||
                        l4c_ptr->cc_current_action[src_id] == ATD_EXE ||
                        l4c_ptr->cc_current_action[src_id] == ATD_ECC
                        || l4c_ptr->cc_current_action[src_id] == ATD_ECC_CHANGE_RAT
                        ) && 
                    #ifdef __MOD_TCM__
                         l4c_ptr->tcm_user != src_id &&
                    #endif //mtk02285, 201003, 6251_ram
                        /* MAUI_02654565: SET_RAT_MODE_ATTACH is allowed to input command */
                        ((l4c_ptr->rac_user != src_id) || (l4c_ptr->rac_current_action == SET_RAT_MODE_ATTACH)
                                                       || (l4c_ptr->rac_current_action == RFON_ATTACH)
                                                       || (l4c_ptr->rac_current_action == PWRON_ATTACH)) && 
                        l4c_ptr->sms_current_action[src_id] == L4C_NO_ACTION && l4c_ptr->phb_user != src_id 
                    #if defined(__MMI_FMI__)                              
                        && l4c_ptr->route_thru_lmmi == KAL_FALSE
                    #endif                         
                        && rmmi_ptr->is_ucm_action == KAL_FALSE)
                    {
                        rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
                    }
                    return;
                }
                else    //rep==0 or rep==1
                {
                    rmmi_ptr->report_mode.ussd = rep;
                    rep_present = KAL_TRUE;
                }
            }
            else        //==RMMI_VALIDATOR_ERROR
            {
                if (error_cause != RMMI_PARSE_NOT_FOUND)
                {
                    break;
                }
            }

            result = rmmi_string_validator_ext(
                        &error_cause,
                        source_string_ptr,
                        (kal_uint8) RMMI_COMMA, /* separator */
                        MAX_DIGITS_USSD,
                        (kal_uint8*) ussd_str);

            if (result == RMMI_VALIDATOR_ERROR)
            {
                if ((error_cause == RMMI_PARSE_NOT_FOUND) && (rep_present == KAL_TRUE))
                {
                    //==RMMI_PARSE_NOT_FOUND: only set <rep> ,then return.
                    rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
                    return;
                }
                else
                {
                    break;
                }
            }

            dcs = rmmi_int_validator_u8_check(
                                &error_cause,
                                source_string_ptr,
                                rmmi_ptr->s_reg.s3 /* separator */ );

            if (error_cause != RMMI_PARSE_OK)
            {
                if (error_cause != RMMI_PARSE_NOT_FOUND)
                {
                    break;
                }
                else
                {
                    dcs = 0x0f; /* 0x0f = language unspecified */
                }
            }

        #ifndef __MMI_FMI__
            if (l4c_check_user_action(L4C_SS, L4C_NO_USER, L4C_NO_ACTION) == KAL_TRUE)
            {
                need_approve = KAL_TRUE; //need PHB approve
            }
        #endif /* __MMI_FMI__ */

            if (is_sim_verified() == KAL_FALSE) //PIN is not verified, disallow to connect
            {
                break;
            }

            ret_val = l4c_ss_exe_ussd_req(source_string_ptr->src_id, (kal_uint8*) ussd_str, dcs, ussd_len);

            //DUMA00209281 response OK after PHB_APPROVE_CNF in modem load, FP load will response after NW return
            if (ret_val == KAL_FALSE)
            {
                rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_RETURN_ERROR);
                return;
            }
        #ifndef __MMI_FMI__ //modem load
            if (need_approve == KAL_FALSE) //MAUI_02580295
            {
                break;
            }
            else
        #endif /* __MMI_FMI__ */
            {
                return;
            }
        }

        default:
        {
            /* unrecognized format of AT command line */
            rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_SYNTEX_ERROR);
            return;
        }
    }   /* end of the switch */

    if (ret_val == KAL_TRUE)
    {
        rmmi_write_to_uart((kal_uint8*) rsp_str, string_length, KAL_TRUE);
        rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
    }
    else
    {
        rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNSPECIFIED);
    }

    return;
}


#if !defined(__MMI_FMI__) || defined(__ECUSD_SUPPORT__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_ecusd_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_ecusd_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 result;
    kal_uint8 dcs = 0x0f;
    kal_uint8 ussd_str[MAX_DIGITS_USSD * 4]; //Android to support UCS2 HEX string input
    kal_uint8 error_cause;
    kal_uint8 length;
    kal_uint8 src_id;
    kal_uint8 count;
    kal_uint8 m, n;
    kal_uint8 sim_id;
    l4ccsm_ciss_ss_parse_req_struct *param_ptr;
    kal_uint8 cf_num_length;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim
    l4c_context_struct *l4c_ptr = L4C_PTR; //for slim
#if defined(__PHB_APPROVE_BY_MMI__)
    l4_addr_bcd_struct tel_number;
    kal_uint16 cause = CM_L4C_GEN_CAUSE;
#else
    l4cphb_approve_req_struct *param1_ptr;
#endif

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_CUSD_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            //not allow AT+ECUSD when other SIM is doing AT+ECUSD
            for (sim_id = 0; sim_id < L4_MAX_SIM_NUM; sim_id++)
            {
                if ((sim_id != (SIM1 + (kal_uint8)(l4c_current_mod_id-MOD_L4C)))
                    &&(L4C_PTR_X(ss_current_action, sim_id) != L4C_NO_ACTION))
                {
                    rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNKNOWN);
                    return;
                }
            }
            
            kal_mem_set((kal_uint8*) ussd_str, 0, sizeof(ussd_str));
            src_id = source_string_ptr->src_id;

            /* m=1 for SS, m=2 for USSD */
            m = (kal_uint8) rmmi_int_validator_ext(
                                &error_cause,
                                source_string_ptr,
                                (kal_uint8) RMMI_COMMA /* separator */ );

            if (m > 2)
            {
                break;
            }

            /* n=1 for excute SS/USSD, n=2 for cancel USSD session */
            n = (kal_uint8) rmmi_int_validator_ext(
                                &error_cause,
                                source_string_ptr,
                                (kal_uint8) RMMI_COMMA /* separator */ );

            if ((m == 1 && n != 1) || (m == 2 && n > 2))
            {
                break;
            }
            //DUMA00209281 remove compile option to let ecusd respond to USSR
            /*mtk02508_090220: respond to NW initiated USSR
              when receiving NW initiated USSR we set ss_user to L4C_SRC only in modem load
              If __FMI_MMI__ is defined we let LMMI to respond
            */
            if ((m == 2) && ((l4c_check_user_action(L4C_SS, L4C_SRC, USSR_FAC_IND) == KAL_TRUE)
        #ifdef __SAT__ //DUMA00209281
        #if !defined(__MMI_FMI__) || defined(__RSAT__)
                || (l4c_check_user_action(L4C_SS, SAT_SRC, USSR_FAC_IND) == KAL_TRUE)
        #endif /* !defined(__MMI_FMI__) || defined(__RSAT__) */
        #endif /* __SAT__ */
                ))
            {
               l4c_set_user_action(L4C_SS, src_id, USSR_FAC_IND); //we know the respond source now
            }

            if (m == 2 && n == 2)
            {
                l4c_ss_exe_abort_req(source_string_ptr->src_id);
                rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
                return;
            }

            result = rmmi_string_validator_ext(
                        &error_cause,
                        source_string_ptr,
                        (kal_uint8) RMMI_COMMA, /* separator */
                        sizeof(ussd_str),
                        (kal_uint8*) ussd_str);

            /* ALPS00224764: null USSD string is only allowed for replying USSR	*/
            if ((n == 1 && result == RMMI_VALIDATOR_ERROR) &&
                !(m == 2 && error_cause == RMMI_PARSE_OK && 
                (l4c_check_user_action(L4C_SS, src_id, USSR_FAC_IND) == KAL_TRUE)))
            {
                break;
            }

            //ALPS00000553: Android will send USSD via UTF8 format and the RIL driver will convert UTF8 to UCS2
            dcs = rmmi_int_validator_u8_check(
                                &error_cause,
                                source_string_ptr,
                                (kal_uint8) RMMI_COMMA /* separator */ );

            if (error_cause != RMMI_PARSE_OK)
            {
                if (error_cause != RMMI_PARSE_NOT_FOUND)
                {
                    break;
                }
                else
                {
                    dcs = 0x0f; /* 0x0f = language unspecified */
                }
            }

            //MAUI_02547720: MD needs cf_num_length to parse forwarding number with *
            cf_num_length = rmmi_int_validator_u8_check(
                                &error_cause,
                                source_string_ptr,
                                rmmi_ptr->s_reg.s3 /* separator */ );

            if (error_cause != RMMI_PARSE_OK)
            {
                if (error_cause != RMMI_PARSE_NOT_FOUND)
                {
                    break;
                }
                else
                {
                    cf_num_length = 0; //no input
                }
            }

        #ifdef __SP_RIL_SUPPORT__ //DUMA00158731
            /* only need to convert the first shot to IRA for PHB approve and CSM parsing
               Coding for USSD reply is processed in l4c_ss_exe_ussd_req()
            */
            if ((m == 2) && (n == 1) && (rmmi_ptr->char_set == RMMI_CHSET_UCS2) && 
                (l4c_check_user_action(L4C_SS, L4C_NO_USER, L4C_NO_ACTION) == KAL_TRUE))
            {
                kal_uint8 hex_value[MAX_DIGITS_USSD*2];

                kal_mem_set(hex_value, 0, sizeof(hex_value));
                check_hex_value(ussd_str, hex_value);
                rmmi_byte_order_reverse(hex_value, MAX_DIGITS_USSD*2);
                ucs2_to_ascii((kal_wchar*) hex_value, ussd_str); //convert to IRA
                dcs = 0x0f; //change dcs to GSM7bit data coding
            }
        #endif
        
            length = strlen((char*)ussd_str);

            l4c_construct_phb_approve_str(ussd_str, length); //MAUI_02884093 fdn revise

            if (is_ss_cmd_conflict(src_id, PARSE_SS_EXE) == KAL_TRUE)
            {
                break;
            }

            if (l4c_check_user_action(L4C_SS, src_id, USSR_FAC_IND) == KAL_TRUE)
            {
                if (m == 2)
                {
                    ret_val = l4c_ss_exe_ussd_req(src_id, ussd_str, dcs, length);
                #ifndef __MMI_FMI__ //DUMA00209281
                    if (ret_val == KAL_TRUE)    /* USSD will return OK immediately, SS will not */
                    {
                        rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
                    }
                #endif /* __MMI_FMI__ */
                }
                break;
            }

            if (l4crac_get_mobile_class() == 2) //class CG
            {
                break;
            }

        #if defined(__PHB_APPROVE_BY_MMI__)
            /* PHB approve by MMI via function call */
            tel_number.addr_bcd[0] = l4c_ptr->l4cphb_approve_req_string.type;
            tel_number.addr_length = 1 + convert_to_bcd(
                                    (kal_uint8*) l4c_ptr->l4cphb_approve_req_string.number,
                                    (kal_uint8*) & (tel_number.addr_bcd[1]),
                                    40);

            if ((KAL_FALSE == custom_phb_xmgnt_approve_fdn((tel_number.addr_bcd), 
                                                            tel_number.addr_length,
                                                            (kal_uint8)(l4c_current_mod_id - MOD_L4C),
                                                            L4C_SS_OPERATION,
                                                            &cause))
               || (l4c_ptr->mmrr_ready_flag == KAL_FALSE))
            {
                break;
            }
            else
            {
                rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
            }
        #else /* !defined(__PHB_APPROVE_BY_MMI__ */
            /* mtk02508_090304 set phb_approve_ussd flag
               Upon receiving L4CPHB_APPROVE_CNF message we can determine whether to 
               respond RMMI_RCODE_OK or RMMI_ERR_UNSPECIFIED to RIL */
            if (m == 2) //ussd
            {
                l4c_ptr->phb_approve_ussd = KAL_TRUE;
            }
            else
            {
                l4c_ptr->phb_approve_ussd = KAL_FALSE;
            }

            param1_ptr = (l4cphb_approve_req_struct*) construct_local_para(
                                                        (kal_uint16) sizeof(l4cphb_approve_req_struct),
                                                        TD_RESET);

            param1_ptr->src_id = src_id;
            param1_ptr->is_retrieve = KAL_FALSE;

            param1_ptr->tel_number.addr_bcd[0] = l4c_ptr->l4cphb_approve_req_string.type;

            count = convert_to_bcd(
                        (kal_uint8*) l4c_ptr->l4cphb_approve_req_string.number,
                        (kal_uint8*) & (param1_ptr->tel_number.addr_bcd[1]),
                        40);

            param1_ptr->tel_number.addr_length = count + 1;
            param1_ptr->approval_type = l4_custom_approval_type(L4C_SS_OPERATION,src_id);
        
            l4c_send_msg_to_phb(MSG_ID_L4CPHB_APPROVE_REQ, param1_ptr, NULL);
        #endif
        
            l4c_ptr->ss_parameter.length = sizeof(l4ccsm_ciss_ss_parse_req_struct); //MAUI_02354954
            l4c_ptr->ss_parameter.data = (l4ccsm_ciss_ss_parse_req_struct*) construct_local_para(
                                                                                    (kal_uint16) sizeof (l4ccsm_ciss_ss_parse_req_struct),
                                                                                    TD_RESET);

            param_ptr = (l4ccsm_ciss_ss_parse_req_struct*) l4c_ptr->ss_parameter.data;
            param_ptr->src_id = src_id;
            param_ptr->ton_npi = 0x81;
            param_ptr->length = length;
            param_ptr->change_phase_req = KAL_FALSE;
            param_ptr->ss_dcs = dcs;

            param_ptr->type_of_modification = SIMCALLCONTROL_NOMODIFY; 
            param_ptr->cf_number_length = cf_num_length; //MAUI_02547720
        #ifdef __CSMSS_EXPLICIT_SS_OPERATION__
            param_ptr->explicit_ss_op = (m == 1) ? CSMSS_EXPLICIT_SS_OP : CSMSS_EXPLICIT_USSD_OP; //MAUI_02553565
        #endif

            kal_mem_set(param_ptr->ss_string, 0, MAX_DIGITS_USSD);
            kal_mem_cpy(param_ptr->ss_string, ussd_str, length + 1);

            l4c_set_user_action(L4C_SS, src_id, PARSE_SS_EXE);

        #if defined(__PHB_APPROVE_BY_MMI__)
            l4c_send_msg_to_csm_ciss(MSG_ID_L4CCSM_CISS_SS_PARSE_REQ, param_ptr);
        #endif

            ret_val = KAL_TRUE;
            break;
        }
        default:
            break;
    }   /* end of the switch */

    //mtk02508_090304 only respond ERROR even for USSD
    if (ret_val != KAL_TRUE)
    {
        rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNKNOWN);
    }
    return;
}
#endif /* __MMI_FMI__ */ 


#if !defined(__MMI_FMI__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_colr_hdlr
 * DESCRIPTION
 *  only support READ and TEST command, READ command will query the network status
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_colr_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;

    switch (source_string_ptr->cmd_mode)
    {

        case RMMI_READ_MODE:
        {
            /* need to do network interrogation, doesnot allow when SIM invalid */
            if (is_sim_verified() == KAL_FALSE)
            {
                rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_PTR->cmee_err);
                return;
            }

            ret_val = l4c_ss_exe_interrogate_req(source_string_ptr->src_id, L4_COLR);

            if (ret_val == KAL_FALSE)
            {
                rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNKNOWN);
            }
            return;
        }

        default:
        {
            /* unrecognized format of AT command line */
            rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNSPECIFIED);
            return;
        }
    }   /* end of the switch */

}
#endif /* !defined(__MMI_FMI__) */ 

#endif  /* !defined(__SLIM_AT__) */

#endif /* __MOD_CSM__ */

