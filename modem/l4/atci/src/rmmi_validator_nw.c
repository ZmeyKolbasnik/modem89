/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 * RMMI_VALIDATOR_NW.C
 *
 * Project:
 * --------
 *   MAUI
 *
 * Description:
 * ------------
 *   This file is intends for ...
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
#include <stdio.h>
#include <string.h>
//#include "kal_release.h"
//#include "stack_common.h"
#include "kal_public_defs.h" //MSBB change #include "stack_msgs.h"
//#include "stack_ltlcom.h" /* Task message communiction */
//#include "stacklib.h"   /* Basic type for dll, evshed, stacktimer */
//#include "app_buff_alloc.h"
//#include "stack_timer.h"
//#include "event_shed.h"
//#include "nvram_editor_data_item.h"
//#include "custom_nvram_editor_data_item.h"
//#ifdef __MOD_SMU__
//#include "ps2sim_struct.h"
//#include "sim_common_enums.h"
//#include "smu_common_enums.h"
//#endif /* __MOD_SMU__ */ 
//#include "device.h"
//#include "csmss_common_enums.h"
#include "mcd_l3_inc_struct.h"
//#include "mcd_l3_inc_gprs_struct.h"
#include "l3_inc_enums.h"
//#include "mcd_l4_common.h" 
//#include "l4c_common_enum.h"
#include "rmmi_common_enum.h"
#include "rmmi_context.h"
#include "l4c_context.h"
#include "layer4_context.h"
//#include "l4c_rspfmttr.h"
//#include "l4c_msghdlr.h"
#include "l4_trc.h"
#include "atci_trc.h"
//#include "uart_sw.h"
//#include "l4_defs.h"
//#include "csmcc_atfunc.h"
//#include "csmss_atfunc.h"
//#include "l4c_aux_struct.h"
//#include "l4c_ss_parse.h"
//#ifdef __MOD_CSM__
//#include "mcd_ss_parameters.h"
//#include "mcd_ss_tcapmessages.h"
//#include "l4c_common_enum.h"
//#include "csmcc_enums.h"
//#include "csmcc_common_enums.h"
//#include "ps2sat_struct.h"
//#include "l4c2csm_cc_struct.h"
//#include "l4c_ciss_cmd.h"
//#include "l4c2csm_ss_struct.h"
//#include "l4c_cc_cmd.h"
//#endif /* __MOD_CSM__ */ 
//#if defined (VM_SUPPORT)
//#include "med_struct.h"
//#endif 
//#ifdef __MOD_UEM__
//#include "device.h"
//#include "l4c2uem_struct.h"
//#include "uem_at_cmd.h"
//#include "custom_em.h"
#include "l4c_eq_cmd.h"
//#endif /* __MOD_UEM__ */ 
#ifdef __MOD_RAC__
#include "l4crac_func.h"
#include "l4c_nw_cmd.h"
#include "l4crac_enums.h"
#endif /* __MOD_RAC__ */ 
//#ifdef __MOD_PHB__
//#include "sim_common_enums.h"
//#include "l4c2phb_enums.h"
//#include "l4c2phb_struct.h"
//#include "phb_sap.h"
//#include "l4c_phb_cmd.h"
//#include "phb_defs.h"
//#include "phb_config.h"
//#endif /* __MOD_PHB__ */ 
//#ifdef __MOD_SMSAL__
//#include "l4c2smsal_struct.h"
//#include "smsal_l4c_defs.h"
//#include "smsal_l4c_funcs.h"
//#include "smsal_l4c_enum.h"
//#include "smsal_defs.h"
//#include "l4c_sms_cmd.h"
//#endif /* __MOD_SMSAL__ */ 
#ifdef __MOD_SMU__
//#include "ps2sat_struct.h"
//#include "mcd_ps2sat_peer.h"
#include "l4c_sim_cmd.h"
#endif /* __MOD_SMU__ */ 
//#ifdef __MOD_TCM__
//#include "mmi_l3_enums.h"
//#include "mmi_sm_enums.h"
//#include "ppp_l4_enums.h"
//#include "tcm_common_enums.h"
//#include "tcm_common.h"
//#include "custom_nvram_editor_data_item.h"
//#include "l4c2abm_struct.h"
//#include "abm2l4c_struct.h"
//#include "l4c2tcm_struct.h"
//#include "l4c2tcm_func.h"
//#include "l4c2abm_struct.h"
//#include "l4c_gprs_cmd.h"
//#endif /* __MOD_TCM__ */ 
#ifdef __MODEM_EM_MODE__
//#include "em_struct.h"
#include "l4c_em.h"
//#include "lmmi_rsp.h"
#endif /* __MODEM_EM_MODE__ */ 
#include "l4c_utility.h"
#include "rmmi_rspfmttr.h"
#include "rmmi_utility.h"
#include "rmmi_rsp.h"
//#include "rmmi_validator.h"
#include "nvram_data_items.h"
//#include "l4c_table.h"
#include "rmmi_parser.h"
//#include "resource_verno.h"     // for +EGMR read MMI resource version
//#ifdef __CSD_FAX__
//#include "csm_data_enums.h"
//#include "l4c2t30_struct.h"
//#include "l4c_t30_cmd.h"
//#include "l4c2t30_enums.h"
//#endif /* __CSD_FAX__ */ 
#include "rmmi_parser.h"
#ifndef MED_NOT_PRESENT
//#include "med_global.h"
//#include "med_main.h"
#endif /* MED_NOT_PRESENT */ 
//#ifdef __CTM_SUPPORT__
//#include "med_struct.h"
//#endif 
#include "l4c_sendmsg.h"
//#ifdef __CUST_NEW__
//#include "gpio_sw.h"
//#endif 
/* for data item NVRAM_EF_IMEI_IMEISV_LID move */
//#include "nvram_user_defs.h"
//#include "csmcc_defs.h"
//#include "keypad_sw.h"
//#include "l4c2smu_struct.h"
#include "lmmi_ind.h"
//#include "csmcc_common_enums.h"
//#include "mncc_struct.h"
//#include "csmcc_bc_types.h"
//#include "csmcc_types.h"
//#include "custom_em.h"
//#include "L4c_ctm_cmd.h"
//#include "csmcc_utility.h"
//#include "sat_def.h"
//#include "uem_proc_cmd.h"
#include "rmmi_msghdlr.h"
#include "nvram_struct.h"

#include "as2l4c_struct.h"

#include "l4c_root.h"

//#include "kal_non_specific_general_types.h"
//#include "ps_trace.h"
#include "kal_trace.h"

#include "kal_general_types.h"    
#include "kal_public_api.h"
#include "ps_public_enum.h"

#if defined(__NO_PSDATA_SEND_SCRI__) || defined(__FAST_DORMANCY__)
#include "custom_l4_utility.h"
#endif

extern kal_bool rmmi_translate_oper_name(
                    kal_uint8 format1,
                    kal_uint8 *oper_str1,
                    kal_uint8 format2,
                    kal_uint8 *oper_str2);
extern void rmmi_get_oper_name(kal_uint8 i, kal_uint8 *oper_numeric, kal_uint8 *oper_short, kal_uint8 *oper_long);
extern kal_uint16 rmmi_get_max_oper_count(void);

#ifdef __UE_EFOPLMN__
extern void l4crac_get_ue_oplmn_version(kal_uint8* verd1, kal_uint8* verd2);
#endif

#ifdef __MOD_RAC__

/*****************************************************************************
 * FUNCTION
 *  rmmi_cops_hdlr
 * DESCRIPTION
 *  when SIM PIN is not verified yet, manuel selection and deregistration should be blocked.
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cops_hdlr(rmmi_string_struct *source_string_ptr)
{
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 result;
    kal_uint8 mode;
    kal_uint8 format;
    kal_uint8 act = 0xFF; //hspa_mmi_h2    
    kal_uint8 oper[7];
    kal_uint8 oper_str[17];
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    kal_uint16 factory_mode_arfcn = 0xFFFF;

    kal_trace(TRACE_FUNC, FUNC_RMMI_COPS_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_TEST_MODE:
        {
            if (source_string_ptr->cmd_index == RMMI_CMD_ATCOPS)
            {
                // AT+COPS=?
                ret_val = l4c_nw_get_plmn_list_req(source_string_ptr->src_id);
                if (ret_val == KAL_TRUE)
                {
                    return;
                }
	         else
	         {
  	    	      rmmi_ptr->cmee_err = OPERATION_NOT_ALLOWED_ERR;   // MAUI_01730747 , mtk02480
	         }
            }
            else
            {
                //AT+EOPS=? 
                kal_sprintf((kal_char*) buffer, "+EOPS: (0,1)");
                string_length = strlen((char*)buffer);
                ret_val = KAL_TRUE;
            }
            break;
        }
        case RMMI_READ_MODE:
        {
            kal_uint8 status;
            kal_uint8 cmd_str[8];

	    #if defined(__GSM_RAT__) || defined(__UMTS_RAT__)
	    plmn_id_rat_struct plmn;
	    #endif

            l4c_nw_get_sel_mode_req(source_string_ptr->src_id, &mode);
            // l4c_nw_get_attach_status_req(source_string_ptr->src_id, RAC_CS, &status);
            status = (rmmi_reg_state_enum)(rmmi_ptr->cs_register_status.state);
#ifndef __DISABLE_PS_ONLY_OPERATOR_SUPPORT__            
            /* mtk03643: ALPS00286197 J-COM operator only support PS, RIL need to get correct PLMN id via COPS,
                        fake current status as REGISTERED when PS is ATTACHED
                    */
            if( rac_get_gprs_status() == GPRS_ATTACHED )
            {
                status = RMMI_REG_STATE_REGISTERED;
            }
#endif   

            if (source_string_ptr->cmd_index == RMMI_CMD_ATCOPS)
            {
                strcpy((char*)cmd_str, "+COPS");
            }
            else
            {
                strcpy((char*)cmd_str, "+EOPS");
            }

            if ((status != RMMI_REG_STATE_REGISTERED) && (status != RMMI_REG_STATE_ROAMING))
            {
                if (rmmi_ptr->cops_mode == 2)
                {
                    mode = 2;
                }
                if (source_string_ptr->cmd_index == RMMI_CMD_ATCOPS)
                {
                    kal_sprintf((kal_char*) buffer, "%s: %d", cmd_str, mode);      /* give space for WM */
                }
                else /* RMMI_CMD_ATEOPS */
                {
                    oper[0] = oper_str[0] = RMMI_END_OF_STRING_CHAR;
                    l4c_nw_get_current_oper_req(source_string_ptr->src_id, (kal_uint8*) oper); //get in NUMERIC format
                    rmmi_translate_oper_name(RMMI_PLMN_NUMERIC, oper, rmmi_ptr->plmn_format, oper_str); // format conv
       		    #if defined(__GSM_RAT__) || defined(__UMTS_RAT__)
        		    l4crac_get_current_plmn(&plmn);
                    act = rmmi_current_access_technology(plmn.rat, l4crac_get_cell_data_speed_support(), L4C_PTR->max_data_bearer_capa); //hspa_mmi_h2
       		    #else /* defined(__GSM_RAT__) || defined(__WCDMA_RAT__) */ 
        		    act = 0;
       		    #endif /* defined(__GSM_RAT__) || defined(__UMTS_RAT__) */ 				
        		    kal_sprintf((kal_char*)buffer, "%s: %d,%d,\"%s\", %d",  // vito : add a space
        				cmd_str, mode, rmmi_ptr->plmn_format, oper_str, act);
                }
                string_length = strlen((char*)buffer);
            }
            else
            {
                l4c_nw_get_current_oper_req(source_string_ptr->src_id, (kal_uint8*) oper);
                rmmi_translate_oper_name(RMMI_PLMN_NUMERIC, oper, rmmi_ptr->plmn_format, oper_str);
                kal_sprintf((kal_char*) buffer, "%s: %d,%d,\"%s\"",    // vito : add a space
                            cmd_str, mode, rmmi_ptr->plmn_format, oper_str);
                string_length = strlen((char*)buffer);
            }
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;

            /* get <mode > */
            mode = rmmi_int_validator_u8_check(
                                &error_cause,
                                source_string_ptr,
                                (kal_uint8) RMMI_COMMA /* separator */ );
            if (error_cause == RMMI_PARSE_NOT_FOUND)
            {
                mode = 0;
            }
            else if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }
        #ifndef __MMI_FMI__
            else if (mode > 4)
            {
                break;
            }
        #else
            else if (mode > 3)
            {
                break;
            }
        #ifndef __NW_DETACH_SUPPORT__
            else if (mode == 2)
            {
                break;
            }
        #endif	        
        #endif

            /* get <format > */
            format = rmmi_int_validator_u8_check(
                                    &error_cause,
                                    source_string_ptr,
                                    (kal_uint8) RMMI_COMMA /* separator */ );
            if (error_cause == RMMI_PARSE_NOT_FOUND)
            {
                format = RMMI_PLMN_NUMERIC;
            }
            else if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }
        #ifdef __PLMN_LIST_WITH_LAC__
            else if (format > 3)
        #else
            else if (format > 2)
        #endif
            {
                break;
            }
        
        #ifdef __PLMN_LIST_WITH_LAC__
            if (format == 3)
            {
                rmmi_ptr->list_plmn_with_lac = KAL_TRUE;
            }
            else
        #endif
            {
                rmmi_ptr->plmn_format = format;
            }

            /* get <oper > */
            result = rmmi_string_validator_ext(
                        &error_cause,
                        source_string_ptr,
                        (kal_uint8) RMMI_COMMA, /* separator */ 
                        17,
                        (kal_uint8*) oper_str);
            if ((error_cause != RMMI_PARSE_NOT_FOUND) && (error_cause != RMMI_PARSE_OK))
            {
                break;
            }

    	    /* get <act> */
	        act = rmmi_int_validator_u8_check(&error_cause,
	                        source_string_ptr, 
	                        (kal_uint8) RMMI_COMMA /* separator */);

    	    /* mtk02480, we only support <Act>=0 or 2  */
	        if (act == RMMI_VALIDATOR_ERROR)
	        {
	    	    if (error_cause == RMMI_PARSE_NOT_FOUND)
    	    	{
            		act = L4C_RAT_NONE;
	        	}
        		else
		        {
        			break;
		        }
       	    }
    	    else
    	    {
    	    	if (act == 0)
    	    	{
                    act = L4C_RAT_GSM;
    	    	}
            #if defined(__UMTS_RAT__)					
        		else if (act == 2)	
        		{
                    act = L4C_RAT_UMTS;
                }
            #endif	
    		    else
    		    {
                    break;
                }
    	    }
		
            /* get <arfcn >, only for +EOPS=1 */ 
            if ((source_string_ptr->cmd_index == RMMI_CMD_ATEOPS) &&
                (mode == 1))
            {
                factory_mode_arfcn = rmmi_int_validator_u16_check(
                                        &error_cause,
                                        source_string_ptr,
                                        rmmi_ptr->s_reg.s3 /* separator */ ); 
                if (error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    factory_mode_arfcn = 0xFFFF;
                }
                else if (error_cause != RMMI_PARSE_OK)
                {
                    break;
                }
            } 

            /* when SIM PIN is not verified yet, do not allowed manual selection and deregisteration */
        #ifndef __MMI_FMI__
            if ((mode == 0) || (mode == 1) || (mode == 2) || (mode == 4))
        #else
            if ((mode == 0) || (mode == 1) || (mode == 2))
        #endif
            {
                if (source_string_ptr->cmd_index == RMMI_CMD_ATCOPS)
                {
                    if (is_sim_verified() == KAL_FALSE)
                    {
                        rmmi_result_code_fmttr(RMMI_RCODE_ERROR, rmmi_ptr->cmee_err);
                        return;
                    }
                }
            }

            /* mtk00714: for preventing retry and re-register when making a MO call after deregistration */
	        if ((mode != 3)
            #if defined(__PERMANENT_AUTO_SEL_MODE__)
                && (mode != 1) //MD won't be MANUAL_SEL mode
            #endif
                )
            {
            	rmmi_ptr->cops_mode = mode;
            }

            switch (mode)
            {
                case 0:
                    if (source_string_ptr->cmd_index == RMMI_CMD_ATCOPS)
                    {
                        /* AT+COPS= 0 */
                    #ifdef __MANUAL_MODE_NW_SEL__
                        ret_val = l4c_nw_set_sel_mode_req(source_string_ptr->src_id, AUTOMATIC_MODE);
                        if (ret_val == KAL_FALSE)
                        {
                            break;
                        }
                        else
                        {
                            l4c_nw_sel_mode_lind(AUTOMATIC_MODE);
                        }
                    #endif /* __MANUAL_MODE_NW_SEL__ */ 

                    /* according to 23.122 sec 4.4.3.2 User reselection 
                       when user requests auto selection, ME shall trigger 
                       a PLMN reselection immediately
                    */                    
	                #if 0 //#ifndef __MMI_FMI__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
                    #endif /* Not __MMI_FMI__ */
					
                        ret_val = l4c_nw_exe_cops_req(source_string_ptr->src_id, AUTO_SELECT, NULL, act, 0xFFFF, 0); 
                        if (ret_val == KAL_TRUE)
                        {
                            return;
                        }
                    }
                    else
                    {
                        /* AT+EOPS=0 */
						// This is different from AT+COPS=0. It only changes selection mode to AUTOMATIC.
						// It does NOT trigger a new PLMN search. Therefore, we don't call l4c_nw_exe_cops_req() here.
                    #ifdef __MANUAL_MODE_NW_SEL__
                        ret_val = l4c_nw_set_sel_mode_req(source_string_ptr->src_id, AUTOMATIC_MODE);
                        if (ret_val == KAL_FALSE)
                        {
                            break;
                        }
                        else
                        {
                            l4c_nw_sel_mode_lind(AUTOMATIC_MODE);
							ret_val = KAL_TRUE;
							break;
                        }
                    #endif /* __MANUAL_MODE_NW_SEL__ */ 
                    }
                    break;
                case 1:
            	#ifndef __MMI_FMI__								
		        case 4:
		        #endif		  	
                    if (result != RMMI_VALIDATOR_ERROR) // <oper> must be present when manual selected
                    {
                          /* mtk02480, AT+COPS=1,2,"str" , str should be numeric string and less than 6 digits */
			            if (rmmi_ptr->plmn_format == RMMI_PLMN_NUMERIC)
			            {
			   	            if (rmmi_is_number_string(oper_str) == KAL_FALSE || strlen((char*)oper_str)>6)
			   	            {		      
	                    		break;		  
			   	            }			   
			            }

                        ret_val = rmmi_translate_oper_name(rmmi_ptr->plmn_format, oper_str, RMMI_PLMN_NUMERIC, oper);
                        if (ret_val == KAL_FALSE)   /* unknown plmn string */
                        {
                            break;
                        }
                        if (source_string_ptr->cmd_index == RMMI_CMD_ATCOPS)
                        {
				            kal_uint8 prefer;
				
                            /* AT+COPS=1, <format>, <oper>, <Act> */
                        #ifdef __MANUAL_MODE_NW_SEL__
                        
                        #if !defined(__PERMANENT_AUTO_SEL_MODE__)
                            ret_val = l4c_nw_set_sel_mode_req(source_string_ptr->src_id, MANUAL_MODE);
                        #else
                            /* only trigger manual reselection, but don't set mode */
                            ret_val = KAL_TRUE;
                        #endif /* __PERMANENT_AUTOMATIC_MODE__ */
                        
                            if (ret_val == KAL_FALSE)
                            {
                                break;
                            }
                            else
                            {
                                l4c_nw_sel_mode_lind(MANUAL_MODE);
                            }
                        #endif /* __MANUAL_MODE_NW_SEL__ */ 

				if (act == L4C_RAT_GSM)
				{
					prefer = 1;  // prefer GSM
				}
				else if (act == L4C_RAT_UMTS)
				{
					prefer = 2;  // prefer UNTS
				}
				else
				{
					prefer = 0;  // use default setting
				}

				/* if L4C_RAT_NONE, MOD_MM will refer to current RAT in MS */
                            ret_val = l4c_nw_exe_cops_req(source_string_ptr->src_id, MANUAL_SEL, (kal_uint8*) oper, L4C_RAT_NONE, 0xFFFF, prefer); 
                            if (ret_val == KAL_TRUE)
                            {
                                return;
                            }
                        }
                        else
                        {
                            /* AT+EOPS=1, <format>, <oper>, <arfcn> */ 
                        #ifdef __MANUAL_MODE_NW_SEL__
                            ret_val = l4c_nw_set_sel_mode_req(source_string_ptr->src_id, MANUAL_MODE);
                            if (ret_val == KAL_FALSE)
                            {
                                break;
                            }
                            else
                            {
                                l4c_nw_sel_mode_lind(MANUAL_MODE);
                            }
                        #endif /* __MANUAL_MODE_NW_SEL__ */ 
                            ret_val = l4c_nw_exe_cops_req(source_string_ptr->src_id, MANUAL_SEL, (kal_uint8*) oper, act, factory_mode_arfcn, 0);
                            //kal_prompt_trace(MOD_ATCI, "factory_mode_arfcn: %d", factory_mode_arfcn);
                            if (ret_val == KAL_TRUE)
                            {
                                return;
                            }                            
                        }
                    }
                    break;
                case 2:        //deregister from network                      
                    if (source_string_ptr->cmd_index == RMMI_CMD_ATCOPS)
                    {
                        /* AT+COPS=2 */
                        ret_val = l4c_nw_exe_cops_req(source_string_ptr->src_id, DEREG, NULL, act, 0xFFFF, 0); 
                        if (ret_val == KAL_TRUE)
                        {
                            return;
                        }
                    }
                    break;
                case 3:
                    ret_val = KAL_TRUE;
                    break;
                default:
                    break;
            }
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) buffer, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_erat_hdlr
 * DESCRIPTION
 *  used to get RAT GRRS/EDGE status
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_erat_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 rat = 0xFF, gprs_status;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    kal_uint8 error_cause, rat_mode = 0xFF;
    kal_uint8 mode = L4C_RAT_NONE;
    l4c_prefer_rat_enum prefer_rat = L4C_PREFER_RAT_NONE;

    /*************************************************************
    *+ERAT: <current RAT>, <GPRS status>,<rat_mode>,<prefer_rat>
    *<current RAT>: 0 for 2G, 1for 3G
    *<GPRS status>: 0 for GPRS, 1 for EDGE
    *<rat_mode>: 0 for GSM_ONLY, 1 for WCDMA_ONLY, 2 for AUTO
    *<prefer_rat>: 0 for NO_PREFER, 1 for PREFER_GSM, 2 for PREFER_UMTS
    *************************************************************/

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:
        {
            #ifdef __ORANGE_H_PLUS__
            rat = RMMI_PTR->register_act;
            #else
            rat = RMMI_PTR->cs_register_status.act;
            #endif

            gprs_status = l4crac_get_egprs_status();
            l4c_nw_get_rat_mode_ext_req(source_string_ptr->src_id, &rat_mode, (kal_uint8 *)&prefer_rat);

            if (rat_mode == L4C_RAT_GSM)
            {
                mode = 0;
            }
            else if (rat_mode == L4C_RAT_UMTS)
            {
                mode = 1;
            }
            else if (rat_mode == L4C_RAT_GSM_UMTS)
            {
                mode = 2;
            }

            kal_sprintf((char*)buffer, "+ERAT: %d,%d,%d,%d", rat, gprs_status, mode, prefer_rat);
            rsp_str = &buffer[0];
            string_length = strlen((char*)rsp_str);

            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            // Set the RAT of the phone
            mode = (kal_uint8)rmmi_int_validator_range_check(
                    &error_cause,
                    source_string_ptr,
                    (kal_uint8) RMMI_COMMA,  /* separator */
                    2);

            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }
            else
            {
                if (mode == 0)
                {
                    rat_mode = L4C_RAT_GSM;
                }
        #ifdef __UMTS_RAT__
                else if (mode == 1)
                {
                    rat_mode = L4C_RAT_UMTS;
                }
                else if (mode == 2)
                {
                    rat_mode = L4C_RAT_GSM_UMTS;
                }
        #endif
                else
                {
                    break;
                }
            }

            prefer_rat = (kal_uint8)rmmi_int_validator_range_check(
                    &error_cause,
                    source_string_ptr,
                    RMMI_PTR->s_reg.s3,  /* separator */
                    2);

            if (error_cause == RMMI_PARSE_NOT_FOUND)
            {
                //prefer_rat = L4C_PREFER_RAT_NONE;
                l4c_nw_get_rat_mode_ext_req(source_string_ptr->src_id, NULL, (kal_uint8 *)&prefer_rat);
            }
            else if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }

            ret_val = l4c_nw_set_rat_mode_ext_req(source_string_ptr->src_id, rat_mode, prefer_rat);
            if (ret_val == KAL_TRUE)
            {
                return;
            }

            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_cfun_hdlr
 * DESCRIPTION
 *  This is rmmi function to initiate Target to Reset.
 *  Syntex: AT+CFUN = 0
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cfun_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 fun, rst;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CFUN_HDLR_ENTRY);
    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_TEST_MODE:
        {        
            break;
        }
        case RMMI_READ_MODE:
        {
            kal_sprintf((kal_char*) buffer, "+CFUN: %u", L4C_PTR->cfun_state);
            string_length = strlen((char*)buffer);
            rsp_str = &buffer[0];
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;

            /* parse <fun> */
            fun = (kal_uint8)rmmi_int_validator_range_check(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA, 4);
            if (error_cause != RMMI_PARSE_OK)
            {
                break;	     
            }

            /* parse <rst> */
            rst = (kal_uint8)rmmi_int_validator_range_check(&error_cause, source_string_ptr, RMMI_PTR->s_reg.s3, 1);			
            if (error_cause != RMMI_PARSE_OK)
            {
                if (error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    rst = 0; // default value	  
                }
                else
                {
                	break;		  
                }
            }

            if (rst == 1)
            {
            #if !defined(NEPTUNE_MMI)
                if (fun == 1 || fun == 4)
                {
                    rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
                    kal_sleep_task(KAL_TICKS_100_MSEC * 2);
                    #ifdef __MMI_FMI__
                        l4c_eq_power_reset_lind(0, 1, 3);
                    #else
                        l4c_target_reset(3);
                    #endif
                    
                    return;
                }
            #endif
            }
            else if (rst == 0)
            {
                if (fun == L4C_PTR->cfun_state)
                {
                    ret_val = KAL_TRUE;
                    break;
                }
                else if (fun == 0)
                {
                    ret_val = l4c_nw_cfun_state_req(source_string_ptr->src_id, fun);
                    if (ret_val == KAL_TRUE)
                    {
                        return;
                    }
                }
                else if (fun == 1 || fun == 4)
                {
                #if defined(__GEMINI__)
                /* mtk80420: For TD project, CFUN will only activate one SIM Protocol stack.
                   Because CMCC test script will use AT+CFUN=0/1 to switch on/off MS. This is to avoid SIM2 affecting SIM1's testing enviornment. */
                        #if (defined(__UMTS_TDD128_MODE__)||defined(__TDD_MODEM__))
                            ret_val = l4c_nw_efun_state_req(source_string_ptr->src_id, (fun==1)?(1<<(rmmi_current_mod_id - MOD_ATCI)):SIM_RADIO_OFF);
                        #else
                            ret_val = l4c_nw_efun_state_req(source_string_ptr->src_id, (fun==1)?QUAD_SIM_CONFIG:SIM_RADIO_OFF);                
                        #endif               
                #else
                    ret_val = l4c_nw_cfun_state_req(source_string_ptr->src_id, fun);
                #endif
                    if (ret_val == KAL_TRUE)
                    {
                        return;
                    }
                }
            }

	     RMMI_PTR->cmee_err = OPERATION_NOT_ALLOWED_ERR;
	     break;
        }
        default:
        {
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_csq_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_csq_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 level, ber;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CSQ_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            ret_val = l4crac_test_signal_level(&rsp_str);
            string_length = strlen((char*)rsp_str);
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_ACTIVE_MODE:
        {
            ret_val = l4c_nw_get_signal_level_req(source_string_ptr->src_id, &level, &ber);
            if (ret_val == KAL_FALSE)
            {
                break;
            }

            RMMI_PTR->arg_list[0] = (void*)&level;
            RMMI_PTR->arg_list[1] = (void*)&ber;
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CSQ: %d, %d", RMMI_PTR->arg_list, 2);
            rsp_str = &buffer[0];
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


#if !defined(__ULC_AT__) 

/*****************************************************************************
 * FUNCTION
 *  rmmi_efun_hdlr
 * DESCRIPTION    
 *  Syntex: AT+EFUN = 0/1/2/3/4
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_efun_hdlr(rmmi_string_struct *source_string_ptr)
{
#if defined(__GEMINI__)
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:
        {
            kal_sprintf((kal_char*) buffer, "+EFUN: %u", L4C_ROOT_PTR->efun_state);
            string_length = strlen((char*)buffer);
            rsp_str = &buffer[0];
            
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;
            kal_uint8 fun;

            /* parse <fun> */
            fun = (kal_uint8)rmmi_int_validator_range_check(&error_cause, source_string_ptr, RMMI_PTR->s_reg.s3, 0xFF);
	     if (error_cause != RMMI_PARSE_OK)
	     {
                break;	     
	     }

	     ret_val = l4c_nw_efun_state_req(source_string_ptr->src_id, fun);
	     if (ret_val == KAL_TRUE)
	     {
                return;	     	     
	     }
	
	     RMMI_PTR->cmee_err = OPERATION_NOT_ALLOWED_ERR;
	     break;
        }
        default:
        {
            break;
        }
    }   
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
#else
    rmmi_cfun_hdlr(source_string_ptr);
#endif
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_eops_hdlr
 * DESCRIPTION
 *  this command is similar to +COPS,
 *  but OK is returned to TE immediately.
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_eops_hdlr(rmmi_string_struct *source_string_ptr)
{
    rmmi_cops_hdlr(source_string_ptr);
    return;
}

/*****************************************************************************
 * FUNCTION
 *  rmmi_creg_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_creg_hdlr(rmmi_string_struct *source_string_ptr)
{
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 mode;
    rmmi_reg_state_enum status;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CREG_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            rsp_str = (kal_uint8 const*)"+CREG: (0-2)";
            string_length = strlen((char*)rsp_str);
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_READ_MODE:
        {
            kal_uint16 rnc;
            
            mode = rmmi_ptr->report_mode.cs_reg;
            //l4c_nw_get_attach_status_req(source_string_ptr->src_id, RAC_CS, &status);
            status = (rmmi_reg_state_enum)(rmmi_ptr->cs_register_status.state);
            
            #ifdef __ORANGE_H_PLUS__
            if (rmmi_ptr->register_act != 0 
                && rmmi_ptr->register_act != 1
                && rmmi_ptr->register_act != 3)
            #else
            if (rmmi_ptr->cs_register_status.act != 0 
                && rmmi_ptr->cs_register_status.act != 1
                && rmmi_ptr->cs_register_status.act != 3)
            #endif
            {
                rnc = (kal_uint16)((rmmi_ptr->cs_register_status.cell_id)>>16); //l4crac_get_rnc_id();
            }
            else
            {
                rnc = 0x00;
            }

            if ((status == RMMI_REG_STATE_REGISTERED) || (status == RMMI_REG_STATE_ROAMING))
            {
                if ((rmmi_ptr->cs_register_status.lac_value != 0xffff) && (mode == 2)) //for module: Maui_sw 9943
                {
                    kal_sprintf(
                        (kal_char*) buffer,
                        "+CREG: %d,%d,\"%04X\",\"%04X%04X\",%d",
                        mode,
                        status,
                        rmmi_ptr->cs_register_status.lac_value,
                        rnc,
                        (kal_uint16)rmmi_ptr->cs_register_status.cell_id,
                        #ifdef __ORANGE_H_PLUS__
                        rmmi_ptr->register_act);
                        #else
                        rmmi_ptr->cs_register_status.act);	// [MAUI_01360129]
                        #endif
                        string_length = strlen((char*)buffer);
                }
                else
                {
                    kal_sprintf((kal_char*) buffer, "+CREG: %d,%d", mode, status);
                    string_length = strlen((char*)buffer);
                }
                rsp_str = &buffer[0];
            }
            else
            {
                rmmi_ptr->arg_list[0] = (void*)&mode;
                rmmi_ptr->arg_list[1] = (void*)&status;

                string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CREG: %d,%d", rmmi_ptr->arg_list, 2);
                rsp_str = &buffer[0];
            }
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;

            /* Get the speed from the command line and validate it */
            mode = rmmi_int_validator_u8_check(
                                &error_cause,
                                source_string_ptr,
                                rmmi_ptr->s_reg.s3 /* separator */ );

            if (mode == RMMI_VALIDATOR_ERROR)
            {
                if (error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    mode = 0;
                }
                else
                {
                    break;
                }
            }
            else
            {
                if (mode > 2)
                {
                    break;
                }
                else if (mode == 2)
                {
                    rmmi_reg_state_enum creg_state;
                    kal_uint16 rnc;
                    kal_uint32 cell_id;
                    kal_uint8 temp_src;

                    creg_state = rmmi_ptr->cs_register_status.state;
                    
                    if (rmmi_ptr->cs_register_status.lac_value != 0xffff)
                    {
                        cell_id = rmmi_ptr->cs_register_status.cell_id;
                        
                        #ifdef __ORANGE_H_PLUS__
                        if (rmmi_ptr->register_act != 0 
                            && rmmi_ptr->register_act != 1
                            && rmmi_ptr->register_act != 3)
                        #else
                        if (rmmi_ptr->cs_register_status.act != 0 
                            && rmmi_ptr->cs_register_status.act != 1
                            && rmmi_ptr->cs_register_status.act != 3)
                        #endif
                        {
                            rnc = (kal_uint16)(cell_id >> 16);
                        }
                        else
                        {
                            rnc = 0x00;
                        }
                    #if defined(__SP_RIL_SUPPORT__)
                        kal_sprintf((kal_char*)buffer, 
                                    "+CREG: %d, \"%04X\", \"%04X%04X\", %d, %d", 
                                    creg_state, 
                                    rmmi_ptr->cs_register_status.lac_value, 
                                    rnc, (kal_uint16)cell_id,
                                    #ifdef __ORANGE_H_PLUS__
                                    rmmi_ptr->register_act,
                                    #else
                                    rmmi_ptr->cs_register_status.act,
                                    #endif
                                    rmmi_ptr->cs_register_status.cause);
                    #else
                        kal_sprintf((kal_char*)buffer, 
                                    "+CREG: %d, \"%04X\", \"%04X%04X\", %d", 
                                    creg_state, 
                                    rmmi_ptr->cs_register_status.lac_value, 
                                    rnc, (kal_uint16)cell_id,
                                    #ifdef __ORANGE_H_PLUS__
                                    rmmi_ptr->register_act);
                                    #else
                                    rmmi_ptr->cs_register_status.act);
                                    #endif
                    #endif
                        string_length = strlen((char*)buffer);
                    }
                    else
                    {
                        /* only print if status changes */
                        if (creg_state != rmmi_ptr->cs_register_status.state)
                        {
                            kal_sprintf((kal_char*) buffer, "+CREG: %d", creg_state);
                            string_length = strlen((char*)buffer);
                        }
                    }

                    temp_src = rmmi_ptr->current_src;
                    rmmi_ptr->current_src = RMMI_UNSOLICITED;
                    rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
                    rmmi_ptr->current_src = temp_src;
                    string_length = 0;
                }
            }
            rmmi_ptr->report_mode.cs_reg = mode;
            ret_val = KAL_TRUE;
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_epof_hdlr
 * DESCRIPTION
 *  This is rmmi function to Power off
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_epof_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;

#ifdef __MMI_FMI__
    kal_uint8 timer;
#endif 
    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_ACTIVE_MODE:
        {
#if defined(__GEMINI__)
            l4c_root_power_off_req(source_string_ptr->src_id);
#else
        #if !defined(__MMI_FMI__)
            RMMI_PTR->poweroff_src_id = source_string_ptr->src_id;
        #else 
            rmmi_final_rsp_generator(source_string_ptr->src_id, KAL_TRUE, NULL, 0);
        #endif
            if (L4C_PTR->cfun_state == 1)
            {
                //l4c_nw_powroff_detach_req(source_string_ptr->src_id);
                l4c_nw_exe_rf_off_req(source_string_ptr->src_id, PWROFF_DETACH);
                L4C_PTR->cfun_state = 4;
            }
            else
            {
                l4c_eq_power_off_req(RMMI_SRC);
            }
#endif
            return;
        }
    #ifdef __MMI_FMI__
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            timer = (kal_uint8) rmmi_int_validator(source_string_ptr, (kal_uint8) RMMI_PTR->s_reg.s3);
            if ((timer == RMMI_VALIDATOR_ERROR) || (timer < 20))
            {
                RMMI_PTR->cmee_err = RMMI_ERR_SYNTEX_ERROR;
                break;
            }
            l4c_eq_power_reset_lind(1, 1, timer);
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __MMI_FMI__ */ 
        default:
        {
            /* unrecognized format of AT command line */
            RMMI_PTR->cmee_err = RMMI_ERR_UNSPECIFIED;
            break;
        }
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_eopn_hdlr
 * DESCRIPTION
 *  to get the operator name according to the operator number
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_eopn_hdlr(rmmi_string_struct *source_string_ptr)
{
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint8 string_length = 0;

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 oper_numeric[6];
            kal_uint8 oper_str[20];
            kal_uint8 format;
            kal_uint8 result;

            format = rmmi_int_validator(source_string_ptr, RMMI_COMMA);
            if (format > 1)
            {
                rmmi_ptr->cmee_err = RMMI_ERR_SYNTEX_ERROR;
                break;
            }
            result = rmmi_string_validator(source_string_ptr, rmmi_ptr->s_reg.s3, 6, oper_numeric);
            if (result == RMMI_VALIDATOR_ERROR)
            {
                rmmi_ptr->cmee_err = RMMI_ERR_SYNTEX_ERROR;
                break;
            }

            if (rmmi_translate_oper_name(RMMI_PLMN_NUMERIC, oper_numeric, format, oper_str) == KAL_FALSE)
            {
                rmmi_ptr->cmee_err = RMMI_ERR_NO_FOUND;
                break;
            }
            else
            {
                kal_sprintf((char*)buffer, "+EOPN: %d, \"%s\"", format, oper_str);
                string_length = strlen((char*)buffer);
                ret_val = KAL_TRUE;
                break;
            }
        }
        default:
        {
            /* unrecognized format of AT command line */
            rmmi_ptr->cmee_err = RMMI_ERR_UNSPECIFIED;
            break;
        }
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, buffer, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_epbse_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for setting MS preferred GSM and UMTS band.
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_epbse_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 cause = 0;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    kal_bool is_gsm_band_present = KAL_TRUE;
    kal_bool is_umts_band_present = KAL_TRUE;

    kal_uint32 rmmi_gsm_auto_band = 0, type_gsm = 0;                //mtk02514_EB
    kal_uint32 rmmi_umts_auto_band = 0, type_umts = 0;

    kal_trace(TRACE_FUNC, FUNC_RMMI_EPBSE_HDLR_ENTRY);

//    custom_get_supported_bands(&rmmi_gsm_auto_band, &rmmi_umts_auto_band);

    l4c_nw_get_band_req(
            source_string_ptr->src_id, 
            (kal_uint8*)&type_gsm, (kal_uint8*) &type_umts,
            (kal_uint8*)&rmmi_gsm_auto_band, (kal_uint8*) &rmmi_umts_auto_band);

    /* checking the command mode */
    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_TEST_MODE:    /* at+epbse=? */
        {
            sprintf((kal_char*)buffer, "+EPBSE: %u, %u", rmmi_gsm_auto_band, rmmi_umts_auto_band);
            string_length = strlen((kal_char*)buffer);
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_READ_MODE:    /* at+epbse? */
        {

            sprintf((kal_char*)buffer, "+EPBSE: %u, %u", type_gsm, type_umts);
            string_length = strlen((kal_char*)buffer);
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:  /* at+epbse = <gsm_band>, <umts_band>*/
        {
            type_gsm = (kal_uint8) rmmi_int_validator_u8_check(
                &cause, 
                source_string_ptr,
                RMMI_COMMA );            

            if ( cause == RMMI_PARSE_ERROR || type_gsm == 0)
            {
                break;
            }
            else if (cause == RMMI_PARSE_NOT_FOUND )
            {
                is_gsm_band_present = KAL_FALSE;
            }
            else if (type_gsm == 0xff )
            {
                type_gsm = rmmi_gsm_auto_band;
            }
            else
            {
                /* Check if the input GSM band is supported */
                if ( (type_gsm | rmmi_gsm_auto_band) != rmmi_gsm_auto_band )
                    break;
            }

            /*If we don't support 3G band, we just ignore the input*/            
            #ifdef __UMTS_RAT__
            type_umts = (kal_uint32) rmmi_int_validator_u32_check(
                &cause, 
                source_string_ptr,
                RMMI_PTR->s_reg.s3);            

            if ( cause == RMMI_PARSE_ERROR || type_umts == 0)
            {
                break;
            }
            else if (cause == RMMI_PARSE_NOT_FOUND )
            {
                is_umts_band_present = KAL_FALSE;
            }
            /*
            * We extend umts bands from 16 bits to 32 bits to support 32 bands
            * So here we still judge if the user input 0xffff to achieve backward compatible
            */
            else if ( (type_umts == 0xffff) || (type_umts == 0xffffffff) )
            {
                type_umts = rmmi_umts_auto_band;
            }
            else 
            {
                /* Check if the input UMTSband is supported */  //MAUI_01803763
                if ( (type_umts | rmmi_umts_auto_band) != rmmi_umts_auto_band )
                    break;
            }

            #else
            
            is_umts_band_present = KAL_FALSE;

            #endif

            if ( !(is_umts_band_present || is_gsm_band_present) )
                break;

            /*********************************************
            *Although we set umts_band_present as TRUE
            * no matter if the compile option __UMTS_RAT__ is on or not
            * the RAC will ignore it automatically
            ***********************************************/
            ret_val = l4c_nw_set_preferred_band_req(
                    source_string_ptr->src_id, 
                    is_gsm_band_present, type_gsm, 
                    is_umts_band_present, (kal_uint8*) &type_umts);   /* call l4c function to RAC */
            if (ret_val == KAL_TRUE)
            {
                return;
            }


            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val,  buffer, string_length);
    return;
}
#endif /* !defined(__ULC_AT__) */


#if !defined(__SLIM_AT__)

/*****************************************************************************
 * FUNCTION
 *  rmmi_copn_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_copn_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_ACTIVE_MODE:
        {
            kal_uint16 i;
            kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
            kal_uint8 oper_numeric[6];
            kal_uint8 oper_short_str[10];
            kal_uint8 oper_long_str[20];

            for (i = 0; i < rmmi_get_max_oper_count(); i++)
            {
                rmmi_get_oper_name((kal_uint8) i, oper_numeric, oper_short_str, oper_long_str);
                if (strlen((char*)oper_numeric) == 0)
                {
                    break;
                }
                kal_sprintf((char*)buffer, "+COPN: \"%s\", \"%s\"", oper_numeric, oper_long_str);
                rmmi_write_to_uart((kal_uint8*) buffer, (kal_uint16) strlen((char*)buffer), KAL_TRUE);
            }
            ret_val = KAL_TRUE;
            break;
        }
        default:
            break;      //ERROR
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_at_t_csq_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_at_t_csq_hdlr(rmmi_string_struct *source_string_ptr)
{
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 level, ber;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CSQ_HDLR_ENTRY);

#if defined(__OP01__) && defined(__UMTS_TDD128_MODE__) && defined(__MMI_FMI__) //MAUI_02973870, ALPS00056754, mtk02285 
    ret_val = KAL_FALSE; 
    //MAUI_02735814, mtk02285, do not support AT$CSQ on this kind of project
    //The correct solution shall be wrapping AT$CSQ code with OPXX option.   
#else
    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_TEST_MODE:
        {
	   #ifdef __UMTS_RAT__
	     string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "$CSQ: (0-31,99),(0-7,99),(0-24)", rmmi_ptr->arg_list, 0);	   
	   #else
	     string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "$CSQ: (0-31,99),(0-7,99)", rmmi_ptr->arg_list, 0);	   
	   #endif	   
            rsp_str = &buffer[0];	   
	     ret_val = KAL_TRUE;
            break;
        }
        case RMMI_ACTIVE_MODE:
        {
            ret_val = l4c_nw_get_signal_level_req(source_string_ptr->src_id, &level, &ber);
            if (ret_val == KAL_FALSE)
            {
                break;
            }

            rmmi_ptr->arg_list[0] = (void*)&level;
            rmmi_ptr->arg_list[1] = (void*)&ber;
			
	     /* AT&T, AT$CSQ */
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "$CSQ: %d, %d", rmmi_ptr->arg_list, 2);
            rsp_str = &buffer[0];
            break;
        }
    }   /* end of the switch */
#endif 	/* defined(__OP01__) && defined(__UMTS_TDD128_MODE__) && defined(__MMI_FMI__) */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}

/*****************************************************************************
 * FUNCTION
 *  rmmi_ecsq_hdlr
 * DESCRIPTION
 *  This is for DTE to enable +ECSQ unsolicited result code
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_ecsq_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint8 string_length = 0;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_TEST_MODE:
        {
            kal_sprintf((kal_char*) buffer, "+ECSQ: (0,1)");
            string_length = strlen((char*)buffer);
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_READ_MODE:
        {
            kal_sprintf((kal_char*) buffer, "+ECSQ: %u", RMMI_PTR->report_mode.ecsq);
            string_length = strlen((char*)buffer);
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_ACTIVE_MODE:
        {
            kal_uint8 rat = 0xFF;
            
            rat = (kal_uint8)l4crac_get_current_rat();
            if(rat == (kal_uint8)L4C_RAT_GSM)
            {
                string_length = kal_sprintf((kal_char*) buffer, "+ECSQ: %u, %u, %d", L4C_PTR->csq_level, L4C_PTR->ber, L4C_PTR->rssi_in_qdbm);
            }
            else if(rat == (kal_uint8)L4C_RAT_UMTS)
            {
                string_length = kal_sprintf((kal_char*) buffer, "+ECSQ: %u, %u, %d, %d, %d", L4C_PTR->csq_level, L4C_PTR->ber, L4C_PTR->rssi_in_qdbm, L4C_PTR->RSCP_in_qdbm, L4C_PTR->EcN0_in_qdbm);
            }
            
            ret_val = KAL_TRUE;
            break;
        }		
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 mode, error_cause;

            mode = (kal_uint8) rmmi_int_validator_ext(&error_cause, source_string_ptr, RMMI_PTR->s_reg.s3);
        #if !defined(__MMI_FMI__)
            if (mode <= 2)
        #else 
            if (mode <= 1)
        #endif 
            {
                RMMI_PTR->report_mode.ecsq = mode;
                ret_val = KAL_TRUE;
            }
            break;
        }
        default:
            break;
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, buffer, string_length);
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_ctzr_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_ctzr_hdlr(rmmi_string_struct *source_string_ptr)
{
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 mode;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CTZR_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            rsp_str = (kal_uint8 const*)"+CTZR: (0-1)";
            string_length = strlen((char*)rsp_str);
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_READ_MODE:
        {
            mode = rmmi_ptr->report_mode.timezone;

            rmmi_ptr->arg_list[0] = (void*)&mode;
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CTZR: %d", rmmi_ptr->arg_list, 1);
            rsp_str = &buffer[0];
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            /* Get the speed from the command line and validate it */
            mode = (kal_uint8) rmmi_int_validator(
                                source_string_ptr,
                                rmmi_ptr->s_reg.s3 /* separator */ );
            if (mode > 1)
            {
                break;
            }
            rmmi_ptr->report_mode.timezone = mode;
            ret_val = KAL_TRUE;
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_ws46_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for select wireless network.
 *  mtk00924 add on 060919
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_ws46_hdlr(rmmi_string_struct *source_string_ptr)
{
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    kal_uint8 n = 0;

    kal_trace(TRACE_FUNC, FUNC_RMMI_WS46_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:
        {
            rmmi_ptr->arg_list[0] = (void*)&rmmi_ptr->ws46;
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+WS46: %d", rmmi_ptr->arg_list, 1);
            rsp_str = &buffer[0];
            ret_val = KAL_TRUE;
            break;
        }

        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;

            /* get <celluar network> */
            n = rmmi_int_validator_u8_check(
                                &error_cause,
                                source_string_ptr,
                                rmmi_ptr->s_reg.s3 /* separator */ );

            /* 12 = GSM */
            /* 22 = WCDMA */
            /* 25 = GPRS and GSM */

            if (n == 25)    /* 25 = GPRS and GSM */
            {
                rmmi_ptr->ws46 = n;
                ret_val = KAL_TRUE;
            }

            break;
        }
        default:
            break;
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;

}


/*****************************************************************************
 * FUNCTION
 *  rmmi_capl_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for abort PLMN list.
 *  mtk00468 add on 04/01
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_capl_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CAPL_HDLR_ENTRY);
    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_ACTIVE_MODE:  /* at+capl active command mode without para. */
        {
            ret_val = l4c_nw_abort_plmn_list_req(source_string_ptr->src_id);
            break;
        }
        default:
            break;
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}


#if defined(__CSG_SUPPORT__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_ecsg_hdlr
 * DESCRIPTION
 *  used to get/set CGS list
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_ecsg_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    kal_uint8 error_cause; 
    kal_uint8 result;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE:
        {
             /*************************************************************
               * AT+ECSG=0[,<PLMN>,<act>] => CSG list for all PLMN or specific PLMN
               * AT+ECSG=1,<PLMN>,<csg_id>[,<act>] => manual CSG attach
               * AT+ECSG=2 => abort CSG list
               * AT+ECSG=3,<auto_csg_search_mode>
             **************************************************************/
            kal_uint8 mode;

            mode = (kal_uint8)rmmi_int_validator_range_check(
                                &error_cause,
                                source_string_ptr,
                                (kal_uint8) RMMI_COMMA,  /* separator */
                                3);

            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }

            if (mode == 0)
            {
                kal_uint8 oper_str[7];
                kal_uint8 *oper = NULL;
                kal_uint8 act = 0xFF, rat;

                /* get <plmn_id > */
                result = rmmi_string_validator_ext(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA, /* separator */7, (kal_uint8*) oper_str);

                if (error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    oper = NULL;
                }
                else if (error_cause != RMMI_PARSE_OK)
                {
                    break;
                }
                else
                {
                    if (rmmi_is_number_string(oper_str) == KAL_FALSE || strlen((char*)oper_str)>6)
                    {		      
                        break;
                    }

                    oper = oper_str;
                }

                /* get <act> */
    	        act = rmmi_int_validator_u8_check(&error_cause, source_string_ptr, RMMI_PTR->s_reg.s3);

                /* only support <Act>=0 or 2  */
                if (error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    rat = L4C_RAT_UMTS;
                }
                else if (error_cause != RMMI_PARSE_OK)
                {
                    break;
                }
                else
                {
                    if (act == 0)
                    {
                        rat = L4C_RAT_GSM;
                    }
                    else if (act == 2)
                    {
                        rat = L4C_RAT_UMTS;
                    }
                    else
                    {
                        break;
                    }
                }

                ret_val = l4c_nw_get_csg_list_req(source_string_ptr->src_id, oper, rat);

                if (ret_val == KAL_TRUE)
                {
                    return;
                }
                else
                {
                    RMMI_PTR->cmee_err = OPERATION_NOT_ALLOWED_ERR;
                }

            }
            else if (mode == 1)
            {
                kal_uint8 oper_str[7];
                kal_uint32 csg_id;
                kal_uint8 act = 0xFF, rat;

                /* get <plmn_id > */
                result = rmmi_string_validator_ext(
                            &error_cause,
                            source_string_ptr,
                            (kal_uint8) RMMI_COMMA, /* separator */ 
                            7,
                            (kal_uint8*) oper_str);
                
                if (error_cause != RMMI_PARSE_OK)
                {
                    break;
                }

                if (rmmi_is_number_string(oper_str) == KAL_FALSE || strlen((char*)oper_str)>6)
                {		      
                    break;
                }

                /* get <csg_id> */
    	        csg_id = rmmi_int_validator_u32_check(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);

                if (error_cause != RMMI_PARSE_OK)
                {
                    break;
                }                

                /* get <act> */
    	        act = rmmi_int_validator_u8_check(&error_cause, source_string_ptr, RMMI_PTR->s_reg.s3);

                /* only support <Act>=0 or 2  */
                if (error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    rat = L4C_RAT_UMTS;
                }
                else if (error_cause != RMMI_PARSE_OK)
                {
                    break;
                }
                else
                {
                    if (act == 0)
                    {
                        rat = L4C_RAT_GSM;
                    }
                    else if (act == 2)
                    {
                        rat = L4C_RAT_UMTS;
                    }
                    else
                    {
                        break;
                    }
                }

                ret_val = l4c_nw_csg_attach_req(source_string_ptr->src_id, oper_str, csg_id, rat);

                if (ret_val == KAL_TRUE)
                {
#ifndef __UE_SIMULATOR__ /* UESIM requires OK response to TTCN */
                    return;  
#endif 
                }
            }
            else if (mode == 2)
            {
                ret_val = l4c_nw_abort_csg_list_req(source_string_ptr->src_id);

                if (ret_val == KAL_TRUE)
                {
                    return;
                }
            }
            else if (mode == 3)
            {
                kal_uint8 auto_search_mode;

                /* get <act> */
                auto_search_mode = (kal_uint8)rmmi_int_validator_range_check(&error_cause, source_string_ptr, RMMI_PTR->s_reg.s3, 1);

                if (error_cause != RMMI_PARSE_OK)
                {
                    break;
                }                          

                ret_val = l4c_nw_set_csg_auto_search_req(source_string_ptr->src_id, (kal_bool)auto_search_mode);
            }            
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}
#endif

#if defined(__NO_PSDATA_SEND_SCRI__) || defined(__FAST_DORMANCY__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_escri_hdlr (Add by mtk01411)
 * DESCRIPTION
 *  This is an rmmi function handler for and description of AT+ESCRI: 
 *  (1) Without Fast Dormancy Feature: 
 *   1. 3G Gemini 2.0 is not ready
 *       Request the network to try to release RRC connection for two purposes
 *       <Reason#1>
 *       This command can be used to request NW to release RRC connection on SIM1,
 *       then plmn search procedure or MO/MT calls can be executed on SIM2 due to SIM1 is in IDLE mode
 *       <Reason#2>
 *       Power Saving
 *   2. 3G Gemini 2.0 is ready
 *       Problem in a. will not happen. Request the network to try to release RRC connection for one purpose => Power Saving
 *  (2) With Fast Dormancy is ready: (Fast Dormancy Feature is only available after 3G Gemini 2.0 is ready)
 *   1. Request the network to enter the Fast Dormancy mode (e.g., Let UE in CELL_PCH state instead of IDLE state) for power saving purpose   
 *  add for Gemini modem on 20101227
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_escri_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 error_cause; 

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_ACTIVE_MODE:
        {
            ret_val = l4c_nw_end_ps_data_session_req(source_string_ptr->src_id, KAL_TRUE);
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 force_send_SCRI;

            // <force_send_SCRI>
            //  1 : force RRCE send SCRI
            //  0 : RRCE send SCRI depend on NW support FD or not

            force_send_SCRI = (kal_uint8)rmmi_int_validator_range_check(
                                &error_cause,
                                source_string_ptr,
                                RMMI_PTR->s_reg.s3,  /* separator */
                                1);

            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }

            ret_val = l4c_nw_end_ps_data_session_req(source_string_ptr->src_id, force_send_SCRI);
            break;
        }
        default:
        {
            ret_val = KAL_FALSE;
            break;
        }
    }
    /* Return OK first, then use URC to notify later response from lower layer */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_efd_hdlr
 * DESCRIPTION
 *  This is an rmmi function handler for and description of AT+EFD: 
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_efd_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 error_cause; 
    kal_uint8 mode;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:
        {
            rmmi_header_rrsp("+EFD:");
            rmmi_tail_int_rrsp(l4c_nw_get_fd_mode_req(), RMMI_SPACE);
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            mode = (kal_uint8)rmmi_int_validator_range_check(
                                &error_cause,
                                source_string_ptr,
                                RMMI_COMMA,
                                3);

            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }

            switch (mode)
            {
                case 0: //disable FD
                case 1: //enable FD
                {
                    ret_val = l4c_nw_set_fd_mode_req(source_string_ptr->src_id, mode);
                    break;
                }
                case 2: //set FD timer
                {
                    kal_uint8 timer_id;
                    kal_uint16 timer_value;

                    timer_id = rmmi_int_validator_u8_check(&error_cause, source_string_ptr, RMMI_COMMA);
                    if (error_cause != RMMI_PARSE_OK)
                    {
                        break;
                    }
                    else
                    {
                        timer_value = rmmi_int_validator_u16_check(&error_cause, source_string_ptr, RMMI_PTR->s_reg.s3);
                        if (error_cause != RMMI_PARSE_OK)
                        {
                            break;
                        }
                        ret_val = custom_set_fd_timer(timer_id, timer_value);
                    }
                    break;
                }
                case 3: //AP screen status
                {
                    kal_uint8 screen_on;

                    screen_on = rmmi_int_validator_range_check(&error_cause, source_string_ptr, RMMI_PTR->s_reg.s3, 1);
                    if (error_cause != RMMI_PARSE_OK)
                    {
                        break;
                    }
                    ret_val = l4c_fd_set_screen_status(screen_on);
                    break;
                }
                default:
                    /* unexpected mode */
                    break;
            }
            break;
        }
        default:
        {
            break;
        }
    }

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}
#endif /* defined(__NO_PSDATA_SEND_SCRI__) || defined(__FAST_DORMANCY__) */


#ifdef __GEMINI_MONITOR_PAGE_DURING_TRANSFER__
/*****************************************************************************
 * FUNCTION
 *  rmmi_emppch_hdlr
 * DESCRIPTION    
 *  Syntex: AT+EMPPCH = <on_off>
 *  This command is used to turn on/off Monitor Peer PCH feature
 *  <on_off>=1 is to turn on; <on_off>=0 is to turn off
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_emppch_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 on_off;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    kal_uint8 const *rsp_str = NULL;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:
        {
            kal_sprintf((kal_char*) buffer, "+EMPPCH: %d", l4crac_get_peer_gprs_transfer_preference());
            string_length = strlen((char*)buffer);
            rsp_str = &buffer[0];

            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;

            /* parse <on_off> */
            on_off = (kal_uint8)rmmi_int_validator_range_check(&error_cause, 
                                                   source_string_ptr, 
                                                   RMMI_PTR->s_reg.s3, 
                                                   1);
            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }
            l4c_nw_set_monitor_peer_pch_req(on_off);
            ret_val = KAL_TRUE;
            break;
        }
        default:
        {
            break;
        }
    }   
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*)rsp_str, string_length);
    return;
}
#endif /* __GEMINI_MONITOR_PAGE_DURING_TRANSFER__ */



#if defined(__MODEM_EM_MODE__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_ecelck_hdlr
 * DESCRIPTION
 *  used to set/get cell lock
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_ecelck_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:
        {
            l4c_em_get_cell_lock_req(source_string_ptr->src_id);
            return;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;
            kal_uint8 band_indicator=0;
            kal_uint16 arfcn[MAX_NUM_CELL_LOCK_ARFCN];
            kal_uint32 mode;
            kal_uint32 counter = 0;
            kal_uint32 enabled_bitmap = 0;

            mode =  rmmi_int_validator_range_check(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA, 4);

            /* mode:
                    0  cancel cell lock
                    1  set cell lock
                    2  get extended cell lock
                    3  set extended cell lock
                    4  cancel extended cell lock
            */
            if (error_cause != RMMI_PARSE_OK)
            {
                ret_val = KAL_FALSE;
                break;
            }
            
            switch(mode)
            {
                case 0:
                case 4:
                {
                    ret_val = KAL_TRUE;
                    break;
                }
                case 1:
                {
                    enabled_bitmap = 0x01;
                    ret_val = KAL_TRUE;
                    break;
                }
                case 2:
                {
                    l4c_em_ext_get_cell_lock_req(source_string_ptr->src_id);
                    return;
                }
                case 3:
                {
                    enabled_bitmap = rmmi_int_validator_u32_check(&error_cause, source_string_ptr, (kal_uint8)RMMI_COMMA);
                    if((error_cause != RMMI_PARSE_OK) && (enabled_bitmap != 0))
                    {
                        ret_val = KAL_FALSE;
                    }
                    else
                    {
                        ret_val = KAL_TRUE;   
                    }
                    break;
                }
                default:
                    break;
            }
            
            if(ret_val == KAL_FALSE)
            {
                break;
            }

            if(enabled_bitmap != 0)
            {
                // get <band_indicator>
                band_indicator = (kal_uint8) rmmi_int_validator_ext(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA /* separator */ );		   
                
                if (error_cause != RMMI_PARSE_OK || band_indicator > 1)
                {
                    ret_val = KAL_FALSE;
                    break;
                }
                
                for( ; counter < MAX_NUM_CELL_LOCK_ARFCN; counter++)
                {
                    if(enabled_bitmap & (0x1<<counter))
                    {
                        // get <arfcn>
                        arfcn[counter] = (kal_uint16) rmmi_int_validator_ext(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA /* separator */ );		   
                        
                        if (error_cause != RMMI_PARSE_OK)
                        {
                            ret_val = KAL_FALSE;
                            break;
                        }		 
                    }
                    else
                    {
                        arfcn[counter] = 0;
                    }
                }
            }
            
            if(ret_val == KAL_TRUE)
            {
                if(mode <= 1)
                {
                    l4c_em_set_cell_lock_req(source_string_ptr->src_id, mode, band_indicator, arfcn[0]);
                }
                else
                {
                    l4c_em_ext_set_cell_lock_req(source_string_ptr->src_id, enabled_bitmap, band_indicator, arfcn);
                }           
    		 
    	        return;
            }
			else
			{
			    break;
			}
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}
#endif

#if !defined(__MMI_FMI__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_enbr_hdlr
 * DESCRIPTION
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_enbr_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
#ifdef __NBR_CELL_INFO__
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
#endif
    kal_uint16 string_length = 0;

    /*  GSM : +ENBR: 1,<rssi>,<cid>,<lac> */
    /*  UMTS: +ENBR: 2,<rssi>,<psc> */	

    switch (source_string_ptr->cmd_mode)
    {	
        case RMMI_ACTIVE_MODE:
        {
        #ifdef __NBR_CELL_INFO__			
            l4c_nbr_cell_info_ind_struct *nbr_info = &(RMMI_PTR->nbr_info);
            kal_uint8 i;

            if (nbr_info->is_nbr_info_valid)
            {
                if (nbr_info->rat_mode == 1)  // RAT_GSM
                {
                    for (i=0; i<nbr_info->ps_nbr_cell_info_union.gas_nbr_cell_info.nbr_cell_num; i++)
                    {
                        kal_uint16 rssi = nbr_info->ps_nbr_cell_info_union.gas_nbr_cell_info.nbr_meas_rslt.nbr_cells[i].rxlev;
			   kal_uint16 cid = nbr_info->ps_nbr_cell_info_union.gas_nbr_cell_info.nbr_cell_info[i].gci.ci;
			   kal_uint16 lac = nbr_info->ps_nbr_cell_info_union.gas_nbr_cell_info.nbr_cell_info[i].gci.lac;;			   

                        if (rssi > 63)
                        {
                            rssi = 99;
                        }
                        else
                        {
                            rssi = rssi >> 1;  // rxlevel (divide 2) -> RSSI
                        }

                        kal_sprintf((char*)buffer, "+ENBR: 1,%d,%d,%d", rssi, cid, lac);
                        rmmi_write_to_uart((kal_uint8*) buffer, (kal_uint16) strlen((char*)buffer), KAL_TRUE);
                    }
                }
            #ifdef __UMTS_RAT__				
                else if (nbr_info->rat_mode == 2) // RAT_UMTS
                {
                    kal_uint8 j;		  

                    if (nbr_info->ps_nbr_cell_info_union.uas_nbr_cell_info.measured_results_list_used)
                    {
                        for (i=0; i<nbr_info->ps_nbr_cell_info_union.uas_nbr_cell_info.measured_results_list.num; i++)
                        {
                            if (nbr_info->ps_nbr_cell_info_union.uas_nbr_cell_info.measured_results_list.element[i].cell_measured_results_list_used)
                            {
                                for (j=0; j<nbr_info->ps_nbr_cell_info_union.uas_nbr_cell_info.measured_results_list.element[i].cell_measured_results_list.num; j++)
                                {
                                    kal_uint16 rssi = 0;
                                    kal_uint16 psc = 0;

                                    if (nbr_info->ps_nbr_cell_info_union.uas_nbr_cell_info.measured_results_list.element[i].cell_measured_results_list.element[j].mode_specific_info.mode == UAS_CELL_MEASURED_RESULTS_MODE_FDD)
                                    {
                                        rssi = nbr_info->ps_nbr_cell_info_union.uas_nbr_cell_info.measured_results_list.element[i].cell_measured_results_list.element[j].mode_specific_info.choice.fdd.cpich_rscp;
                                        psc = nbr_info->ps_nbr_cell_info_union.uas_nbr_cell_info.measured_results_list.element[i].cell_measured_results_list.element[j].mode_specific_info.choice.fdd.psc;
                                    }
                                #ifdef __UMTS_TDD128_MODE__
                                    else if (nbr_info->ps_nbr_cell_info_union.uas_nbr_cell_info.measured_results_list.element[i].cell_measured_results_list.element[j].mode_specific_info.mode == UAS_CELL_MEASURED_RESULTS_MODE_TDD)
                                    {
                                        rssi = nbr_info->ps_nbr_cell_info_union.uas_nbr_cell_info.measured_results_list.element[i].cell_measured_results_list.element[j].mode_specific_info.choice.tdd.pccpch_rscp;
                                        psc = nbr_info->ps_nbr_cell_info_union.uas_nbr_cell_info.measured_results_list.element[i].cell_measured_results_list.element[j].mode_specific_info.choice.tdd.cellParameterId;
                                    }
                                #endif

                                    kal_sprintf((char*)buffer, "+ENBR: 2,%d,%d", rssi, psc);
                                    rmmi_write_to_uart((kal_uint8*) buffer, (kal_uint16) strlen((char*)buffer), KAL_TRUE);
                                }
                            }
                        }
                    }
                }
            #endif		  
            }

	     ret_val = KAL_TRUE;
        #endif		 
            break;
        }                
        default:
            break;
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);	
}

/*****************************************************************************
 * FUNCTION
 *  rmmi_epsb_hdlr
 * DESCRIPTION
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_epsb_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;	
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;

    /*  +EPSB: <bearer> */

    // GPRS: 0x01
    // EDGE: 0x02
    // WCDMA: 0x04
    // TD-SCDMA: 0x08
    // HSDPA: 0x10
    // HSUPA: 0x20
    // HSPA+: 0x40
    // LTE: 0x80

    switch (source_string_ptr->cmd_mode)
    {	
        case RMMI_ACTIVE_MODE:
        case RMMI_READ_MODE:
        {
            kal_uint8 bearer;

            bearer = 0x00
                #ifdef __PS_SERVICE__
                    | 0x01
                #endif
                #ifdef __EGPRS_MODE__
                    | 0x02
                #endif
                    ;

            if (l4c_current_mod_id == MOD_L4C)
            {
                bearer = bearer
                    #ifdef __UMTS_FDD_MODE__
                        | 0x04
                    #endif
                    #ifdef __UMTS_TDD128_MODE__
                        | 0x08
                    #endif
                    #ifdef __HSUPA_SUPPORT__
                        | 0x10
                    #endif
                    #ifdef __HSDPA_SUPPORT__
                        | 0x20
                    #endif
                        ;
            }

            kal_sprintf((char*)buffer, "+EPSB: %d", bearer);
            rmmi_write_to_uart((kal_uint8*) buffer, (kal_uint16) strlen((char*)buffer), KAL_TRUE);

            ret_val = KAL_TRUE;
            break;
        }                
        default:
            break;
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);	
}

#endif /* __MMI_FMI__ */ 

#if defined(__GEMINI__) && defined(__WM_RIL_SUPPORT__)

/*****************************************************************************
 * FUNCTION
 *  rmmi_edsw_hdlr
 * DESCRIPTION
 *  This is an rmmi function handler for:
 *   1. Notify SIM1/SIM2 the SIM mode switching procedure beginning/end
 *   2. Refer to MSG_ID_MMI_NW_SIM_MODE_SWITCH_START_REQ
 *   3. Refer to MSG_ID_MMI_NW_SIM_MODE_SWITCH_STOP_REQ
 *  add for Gemini modem on 20080923
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_edsw_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 command;    

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:
        {
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            command = (kal_uint8) rmmi_int_validator(
                                    source_string_ptr,
                                    RMMI_PTR->s_reg.s3);
            // command: (0,1)
            // if command == 0, means "switching begins"
            // if command == 1, means "switching ends"
            if (command == 0)
            {
                l4c_nw_sim_mode_switch_start_req(source_string_ptr->src_id);
                ret_val = KAL_TRUE;
                break;            
            }
            else if (command == 1)
            {
                l4c_nw_sim_mode_switch_stop_req(source_string_ptr->src_id);
                ret_val = KAL_TRUE;
                break;
            }
        }
        default:
            break;
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}

/*****************************************************************************
 * FUNCTION
 *  rmmi_euds_hdlr
 * DESCRIPTION
 *  This is an rmmi function handler for:
 *   1. Update Dual SIM mode setting to SIM1/SIM2
 *   2. Refer to MSG_ID_MMI_SMU_SIM_STATUS_UPDATE_REQ
 *   3. Refer to MSG_ID_MMI_SMU_DUAL_SIM_TO_FLIGHT_MODE_REQ as well
 *  add for Gemini modem on 20080923
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_euds_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 command;    

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:
        {
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            command = (kal_uint8) rmmi_int_validator(
                                    source_string_ptr,
                                    RMMI_PTR->s_reg.s3);
            // command: (0-3)
            // if command == 0, means "Flight mode"
            // if command == 1, means "SIM1 ONLY"
            // if command == 2, means "SIM2 ONLY"
            // if command == 3, means "DUAL SIM MODE"
            if (command == 0)
            {
		  if (L4C_PTR->cfun_state == 0)
		  {
	              l4c_smu_sim_status_update_req(SIM_CONFIG_STATUS_NONE);		  
		  }
		  else
                {
                    l4c_smu_dual_sim_to_flight_mode_req();
                }                
                ret_val = KAL_TRUE;
                break;            
            }
            else if ((command >= 1) && (command <= 3))
            {
                kal_uint8 new_sim_config = 0xFF;
                // Reference to sim_config_status_enum:
                //    SIM1_ONLY_CONFIG = 0 <=> command = 1
                //    SIM2_ONLY_CONFIG = 1 <=> command = 2
                //    DAUL_SIM_CONFIG  = 2 <=> command = 3
                //    SIM_CONFIG_STATUS_NONE = 0xFF <=> command = ??
                if (command == 1)
                    new_sim_config = SIM1_ONLY_CONFIG;
                else if (command == 2)
                    new_sim_config = SIM2_ONLY_CONFIG;
                else if (command == 3)
                    new_sim_config = DAUL_SIM_CONFIG;                
                l4c_smu_sim_status_update_req(new_sim_config);
                ret_val = KAL_TRUE;
                break;
            }
        }
        default:
            break;
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}

/*****************************************************************************
 * FUNCTION
 *  rmmi_edsim_hdlr
 * DESCRIPTION
 *  This is an rmmi function handler for:
 *   1. Get/Set dual SIM mode setting in NVRAM
 *   2. Get the dual SIM inserted status
 *  add for Gemini modem on 20080919
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_edsim_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 command;    

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:
        {
            nvram_read_req_struct *param_ptr = NULL;
            //kal_prompt_trace(rmmi_current_mod_id, "+EDSIM: READ MODE");
            /* Read the dual SIM setting from NVRAM */
            L4C_PTR->dual_sim_mode_setting_command = RMMI_EDSIM_READING;
            param_ptr = (nvram_read_req_struct*) construct_local_para((kal_uint16) sizeof(nvram_read_req_struct), TD_RESET);
            param_ptr->file_idx = NVRAM_EF_SYS_CACHE_OCTET_LID;
            param_ptr->access_id = source_string_ptr->src_id;
            param_ptr->para = NVRAM_SYS_FLIGHTMODE_STATE;
            param_ptr->rec_amount = 1;
            l4c_send_msg_to_nvm(MSG_ID_NVRAM_READ_REQ, param_ptr, NULL, 0);
            return;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            command = (kal_uint8) rmmi_int_validator(
                                    source_string_ptr,
                                    RMMI_PTR->s_reg.s3);
            // command: (0-3)
            // if command == 0, means "Flight mode"
            // if command == 1, means "SIM1 ONLY"
            // if command == 2, means "SIM2 ONLY"
            // if command == 3, means "DUAL SIM MODE"
            if ((command <=3) /* &&(command >= 0) */)
            {
                nvram_read_req_struct *param_ptr = NULL;         
                /* Read the current dual SIM setting from NVRAM */
                param_ptr = (nvram_read_req_struct*) construct_local_para((kal_uint16) sizeof(nvram_read_req_struct), TD_RESET);
                param_ptr->file_idx = NVRAM_EF_SYS_CACHE_OCTET_LID;
                param_ptr->access_id = source_string_ptr->src_id;
                param_ptr->para = NVRAM_SYS_FLIGHTMODE_STATE;
                param_ptr->rec_amount = 1;
                L4C_PTR->dual_sim_mode_setting_command = (rmmi_edsim_set_mode_state_enum) command;
                l4c_send_msg_to_nvm(MSG_ID_NVRAM_READ_REQ, param_ptr, NULL, 0);
                return;
                break;            
            }
            else
            {
                break;
            }
        }
        default:
            break;
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;

}
#endif /* defined(__GEMINI__) && !defined(__MMI_FMI__) */

#endif /* !(defined(__SLIM_AT__)*/


#if defined(__SYSSEL_SUPPORT__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_syssel_hdlr
 * DESCRIPTION
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_syssel_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 error_cause;
    kal_uint8 buffer[250];//RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    kal_uint32 rmmi_gsm_auto_band;
    kal_uint32 rmmi_umts_auto_band;
    kal_uint8 gsm_band = 0; //8 bitmap
    kal_uint16 umts_band = 0; //16 bitmap
    kal_uint8 band, mode, order, domain;
    kal_uint8 rat_mode, prefer_rat, mobile_class;
    kal_uint32 band_map;

    custom_get_supported_bands(&rmmi_gsm_auto_band, &rmmi_umts_auto_band);

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_TEST_MODE: /* at+syssel=? */
        {
            /* +SYSSEL: (list of supported <band>s), (list of supported <mode>s), 
             *          (list of supported <order>s), (list of supported <domain>s) 
             */
            kal_uint8 *ptr, i;

            rmmi_convert_syssel_band(rmmi_gsm_auto_band, rmmi_umts_auto_band, &band_map);
            string_length = kal_sprintf((kal_char*)buffer, "+SYSSEL: (");
            ptr = buffer + string_length;
            if ((band_map & 0x00000001) == 0x00000001)
            {
                string_length = kal_sprintf(ptr, "0");
                ptr += string_length;
                band_map >>= 1;
            }
            
            for (i=1; i<=22; i++)
            {
                if (((band_map >> i) & 0x00000001) == 0x00000001)
                {
                    string_length = kal_sprintf(ptr, ", %d", i);
                    ptr += string_length;
                }
            }
            kal_sprintf(ptr, "), (0, 1, 2), (0, 1, 2), (0, 1, 2)");
            string_length = strlen((char*)buffer);
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_READ_MODE:
        {
            // band
            band = RMMI_PTR->syssel_band;

            // mode
            ret_val = l4c_nw_get_rat_mode_req(source_string_ptr->src_id, &rat_mode);
            if (rat_mode == L4C_RAT_GSM)
            {
                mode = 1;
            }
            else if (rat_mode == L4C_RAT_UMTS)
            {
                mode = 2;
            }
            else
            {
                mode = 0;
            }

            // order
            ret_val = l4c_nw_get_prefer_rat_req(&prefer_rat);
            if (prefer_rat == RAT_GSM)
            {
                order = 2; //GSM then WCDMA
            }
            else if (prefer_rat == RAT_UMTS)
            {
                order = 1; //WCDMA than GSM
            }
            else
            {
                order = 0; //AUTO
            }

            // domain
            ret_val = l4c_nw_get_class_req(source_string_ptr->src_id, &mobile_class);
            if (mobile_class == 0 || mobile_class == 1) // A , B
            {
                domain = 0;  // CS+PS
            }
            else if (mobile_class == 2) // CG
            {
                domain = 2;  // PS only
            }
            else if (mobile_class == 3) // CC
            {
                domain = 1;  // CS only
            }

            RMMI_PTR->arg_list[0] = (void*)&band;
            RMMI_PTR->arg_list[1] = (void*)&mode;
            RMMI_PTR->arg_list[2] = (void*)&order;
            RMMI_PTR->arg_list[3] = (void*)&domain;
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+SYSSEL:%d,%d,%d,%d", RMMI_PTR->arg_list, 4);

            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_bool band_mode_conflict = KAL_FALSE;
                
            band = (kal_uint8)rmmi_int_validator_range_check(
                                    &error_cause,
                                    source_string_ptr,
                                    (kal_uint8) RMMI_COMMA,
                                    22);
            
            if (error_cause != RMMI_PARSE_OK)
            {
                if (error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    band = 0xff; // unchanged
                }
                else
                {
                    break;        
                }
            }

            if (band != 0xff)
            {
                rmmi_get_syssel_band(band, &gsm_band, &umts_band);
            
                if ((gsm_band | rmmi_gsm_auto_band) != rmmi_gsm_auto_band)
                {
                    /* Check if the input GSM band is supported */
                    break;
                }
            #ifdef __UMTS_RAT__
                if ((umts_band | rmmi_umts_auto_band) != rmmi_umts_auto_band)
                {
                    /* Check if the input UMTS band is supported */
                    break;
                }
            #else
                if (umts_band != 0)
                {
                    /* don't support WCDMA band */
                    break;
                }
            #endif
            }
        
            mode = (kal_uint8)rmmi_int_validator_range_check(
                                    &error_cause,
                                    source_string_ptr,
                                    (kal_uint8) RMMI_COMMA,
                                    2);

            if (error_cause != RMMI_PARSE_OK)
            {
                if (error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    mode = 0xff; // unchanged
                }
                else
                {
                	break;		  
                }
            }

            /* check <band> and <mode> dependency 
               we don't allow GSM only <band> but <mode> set to 0-Auto or 2-WCDMA only
               we don't allow UMTS only <band> but <mode> set to 0-Auto or 1-GSM only
            */
            switch (band)
            {
                case 3:
                case 5:
                case 6:
                case 7:
                case 8:
                {
                    if (mode == 0 || mode == 2)
                    {
                        /* GSM only band but RAT is auto or WCDMA only */
                        band_mode_conflict = KAL_TRUE;
                    }
                    break;
                }
                case 4:
                case 9:
                case 10:
                case 11:
                case 12:
                {
                    if (mode == 0 || mode == 1)
                    {
                        /* UMTS only band but RAT is auto or GSM only */
                        band_mode_conflict = KAL_TRUE;
                    }
                    break;
                }
            }
            
            if (band_mode_conflict == KAL_TRUE)
            {
                break;
            }
            
            order = (kal_uint8)rmmi_int_validator_range_check(
                                    &error_cause,
                                    source_string_ptr,
                                    (kal_uint8) RMMI_COMMA,
                                    2);

            if (error_cause != RMMI_PARSE_OK)
            {
                if (error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    order = 0xff; // unchanged
                }
                else
                {
                    break;		  
                }
            }


            domain = (kal_uint8)rmmi_int_validator_range_check(
                                    &error_cause,
                                    source_string_ptr,
                                    (kal_uint8) RMMI_COMMA,
                                    2);

            if (error_cause != RMMI_PARSE_OK)
            {
                if (error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    domain = 0xff; // unchanged
                }
                else
                {
                    break;		  
                }
            }

            // Do nothing if totally unchaged
            if (band == 0xff && mode == 0xff && order == 0xff && domain == 0xff)  
            {
                ret_val = KAL_TRUE;
                break;
            }

            // rat_mode
            if (mode == 0)
            {
                rat_mode = RAT_GSM_UMTS;
            }
            else if (mode == 1)
            {
                rat_mode = RAT_GSM;
            }
            else if (mode == 2)
            {
                rat_mode = RAT_UMTS;
            }
            else if (order == 0xff)
            {
                ret_val = l4c_nw_get_rat_mode_req(source_string_ptr->src_id, &rat_mode); // unchange
            }

            // prefer_rat
            if (order == 0)
            {
                prefer_rat = RAT_GSM_UMTS;
            }
            else if (order == 1)
            {
                prefer_rat = RAT_UMTS;
            }
            else if (order == 2)
            {
                prefer_rat = RAT_GSM;
            }
            else if (order == 0xff)
            {
                l4c_nw_get_prefer_rat_req(&prefer_rat); // unchange
            }

            // mobile_class
            if (domain == 0)
            {
                mobile_class = 1; // CS_PS
            }
            else if (domain == 1)
            {          
                mobile_class = 3; // CS only
            }
            else if (domain == 2)
            {
                mobile_class = 2; // PS only
            }
            else if (domain == 0xff)
            {
                l4c_nw_get_class_req(source_string_ptr->src_id, &mobile_class); // unchange
            }

            ret_val = l4c_nw_set_syssel_req(source_string_ptr->src_id, rat_mode, prefer_rat, mobile_class);
            
            if (ret_val == KAL_TRUE)
            {
                /* save band to RMMI context and NVRAM */
                if (band != 0xff)
                {
                    RMMI_PTR->syssel_band = band;
                    l4c_save_syssel_setting(source_string_ptr->src_id, band);
                }
                return;
            }
        }
        default:
            break;
    }
      
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) buffer, string_length);
}
#endif /* defined(__SYSSEL_SUPPORT__) */ 


#if defined(__ACMT_SUPPORT__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_eacmt_hdlr
 * DESCRIPTION
 *  This is an rmmi validator function for +EACMT command
 *
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_eacmt_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:
        {
            kal_sprintf((char*)buffer, "+EACMT: %d", RMMI_PTR->eacmt_mode);
            string_length = strlen((char*)buffer);
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 mode, error_cause;

            mode = (kal_uint8)rmmi_int_validator_range_check(&error_cause, source_string_ptr, RMMI_PTR->s_reg.s3, 1);

            if (error_cause == RMMI_PARSE_OK)
            {
                RMMI_PTR->eacmt_mode = mode;
                ret_val = KAL_TRUE;
            }
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, buffer, string_length);
    return;
}
#endif /* defined(__ACMT_SUPPORT__) */


#if defined(__REPORT_AVAILABLE_PLMN__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_ecops_hdlr
 * DESCRIPTION
 *  handler function for AT+ECOPS=<mode>. When <mode>=1, +ECOPS URC is reported
 *
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_ecops_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:
        {
            rmmi_header_rrsp("+ECOPS:");
            rmmi_tail_int_rrsp(rmmi_ptr->ecops_mode, RMMI_SPACE);
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 mode, error_cause;

            mode = (kal_uint8)rmmi_int_validator_range_check(&error_cause, source_string_ptr, rmmi_ptr->s_reg.s3, 1);

            if (error_cause == RMMI_PARSE_OK)
            {   
                if ((mode == 0) && (rmmi_ptr->emsr_mode != 0))
                {
                    /* +ECOPS could be turn off only when +EMSR is already turned off */
                    break;
                }
                rmmi_ptr->ecops_mode = mode;
                ret_val = KAL_TRUE;
            }
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}
#endif /* defined(__REPORT_AVAILABLE_PLMN__) */


#if defined(__2STAGE_NW_SELECTION__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_emsr_hdlr
 * DESCRIPTION
 *  This is an rmmi validator function for +EMSR command
 *
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_emsr_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:
        {
            rmmi_header_rrsp("+EMSR:");
            rmmi_tail_int_rrsp(rmmi_ptr->emsr_mode, RMMI_SPACE);
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 action, data, error_cause;

            action = (kal_uint8)rmmi_int_validator_range_check(&error_cause, 
                                                               source_string_ptr, 
                                                               (kal_uint8)RMMI_COMMA, 
                                                               1);

            if (error_cause == RMMI_PARSE_OK)
            {
                data = rmmi_int_validator_u8_check(&error_cause, source_string_ptr, rmmi_ptr->s_reg.s3);
                if (error_cause != RMMI_PARSE_OK)
                {
                    break;
                }
                else if (action == 0)
                {
                    /* set suspend-resume mode, data indicates the mode */
                    if ((data == 1) && (rmmi_ptr->ecops_mode != 1))
                    {
                        /* +EMSR could be turn on only when +ECOPS is already turned on */
                        break;
                    }
                    else if (data <= 1)
                    {
                        ret_val = l4c_nw_susp_resum_update_req(source_string_ptr->src_id, data, action);
                        if (ret_val == KAL_TRUE)
                        {
                            rmmi_ptr->emsr_mode = data;
                            /* respond after MSG_ID_L4CRAC_SUSP_RESU_UPDATE_CNF */
                            return;
                        }
                    }
                }
                else
                {
                    /* resume modem, data indicates the session ID */
                    ret_val = l4c_nw_susp_resum_update_req(source_string_ptr->src_id, data, action);
                    if (ret_val == KAL_TRUE)
                    {
                        /* respond after MSG_ID_L4CRAC_SUSP_RESU_UPDATE_CNF */
                        return;
                    }
                }
            }
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}

#endif /* defined(__2STAGE_NW_SELECTION__) */

#ifdef __UE_EFOPLMN__
/*****************************************************************************
 * FUNCTION
 *  rmmi_epol_hdlr
 * DESCRIPTION
 *  refer to rmmi_cpol_hdlr()
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_epol_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 result;
    kal_uint8 version[2];
    kal_uint16 i;
    kal_uint8 no_entry;
    kal_uint8 *oper_list = NULL;
    kal_uint8 *rat_list = NULL;
    kal_uint8 oper_str[7];
    kal_uint16 UTRA_AcT = 0, GSM_com_AcT = 0, GSM_AcT = 0;
    kal_uint8 error_cause;
    kal_uint8 version_str[8]; // longest number string includes dot: "254.254"
    kal_uint8 version_val[2]; // digit value before and after dot of the version

    kal_trace(TRACE_FUNC, FUNC_RMMI_EPOL_HDLR_ENTRY);

    kal_mem_set(oper_str, 0x00, sizeof(oper_str));

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:
        {
            /* get OPLMN file version from RAC */
            l4crac_get_ue_oplmn_version(&(version[0]), &(version[1]));
            rmmi_header_rrsp("+EPOL:");
            rmmi_int_space_rrsp((kal_uint32)version[0]);
            rmmi_tail_int_rrsp(version[1], RMMI_CHAR_DOT);
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            /* get <version> */
            result = rmmi_string_validator_ext(&error_cause, 
                                               source_string_ptr, 
                                               RMMI_COMMA, 
                                               sizeof(version_str), 
                                               (kal_uint8*)version_str);
            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }
            
            result = check_dotted_value8(version_str, version_val, sizeof(version_val));
            if (result == RMMI_VALIDATOR_ERROR)
            {
                break;
            }

            /* get <no_entry> */
            no_entry = (kal_uint8) rmmi_int_validator_range_check(&error_cause, 
                                                                  source_string_ptr, 
                                                                  (kal_uint8)RMMI_COMMA, 
                                                                  MAX_UE_OPLMN_ENTRY);

            if ((error_cause != RMMI_PARSE_OK) || (no_entry <= 0))
            {
                break;
            }
            else
            {
                oper_list = get_ctrl_buffer(no_entry * sizeof(oper_str));
                rat_list = (kal_uint8*) get_ctrl_buffer(no_entry);
            }

            /* get <oper> entries */
            for (i=0; i<no_entry; i++)
            {
                result = rmmi_string_validator_ext(&error_cause, 
                                                   source_string_ptr, 
                                                   RMMI_COMMA, 
                                                   sizeof(oper_str), 
                                                   (kal_uint8*) oper_str);

                if ((result == RMMI_VALIDATOR_ERROR) || 
                    (strlen((char*)oper_str) < 5) || 
                    (rmmi_is_number_string(oper_str) == KAL_FALSE))
                {
                    break;
                }
                else
                {
                    // get <GSM_AcT>
                    GSM_AcT = (kal_uint8)rmmi_int_validator_range_check(
                                        &error_cause, 
                                        source_string_ptr, 
                                        (kal_uint8) RMMI_COMMA, 
                                        1);

                    if (error_cause != RMMI_PARSE_OK)
                    {
                        break;
                    }

                    // get <GSM_com_AcT>
                    GSM_com_AcT = (kal_uint8)rmmi_int_validator_range_check(
                                        &error_cause, 
                                        source_string_ptr, 
                                        (kal_uint8) RMMI_COMMA, 
                                        1);

                    if ((error_cause != RMMI_PARSE_OK) || (GSM_com_AcT == 1)) // Not support GSM_com
                    {
                        break;
                    }

                    // get <UTRA_AcT>
                    UTRA_AcT = (kal_uint8)rmmi_int_validator_range_check(
                                        &error_cause, 
                                        source_string_ptr, 
                                        (kal_uint8) RMMI_COMMA, 
                                        1);

                    if (error_cause != RMMI_PARSE_OK)
                    {
                        break;
                    }

                    if (GSM_AcT == 1 && UTRA_AcT == 0)
                    {
                        rat_list[i] = L4C_RAT_GSM;
                    }
                    else if (GSM_AcT == 0 && UTRA_AcT == 1)
                    {
                        rat_list[i] = L4C_RAT_UMTS;
                    }
                    else if (GSM_AcT == 1 && UTRA_AcT == 1)
                    {
                        rat_list[i] = L4C_RAT_GSM_UMTS;
                    }
                    else
                    {
                        rat_list[i] = L4C_RAT_NONE;
                    }

                    kal_mem_cpy(oper_list+(i * sizeof(oper_str)), oper_str, sizeof(oper_str));
                } //valid PLMN string
            }

            if (i >= no_entry)
            {
                /* construct message for RAC */
                ret_val = l4c_nw_set_preferred_oper_list_req(version_val, no_entry, oper_list, rat_list);
            }
            free_ctrl_buffer(oper_list);
            free_ctrl_buffer(rat_list);
            break;
        }
        default:
            break;
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}
#endif /* __UE_EFOPLMN__ */
#endif /* __MOD_RAC__ */ 

