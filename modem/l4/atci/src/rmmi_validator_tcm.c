/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 * RMMI_VALIDATOR_TCM.C
 *
 * Project:
 * --------
 *   MAUI
 *
 * Description:
 * ------------
 *   This file is intends for ???K.
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
#include <stdio.h>
#include <string.h>
//#include "kal_non_specific_general_types.h"
//#include "ps_trace.h"
//#include "stack_config.h"
#include "kal_trace.h"
//#include "kal_release.h"
//#include "stack_common.h"
//#include "stack_msgs.h"
//#include "app_ltlcom.h" /* Task message communiction */
//#include "stacklib.h"   /* Basic type for dll, evshed, stacktimer */
//#include "app_buff_alloc.h"
//#include "stack_timer.h"
//#include "event_shed.h"
//#include "nvram_editor_data_item.h"
//#include "custom_nvram_editor_data_item.h"

#ifdef __MOD_SMU__
//#include "ps2sim_struct.h"
//#include "sim_common_enums.h"
//#include "smu_common_enums.h"
#endif /* __MOD_SMU__ */
//#include "device.h"
//#include "csmss_common_enums.h"

//#include "mcd_l3_inc_struct.h"
//#include "mcd_l3_inc_gprs_struct.h"
//#include "l3_inc_enums.h"

//#include "mcd_l4_common.h"

#include "l4c_common_enum.h"
#include "rmmi_common_enum.h"
#include "rmmi_context.h"
#include "l4c_context.h"
#include "layer4_context.h"
//#include "l4c_rspfmttr.h"
//#include "l4c_msghdlr.h"
#include "l4_trc.h"
#include "atci_trc.h"

//#include "l4_defs.h"
//#include "csmcc_atfunc.h"
//#include "csmss_atfunc.h"
//#include "l4c_aux_struct.h"
//#include "l4c_ss_parse.h"

#ifdef __MOD_CSM__
//#include "mcd_ss_parameters.h"
//#include "mcd_ss_tcapmessages.h"
#include "l4c_common_enum.h"
//#include "csmcc_enums.h"
//#include "csmcc_common_enums.h"
//#include "ps2sat_struct.h"
//#include "l4c2csm_cc_struct.h"

//#include "l4c_ciss_cmd.h"
//#include "l4c2csm_ss_struct.h"
//#include "l4c_cc_cmd.h"
#endif /* __MOD_CSM__ */

#if defined (VM_SUPPORT)
//#include "med_struct.h"
#endif
#ifdef __MOD_UEM__
//#include "device.h"
//#include "l4c2uem_struct.h"
//#include "uem_at_cmd.h"
//#include "custom_em.h"
//#include "l4c_eq_cmd.h"
#endif /* __MOD_UEM__ */
#ifdef __MOD_RAC__
#include "l4crac_func.h"
#include "l4c_nw_cmd.h"
#include "l4crac_enums.h"
#endif /* __MOD_RAC__ */

#ifdef __MOD_SMSAL__
//#include "l4c2smsal_struct.h"
//#include "smsal_l4c_defs.h"
//#include "smsal_l4c_funcs.h"
//#include "smsal_l4c_enum.h"
//#include "smsal_defs.h"
//#include "l4c_sms_cmd.h"
#endif /* __MOD_SMSAL__ */
#ifdef __MOD_SMU__
//#include "ps2sat_struct.h"
//#include "mcd_ps2sat_peer.h"
#include "l4c_sim_cmd.h"
#endif /* __MOD_SMU__ */
#ifdef __MOD_TCM__
//#include "mmi_l3_enums.h"
//#include "mmi_sm_enums.h"
//#include "ppp_l4_enums.h"
//#include "tcm_common_enums.h"
//#include "tcm_common.h"
#include "tcm_context.h"
//#include "custom_nvram_editor_data_item.h"
//#include "l4c2abm_struct.h"
//#include "abm2l4c_struct.h"
#include "l4c2tcm_struct.h"
#include "l4c2tcm_func.h"
//#ifdef __TCPIP__
//#include "l4c2abm_struct.h"
//#endif /* __TCPIP__ */
#include "l4c_gprs_cmd.h"
#endif /* __MOD_TCM__ */

#include "l4c_utility.h"
#include "rmmi_rspfmttr.h"
#include "rmmi_utility.h"
//#include "rmmi_rsp.h"
//#include "rmmi_validator.h"
//#include "nvram_data_items.h"
//#include "custom_hw_default.h"
//#include "l4c_table.h"
#include "rmmi_parser.h"
//#include "resource_verno.h"     // for +EGMR read MMI resource version

#ifdef __CSD_FAX__
//#include "csm_data_enums.h"
//#include "l4c2t30_struct.h"
//#include "l4c_t30_cmd.h"
//#include "l4c2t30_enums.h"
#endif /* __CSD_FAX__ */
#include "rmmi_parser.h"
#ifndef MED_NOT_PRESENT
//#include "med_global.h"
//#include "med_main.h"
#endif /* MED_NOT_PRESENT */
#ifdef __J2ME__
#include "jam_msg_handler.h"
#endif

#ifdef __CTM_SUPPORT__
//#include "med_struct.h"
#endif
//#include "l4c_sendmsg.h"

#ifdef __CUST_NEW__
//#include "gpio_sw.h"
#endif

/* for data item NVRAM_EF_IMEI_IMEISV_LID move */
//#include "nvram_user_defs.h"
//#include "csmcc_defs.h"

//#include "keypad_sw.h"
//#include "l4c2smu_struct.h"
//#include "lmmi_ind.h"

//#include "csmcc_common_enums.h"

//#include "mncc_struct.h"
//#include "csmcc_bc_types.h"
//#include "csmcc_types.h"
//#include "custom_em.h"
//#include "L4c_ctm_cmd.h"
//#include "csmcc_utility.h"

//#include "sat_def.h"

//#include "uem_proc_cmd.h"

#include "rmmi_msghdlr.h"

#include "kal_general_types.h"
#include "kal_public_api.h"
#include "ps_public_enum.h"
#include "ps_public_struct.h"
#include "ps_em_enum.h" //mtk02285, MAUI_02931839, 20110505
#include "mmi_l3_enums.h" //for EGPAU's SM_AUTHENTICATION_XXX types
#include "rmmi_sio.h"

#if defined(__MOBILE_BROADBAND_PROVISION_CONTEXT__) || defined(__MEDIATEK_SMART_QOS__)
#include "nvram_data_items.h"
#endif

extern l4c_data_bearer_capablility_enum custom_max_bearer_capability(void);

#if defined(__MOD_TCM__)
#if !defined(__ULC_AT__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_cgatt_hdlr
 * DESCRIPTION
 *
 * PARAMETERS
 *  source_string_ptr       [?]
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cgatt_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 status;
    kal_uint8 opcode;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    kal_trace(TRACE_FUNC, FUNC_RMMI_CGATT_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
#ifdef __test_mode__
    case RMMI_TEST_MODE:
    {
        ret_val = l4crac_test_attach_mode(&rsp_str);
        string_length = strlen((char*)rsp_str);
        break;
    }
#endif /* __test_mode__ */
    case RMMI_READ_MODE:
    {
        //ret_val = l4c_nw_get_attach_status_req(source_string_ptr->src_id, RAC_PS, &status);
        status = rmmi_ptr->ps_register_status.state;

        if (status != REG_STATE_REGISTERED)
        {
            status = REG_STATE_NOT_REGISTERED;
        }
        rmmi_ptr->arg_list[0] = (void*)&status;
        string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CGATT: %d", rmmi_ptr->arg_list, 1);
        rsp_str = &buffer[0];
        ret_val = KAL_TRUE;
        break;
    }
    case RMMI_SET_OR_EXECUTE_MODE:
    {
        kal_uint8 gprs_state;
        kal_uint8 error_cause;
        //kal_uint8 service;
        //l4crac_get_attach_status(&gsm_state, &gprs_state, &service);  //MAUI_01393256, 20090217, mtk02285

        gprs_state = rmmi_ptr->ps_register_status.state;
        opcode = rmmi_int_validator_u8_check(
                     &error_cause,
                     source_string_ptr,
                     rmmi_ptr->s_reg.s3  /* separator */
                 );
        if (opcode == 0)
        {
        #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #endif
            rmmi_ptr->cgatt_last_action = 0;
            opcode = RAC_DETACH;
        }
        else if (opcode == 1)
        {
            if ((rmmi_ptr->cgatt_last_action == 1) &&
                    (gprs_state == RMMI_REG_STATE_REGISTERED)) //MAUI_01393256, 20090217, mtk02285
            {
                //to avoid continous +CGATT=1 (for example : script )
                ret_val = KAL_TRUE;
                break;
            }
            rmmi_ptr->cgatt_last_action = 1;
            opcode = RAC_ATTACH;
        }
        else
        {
            break;
        }

        ret_val = l4c_nw_exe_att_req(source_string_ptr->src_id, RAC_PS, opcode, KAL_FALSE);
        if (ret_val == KAL_TRUE)
        {
            return;
        }
        else
        {
            rmmi_ptr->cgatt_last_action = 0;
        }
        break;
    }
    default:
        break;
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
} /* end of rmmi_cgatt_hdlr */


/*****************************************************************************
 * FUNCTION
 *  rmmi_cgreg_hdlr
 * DESCRIPTION
 *
 * PARAMETERS
 *  source_string_ptr       [?]
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cgreg_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 mode, status;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    kal_trace(TRACE_FUNC, FUNC_RMMI_CGREG_HDLR_ENTRY);
    switch (source_string_ptr->cmd_mode)
    {
#ifdef __test_mode__
    case RMMI_TEST_MODE:
    {
        rsp_str = (kal_uint8 const*)"+CGREG: (0-2)";
        string_length = strlen((char*)rsp_str);
        ret_val = KAL_TRUE;
        break;
    }
#endif /* __test_mode__ */
    case RMMI_READ_MODE:
    {
        kal_uint16 rnc;

        mode = rmmi_ptr->report_mode.ps_reg;
        //l4c_nw_get_attach_status_req(source_string_ptr->src_id, RAC_PS, &status);
        status = rmmi_ptr->ps_register_status.state;

        #ifdef __ORANGE_H_PLUS__
        if (rmmi_ptr->register_act != 0
                && rmmi_ptr->register_act != 1
                && rmmi_ptr->register_act != 3)
        #else
        if (rmmi_ptr->ps_register_status.act != 0
                && rmmi_ptr->ps_register_status.act != 1
                && rmmi_ptr->ps_register_status.act != 3)
        #endif
        {
            rnc = (kal_uint16)((rmmi_ptr->ps_register_status.cell_id)>>16); //l4crac_get_rnc_id();
        }
        else
        {
            rnc = 0x00;
        }

        if ((status == RMMI_REG_STATE_REGISTERED) || (status == RMMI_REG_STATE_ROAMING))
        {
            if (rmmi_ptr->ps_register_status.lac_value != 0xffff)
            {
            #ifdef __REPORT_RAC__
                kal_sprintf(
                    (kal_char*) buffer,
                    "+CGREG: %d, %d, \"%04X\", \"%04X%04X\", %d, %d",
                    mode,
                    status,
                    rmmi_ptr->ps_register_status.lac_value,
                    rnc,
                    (kal_uint16)rmmi_ptr->ps_register_status.cell_id,
                    #ifdef __ORANGE_H_PLUS__
                    rmmi_ptr->register_act,
                    #else
                    rmmi_ptr->ps_register_status.act,	// [MAUI_01360129]
                    #endif
                    rmmi_ptr->ps_register_status.rac_value);
            #else
                    kal_sprintf(
                    (kal_char*) buffer,
                    "+CGREG: %d, %d, \"%04X\", \"%04X%04X\", %d",
                    mode,
                    status,
                    rmmi_ptr->ps_register_status.lac_value,
                    rnc,
                    (kal_uint16)rmmi_ptr->ps_register_status.cell_id,
                    #ifdef __ORANGE_H_PLUS__
                    rmmi_ptr->register_act);
                    #else
                    rmmi_ptr->ps_register_status.act);	// [MAUI_01360129]
                    #endif
            #endif
                string_length = strlen((char*)buffer);
            }
            else
            {
                kal_sprintf((kal_char*) buffer, "+CGREG: %d, %d", mode, status);
                string_length = strlen((char*)buffer);
            }
        }
        else
        {
            rmmi_ptr->arg_list[0] = (void*)&mode;
            rmmi_ptr->arg_list[1] = (void*)&status;
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CGREG: %d, %d", rmmi_ptr->arg_list, 2);
        }
        rsp_str = &buffer[0];
        ret_val = KAL_TRUE;
        break;
    }
    case RMMI_SET_OR_EXECUTE_MODE:
    {
        kal_uint8 error_cause;

        mode = rmmi_int_validator_u8_check(
                   &error_cause,
                   source_string_ptr,
                   rmmi_ptr->s_reg.s3 /* separator */ );
        if (mode == RMMI_VALIDATOR_ERROR)
        {
            if (error_cause == RMMI_PARSE_NOT_FOUND)
            {
                mode = 0;
            }
            else
            {
                break;
            }
        }
        else
        {
            if (mode > 2)
            {
                break;
            }
        }
        rmmi_ptr->report_mode.ps_reg = mode;
        ret_val = KAL_TRUE;
        break;
    }
    default:
    {
        /* unrecognized format of AT command line */
        break;
    }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
} /* end of rmmi_cgreg_hdlr */


/*****************************************************************************
 * FUNCTION
 *  rmmi_cgclass_hdlr
 * DESCRIPTION
 *
 * PARAMETERS
 *  source_string_ptr       [?]
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cgclass_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 result;
    kal_uint8 type, type_str[3];
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    kal_trace(TRACE_FUNC, FUNC_RMMI_CGCLASS_HDLR_ENTRY);
    if (is_sim_verified() == KAL_FALSE)
    {
        rmmi_result_code_fmttr(RMMI_RCODE_ERROR, rmmi_ptr->cmee_err);
        return;
    }
    /*
    if (l4c_is_test_sim() == KAL_FALSE)
    {
        rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_OPERATION_NOT_SUPPORTED);
        return;
    }
    */ // mtk02285, 20090421
    switch (source_string_ptr->cmd_mode)
    {
    case RMMI_TEST_MODE:
    {
        ret_val = l4crac_test_mobile_class(&rsp_str);
        string_length = strlen((char*)rsp_str);
        break;
    }
    case RMMI_READ_MODE:
    {
        ret_val = l4c_nw_get_class_req(source_string_ptr->src_id, &type);
        if (ret_val == KAL_FALSE)
        {
            break;
        }
        check_nw_class_name(type, type_str);

        rmmi_ptr->arg_list[0] = (void*)type_str;
        string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CGCLASS: \"%s\"", rmmi_ptr->arg_list, 1);
        rsp_str = &buffer[0];
        break;
    }
    case RMMI_SET_OR_EXECUTE_MODE:
    {
        if (l4c_is_test_sim() == KAL_FALSE)
        {
            rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_OPERATION_NOT_SUPPORTED);
            return;
        } // mtk02285, 20090421
        result = rmmi_string_validator(
                     source_string_ptr,
                     rmmi_ptr->s_reg.s3, /* separator */
                     3,
                     (kal_uint8*) type_str);
        if (result == RMMI_VALIDATOR_ERROR)
        {
            break;
        }

        type = check_nw_class_code(type_str);
        if (type == 0)
        {
            break;
        }
        ret_val = l4c_nw_set_class_req(source_string_ptr->src_id, type);
        if (ret_val == KAL_TRUE)
        {
            return;
        }
        break;
    }
    default:
    {
        /* unrecognized format of AT command line */
        break;
    }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
} /* end of rmmi_cgclass_hdlr */


#if defined(__EXT_PDP_CONTEXT_ON__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_cgact_hdlr
 * DESCRIPTION
 *
 * PARAMETERS
 *  source_string_ptr       [?]
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cgact_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 i, num, state, cid;
    kal_uint8 state_list[TCM_TOT_CONTEXT][2];
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    kal_uint16 return_error_cause = RMMI_ERR_UNSPECIFIED;
#if defined(__LOCAL_DEACTIVATE_PDP_SUPPORT__) || (!defined(__MMI_FMI__) && defined(__PS_DIALUP__)) //L4CPPP_FB_2
    /* Wrap the local variable declaration to resolve build warning */
    kal_bool local_deactivate_pdp = KAL_FALSE;
#endif
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    kal_trace(TRACE_FUNC, FUNC_RMMI_CGACT_HDLR_ENTRY);

    rmmi_ptr->cgatt_last_action = 0xff; /* +CGACT might change attach status, so clear +CGATT flag here */
    switch (source_string_ptr->cmd_mode)
    {
#ifdef __test_mode__
    case RMMI_TEST_MODE:
    {
        ret_val = l4ctcm_test_act_mode(&rsp_str);
        string_length = strlen((char*)rsp_str);

        break;
    }
#endif /* __test_mode__ */
    case RMMI_READ_MODE:
    {
        ret_val = l4c_ps_get_context_state_req(source_string_ptr->src_id, &num, (kal_uint8*) state_list);

        if (ret_val == KAL_TRUE)
        {
            for (i = 0; i < num; i++)
            {
                rmmi_ptr->arg_list[0] = (void*)&state_list[i][0];
                rmmi_ptr->arg_list[1] = (void*)&state_list[i][1];
                if (state_list[i][0] <= MAX_EXT_PDP_CONTEXT)
                {
                    string_length = rmmi_fast_string_print(
                                        buffer,
                                        (kal_uint8*) "+CGACT: %d, %d",
                                        rmmi_ptr->arg_list,
                                        2);
                    rsp_str = &buffer[0];
                    rmmi_write_to_uart((kal_uint8*) rsp_str, string_length, KAL_TRUE);
                } // MAUI_02316028, l4ctcm_get_context_state() supports both INT & EXT PDP
            }
        }
        string_length = 0;  //only print OK at last
        break;
    }
    case RMMI_SET_OR_EXECUTE_MODE:
    {
        kal_uint8 error_cause;
        kal_bool do_activate = KAL_TRUE;

        state = (kal_uint8) rmmi_int_validator(source_string_ptr, (kal_uint8) RMMI_COMMA);

        if (state == RMMI_VALIDATOR_ERROR)
        {
            return_error_cause = L4C_AT_CMD_INVALID_PARAMETER_OR_MISSING;
            break;          //Reject Cause: AT param: missing
        }
        else if (state > 1)
        {
#ifdef __LOCAL_DEACTIVATE_PDP_SUPPORT__
            if (state == 100)
            {
                //kal_prompt_trace(MOD_L4C, "AT+CGACT=%d,<cid> : local deactivate PDP!", state);
                state = 0;
                local_deactivate_pdp = KAL_TRUE;
            }
            else
#endif /* __LOCAL_DEACTIVATE_PDP_SUPPORT__ */
            {
                return_error_cause = L4C_AT_CMD_PARAMETER_OUT_OF_RANGE;
                break;      //Reject Cause: AT param: out of range
            }
        }

        cid = (kal_uint8) rmmi_int_validator_ext(
                  &error_cause,
                  source_string_ptr,
                  rmmi_ptr->s_reg.s3 /* separator */ );

        if (cid == RMMI_VALIDATOR_ERROR)
        {
            if (error_cause == RMMI_PARSE_NOT_FOUND)
            {
                cid = 1;
            }
            else
            {
                return_error_cause = L4C_AT_CMD_INVALID_PARAMETER;
                break;      //Reject Cause: AT param: invalid format
            }
        }
        else
        {
            if (cid == 0 || cid > MAX_EXT_PDP_CONTEXT)
            {
                return_error_cause = L4C_AT_CMD_CID_UNEXPECTED;
                break;      //Reject Cause: AT param: out of cid range
            }
        }

        /*
         * mtk02126:
         * 1.!defined(__MMI_FMI__): We don't support cgact to disconnect GPRS dial-up in feature phone.
         * 2.!defined(__MULTIPLE_PPP_DIALUP_SUPPORT__):
         *   L4C_PTR->cid_used_by_ppp can record one cid only.
         *   Therefore we use this compile option to make sure that.
         */

#if defined(__PS_DIALUP__)
#if !defined(__MMI_FMI__)
        if ((state == 0) && (uart_port_null != l4c_ps_dialup_get_port(cid)))
        {
            //l4c_ps_disc_ppp_dialup_req(source_string_ptr->src_id, data_src_id, cid, local_deactivate_pdp);
            l4c_ps_dialup_disc_req(source_string_ptr->src_id, cid, local_deactivate_pdp);
            return; // the rrsp will be printed in l4cppp_deactivate_cnf_hdlr
        }
#elif defined(__MMI_FMI__)
        /* MAUI_02951469, mtk02285, Help TCM to handle this concurrency, or it will assert at TCM (PPP deactivate PDP ongoing, and receive CGACT=0/1 */
        if (uart_port_null != l4c_ps_dialup_get_port(cid))
        {
            ret_val = KAL_FALSE;
            return_error_cause = L4C_CONTEXT_CONFLICT_PPP_DEACTIVATING;
            // Reject Cause: act 0/1 when PPP deactivate PDP ongoing
            break;
        }
#endif /* defined(__MMI_FMI__) */
#endif /* __PS_DIALUP__ */

        /* mtk00714: check if the context is already activated */
        if (state == 1)
        {
            ret_val = l4c_ps_get_context_state_req(source_string_ptr->src_id, &num, (kal_uint8*) state_list);
            if (ret_val == KAL_TRUE)
            {
                for (i = 0; i < num; i++)
                {
                    if ((state_list[i][0] == cid) && (state_list[i][1] == state))
                    {
                        do_activate = KAL_FALSE;
                        return_error_cause = L4C_CONTEXT_CONFLICT_ACT_ALREADY_ACTIVATED;
                        // Reject Cause: context already activated for act 1
                        break;
                    }
                }
            }
        }
        else if (state == 0)
        {
            ret_val = l4c_ps_get_context_state_req(source_string_ptr->src_id, &num, (kal_uint8*) state_list);
            if (ret_val == KAL_TRUE)
            {
                for (i = 0; i < num; i++)
                {
                    if ((state_list[i][0] == cid) && (state_list[i][1] == state))
                    {
                        do_activate = KAL_FALSE;
                        return_error_cause = L4C_CONTEXT_CONFLICT_DEACT_ALREADY_DEACTIVATED;
                        // Reject Cause: context already deactivated for act 0
                        break;
                    }
                }
            }
        }
#if defined(__RMMI_UT__) && !defined(__MTK_TARGET__)
        do_activate = KAL_TRUE; //MAUI_01922673, mtk02285, 20091208
#endif
        if (do_activate == KAL_FALSE)       //already activated, so we return OK directly.
        {
            break;
        }
        /* End: mtk00714 */
#ifdef __LOCAL_DEACTIVATE_PDP_SUPPORT__
        if (local_deactivate_pdp == KAL_TRUE)
        {
            state = TCM_PDP_DEACTIVATE_LOCAL;
        }
#endif /* __LOCAL_DEACTIVATE_PDP_SUPPORT__ */
        // [WORKAROUND] ALPS00809225: when no cell coverage, L4C directly returns error to RIL's CGACT
        if (rac_get_gprs_status() == GPRS_NO_COVERAGE  && state == 1)
        {
            return_error_cause = KAL_FALSE;            
        }
        // could activate PDP
        else
        {
            return_error_cause = l4c_ps_exe_act_req(source_string_ptr->src_id, state, cid);       
        }
        
        if ((kal_bool)return_error_cause == KAL_TRUE)
        {
            return;
        }

        break;
    }
    default:
    {
        /* unrecognized format of AT command line */
        break;
    }
    }   /* end of the switch */
    if (source_string_ptr->cmd_mode == RMMI_SET_OR_EXECUTE_MODE)
    {
        rmmi_result_code_fmttr(RMMI_RCODE_ERROR, return_error_cause);
    }
    else
    {
        rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    }
    return;
} /* end of rmmi_cgact_hdlr */


/*****************************************************************************
 * FUNCTION
 *  rmmi_cgcmod_hdlr
 * DESCRIPTION
 *
 * PARAMETERS
 *  source_string_ptr       [?]
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cgcmod_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 cid;
    kal_uint16 string_length = 0;
    kal_uint16 return_error_cause = RMMI_ERR_UNSPECIFIED;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];

    kal_trace(TRACE_FUNC, FUNC_RMMI_CGCMOD_HDLR_ENTRY);
    switch (source_string_ptr->cmd_mode)
    {
    case RMMI_TEST_MODE:
    {
        rsp_str = &buffer[0];
        ret_val = l4ctcm_test_modify_info(&rsp_str);
        string_length = strlen((char*)rsp_str);
        break;
    }
    case RMMI_SET_OR_EXECUTE_MODE:
    {
        /* parse <cid> */
        cid = (kal_uint8) rmmi_int_validator(
                  source_string_ptr,
                  RMMI_PTR->s_reg.s3 /* separator */ );

        if (cid == RMMI_VALIDATOR_ERROR)
        {
            return_error_cause = L4C_AT_CMD_INVALID_PARAMETER_OR_MISSING;
            break;
        }
        else
        {
            if (cid == 0)
            {
                return_error_cause = L4C_AT_CMD_CID_UNEXPECTED;
                break;
            }
        }

        ret_val = l4c_ps_exe_modify_req(source_string_ptr->src_id, cid);
        if (ret_val == KAL_TRUE)
        {
            return;
        }
        return_error_cause = L4C_CMD_CONFLICT;
        break;
    }
    default:
    {
        /* unrecognized format of AT command line */
        break;
    }
    }   /* end of the switch */
    if (source_string_ptr->cmd_mode == RMMI_SET_OR_EXECUTE_MODE)
    {
        rmmi_result_code_fmttr(RMMI_RCODE_ERROR, return_error_cause);
    }
    else
    {
        rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    }
    return;
} /* end of rmmi_cgcmod_hdlr */


/*****************************************************************************
 * FUNCTION
 *  rmmi_cgdcont_hdlr
 * DESCRIPTION
 *
 * PARAMETERS
 *  source_string_ptr       [?]
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cgdcont_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 result;
    kal_uint8 i, num;
    kal_uint8 pdp_type[10], pdp_addr[IPV4_ADDR_LEN*4+1]; //mtk02285, AT+CGDCONT? is used to return user setting. It's impossible to have IPV6/IPV4V6 address
    kal_uint8 *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN+MAX_APN_LEN]; // MAUI_01571578, mtk02285, 20090407
    kal_uint16 string_length = 0;
    kal_uint16 return_error_cause = RMMI_ERR_UNSPECIFIED;
    l4c_prim_pdp_info_struct pdp;
    l4c_prim_pdp_info_list_struct *pdp_list;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    kal_trace(TRACE_FUNC, FUNC_RMMI_CGDCONT_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    case RMMI_TEST_MODE:
    {
        rsp_str = &buffer[0]; //MAUI_02633724
        ret_val = l4ctcm_test_pri_pdp_info(&rsp_str);
        string_length = strlen((char*)rsp_str);
        break;
    }
    case RMMI_READ_MODE:
    {

        ASSERT(sizeof(l4c_prim_pdp_info_list_struct) < 2048);
        pdp_list = (l4c_prim_pdp_info_list_struct*) get_ctrl_buffer(sizeof(l4c_prim_pdp_info_list_struct));

        ret_val = l4c_ps_get_definition_list_req(source_string_ptr->src_id, pdp_list);
        if (ret_val == KAL_TRUE)
        {
            for (i = 0; i < pdp_list->length; i++)
            {
                rmmi_ptr->arg_list[0] = (void*)&pdp_list->prim_pdp_info[i].context_id;
                check_pdp_type_name((kal_uint8) pdp_list->prim_pdp_info[i].pdp_type, (kal_uint8*) pdp_type);
                rmmi_ptr->arg_list[1] = (void*)pdp_type;
                if (pdp_list->prim_pdp_info[i].apn_length == 0)
                {
                    pdp_list->prim_pdp_info[i].apn[0] = '\0';
                }
                else
                {
                    pdp_list->prim_pdp_info[i].apn[pdp_list->prim_pdp_info[i].apn_length] = 0;
                }
                rmmi_ptr->arg_list[2] = (void*)&pdp_list->prim_pdp_info[i].apn;
                //030610 mtk00468 modify for bug in cgdcont query with trash code
                if ((pdp_list->prim_pdp_info[i].pdp_addr_len == NULL_PDP_ADDR_LEN)
                        || (pdp_list->prim_pdp_info[i].pdp_addr_len > IPV4_ADDR_LEN)) //mtk02285, AT+CGDCONT? is used to return user setting. It's impossible to have IPV6/IPV4V6 address
                {
                    //pdp_list->prim_pdp_info[i].addr_val[0] = '\0';
                    //pdp_addr[0] = 0;
                    strcpy((char*)pdp_addr, "0.0.0.0"); // [MAUI_03008178] for Linux dial-up
                }
                else
                {
                    pdp_list->prim_pdp_info[i].addr_val[pdp_list->prim_pdp_info[i].pdp_addr_len] = 0;
                    //}
                    rmmi_u8_to_dotstring(
                        pdp_list->prim_pdp_info[i].addr_val,
                        (kal_uint8*) pdp_addr,
                        (kal_uint8) pdp_list->prim_pdp_info[i].pdp_addr_len);

                }
                rmmi_ptr->arg_list[3] = (void*)pdp_addr;
                rmmi_ptr->arg_list[4] = (void*)&pdp_list->prim_pdp_info[i].dcomp_algo;
                rmmi_ptr->arg_list[5] = (void*)&pdp_list->prim_pdp_info[i].hcomp_algo;
#ifdef __REL8__
                rmmi_ptr->arg_list[6] = (void*)&pdp_list->prim_pdp_info[i].ipv4addralloc;
                string_length = rmmi_fast_string_print(
                                    buffer,
                                    (kal_uint8*) "+CGDCONT: %d, \"%s\", \"%s\", \"%s\", %d, %d, %d",
                                    rmmi_ptr->arg_list,
                                    7);
#else /* not __REL8__ */
                string_length = rmmi_fast_string_print(
                                    buffer,
                                    (kal_uint8*) "+CGDCONT: %d, \"%s\", \"%s\", \"%s\", %d, %d",
                                    rmmi_ptr->arg_list,
                                    6);
#endif /* __REL8__ */
                rsp_str = &buffer[0];
                rmmi_write_to_uart((kal_uint8*) rsp_str, string_length, KAL_TRUE);
            }
            string_length = 0;
        }
        free_ctrl_buffer(pdp_list);
        break;
    }
    case RMMI_SET_OR_EXECUTE_MODE:
    {
        kal_uint8 error_cause;

        kal_mem_set(&pdp, 0xFF, sizeof(l4c_prim_pdp_info_struct));
        pdp.context_id = (kal_uint8) rmmi_int_validator_ext(
                             &error_cause,
                             source_string_ptr,
                             (kal_uint8) RMMI_COMMA);

        if (pdp.context_id == RMMI_VALIDATOR_ERROR)
        {
            return_error_cause = L4C_AT_CMD_INVALID_PARAMETER_OR_MISSING;
            break;
        }
        else if ((pdp.context_id > MAX_EXT_PDP_CONTEXT) || (pdp.context_id == 0))
        {
            return_error_cause = L4C_AT_CMD_CID_UNEXPECTED;
            break;
        }

        result = rmmi_string_validator_ext(
                     &error_cause,
                     source_string_ptr,
                     (kal_uint8) RMMI_COMMA,
                     10,
                     (kal_uint8*) pdp_type);
        pdp.pdp_type = (pdp_addr_type_enum)check_pdp_type_code(pdp_type);

        if (result == RMMI_VALIDATOR_ERROR && error_cause == RMMI_PARSE_NOT_FOUND)
        {
            ret_val = l4c_ps_exe_undefine_req(source_string_ptr->src_id, pdp.context_id, CGDCONT_EXE);
            if (ret_val == KAL_TRUE)
            {
                return;
            }
            else
            {
                return_error_cause = L4C_CMD_CONFLICT;
                break;
            }
        }

        if (pdp.pdp_type == NULL_PDP_ADDR_TYPE && !(result == RMMI_VALIDATOR_ERROR && error_cause == RMMI_PARSE_NOT_FOUND))
        {
            //return_error_cause = L4C_CONTEXT_CONFLICT_DEACT_ALREADY_DEACTIVATED;
            // Reject Cause: AT wrong param: invalid param
            return_error_cause = L4C_AT_CMD_INVALID_PARAMETER;
            break;  //mtk00924_060306: pdp_type is not a NULL string but a type not allowed.
        }

        result = rmmi_string_validator_ext(
                     &error_cause,
                     source_string_ptr,
                     (kal_uint8) RMMI_COMMA,
                     MAX_APN_LEN,
                     (kal_uint8*) pdp.apn);

        //mtk01616_071017:  empty APN (null string) shall be okay
        if (result == RMMI_VALIDATOR_ERROR && error_cause != RMMI_PARSE_NOT_FOUND && error_cause != RMMI_PARSE_OK)
        {
            // Reject Cause: AT wrong param: invalid param
            return_error_cause = L4C_AT_CMD_INVALID_PARAMETER;
            break;
        }

        pdp.apn_length = strlen((char*)pdp.apn);

        result = rmmi_string_validator(source_string_ptr, (kal_uint8) RMMI_COMMA, 16, (kal_uint8*) pdp_addr);

        //if(result == RMMI_VALIDATOR_ERROR)
        //    break;

        if (pdp.pdp_type == IPV4_ADDR_TYPE)
        {
            //MAUI_02555586 mtk02126 refine check_dotted_value8
            num = check_dotted_value8(pdp_addr, pdp.addr_val, MAX_PDP_ADDR_LEN);
            if (RMMI_VALIDATOR_ERROR == num)
            {
                // Reject Cause: PDP address value have no dot
                return_error_cause = L4C_AT_CMD_INVALID_PARAMETER;
                break;
            }

            if (strlen((char*)pdp_addr) != 0)
            {
                pdp.pdp_addr_len = IPV4_ADDR_LEN;
            }
            else
            {
                pdp.pdp_addr_len = NULL_PDP_ADDR_LEN;
            }
        }

        pdp.dcomp_algo = (kal_uint8) rmmi_int_validator_ext(
                             (kal_uint8*) & error_cause,
                             source_string_ptr,
                             (kal_uint8) RMMI_COMMA);
        if (pdp.dcomp_algo == RMMI_VALIDATOR_ERROR)
        {
            if (error_cause == RMMI_PARSE_ERROR)
            {
                return_error_cause = L4C_AT_CMD_INVALID_PARAMETER;
                break;
            }
            else if (error_cause == RMMI_PARSE_NOT_FOUND)
            {
                pdp.dcomp_algo = 0;
            }
        }

        pdp.hcomp_algo = (kal_uint8) rmmi_int_validator_ext(
                             (kal_uint8*) & error_cause,
                             source_string_ptr,
                             (kal_uint8) RMMI_COMMA             );
        if (pdp.hcomp_algo == RMMI_VALIDATOR_ERROR)
        {
            if (error_cause == RMMI_PARSE_ERROR)
            {
                return_error_cause = L4C_AT_CMD_INVALID_PARAMETER;
                break;
            }
            else if (error_cause == RMMI_PARSE_NOT_FOUND)
            {
                pdp.hcomp_algo = 0;
            }
        }

#ifdef __REL8__
        pdp.ipv4addralloc = (kal_uint8)rmmi_int_validator_range_check(&error_cause, source_string_ptr, RMMI_PTR->s_reg.s3, 1);
        if (error_cause != RMMI_PARSE_OK)
        {
            if (error_cause == RMMI_PARSE_NOT_FOUND)
            {
                pdp.ipv4addralloc = 0;
            }
            else
            {
                return_error_cause = L4C_AT_CMD_INVALID_PARAMETER;
                break;
            }
        }
#endif /* __REL8__ */

        ret_val = l4c_ps_set_definition_req(source_string_ptr->src_id, &pdp);

        if (ret_val == KAL_TRUE)
        {
            return;
        }
        return_error_cause = L4C_CMD_CONFLICT;
        break;
    }
    default:
    {
        /* unrecognized format of AT command line */
        break;
    }
    }   /* end of the switch */
    if (source_string_ptr->cmd_mode == RMMI_SET_OR_EXECUTE_MODE)
    {
        rmmi_result_code_fmttr(RMMI_RCODE_ERROR, return_error_cause);
    }
    else
    {
        rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    }
    return;
} /* end of rmmi_cgdcont_hdlr */


/*****************************************************************************
 * FUNCTION
 *  rmmi_cgsdata_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for sending uplink data to NW.
 *  mtk00468 add on 06/26
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cgsdata_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint32 bytes;   //number of bytes
    kal_uint8 cid;
    kal_uint8 error_cause;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CGSDATA_HDLR_ENTRY);

    // checking the command mode
    switch (source_string_ptr->cmd_mode)
    {
    case RMMI_SET_OR_EXECUTE_MODE: // at+cgsdata = 500 send 500 byte
    {
        // Get the seed from the command line and validate it
        bytes = rmmi_int_validator(source_string_ptr, (kal_uint8) RMMI_COMMA);

        if (bytes == 0)     //wrong byte number
        {
            break;
        }

        cid = (kal_uint8) rmmi_int_validator_ext(
                  &error_cause,
                  source_string_ptr,
                  RMMI_PTR->s_reg.s3);

        if (cid  == RMMI_VALIDATOR_ERROR)
        {
            if (error_cause == RMMI_PARSE_NOT_FOUND)
            {
                cid = TCM_AT_PDP_CID;
            }
            else
            {
                break;
            }
        }
        else
        {
#if !defined(__TCPIP__) && !defined(__MULTIPLE_NDIS_SUPPORT__) && !defined(__IPV6__)  //mtk02285, 20120416, IPV6_2_PDP
            if (cid > TCM_AT_PDP_CID)
            {
                break;
            }
#endif
            if (cid == 0 || cid > MAX_EXT_PDP_CONTEXT)
            {
                break;
            }
        }
        ret_val = l4c_ps_exe_send_data_req(source_string_ptr->src_id, cid, bytes);

        if (ret_val == KAL_TRUE)
        {
            return;
        }
        break;

    }
    default:
    {
        //  unrecognized format of AT command line
        break;
    }
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
} /* end of rmmi_cgsdata_hdlr */


/*****************************************************************************
 * FUNCTION
 *  rmmi_acttest_hdlr
 * DESCRIPTION
 *
 * PARAMETERS
 *  source_string_ptr       [?]
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_acttest_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 i, num, state, cid;
    kal_uint8 state_list[TCM_TOT_CONTEXT][2];
    kal_uint16 string_length = 0;

    switch (source_string_ptr->cmd_mode)
    {
    case RMMI_SET_OR_EXECUTE_MODE:
    {
        kal_uint8 error_cause;
        kal_bool do_activate = KAL_TRUE;

        state = (kal_uint8) rmmi_int_validator(source_string_ptr, (kal_uint8) RMMI_COMMA);

        if (state == RMMI_VALIDATOR_ERROR)
        {
            break;
        }
        else if (state > 1)
        {
            break;
        }

        cid = (kal_uint8) rmmi_int_validator_ext(
                  &error_cause,
                  source_string_ptr,
                  RMMI_PTR->s_reg.s3 /* separator */ );

        if (cid == RMMI_VALIDATOR_ERROR)
        {
            if (error_cause == RMMI_PARSE_NOT_FOUND)
            {
                cid = TCM_AT_PDP_CID; //1
            }
            else
            {
                break;
            }
        }
        else
        {
            if ((cid == 0) || (cid > MAX_EXT_PDP_CONTEXT)
#if !defined(__TCPIP__) && !defined (__MULTIPLE_NDIS_SUPPORT__) && !defined(__IPV6__) //mtk02285, 20120416, IPV6_2_PDP
                    || (cid > TCM_AT_PDP_CID)
#endif
               )
            {
                break;
            }
        }

        /* mtk00714: check if the context is already activated */
        if (state == 1)
        {
            ret_val = l4c_ps_get_context_state_req(source_string_ptr->src_id, &num, (kal_uint8*) state_list);
            if (ret_val == KAL_TRUE)
            {
                for (i = 0; i < num; i++)
                {
                    if ((state_list[i][0] == cid) && (state_list[i][1] == state))
                    {
                        do_activate = KAL_FALSE;
                        break;
                    }
                }
            }
        }
        if (do_activate == KAL_FALSE)       //already activated, so we return OK directly.
        {
            break;
        }
        /* End: mtk00714 */

        ret_val = l4c_ps_exe_act_test_req(source_string_ptr->src_id, state, cid);
        if (ret_val == KAL_TRUE)
        {
            return;
        }

        break;
    }
    default:
    {
        /* unrecognized format of AT command line */
        break;
    }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
} /* end of rmmi_acttest_hdlr */


/*****************************************************************************
 * FUNCTION
 *  rmmi_cgqmin_hdlr
 * DESCRIPTION
 *
 * PARAMETERS
 *  source_string_ptr       [?]
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cgqmin_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 i;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    l4c_qos_struct qos;
    l4c_qos_list_struct *qos_list;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    kal_trace(TRACE_FUNC, FUNC_RMMI_CGQMIN_HDLR_ENTRY);
    switch (source_string_ptr->cmd_mode)
    {
#ifdef __test_mode__
    case RMMI_TEST_MODE:
    {
        ret_val = l4ctcm_test_qos_info(ATCI_MIN_QOS, &rsp_str);
        string_length = strlen((char*)rsp_str);
        break;
    }
#endif /* __test_mode__ */
    case RMMI_READ_MODE:
    {
        ASSERT(sizeof(l4c_qos_list_struct) < 2048);
        qos_list = (l4c_qos_list_struct*) get_ctrl_buffer(sizeof(l4c_qos_list_struct));

        ret_val = l4c_ps_get_qos_req(source_string_ptr->src_id, ATCI_MIN_QOS, qos_list);

        if (ret_val == KAL_TRUE)
        {
            for (i = 0; i < qos_list->length; i++)
            {
                rmmi_ptr->arg_list[0] = (void*)&qos_list->qos_info[i].context_id;
                rmmi_ptr->arg_list[1] = (void*)&qos_list->qos_info[i].precedence_class;
                rmmi_ptr->arg_list[2] = (void*)&qos_list->qos_info[i].delay_class;
                rmmi_ptr->arg_list[3] = (void*)&qos_list->qos_info[i].reliability_class;
                rmmi_ptr->arg_list[4] = (void*)&qos_list->qos_info[i].peak_throughput;
                rmmi_ptr->arg_list[5] = (void*)&qos_list->qos_info[i].mean_throughput;
                string_length = rmmi_fast_string_print(
                                    buffer,
                                    (kal_uint8*) "+CGQMIN: %d, %d, %d, %d, %d, %d",
                                    rmmi_ptr->arg_list,
                                    6);
                rsp_str = &buffer[0];
                rmmi_write_to_uart((kal_uint8*) rsp_str, string_length, KAL_TRUE);
            }
            string_length = 0;
        }
        free_ctrl_buffer(qos_list);
        break;
    }
    case RMMI_SET_OR_EXECUTE_MODE:
    {
        kal_uint8 error_cause;

        qos.context_id = (kal_uint8) rmmi_int_validator(source_string_ptr, (kal_uint8) RMMI_COMMA);
        if (qos.context_id == RMMI_VALIDATOR_ERROR)
        {
            break;
        }

        qos.precedence_class = (precedence_class_enum) rmmi_int_validator_ext(
                                   &error_cause,
                                   source_string_ptr,
                                   (kal_uint8) RMMI_COMMA);

        if (qos.precedence_class == RMMI_VALIDATOR_ERROR && error_cause == RMMI_PARSE_NOT_FOUND)
        {
            ret_val = l4c_ps_exe_undefine_req(source_string_ptr->src_id, qos.context_id, CGQMIN_EXE);
            if (ret_val == KAL_TRUE)
            {
                return;
            }
            else
            {
                break;
            }
        }

        if (qos.precedence_class == RMMI_VALIDATOR_ERROR)
        {
            if (error_cause != RMMI_PARSE_NOT_FOUND)
            {
                break;
            }
            else
            {
                qos.precedence_class = SUBSCRIBED_PREC_CLASS;
                qos.delay_class = SUBSCRIBED_DELAY_CLASS;
                qos.reliability_class = SUBSCRIBED_REL_CLASS;
                qos.peak_throughput = SUBSCRIBED_PTC;
                qos.mean_throughput = SUBSCRIBED_MEAN_THROUGHPUT;
            }
        }
        else
        {
            if (qos.precedence_class > 3)
            {
                break;
            }

            qos.delay_class = (delay_class_enum) rmmi_int_validator(source_string_ptr, (kal_uint8) RMMI_COMMA);
            if (qos.delay_class > 4)
            {
                break;
            }

            qos.reliability_class = (reliability_class_enum) rmmi_int_validator(source_string_ptr, (kal_uint8) RMMI_COMMA);
            if (qos.reliability_class > 5)
            {
                break;
            }

            qos.peak_throughput = (peak_throughput_class) rmmi_int_validator(source_string_ptr, (kal_uint8) RMMI_COMMA);
            if (qos.peak_throughput > 9)
            {
                break;
            }

            qos.mean_throughput = (mean_throughput_enum) rmmi_int_validator(
                                      source_string_ptr,
                                      rmmi_ptr->s_reg.s3 /* separator */ );
            if (!((qos.mean_throughput <= 18) || (qos.mean_throughput == 31)))
            {
                break;
            }

        }

        qos.qos_type = ATCI_MIN_QOS;

        ret_val = l4c_ps_set_qos_req(source_string_ptr->src_id, ATCI_MIN_QOS, &qos);

        if (ret_val == KAL_TRUE)
        {
            return;
        }
        break;
    }
    default:
    {
        /* unrecognized format of AT command line */
        break;
    }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
} /* end of rmmi_cgqmin_hdlr */


/*****************************************************************************
 * FUNCTION
 *  rmmi_cgqreq_hdlr
 * DESCRIPTION
 *
 * PARAMETERS
 *  source_string_ptr       [?]
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cgqreq_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 i;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    l4c_qos_struct qos;
    l4c_qos_list_struct *qos_list;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    kal_trace(TRACE_FUNC, FUNC_RMMI_CGQREQ_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
#ifdef __test_mode__
    case RMMI_TEST_MODE:
    {
        ret_val = l4ctcm_test_qos_info(ATCI_REQ_QOS, &rsp_str);
        string_length = strlen((char*)rsp_str);
        break;
    }
#endif /* __test_mode__ */
    case RMMI_READ_MODE:
    {
        ASSERT(sizeof(l4c_qos_list_struct) < 2048);
        qos_list = (l4c_qos_list_struct*) get_ctrl_buffer(sizeof(l4c_qos_list_struct));

        ret_val = l4c_ps_get_qos_req(source_string_ptr->src_id, ATCI_REQ_QOS, qos_list);

        if (ret_val == KAL_TRUE)
        {
            for (i = 0; i < qos_list->length; i++)
            {
                rmmi_ptr->arg_list[0] = (void*)&qos_list->qos_info[i].context_id;
                rmmi_ptr->arg_list[1] = (void*)&qos_list->qos_info[i].precedence_class;
                rmmi_ptr->arg_list[2] = (void*)&qos_list->qos_info[i].delay_class;
                rmmi_ptr->arg_list[3] = (void*)&qos_list->qos_info[i].reliability_class;
                rmmi_ptr->arg_list[4] = (void*)&qos_list->qos_info[i].peak_throughput;
                rmmi_ptr->arg_list[5] = (void*)&qos_list->qos_info[i].mean_throughput;
                string_length = rmmi_fast_string_print(
                                    buffer,
                                    (kal_uint8*) "+CGQREQ: %d, %d, %d, %d, %d, %d",
                                    rmmi_ptr->arg_list,
                                    6);
                rsp_str = &buffer[0];
                rmmi_write_to_uart((kal_uint8*) rsp_str, string_length, KAL_TRUE);
            }
            string_length = 0;
        }
        free_ctrl_buffer(qos_list);
        break;
    }
    case RMMI_SET_OR_EXECUTE_MODE:
    {
        kal_uint8 error_cause;

        qos.context_id = (kal_uint8) rmmi_int_validator(source_string_ptr, (kal_uint8) RMMI_COMMA);
        if (qos.context_id == RMMI_VALIDATOR_ERROR)
        {
            break;
        }

        qos.precedence_class = (precedence_class_enum) rmmi_int_validator_ext(
                                   &error_cause,
                                   source_string_ptr,
                                   (kal_uint8) RMMI_COMMA);

        if (qos.precedence_class == RMMI_VALIDATOR_ERROR && error_cause == RMMI_PARSE_NOT_FOUND)
        {
            ret_val = l4c_ps_exe_undefine_req(source_string_ptr->src_id, qos.context_id, CGQREQ_EXE);
            if (ret_val == KAL_TRUE)
            {
                return;
            }
            else
            {
                break;
            }
        }

        if (qos.precedence_class == RMMI_VALIDATOR_ERROR)
        {
            if (error_cause != RMMI_PARSE_NOT_FOUND)
            {
                break;
            }
            else
            {
                qos.precedence_class = SUBSCRIBED_PREC_CLASS;
                qos.delay_class = SUBSCRIBED_DELAY_CLASS;
                qos.reliability_class = SUBSCRIBED_REL_CLASS;
                qos.peak_throughput = SUBSCRIBED_PTC;
                qos.mean_throughput = SUBSCRIBED_MEAN_THROUGHPUT;
            }
        }
        else
        {
            if (qos.precedence_class > 3)
            {
                break;
            }

            qos.delay_class = (delay_class_enum) rmmi_int_validator(source_string_ptr, (kal_uint8) RMMI_COMMA);
            if (qos.delay_class > 4)
            {
                break;
            }

            qos.reliability_class = (reliability_class_enum) rmmi_int_validator(source_string_ptr, (kal_uint8) RMMI_COMMA);
            if (qos.reliability_class > 5)
            {
                break;
            }

            qos.peak_throughput = (peak_throughput_class) rmmi_int_validator(source_string_ptr, (kal_uint8) RMMI_COMMA);
            if (qos.peak_throughput > 9)
            {
                break;
            }

            qos.mean_throughput = (mean_throughput_enum) rmmi_int_validator(
                                      source_string_ptr,
                                      rmmi_ptr->s_reg.s3 /* separator */ );
            if (!((qos.mean_throughput <= 18) || (qos.mean_throughput == 31)))
            {
                break;
            }

        }

        qos.qos_type = ATCI_REQ_QOS;
        ret_val = l4c_ps_set_qos_req(source_string_ptr->src_id, ATCI_REQ_QOS, &qos);

        if (ret_val == KAL_TRUE)
        {
            return;
        }
        break;
    }

    default:
    {
        /* unrecognized format of AT command line */
        break;
    }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
} /* end of rmmi_cgqreq_hdlr */


#ifdef __R99__ //MAUI_02232041, mtk02285, 20100203

kal_bool l4ctcm_test_eqos_info(atci_qos_enum type, kal_uint8 **rsp_str)
{
    kal_uint8 i = 0;
    kal_uint8 j = 0;
    const kal_uint8 pdp_type_string[4][7] = {"IP",     "PPP",     "IPV6",    "IPV4V6"};
    kal_bool pdp_type_support[4] =          {KAL_TRUE, KAL_FALSE, KAL_FALSE, KAL_FALSE};
    kal_uint8* write_ptr = NULL;
    kal_uint8* buffer_head = NULL;
#ifdef __REL6__
    kal_uint32 bitrate_upper_bound = 256000; //256000Kbps
#else
    kal_uint32 bitrate_upper_bound = 8640;
#endif
    kal_uint8 max_traffic_class = 4;
    kal_uint8 max_delivery_order = 2;
    kal_uint8 max_delivery_of_err_sdu = 3;
    kal_uint8 cgeq_prefix_string[10] = {0}; //"+CGEQREQ:"

    if (rsp_str == NULL) return KAL_FALSE;

    buffer_head = *rsp_str;

#ifdef __PPP_TYPE_PDP_DIALUP_SUPPORT__
    pdp_type_support[1] = KAL_TRUE;
#endif
#ifdef __IPV6__
    pdp_type_support[2] = KAL_TRUE;
#endif
#ifdef __IPV4V6__
    pdp_type_support[3] = KAL_TRUE;
#endif

    if (ATCI_REQ_QOS == type)
    {
        kal_sprintf((char*)cgeq_prefix_string, "+CGEQREQ:");
    }
    else if (ATCI_MIN_QOS == type)
    {
        max_traffic_class--;
        max_delivery_order--;
        max_delivery_of_err_sdu--;
        kal_sprintf((char*)cgeq_prefix_string, "+CGEQMIN:");
    }
    else //if (ATCI_NEG_QOS == type)
    {
        return KAL_FALSE;
    }

    for (i=0; i<4; i++)
    {
        if (KAL_TRUE == pdp_type_support[i])
        {
            //0. this round starts!
            write_ptr = buffer_head;

            //1. max length estimate: <CR><LF>+CGEQREQ: ,"IPV4V6", (0-4), ==> 29 bytes
            write_ptr += kal_sprintf((char*)write_ptr, "\r\n%s \"%s\", (0-%d),", cgeq_prefix_string, pdp_type_string[i], max_traffic_class);
            for (j=0; j<4; j++)
            {   //2. max length estimate: " (0-256000000)," ==> 15 bytes * 4
                write_ptr += kal_sprintf((char*)write_ptr, " (0-%d),", bitrate_upper_bound);
            }
            //3. max length estimate: "(0-2), (0, 10-1500, 1502, 1510, 1520), (" => 40 bytes
            write_ptr += kal_sprintf((char*)write_ptr, "(0-%d), (0, 10-1500, 1502, 1510, 1520), (", max_delivery_order);
            for (j=0; j<8; j++)
            {   //4. max length estimate: "0E0" ==> 6 bytes * 8
                write_ptr += kal_sprintf((char*)write_ptr, "\"%c%c%c\"",
                                         rmmi_sdu_err_ratio_string_table[j][0], rmmi_sdu_err_ratio_string_table[j][1], rmmi_sdu_err_ratio_string_table[j][2]);
                if (j != 7)
                {
                    write_ptr += kal_sprintf((char*)write_ptr, ",");
                }
            }
            //5. max length estimate: "), (" => 4 bytes
            write_ptr += kal_sprintf((char*)write_ptr, "), (");
            for (j=0; j<10; j++)
            {   //6. max length estimate: "0E0" ==> 6 bytes * 8
                write_ptr += kal_sprintf((char*)write_ptr, "\"%c%c%c\"",
                                         rmmi_residual_ber_string_table[j][0], rmmi_residual_ber_string_table[j][1], rmmi_residual_ber_string_table[j][2]);
                if (j != 9)
                {
                    write_ptr += kal_sprintf((char*)write_ptr, ",");
                }
            }
            //7. max length estimate: "), (0-3), (0, 10-150, 200-950, 1000-4000), (0-3)" => 48 bytes
            write_ptr += kal_sprintf((char*)write_ptr, "), (0-%d), (0, 10-150, 200-950, 1000-4000), (0-3)", max_delivery_of_err_sdu);

            //8. this round ends, output it!!
            rmmi_write_to_uart(buffer_head, (kal_uint16)(write_ptr-buffer_head), KAL_FALSE);
        }
    }
    //write_ptr += kal_sprintf((char*)write_ptr, "\r\n"); //max length estimate: 277*4+2 = 1110
    return KAL_TRUE;
}

/* <traffic class>
 * 24.008     27.007      Description      Comment
 *      1          0      conversational
 *      2          1      streaming
 *      3          2      interactive
 *      4          3      background
 *      0          4      subscribed       only for CGEQREQ
 */
#define RMMI_CGEQ_TRAFFIC_CLASS_CONVERT_SM2RMMI(TC) ((0==TC)?(4):(TC-1))
#define RMMI_CGEQ_TRAFFIC_CLASS_CONVERT_RMMI2SM(TC) ((4==TC)?(0):(TC+1))

/* <delivery order>
 * 24.008     27.007      Description      Comment
 *      2          0      no
 *      1          1      yes
 *      0          2      subscribed       only for CGEQREQ
 */
#define RMMI_CGEQ_DELIVERY_ORDER_CONVERT_SM2RMMI(DO) (2-DO)
#define RMMI_CGEQ_DELIVERY_ORDER_CONVERT_RMMI2SM(DO) (2-DO)


/* <delivery of erroneous SDUs>
 * 24.008     27.007      Description      Comment
 *      3          0      no
 *      2          1      yes
 *      1          2      no detect
 *      0          3      subscribed       only for CGEQREQ
 */
#define RMMI_CGEQ_DELIVERY_OF_ERR_SDU_CONVERT_SM2RMMI(DOES) (3-DOES)
#define RMMI_CGEQ_DELIVERY_OF_ERR_SDU_CONVERT_RMMI2SM(DOES) (3-DOES)

void rmmi_cgeq_single_eqos_result_code(kal_bool* ret_ptr, atci_qos_enum qos_type, l4c_eqos_struct *single_eqos, kal_uint8* buffer)
{
    kal_uint8 rmmi_arg_idx = 0;
    kal_uint16 string_length = 0;
    kal_uint8 delivery_order, delivery_of_err_sdu, sdu_err_ratio[4], residual_bit_err_rate[4];
    kal_uint16 sdu_size, delay;
#ifdef __REL6__
    kal_uint32 max_bitrate_up_lnk, max_bitrate_down_lnk, guarntd_bit_rate_up_lnk, guarntd_bit_rate_down_lnk;
#else
    kal_uint16 max_bitrate_up_lnk, max_bitrate_down_lnk, guarntd_bit_rate_up_lnk, guarntd_bit_rate_down_lnk;
#endif

    kal_mem_set(sdu_err_ratio, 0x0, 4);
    kal_mem_set(residual_bit_err_rate, 0x0, 4);

    /* context id */
    RMMI_PTR->arg_list[rmmi_arg_idx++] = (void*)&single_eqos->context_id;

    /* traffic class */
    single_eqos->traffic_class = RMMI_CGEQ_TRAFFIC_CLASS_CONVERT_SM2RMMI(single_eqos->traffic_class);
    RMMI_PTR->arg_list[rmmi_arg_idx++] = (void*)&single_eqos->traffic_class;

    /* max_bitrate_ul */
    *ret_ptr = l4ctcm_decode_bit_rate(
                   (kal_uint16) ((single_eqos->max_bitrate_up_lnk)
#ifdef __REL6__
                                 + ((single_eqos->ext_max_bitrate_up_lnk)<<8)
#endif
                                ),&max_bitrate_up_lnk);
    if (KAL_FALSE == *ret_ptr)
    {
        return;
    }
    RMMI_PTR->arg_list[rmmi_arg_idx++] = (void*)&max_bitrate_up_lnk;

    /* max_bitrate_dl */
    *ret_ptr = l4ctcm_decode_bit_rate(
                   (kal_uint16) ((single_eqos->max_bitrate_down_lnk)
#ifdef __REL6__
                                 + ((single_eqos->ext_max_bitrate_down_lnk)<<8)
#endif
                                ),&max_bitrate_down_lnk);
    if (KAL_FALSE == *ret_ptr)
    {
        return;
    }
    RMMI_PTR->arg_list[rmmi_arg_idx++] = (void*)&max_bitrate_down_lnk;

    /* guarantee_bitrate_ul */
    *ret_ptr = l4ctcm_decode_bit_rate(
                   (kal_uint16) ((single_eqos->guarntd_bit_rate_up_lnk)
#ifdef __REL6__
                                 + ((single_eqos->ext_guarntd_bit_rate_up_lnk)<<8)
#endif
                                ),&guarntd_bit_rate_up_lnk);
    if (KAL_FALSE == *ret_ptr)
    {
        return;
    }
    RMMI_PTR->arg_list[rmmi_arg_idx++] = (void*)&guarntd_bit_rate_up_lnk;

    /* guarantee_bitrate_dl */
    *ret_ptr = l4ctcm_decode_bit_rate(
                   (kal_uint16) ((single_eqos->guarntd_bit_rate_down_lnk)
#ifdef __REL6__
                                 + ((single_eqos->ext_guarntd_bit_rate_down_lnk)<<8)
#endif
                                ),&guarntd_bit_rate_down_lnk);
    if (KAL_FALSE == *ret_ptr)
    {
        return;
    }
    RMMI_PTR->arg_list[rmmi_arg_idx++] = (void*)&guarntd_bit_rate_down_lnk;

    /* delivery order */
    delivery_order = RMMI_CGEQ_DELIVERY_ORDER_CONVERT_SM2RMMI(single_eqos->delivery_order);
    RMMI_PTR->arg_list[rmmi_arg_idx++] = (void*)&delivery_order;

    /* max sdu size */
    *ret_ptr = l4ctcm_decode_sdu_size((kal_uint16) single_eqos->max_sdu_size, &sdu_size); // MAUI_02556157 mtk02126 refine error handling of l4ctcm_decode_bit_rate
    if (KAL_FALSE == *ret_ptr)
    {
        return;
    }
    RMMI_PTR->arg_list[rmmi_arg_idx++] = (void*)&sdu_size;

    /* sdu error ratio */
    if (single_eqos->sdu_err_ratio > 7)
    {
        return;
    }
    else
    {
        strncpy((kal_char*)sdu_err_ratio, (const char*)rmmi_sdu_err_ratio_string_table[single_eqos->sdu_err_ratio], 3);
    }
    RMMI_PTR->arg_list[rmmi_arg_idx++] = (void*)sdu_err_ratio;

    /* residual bit error ratio */
    if (single_eqos->residual_bit_err_rate > 9)
    {
        return;
    }
    else
    {
        strncpy((kal_char*)residual_bit_err_rate, (const char*)rmmi_residual_ber_string_table[single_eqos->residual_bit_err_rate], 3);
    }
    RMMI_PTR->arg_list[rmmi_arg_idx++] = (void*)residual_bit_err_rate;

    /* delivery of erroneous SDUs */
    delivery_of_err_sdu = RMMI_CGEQ_DELIVERY_OF_ERR_SDU_CONVERT_SM2RMMI(single_eqos->delivery_of_err_sdu);
    RMMI_PTR->arg_list[rmmi_arg_idx++] = (void*)&delivery_of_err_sdu;

    /* transfer delay */
    *ret_ptr = l4ctcm_decode_transfer_delay((kal_uint16) single_eqos->transfer_delay, &delay); // MAUI_02556157 mtk02126 refine error handling of l4ctcm_decode_bit_rate
    if (KAL_FALSE == *ret_ptr)
    {
        return;
    }
    RMMI_PTR->arg_list[rmmi_arg_idx++] = (void*)&delay;

    /* traffic handling priority */
    RMMI_PTR->arg_list[rmmi_arg_idx++] = (void*)&single_eqos->traffic_hndl_priority;

    /* Combine all parameters */
    string_length = rmmi_fast_string_print(
                        buffer,
#ifdef __REL6__
                        (kal_uint8*) "+CGEQREQ: %d, %d, %e, %e, %e, %e, %d, %u, \"%s\", \"%s\", %d, %u, %d",
#else
                        (kal_uint8*) "+CGEQREQ: %d, %d, %u, %u, %u, %u, %d, %u, \"%s\", \"%s\", %d, %u, %d",
#endif
                        RMMI_PTR->arg_list,
                        rmmi_arg_idx);
    if (qos_type == ATCI_MIN_QOS)
    {
        buffer[5] = 'M';
        buffer[6] = 'I';
        buffer[7] = 'N';
    }
    else if (qos_type == ATCI_NEG_QOS)
    {
        buffer[5] = 'N';
        buffer[6] = 'E';
        buffer[7] = 'G';
    }
    rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_cgeq_hdlr
 * DESCRIPTION
 *  for both CGEQREQ and CGEQMIN
 * PARAMETERS
 *  source_string_ptr       [?]
 * RETURNS
 *  void
 * NOTES
 *  mtk02126
 *  We don't support extended byte for bitrate field before R6.
 *  This is not exactly the same as spec.(24.008 R5 supports extended byte for bitrate)
 *****************************************************************************/
void rmmi_cgeq_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 i;
    kal_uint8 *rsp_str = NULL;
    kal_uint8 buffer[320]; //the worst cases: TEST_MODE for IPV4V6 types: 273 bytes
    kal_uint16 string_length = 0;
    l4c_eqos_struct eqos;
    l4c_eqos_list_struct *eqos_list;
    atci_qos_enum qos_type = ATCI_MIN_QOS;
    /* if (source_string_ptr->cmd_index == RMMI_CMD_ATCGEQMIN)
    {
        qos_type = ATCI_MIN_QOS;
    }
    else */
    if (source_string_ptr->cmd_index == RMMI_CMD_ATCGEQREQ)
    {
        qos_type = ATCI_REQ_QOS;
    }
    else if (source_string_ptr->cmd_index == RMMI_CMD_ATCGEQNEG)
    {
        qos_type = ATCI_NEG_QOS;
    }
    kal_trace(TRACE_FUNC, FUNC_RMMI_CGEQ_COMMON_HDLR_ENTRY, qos_type);

    switch (source_string_ptr->cmd_mode)
    {
    case RMMI_TEST_MODE:
    {
        rsp_str = &buffer[0];
        if (ATCI_NEG_QOS == qos_type)
        {
            ret_val = l4ctcm_test_negotiated_eqos(&rsp_str);
        }
        else
        {
            ret_val = l4ctcm_test_eqos_info(qos_type, &rsp_str);
            if (KAL_TRUE == ret_val)
            {
                rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
                return;
            }
        }
        string_length = strlen((char*)rsp_str);
        break;
    }
    case RMMI_READ_MODE:
    {
        if (qos_type == ATCI_NEG_QOS)
        {
            break;
        }
        ASSERT(sizeof(l4c_eqos_list_struct) < 2048);
        eqos_list = (l4c_eqos_list_struct*) get_ctrl_buffer(sizeof(l4c_eqos_list_struct));

        ret_val = l4c_ps_get_eqos_req(source_string_ptr->src_id, qos_type, eqos_list);
        if (ret_val == KAL_TRUE)
        {
            for (i = 0; i < eqos_list->length; i++)
            {
                rmmi_cgeq_single_eqos_result_code(&ret_val, qos_type, &(eqos_list->qos_info[i]), buffer);
            }
        }
        free_ctrl_buffer(eqos_list);
        break;
    }
    case RMMI_SET_OR_EXECUTE_MODE:
    {
        kal_uint8 error_cause, result, row_index;
        kal_uint8 temp_sdu_err_ratio[4], temp_residual_bit_err_rate[4], temp_delivery_order,
                  temp_delivery_of_err_sdu;
#ifdef __REL6__
        kal_uint32 temp_bitrate;
#else
        kal_uint16 temp_bitrate;
#endif
        kal_uint16 temp_sdu_size, temp_transfer_delay, value;

        /* Initialize all fields */
        kal_mem_set(&eqos, 0, sizeof(eqos));

        /* get cid */
        eqos.context_id = (kal_uint8)rmmi_int_validator_range_check(&error_cause, source_string_ptr, RMMI_COMMA, MAX_EXT_PDP_CONTEXT);
        if ((error_cause != RMMI_PARSE_OK) || (eqos.context_id == 0))
        {
            break;
        }

        /* get traffic_class */
        eqos.traffic_class = (kal_uint8) rmmi_int_validator_range_check(&error_cause, source_string_ptr, RMMI_COMMA, 4); //traffic class is 1 to 4
        if (error_cause == RMMI_PARSE_OK)
        {
            if (source_string_ptr->cmd_index == RMMI_CMD_ATCGEQNEG)
            {
                break; //do not support multiple <cid> for CGEQNEG
            }
            else
            {
                if (source_string_ptr->cmd_index == RMMI_CMD_ATCGEQMIN && eqos.traffic_class > 3)
                {   //it is not reasonalbe for CGEQMIN to specify 4 (subscribed value)
                    break;
                }
                eqos.traffic_class = RMMI_CGEQ_TRAFFIC_CLASS_CONVERT_RMMI2SM(eqos.traffic_class);
            }
        }
        else if (error_cause == RMMI_PARSE_NOT_FOUND)
        {
            if (source_string_ptr->cmd_index == RMMI_CMD_ATCGEQNEG)
            {
                ASSERT(sizeof(l4c_eqos_list_struct) < 2048);
                eqos_list = (l4c_eqos_list_struct*) get_ctrl_buffer(sizeof(l4c_eqos_list_struct));
                ret_val = l4c_ps_get_eqos_req(source_string_ptr->src_id, qos_type, eqos_list);
                if (ret_val == KAL_TRUE)
                {
                    for (i = 0; i < eqos_list->length; i++)
                    {
                        if (eqos_list->qos_info[i].context_id == eqos.context_id)
                        {
                            rmmi_cgeq_single_eqos_result_code(&ret_val, qos_type, &(eqos_list->qos_info[i]), buffer);
                        }
                    }
                }
                free_ctrl_buffer(eqos_list);
                break;
            }
            else
            {   // this is CGEQREQ/CGEQMIN undefine
                ret_val = l4c_ps_exe_undefine_req(
                              source_string_ptr->src_id,
                              eqos.context_id,
                              (source_string_ptr->cmd_index == RMMI_CMD_ATCGEQMIN)?(CGEQMIN_EXE):(CGEQREQ_EXE)
                          );
                if (ret_val == KAL_TRUE)
                {
                    return;
                }
                else
                {
                    break;
                }
            }
        }
        else
        {
            break;
        }

        /* get max_bitrate_up_lnk */
#ifdef __REL6__
        temp_bitrate = rmmi_int_validator_u32_check(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);
#else
        temp_bitrate = rmmi_int_validator_u16_check(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);
#endif
        if (error_cause == RMMI_PARSE_OK)
        {
            if (KAL_TRUE == l4ctcm_encode_bit_rate(temp_bitrate, &value))
            {
                eqos.max_bitrate_up_lnk = (kal_uint8) value;
#ifdef __REL6__
                eqos.ext_max_bitrate_up_lnk = (kal_uint8) (value>>8);
#endif
            }
            else
            {
                RMMI_PTR->cmee_err = RMMI_ERR_SYNTEX_ERROR;
                break;
            }
        }
        else if (error_cause == RMMI_PARSE_NOT_FOUND)
        {
#if 0
/* under construction !*/
#ifdef __REL6__
/* under construction !*/
#endif
#endif
        }
        else
        {
            break;
        }

        /* get max_bitrate_down_lnk */
#ifdef __REL6__
        temp_bitrate = rmmi_int_validator_u32_check(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);
#else
        temp_bitrate = rmmi_int_validator_u16_check(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);
#endif
        if (error_cause == RMMI_PARSE_OK)
        {
            if (KAL_TRUE == l4ctcm_encode_bit_rate(temp_bitrate, &value))
            {
                eqos.max_bitrate_down_lnk = (kal_uint8) value;
#ifdef __REL6__
                eqos.ext_max_bitrate_down_lnk = (kal_uint8) (value>>8);
#endif
            }
            else
            {
                RMMI_PTR->cmee_err = RMMI_ERR_SYNTEX_ERROR;
                break;
            }
        }
        else if (error_cause == RMMI_PARSE_NOT_FOUND)
        {
#if 0
/* under construction !*/
#ifdef __REL6__
/* under construction !*/
#endif
#endif
        }
        else
        {
            break;
        }

        /* get guarntd_bit_rate_up_lnk */
#ifdef __REL6__
        temp_bitrate = rmmi_int_validator_u32_check(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);
#else
        temp_bitrate = rmmi_int_validator_u16_check(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);
#endif
        if (error_cause == RMMI_PARSE_OK)
        {
            if (KAL_TRUE == l4ctcm_encode_bit_rate(temp_bitrate, &value))
            {
                eqos.guarntd_bit_rate_up_lnk = (kal_uint8) value;
#ifdef __REL6__
                eqos.ext_guarntd_bit_rate_up_lnk = (kal_uint8) (value>>8);
#endif
            }
            else
            {
                RMMI_PTR->cmee_err = RMMI_ERR_SYNTEX_ERROR;
                break;
            }
        }
        else if (error_cause == RMMI_PARSE_NOT_FOUND)
        {
#if 0
/* under construction !*/
#ifdef __REL6__
/* under construction !*/
#endif
#endif
        }
        else
        {
            break;
        }

        /* get guarntd_bit_rate_down_lnk */
#ifdef __REL6__
        temp_bitrate = rmmi_int_validator_u32_check(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);
#else
        temp_bitrate = rmmi_int_validator_u16_check(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);
#endif
        if (error_cause == RMMI_PARSE_OK)
        {
            if (KAL_TRUE == l4ctcm_encode_bit_rate(temp_bitrate, &value))
            {
                eqos.guarntd_bit_rate_down_lnk = (kal_uint8) value;
#ifdef __REL6__
                eqos.ext_guarntd_bit_rate_down_lnk = (kal_uint8) (value>>8);
#endif
            }
            else
            {
                RMMI_PTR->cmee_err = RMMI_ERR_SYNTEX_ERROR;
                break;
            }
        }
        else if (error_cause == RMMI_PARSE_NOT_FOUND)
        {
#if 0
/* under construction !*/
#ifdef __REL6__
/* under construction !*/
#endif
#endif
        }
        else
        {
            break;
        }


        /* get delivery_order */
        temp_delivery_order = (kal_uint8) rmmi_int_validator_range_check(&error_cause, source_string_ptr, RMMI_COMMA, 2); //delivery order: 0 to 2
        if (error_cause == RMMI_PARSE_OK)
        {
            if (source_string_ptr->cmd_index == RMMI_CMD_ATCGEQMIN && temp_delivery_order > 1)
            {   //it is not reasonalbe for CGEQMIN to specify 2 (subscribed value)
                break;
            }
            else
            {
                eqos.delivery_order = RMMI_CGEQ_DELIVERY_ORDER_CONVERT_RMMI2SM(temp_delivery_order);
            }
        }
        else if (error_cause == RMMI_PARSE_NOT_FOUND)
        {
#if 0
/* under construction !*/
#endif
        }
        else
        {
            break;
        }

        /* get max_sdu_size */
        temp_sdu_size = (kal_uint16) rmmi_int_validator_u16_check(&error_cause, source_string_ptr, RMMI_COMMA);
        if (error_cause == RMMI_PARSE_OK)
        {
            if ((temp_sdu_size == 0) ||
                    (temp_sdu_size == 1502) ||
                    (temp_sdu_size == 1510) ||
                    (temp_sdu_size == 1520) || (temp_sdu_size >= 10 && temp_sdu_size <= 1500))
            {
                if (KAL_TRUE == l4ctcm_encode_sdu_size(temp_sdu_size, &value))
                {
                    eqos.max_sdu_size = (kal_uint8) value;
                }
                else
                {
                    RMMI_PTR->cmee_err = RMMI_ERR_SYNTEX_ERROR;
                    break;
                }
            }
            else
            {
                break;
            }
        }
        else if (error_cause == RMMI_PARSE_NOT_FOUND)
        {
#if 0
/* under construction !*/
#endif
        }
        else
        {
            break;
        }

        /* get sdu_err_ratio */
        result = rmmi_string_validator_ext(
                     &error_cause,
                     source_string_ptr,
                     (kal_uint8) RMMI_COMMA,
                     4,
                     (kal_uint8*) temp_sdu_err_ratio);

        if (result == RMMI_VALIDATOR_ERROR)
        {
            if (error_cause == RMMI_PARSE_TEXT_TOO_LONG)
            {
                RMMI_PTR->cmee_err = TEXT_ERRSTRING_TOO_LONG_ERR;
                break;
            }
            else if (error_cause == RMMI_PARSE_NOT_FOUND)
            {
#if 0
/* under construction !*/
#endif
            }
            else
            {
                break;
            }

        }
        else //result != RMMI_VALIDATOR_ERROR
        {
            if (temp_sdu_err_ratio[1] == rmmi_char_e)
            {
                temp_sdu_err_ratio[1] = RMMI_CHAR_E;
            }
            for (row_index = 0; row_index < 8; row_index++)
            {
                if (0 == strncmp((kal_char*)temp_sdu_err_ratio, (const char*)rmmi_sdu_err_ratio_string_table[row_index],3))
                {
                    eqos.sdu_err_ratio = row_index;
                    break;
                }
            }
            if (row_index >= 8)
            {
                break;
            }
        }

        /* get residual_bit_err_rate */
        result = rmmi_string_validator_ext(
                     &error_cause,
                     source_string_ptr,
                     (kal_uint8) RMMI_COMMA,
                     4,
                     (kal_uint8*) temp_residual_bit_err_rate);

        if (result == RMMI_VALIDATOR_ERROR)
        {
            if (error_cause == RMMI_PARSE_TEXT_TOO_LONG)
            {
                RMMI_PTR->cmee_err = TEXT_ERRSTRING_TOO_LONG_ERR;
                break;
            }
            else if (error_cause == RMMI_PARSE_NOT_FOUND)
            {
#if 0
/* under construction !*/
#endif
            }
            else
            {
                break;
            }
        }
        else //result != RMMI_VALIDATOR_ERROR
        {
            if (temp_residual_bit_err_rate[1] == rmmi_char_e)
            {
                temp_residual_bit_err_rate[1] = RMMI_CHAR_E;
            }
            for (row_index = 0; row_index < 10; row_index++)
            {
                if (0 == strncmp((kal_char*)temp_residual_bit_err_rate, (const char*)rmmi_residual_ber_string_table[row_index],3))
                {
                    eqos.residual_bit_err_rate = row_index;
                    break;
                }
            }
            if (row_index >= 10)
            {
                break;
            }
        }

        /* get delivery_of_err_sdu */
        temp_delivery_of_err_sdu = rmmi_int_validator_range_check(&error_cause, source_string_ptr, RMMI_COMMA, 3); //delivery of err sdu: 0 to 3
        if (error_cause == RMMI_PARSE_OK)
        {
            if (source_string_ptr->cmd_index == RMMI_CMD_ATCGEQMIN && temp_delivery_of_err_sdu > 2)
            {   //it is not reasonalbe for CGEQMIN to specify 3 (subscribed value)
                break;
            }
            else
            {
                eqos.delivery_of_err_sdu = RMMI_CGEQ_DELIVERY_OF_ERR_SDU_CONVERT_RMMI2SM(temp_delivery_of_err_sdu);
            }
        }
        else if (error_cause == RMMI_PARSE_NOT_FOUND)
        {
#if 0
/* under construction !*/
#endif
        }
        else
        {
            break;
        }

        /* get transfer_delay */
        temp_transfer_delay = rmmi_int_validator_u16_check(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);
        if (error_cause == RMMI_PARSE_OK)
        {
            if (KAL_TRUE == l4ctcm_encode_transfer_delay(temp_transfer_delay, &value))
            {
                eqos.transfer_delay = (kal_uint8) value;
            }
            else
            {
                RMMI_PTR->cmee_err = RMMI_ERR_SYNTEX_ERROR;
                break;
            }
        }
        else if (error_cause == RMMI_PARSE_NOT_FOUND)
        {
#if 0
/* under construction !*/
#endif
        }
        else
        {
            break;
        }

        /* get traffic_hndl_priority */
        eqos.traffic_hndl_priority = rmmi_int_validator_u8_check(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);
        if (error_cause == RMMI_PARSE_OK)
        {
            if (eqos.traffic_hndl_priority > 3)
            {
                break;
            }
        }
        else if (error_cause == RMMI_PARSE_NOT_FOUND)
        {
            eqos.traffic_hndl_priority = 0;     //don't care, depend on network setting
        }
        else
        {
            break;
        }
        eqos.qos_type = qos_type;
        ret_val = l4c_ps_set_eqos_req(source_string_ptr->src_id, qos_type, &eqos);
        if (ret_val == KAL_TRUE)
        {
            return;
        }
        break;
    }
    default:
    {
        /* unrecognized format of AT command line */
        break;
    }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}
#endif /* __R99__ */
#endif /* __EXT_PDP_CONTEXT_ON__ */
#endif /* !defined(__ULC_AT__) */


// !defined(__SLIM_AT__)
//     - feature option to enable/disable Secondary PDP support for RMMI
//     - This shall be build error, if TCM is unavailable to support corresponding context and code logic
//
// [L4C] __APP_SECONDARY_PDP_SUPPORT__    NOT__SLIM_AT__
// [TCM] Internal 2nd PDP Support         External 2nd PDP Support
#if !defined(__SLIM_AT__)
#if defined(__EXT_PDP_CONTEXT_ON__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_cgans_hdlr
 * DESCRIPTION
 *
 * PARAMETERS
 *  source_string_ptr       [?]
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cgans_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;

    //kal_uint8        buffer[RMMI_SHORT_RSP_LEN];
    kal_uint8 response, cid, l2p = TCM_PPP_L2P;
    kal_uint16 string_length = 0;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CGANS_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
#ifdef __test_mode__
    case RMMI_TEST_MODE:
    {
        //ret_val = l4ctcm_test_answer_mode (&rsp_str);
        kal_sprintf((kal_char*) buffer, "+CGANS: (0-1), \"PPP\"");
        rsp_str = &buffer[0];
        string_length = strlen((char*)rsp_str);
        ret_val = KAL_TRUE;
        break;
    }
#endif /* __test_mode__ */
    case RMMI_SET_OR_EXECUTE_MODE:
    {
        kal_uint8 error_cause;
        kal_uint8 l2p_str[4];
        kal_uint8 result;

        response = (kal_uint8) rmmi_int_validator(source_string_ptr, (kal_uint8) RMMI_COMMA);

        //if (response == RMMI_VALIDATOR_ERROR)
        if (response > 1)
        {
            break;
        }

        result = (kal_uint8) rmmi_string_validator_ext(
                     &error_cause,
                     source_string_ptr,
                     (kal_uint8) RMMI_COMMA,
                     4,
                     (kal_uint8*) l2p_str);

        if (result == RMMI_VALIDATOR_ERROR)
        {
            if (error_cause != RMMI_PARSE_NOT_FOUND)
            {
                break;
            }
        }
        else if (strcmp((char*)l2p_str, "PPP") != 0)
        {
            break;
        }

        cid = (kal_uint8) rmmi_int_validator_ext(
                  &error_cause,
                  source_string_ptr,
                  RMMI_PTR->s_reg.s3 /* separator */ );

        if (cid == RMMI_VALIDATOR_ERROR)
        {
            if (error_cause == RMMI_PARSE_NOT_FOUND)
            {
                cid = 1;
            }
            else
            {
                break;
            }
        }

        ret_val = l4c_ps_exe_answer_req(source_string_ptr->src_id, response, l2p, cid);

        /* mtk02126 MAUI_02420760
         * If success && response == 1, we'll respond while receiving MSG_ID_TCM_PDP_ACTIVATE_CNF
         * For other cases(cgans=0 & success), we need to rspond according to ret_val in the end of this function.
         */
        if (ret_val == KAL_TRUE && 1 == response)
        {
            return;
        }
        break;
    }
    default:
    {
        /* unrecognized format of AT command line */
        break;
    }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_cgauto_hdlr
 * DESCRIPTION
 *
 * PARAMETERS
 *  source_string_ptr       [?]
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cgauto_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 mode;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim
    l4c_context_struct *l4c_ptr = L4C_PTR; //for slim

    kal_trace(TRACE_FUNC, FUNC_RMMI_CGAUTO_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
#ifdef __test_mode__
    case RMMI_TEST_MODE:
    {
        kal_sprintf((kal_char*) buffer, "+CGAUTO: (0,1)");
        string_length = strlen((char*)buffer);
        rsp_str = &buffer[0];
        ret_val = KAL_TRUE;
        break;
    }
#endif /* __test_mode__ */
    case RMMI_READ_MODE:
    {
        rmmi_ptr->arg_list[0] = (void*)&l4c_ptr->tcm_auto_answer;
        string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CGAUTO: %d", rmmi_ptr->arg_list, 1);
        rsp_str = &buffer[0];
        ret_val = KAL_TRUE;
        break;
    }
    case RMMI_SET_OR_EXECUTE_MODE:
    {
        kal_uint8 status;

        mode = (kal_uint8) rmmi_int_validator(
                   source_string_ptr,
                   rmmi_ptr->s_reg.s3 /* separator */ );

        if (mode > 1)
        {
            break;
        }
        if (mode == 0)
        {
            l4c_ptr->tcm_auto_answer = KAL_FALSE;
            ret_val = KAL_TRUE;
        }
        else        //mode == 1
        {
            l4c_ptr->tcm_auto_answer = KAL_TRUE;
            l4c_nw_get_attach_status_req(source_string_ptr->src_id, RAC_PS, &status);
            if ((status != REG_STATE_REGISTERED) && (status != REG_STATE_SEARCHING))        // not attach => request attach
            {
                ret_val = l4c_nw_exe_att_req(source_string_ptr->src_id, RAC_PS, RAC_ATTACH, KAL_FALSE);
                if (ret_val == KAL_TRUE)
                {
                    return;
                }
            }
            else    // already attached, return OK
            {
                ret_val = KAL_TRUE;
            }
        }
        break;
    }
    default:
    {
        /* unrecognized format of AT command line */
        break;
    }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_cgpaddr_hdlr
 * DESCRIPTION
 *
 * PARAMETERS
 *  source_string_ptr       [?]
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cgpaddr_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 cid;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    kal_uint8 addr_len = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
#ifdef __IPV6__
    kal_uint8 addr[IPV4V6_ADDR_LEN]; //IPV6_TODO: extend to 20
#else
    kal_uint8 addr[IPV4_ADDR_LEN];
#endif

    kal_trace(TRACE_FUNC, FUNC_RMMI_CGPADDR_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    case RMMI_TEST_MODE:
    {
        rsp_str = &buffer[0]; //MAX_EXT_PDP_CONTEXT_revise, mtk02285, 20100203
        ret_val = l4ctcm_test_pdp_addr(&rsp_str);
        string_length = strlen((char*)rsp_str);
        break;
    }
    case RMMI_SET_OR_EXECUTE_MODE:
    {
        cid = (kal_uint8) rmmi_int_validator(
                  source_string_ptr,
                  rmmi_ptr->s_reg.s3 /* separator */ );

        if (cid == RMMI_VALIDATOR_ERROR)
        {
            break;
        }
        else if (cid == 0)
        {
            break;  //<cid> start from 1
        }

        ret_val = l4c_ps_get_pdp_addr_req(source_string_ptr->src_id, cid, addr, &addr_len);

        if (ret_val == KAL_FALSE)
        {
            break;
        }

        if (addr[0] == '\0')        //print null string
        {
            sprintf((kal_char*)buffer, "+CGPADDR: %d, \"\"", cid);
            string_length = strlen((const char*)buffer);
        }
        else        //addr is a ip address
        {
            kal_uint8 pdp_addr1[IPV6_ADDR_LEN*4+1];
#if defined(__IPV4V6__)
            kal_uint8 pdp_addr2[IPV6_ADDR_LEN*4+1];
#endif

            kal_mem_set(pdp_addr1, 0, sizeof(pdp_addr1));
#if defined(__IPV4V6__)
            kal_mem_set(pdp_addr2, 0, sizeof(pdp_addr2));
            if (IPV4V6_ADDR_LEN == addr_len)
            {
                rmmi_u8_to_dotstring(addr, pdp_addr1, IPV4_ADDR_LEN); //V4 addr
                rmmi_u8_to_dotstring(addr+IPV4_ADDR_LEN, pdp_addr2, IPV6_ADDR_LEN); //V6 addr
                sprintf((kal_char*)buffer, "+CGPADDR: %d, \"%s\", \"%s\"", cid, pdp_addr1, pdp_addr2);
            }
            else
#endif /* __IPV4V6__ */
                if ((IPV6_ADDR_LEN == addr_len) || (IPV4_ADDR_LEN == addr_len))
                {
                    //Single addr
                    rmmi_u8_to_dotstring(addr, pdp_addr1, addr_len);
                    sprintf((kal_char*)buffer, "+CGPADDR: %d, \"%s\"", cid, pdp_addr1);
                }
                else
                {
                    ASSERT(0);
                }
            string_length = strlen((const char*)buffer);
        } //IPV6_TODO: handle IPV6 address

        rsp_str = &buffer[0];
        ret_val = KAL_TRUE;
        break;
    }
    default:
    {
        /* unrecognized format of AT command line */
        break;
    }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
} /* end of rmmi_cgpaddr_hdlr */


/*****************************************************************************
 * FUNCTION
 *  rmmi_egpau_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for ppp auth info request
 *  mtk00468 add on 10/15
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_egpau_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 op, cid;  //number of bytes
    kal_uint8 is_chap;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    kal_trace(TRACE_FUNC, FUNC_RMMI_CGSDATA_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    case RMMI_TEST_MODE:
    {
        rsp_str = &buffer[0]; //MAX_EXT_PDP_CONTEXT_revise, mtk02285, 20100203
        ret_val = l4ctcm_test_ppp_auth(&rsp_str);
        string_length = strlen((char*)rsp_str);
        break;
    }
    case RMMI_SET_OR_EXECUTE_MODE:
    {
        op = (kal_uint8) rmmi_int_validator(source_string_ptr, RMMI_COMMA);
        if (op > 1)
        {
            break;
        }

        if (op == 0)        //read
        {
            cid = (kal_uint8) rmmi_int_validator(source_string_ptr, rmmi_ptr->s_reg.s3);
            if (cid < 1 || cid > MAX_EXT_PDP_CONTEXT)
            {
                break;
            }

            l4ctcm_get_ppp_auth(cid, &is_chap);
            rmmi_ptr->arg_list[0] = (void*)&is_chap;
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+EGPAU: %d", rmmi_ptr->arg_list, 1);
            rsp_str = &buffer[0];
            ret_val = KAL_TRUE;
        }
        else        //set
        {
            cid = (kal_uint8) rmmi_int_validator(source_string_ptr, RMMI_COMMA);
            if (cid < 1 || cid > MAX_EXT_PDP_CONTEXT)
            {
                break;
            }

            is_chap = (kal_uint8) rmmi_int_validator(source_string_ptr, rmmi_ptr->s_reg.s3);
            //kal_prompt_trace(rmmi_current_mod_id, "is_chap=%d", is_chap);
            //Support: NONE, PAP, CHAP on FP
            if ((is_chap == SM_GPRS_AUTHENTICATION_PAP)
                    || (is_chap == SM_GPRS_AUTHENTICATION_CHAP)
                    || (is_chap == SM_GPRS_AUTHENTICATION_NONE)
#ifdef __SP_RIL_SUPPORT__
                    || (is_chap == SM_GPRS_AUTHENTICATION_PAP_CHAP) //Support one more: PAP/CHAP on SP
#endif
               )

            {
                l4c_tcm_set_ppp_auth_info_req(source_string_ptr->src_id, cid, is_chap);
                return;
            }
            else
            {
                break;
            }

        }
        break;
    }
    default:
    {
        //  unrecognized format of AT command line
        break;

    }
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
} /* end of rmmi_egpau_hdlr */



/*****************************************************************************
 * FUNCTION
 *  rmmi_cgerep_hdlr
 * DESCRIPTION
 *
 * PARAMETERS
 *  source_string_ptr       [?]
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cgerep_hdlr(rmmi_string_struct *source_string_ptr)
{

    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
    kal_uint16 string_length = 0;
    kal_uint8 mode, bfr, error_cause;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    switch (source_string_ptr->cmd_mode)
    {
    case RMMI_READ_MODE:
    {
        rmmi_ptr->arg_list[0] = (void*)&rmmi_ptr->report_mode.cgerep;
        bfr = 0;
        rmmi_ptr->arg_list[1] = (void*)&bfr;
        string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CGEREP: %d, %d", rmmi_ptr->arg_list, 2);

        rsp_str = &buffer[0];
        rmmi_write_to_uart((kal_uint8*) rsp_str, string_length, KAL_TRUE);
        ret_val = KAL_TRUE;
        string_length = 0;  //only print OK at last
        break;
    }
    case RMMI_SET_OR_EXECUTE_MODE:
    {

        mode = (kal_uint8) rmmi_int_validator(source_string_ptr, (kal_uint8) RMMI_COMMA);

        if ((mode == RMMI_VALIDATOR_ERROR) || (mode > 1))
        {
            break;
        }

        bfr = (kal_uint8) rmmi_int_validator_ext(
                  &error_cause,
                  source_string_ptr,
                  rmmi_ptr->s_reg.s3 /* separator */ );

        if (bfr == RMMI_VALIDATOR_ERROR)
        {
            if (error_cause == RMMI_PARSE_NOT_FOUND)
            {
                bfr = 0;
            }
            else
            {
                break;      //invalid format
            }
        }
        else
        {
            if (bfr > 0)
            {
                break;      //out of range
            }
        }

        rmmi_ptr->report_mode.cgerep = mode;
        ret_val = KAL_TRUE;

        break;
    }

    default:
    {
        /* unrecognized format of AT command line */
        break;
    }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;

} /* end of rmmi_cgerep_hdlr */

/*****************************************************************************
 * FUNCTION
 *  rmmi_cgdata_hdlr
 * DESCRIPTION
 *
 * PARAMETERS
 *  source_string_ptr       [?]
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cgdata_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;

    //kal_uint8        buffer[RMMI_SHORT_RSP_LEN];
#if defined(__NDIS_SUPPORT__) || defined(__PS_DIALUP__)
    kal_uint8 cid;
#endif
    kal_uint16 string_length = 0;
#if defined(__PS_DIALUP__) && !defined(__NDIS_SUPPORT__)
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim
    l4c_context_struct *l4c_ptr = L4C_PTR;
#endif

    kal_trace(TRACE_FUNC, FUNC_RMMI_CGDATA_HDLR_ENTRY);
    switch (source_string_ptr->cmd_mode)
    {
    case RMMI_SET_OR_EXECUTE_MODE:
    {
#ifdef __NDIS_SUPPORT__
        kal_uint8 result;
        kal_uint8 error_cause;
        kal_uint8 l2p_str[10];
        l4c_tcm_l2p_enum l2p_type = TCM_INVALID_L2P;
        kal_uint8 chid = 0;

        /* L2P protocol */
        result = (kal_uint8) rmmi_string_validator(source_string_ptr,
                 (kal_uint8) RMMI_COMMA, 10, (kal_uint8*) l2p_str);
        if (result == RMMI_VALIDATOR_ERROR)
        {
            break;
        }
#if defined(__UPS_SUPPORT__)
        else if (strcmp((char*)l2p_str, "M-UPS") == 0) //MAUI_02900475
        {
            l2p_type = TCM_UPS_L2P;
        }
#else
        else if (strcmp((char*)l2p_str, "M-WM") == 0)
        {
            l2p_type = TCM_WM_L2P;
        }
#endif /* __UPS_SUPPORT__ */

        /* context_id */
        cid = (kal_uint8)rmmi_int_validator_range_check(&error_cause, source_string_ptr, RMMI_COMMA, MAX_EXT_PDP_CONTEXT);
        if ((error_cause != RMMI_PARSE_OK) || (cid == 0))
        {
            break;
        }

        /* channel id*/                 //IPV6_TODO: parse ch_id and pass to UPS
        chid = (kal_uint8)rmmi_int_validator_u8_check(&error_cause, source_string_ptr, RMMI_PTR->s_reg.s3);
        if (error_cause == RMMI_PARSE_NOT_FOUND)
        {
            chid = cid;
        }
        else if (error_cause != RMMI_PARSE_OK)
        {
            break;
        }

        ret_val = l4c_ps_exe_enter_data_state_req(source_string_ptr->src_id, l2p_type, cid, chid);

        if (ret_val == KAL_TRUE)
        {
            return;
        }
        break;

#elif defined(__PS_DIALUP__)
        kal_uint8 result;
        kal_uint8 error_cause;
        kal_uint8 l2p_str[4];

        result = (kal_uint8) rmmi_string_validator_ext(
                     &error_cause,
                     source_string_ptr,
                     (kal_uint8) RMMI_COMMA,
                     4,
                     (kal_uint8*) l2p_str);

        /* MAUI_02850462: 2011/02/01, avoid dialup on USB COM2 */
        /* MAUI_02738549: 2011/03/02, avoid dialup on 1T1R USB COM */
#if defined(__USB_MULTIPLE_COMPORT_SUPPORT__)
        {
            kal_uint8 port = rmmi_cid_2_port(rmmi_srcid_2_cid(source_string_ptr->src_id));
            if (KAL_FALSE == RMMI_UART_is_usb_cdc_acm(port))
            {
                kal_brief_trace(TRACE_WARNING, WARNING_DIALUP_NOT_ALLOWED_ON_1T1R, port);
                result = RMMI_VALIDATOR_ERROR;
            }
        }
#endif /* __USB_MULTIPLE_COMPORT_SUPPORT__ */

        if (result == RMMI_VALIDATOR_ERROR)
        {
            break;
        }
        else if (strcmp((char*)l2p_str, "PPP") == 0)
        {
            cid = (kal_uint8) rmmi_int_validator_ext(
                      &error_cause,
                      source_string_ptr,
                      rmmi_ptr->s_reg.s3 /* separator */ );

            if (cid == RMMI_VALIDATOR_ERROR)
            {
                if (error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    cid = 1;
                }
                else
                {
                    break;
                }
            }
            else
            {
                if (cid == 0 || cid > MAX_EXT_PDP_CONTEXT)
                {
                    break;  //out of range
                }
            }

            /*
             * mtk02126
             * 0x81 means without +???A0x91 means with +???A
             * + is international number ex. +886???K
             */
            //save number for later approve
            l4c_ptr->l4cphb_approve_req_string.type = 0x81;
            kal_sprintf((kal_char*) l4c_ptr->l4cphb_approve_req_string.number, "*99#");

            ret_val = l4c_ps_exe_enter_data_state_req(source_string_ptr->src_id, TCM_PPP_L2P, cid, 0);

            if (ret_val == KAL_TRUE)
            {
#ifdef __PHB_APPROVE_BY_MMI__
                if (PHB_FDN_CHECK == l4c_ptr->cc_current_action[source_string_ptr->src_id])
                {
                    l4c_ptr->cc_current_action[source_string_ptr->src_id] = L4C_NO_ACTION; //MAUI_02956467_CGDATA_APPROVE_FAIL
                }
#endif /* __PHB_APPROVE_BY_MMI__ */
                return;
            }
            break;

        }
        else
#endif /* __NDIS_SUPPORT__, __PS_DIALUP__ */
        {
            break;
        }

    }
    default:
    {
        /* unrecognized format of AT command line */
        break;
    }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
} /* end of rmmi_cgdata_hdlr */


#ifdef __EXT_SECONDARY_PDP_FEASIBLE__
/*****************************************************************************
 * FUNCTION
 *  rmmi_cgdscont_hdlr
 * DESCRIPTION
 *
 * PARAMETERS
 *  source_string_ptr       [?]
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cgdscont_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 i;
    kal_uint8 *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    kal_uint16 return_error_cause = RMMI_ERR_UNSPECIFIED;
    l4c_sec_pdp_info_struct pdp;
    l4c_sec_pdp_info_list_struct *pdp_list;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    kal_trace(TRACE_FUNC, FUNC_RMMI_CGDSCONT_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    case RMMI_TEST_MODE:
    {
        rsp_str = &buffer[0];
        ret_val = l4ctcm_test_sec_pdp_info(&rsp_str);
        string_length = strlen((char*)rsp_str);
        break;
    }
    case RMMI_READ_MODE:
    {
        ASSERT(sizeof(l4c_sec_pdp_info_list_struct) < 2048);
        pdp_list = (l4c_sec_pdp_info_list_struct*) get_ctrl_buffer(sizeof(l4c_sec_pdp_info_list_struct));

        ret_val = l4c_ps_get_sec_definition_list_req(source_string_ptr->src_id, pdp_list);

        if (ret_val == KAL_TRUE)
        {
            for (i = 0; i < pdp_list->length; i++)
            {
                rmmi_ptr->arg_list[0] = (void*)&pdp_list->sec_pdp_info[i].context_id;
                rmmi_ptr->arg_list[1] = (void*)&pdp_list->sec_pdp_info[i].prim_context_id;
                rmmi_ptr->arg_list[2] = (void*)&pdp_list->sec_pdp_info[i].dcomp_algo;
                rmmi_ptr->arg_list[3] = (void*)&pdp_list->sec_pdp_info[i].hcomp_algo;
                string_length = rmmi_fast_string_print(
                                    buffer,
                                    (kal_uint8*) "+CGDSCONT: %d, %d, %d, %d",
                                    rmmi_ptr->arg_list,
                                    4);
                rsp_str = &buffer[0];
                rmmi_write_to_uart((kal_uint8*) rsp_str, string_length, KAL_TRUE);
            }
            string_length = 0;
        }
        free_ctrl_buffer(pdp_list);
        break;
    }
    case RMMI_SET_OR_EXECUTE_MODE:
    {
        kal_uint8 error_cause;

        pdp.context_id = (kal_uint8) rmmi_int_validator(source_string_ptr, (kal_uint8) RMMI_COMMA);

        if (pdp.context_id == RMMI_VALIDATOR_ERROR)
        {
            // Reject Cause: AT wrong param: cid missing
            return_error_cause = L4C_AT_CMD_INVALID_PARAMETER_OR_MISSING;
            break;
        }
        else if (pdp.context_id == 0 || pdp.context_id > MAX_EXT_PDP_CONTEXT)
        {
            // Reject Cause: AT wrong param: cid out of range
            return_error_cause = L4C_AT_CMD_CID_UNEXPECTED;
            break;
        }//MAUI_01783571, mtk02285

        pdp.prim_context_id = (kal_uint8) rmmi_int_validator_ext(
                                  &error_cause,
                                  source_string_ptr,
                                  (kal_uint8) RMMI_COMMA);

        if (pdp.prim_context_id == RMMI_VALIDATOR_ERROR && error_cause == RMMI_PARSE_NOT_FOUND)
        {
            ret_val = l4c_ps_exe_undefine_req(source_string_ptr->src_id, pdp.context_id, CGDSCONT_EXE);
            if (ret_val == KAL_TRUE)
            {
                return;
            }
            else
            {
                // Reject Cause: undefine fail, only happen at command conflict
                return_error_cause = L4C_CMD_CONFLICT;
                break;
            }
        }

        if (pdp.prim_context_id == RMMI_VALIDATOR_ERROR)
        {
            return_error_cause = L4C_AT_CMD_INVALID_PARAMETER_OR_MISSING;
            break;
        }
        else if (pdp.prim_context_id == 0 || pdp.prim_context_id > MAX_EXT_PDP_CONTEXT)
        {
            return_error_cause = L4C_AT_CMD_CID_UNEXPECTED;
            break;
        }//MAUI_01783571, mtk02285
        pdp.dcomp_algo = (kal_uint8) rmmi_int_validator_ext(
                             (kal_uint8*) & error_cause,
                             source_string_ptr,
                             (kal_uint8) RMMI_COMMA);

        if (pdp.dcomp_algo == RMMI_VALIDATOR_ERROR)
        {
            if (error_cause == RMMI_PARSE_ERROR)
            {
                return_error_cause = L4C_AT_CMD_INVALID_PARAMETER;
                break;
            }
            else if (error_cause == RMMI_PARSE_NOT_FOUND)
            {
                pdp.dcomp_algo = 0;
            }
        }

        pdp.hcomp_algo = (kal_uint8) rmmi_int_validator_ext(
                             (kal_uint8*) & error_cause,
                             source_string_ptr,
                             rmmi_ptr->s_reg.s3 /* separator */ );

        if (pdp.hcomp_algo == RMMI_VALIDATOR_ERROR)
        {
            if (error_cause == RMMI_PARSE_ERROR)
            {
                return_error_cause = L4C_AT_CMD_INVALID_PARAMETER;
                break;
            }
            else if (error_cause == RMMI_PARSE_NOT_FOUND)
            {
                pdp.hcomp_algo = 0;
            }
        }

        ret_val = l4c_ps_set_sec_definition_req(source_string_ptr->src_id, &pdp);

        if (ret_val == KAL_TRUE)
        {
            return;
        }
        return_error_cause = L4C_CMD_CONFLICT;
        break;
    }
    default:
    {
        /* unrecognized format of AT command line */
        break;
    }
    }   /* end of the switch */
    if (source_string_ptr->cmd_mode == RMMI_SET_OR_EXECUTE_MODE)
    {
        rmmi_result_code_fmttr(RMMI_RCODE_ERROR, return_error_cause);
    }
    else
    {
        rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    }
    return;
} /* end of rmmi_cgdscont_hdlr */ //mtk01616_100130, remove Secondary PDP cmd from SLIM AT set

/*****************************************************************************
 * FUNCTION
 *  rmmi_cgtft_hdlr
 * DESCRIPTION
 *
 * PARAMETERS
 *  source_string_ptr       [?]
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cgtft_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 *rsp_str = NULL;
    kal_uint16 string_length = 0;
    kal_uint8 i, j;
    kal_uint8 buffer[384]; //worst case: TEST_MODE for 4 PDP types: 346 bytes
    kal_uint8 mask[2*IPV6_ADDR_LEN*4+1];
    kal_uint8 dest_port_range[12];
    kal_uint8 src_port_range[12];
    kal_uint8 tos[8];
    kal_uint8 range[12];
    l4c_tft_struct tft;

    kal_trace(TRACE_FUNC, FUNC_RMMI_CGTFT_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    case RMMI_TEST_MODE:
    {
        rsp_str = &buffer[0];
        ret_val = l4ctcm_test_tft_info(&rsp_str);
        string_length = strlen((char*)rsp_str);
        break;
    }
    case RMMI_READ_MODE:
    {
        for (i = 1; i < TCM_TOT_CONTEXT; i++)
        {
            tft.context_id = i;
            ret_val = l4c_ps_get_tft_req(source_string_ptr->src_id, &tft);
            if (ret_val == KAL_FALSE)
            {
                break;
            }

            for (j = 0; j < tft.tot_pf_count; j++)
            {
                kal_uint16 index = 0;

                rmmi_u8_to_dotstring(tft.pf[j].src_addr_sb_net_mask, mask, tft.pf[j].src_addr_sb_net_mask_len);
                rmmi_u16_to_dotstring(tft.pf[j].dst_port_range, dest_port_range, tft.pf[j].dst_port_len);
                rmmi_u16_to_dotstring(tft.pf[j].src_port_range, src_port_range, tft.pf[j].src_port_len);
                rmmi_u8_to_dotstring(tft.pf[j].tos_traffic_class_mask, tos, tft.pf[j].tos_len);
                /*
                 * kal_sprintf((kal_char*)buffer, "+CGTFT: %u,%u,%u,\"%s\",%u,\"%s\",\"%s\",%08X,\"%s\",%05X",
                 * tft.context_id,
                 * tft.pf[j].pfi,
                 * tft.pf[j].epi,
                 * mask,
                 * tft.pf[j].prot_number_next_hdr,
                 * dest_port_range,
                 * src_port_range,
                 * tft.pf[j].ipsec_spi,
                 * tos,
                 * tft.pf[j].flow_label);
                 */

                /* format the <cid>, <pfi>,<epi>, <source addr and mask> */
                index += kal_sprintf(
                             (char*)buffer + index,
                             "+CGTFT: %u,%u,%u,\"%s\"",
                             tft.context_id,
                             tft.pf[j].pfi,
                             tft.pf[j].epi,
                             mask);

                /* format the <port number next header>, <dest port range> and <source port range> */
                if (tft.pf[j].prot_number_present == KAL_FALSE)
                {
                    index += kal_sprintf(
                                 (char*)buffer + index,
                                 ",,\"%s\",\"%s\"",
                                 dest_port_range,
                                 src_port_range);
                }
                else
                {
                    index += kal_sprintf(
                                 (char*)buffer + index,
                                 ",%u,\"%s\",\"%s\"",
                                 tft.pf[j].prot_number_next_hdr,
                                 dest_port_range,
                                 src_port_range);
                }

                /* format the <ipsec spi>, <tos> */
                if (tft.pf[j].ipsec_spi_present == KAL_FALSE)
                {
                    index += kal_sprintf((char*)buffer + index, ",\"\",\"%s\"", tos);
                }
                else
                {
                    index += kal_sprintf((char*)buffer + index, ",\"%08X\",\"%s\"", tft.pf[j].ipsec_spi, tos);
                }
                /* format the <flow label> */
                if (tft.pf[j].flow_label_present == KAL_TRUE)
                {
                    index += kal_sprintf((char*)buffer + index, ",\"%05X\"", tft.pf[j].flow_label);
                }
                string_length = strlen((char*)buffer);
                rsp_str = &buffer[0];
                rmmi_write_to_uart((kal_uint8*) rsp_str, string_length, KAL_TRUE);
            }
        }
        string_length = 0;
        ret_val = KAL_TRUE;
        break;
    }
    case RMMI_SET_OR_EXECUTE_MODE:
    {
        kal_uint8 error_cause;

        /* parse <cid> */
        tft.context_id = (kal_uint8) rmmi_int_validator(source_string_ptr, (kal_uint8) RMMI_COMMA);
        if (tft.context_id == RMMI_VALIDATOR_ERROR)
        {
            break;
        }

        /* parse <pfi> */
        tft.pf[0].pfi = (kal_uint8) rmmi_int_validator_ext(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);

        if (tft.pf[0].pfi == RMMI_VALIDATOR_ERROR && error_cause == RMMI_PARSE_NOT_FOUND)
        {
            ret_val = l4c_ps_exe_undefine_req(source_string_ptr->src_id, tft.context_id, CGTFT_EXE);
            if (ret_val == KAL_TRUE)
            {
                return;
            }
            else
            {
                break;
            }
        }

        //if (error_cause == RMMI_PARSE_NOT_FOUND)
        //{
        //  /* make the PFs for the cid become undefined. */
        //     tft.tot_pf_count = 0;
        //        ret_val = l4c_ps_set_tft_req (source_string_ptr->src_id, &tft);
        //     break;
        //}
        /* else */ if (tft.pf[0].pfi > 8)
        {
            break;
        }
        tft.tot_pf_count = 1;

        /* parse <epi> */
        tft.pf[0].epi = (kal_uint8) rmmi_int_validator_ext(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);
        if (error_cause != RMMI_PARSE_OK)
        {
            break;
        }

        /* parse <source addr and mask> */
        rmmi_string_validator_ext(
            &error_cause,
            source_string_ptr,
            (kal_uint8) RMMI_COMMA,
            sizeof(mask),
            (kal_uint8*) mask);
        if (error_cause == RMMI_PARSE_OK)
        {
            //MAUI_02555586 mtk02126 refine check_dotted_value8
            tft.pf[0].src_addr_sb_net_mask_len = check_dotted_value8(mask, tft.pf[0].src_addr_sb_net_mask, 2*IPV4_ADDR_LEN);
            if ((tft.pf[0].src_addr_sb_net_mask_len != 2*IPV4_ADDR_LEN) && (tft.pf[0].src_addr_sb_net_mask_len != 0)) //if the field is given and it's not IPV4
            {
#ifdef __IPV6__
                tft.pf[0].src_addr_sb_net_mask_len = check_dotted_value8(mask, tft.pf[0].src_addr_sb_net_mask, 2*IPV6_ADDR_LEN);//try IPV6
                if ((tft.pf[0].src_addr_sb_net_mask_len != 2*IPV6_ADDR_LEN) && (tft.pf[0].src_addr_sb_net_mask_len != 0)) //if the field is given and it's not IPV6
                {
                    break;
                }
#else
                break;
#endif
            }
        }
        else if (error_cause == RMMI_PARSE_NOT_FOUND)
        {
            tft.pf[0].src_addr_sb_net_mask_len = 0;
        }
        else        //parse error
        {
            break;
        }

        /* parse <prot_number_next_hdr> */
        tft.pf[0].prot_number_next_hdr = (kal_uint8) rmmi_int_validator_ext(
                                             &error_cause,
                                             source_string_ptr,
                                             (kal_uint8) RMMI_COMMA);
        if ((error_cause != RMMI_PARSE_OK) && (error_cause != RMMI_PARSE_NOT_FOUND))
        {
            break;
        }
        tft.pf[0].prot_number_present = (error_cause == RMMI_PARSE_NOT_FOUND) ? KAL_FALSE : KAL_TRUE;

        /* parse <dest_port_range> */
        rmmi_string_validator_ext(
            &error_cause,
            source_string_ptr,
            (kal_uint8) RMMI_COMMA,
            12,
            (kal_uint8*) range);
        if (error_cause == RMMI_PARSE_OK)
        {
            // MAUI_02555586 mtk02126 refine check_dotted_value16
            tft.pf[0].dst_port_len = check_dotted_value16(range, (kal_uint16*) tft.pf[0].dst_port_range, 2);
            if ((tft.pf[0].dst_port_len != 2) && (tft.pf[0].dst_port_len != 0))
            {
                break;
            }
        }
        else if (error_cause == RMMI_PARSE_NOT_FOUND)
        {
            tft.pf[0].dst_port_len = 0;
        }
        else
        {
            break;
        }

        /* parse <src_port_range> */
        rmmi_string_validator_ext(
            &error_cause,
            source_string_ptr,
            (kal_uint8) RMMI_COMMA,
            12,
            (kal_uint8*) range);
        if (error_cause == RMMI_PARSE_OK)
        {
            // MAUI_02555586 mtk02126 refine check_dotted_value16
            tft.pf[0].src_port_len = check_dotted_value16(range, (kal_uint16*) tft.pf[0].src_port_range, 2);
            if ((tft.pf[0].src_port_len != 2) && (tft.pf[0].src_port_len != 0))
            {
                break;
            }
        }
        else if (error_cause == RMMI_PARSE_NOT_FOUND)
        {
            tft.pf[0].src_port_len = 0;
        }
        else
        {
            break;
        }

        /* parse <ipsec_spi> */
        rmmi_string_validator_ext(
            (kal_uint8*) & error_cause,
            source_string_ptr,
            (kal_uint8) RMMI_COMMA,
            9,
            (kal_uint8*) range);
        if (error_cause == RMMI_PARSE_OK)
        {
            tft.pf[0].ipsec_spi_present = KAL_TRUE;
            if (rmmi_hexstring_to_integer(range, &tft.pf[0].ipsec_spi) == KAL_FALSE)
            {
                break;
            }
        }
        else if (error_cause == RMMI_PARSE_NOT_FOUND)
        {
            tft.pf[0].ipsec_spi_present = KAL_FALSE;
        }
        else
        {
            break;
        }

        /* parse <tos> */
        rmmi_string_validator_ext(
            &error_cause,
            source_string_ptr,
            (kal_uint8) RMMI_COMMA,
            8,
            (kal_uint8*) range);
        if (error_cause == RMMI_PARSE_OK)
        {
            //MAUI_02555586 mtk02126 refine check_dotted_value8
            tft.pf[0].tos_len = check_dotted_value8(range, tft.pf[0].tos_traffic_class_mask, 2);
            if ((tft.pf[0].tos_len != 0) && (tft.pf[0].tos_len != 2))   //this condition includes RMMI_VALIDATOR_ERROR
            {
                break;
            }
        }
        else if (error_cause == RMMI_PARSE_NOT_FOUND)
        {
            tft.pf[0].tos_len = 0;
        }
        else
        {
            break;
        }

        /* parse <flow label> */
        rmmi_string_validator_ext(
            (kal_uint8*) & error_cause,
            source_string_ptr,
            (kal_uint8) RMMI_COMMA,
            6,
            (kal_uint8*) range);
        if (error_cause == RMMI_PARSE_OK)
        {
            tft.pf[0].flow_label_present = KAL_TRUE;
            if (rmmi_hexstring_to_integer(range, &tft.pf[0].flow_label) == KAL_FALSE)
            {
                break;
            }
        }
        else if (error_cause == RMMI_PARSE_NOT_FOUND)
        {
            tft.pf[0].flow_label_present = KAL_FALSE;
        }
        else
        {
            break;
        }

        /* execute setting tft */
        ret_val = l4c_ps_set_tft_req(source_string_ptr->src_id, &tft);
        break;
    }
    default:
    {
        /* unrecognized format of AT command line */
        break;
    }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
} /* end of rmmi_cgtft_hdlr */ //mtk01616_100130, remove Secondary PDP cmd from SLIM AT set
#endif // __EXT_SECONDARY_PDP_FEASIBLE__


#ifdef __NDIS_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  rmmi_cgprco_hdlr
 * DESCRIPTION
 *
 * PARAMETERS
 *  source_string_ptr       [?]
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cgprco_hdlr(rmmi_string_struct *source_string_ptr)
{

    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
    kal_uint16 string_length = 0;
    kal_uint16 return_error_cause = RMMI_ERR_UNSPECIFIED;
    kal_uint8 cid = 0;
    kal_uint8 result, i;
    l4c_config_option_list_struct option_list;
    kal_uint8 dns1_str[IPV4_ADDR_LEN*4+1];
    kal_uint8 dns2_str[IPV4_ADDR_LEN*4+1];
#ifndef __IPV6__
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
#else
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN+IPV6_ADDR_LEN*8+2];
#endif

    l4ctcm_set_config_option_req_struct prco_req;

    //kal_trace(TRACE_FUNC, FUNC_RMMI_CGPRCO_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    case RMMI_TEST_MODE:
    {
        rsp_str = &buffer[0];
        ret_val = l4ctcm_test_protocol_config(&rsp_str); //+CGPRCO: (1-cid), max_username_len, max_passwd_len
        string_length = strlen ((char *)rsp_str);
        break;
    }
    case RMMI_READ_MODE:
    {
        ret_val = l4ctcm_get_config_option_info(&option_list);
        if (ret_val == KAL_TRUE)
        {
#ifdef __IPV6__
            kal_uint8 v6_dns1_str[IPV6_ADDR_LEN*4+1];
            kal_uint8 v6_dns2_str[IPV6_ADDR_LEN*4+1];
#endif
            for (i = 0; i < TCM_TOT_EXT_CONTEXT; i++)   // MMI_TOT_VISIBLE_CONTEXT
            {
                cid = i + 1;
                rmmi_u8_to_dotstring(option_list.config_option_info[i].pri_dns, dns1_str, IPV4_ADDR_LEN);
                rmmi_u8_to_dotstring(option_list.config_option_info[i].sec_dns, dns2_str, IPV4_ADDR_LEN);
#ifndef __IPV6__
                kal_sprintf((char*)buffer, "+CGPRCO: %d, \"%s\", \"%s\"", cid, dns1_str, dns2_str);
#else
                if (KAL_TRUE == option_list.config_option_info[i].ipv6_dns1_present)
                {
                    rmmi_u8_to_dotstring(option_list.config_option_info[i].ipv6_dns1, v6_dns1_str, IPV6_ADDR_LEN);
                }
                else
                {
                    kal_mem_set(v6_dns1_str, 0, sizeof(v6_dns1_str));
                }
                if (KAL_TRUE == option_list.config_option_info[i].ipv6_dns2_present)
                {
                    rmmi_u8_to_dotstring(option_list.config_option_info[i].ipv6_dns2, v6_dns2_str, IPV6_ADDR_LEN);
                }
                else
                {
                    kal_mem_set(v6_dns2_str, 0, sizeof(v6_dns2_str));
                }
                kal_sprintf((char*)buffer, "+CGPRCO: %d, \"%s\", \"%s\", \"%s\", \"%s\"",
                            cid, dns1_str, dns2_str, v6_dns1_str, v6_dns2_str);
#endif /* __IPV6__ */
                string_length = strlen((char*)buffer);
                rsp_str = &buffer[0];
                rmmi_write_to_uart((kal_uint8*) rsp_str, string_length, KAL_TRUE);
            }
        }
        string_length = 0;  //only print OK at last
        break;
    }
    case RMMI_SET_OR_EXECUTE_MODE:
    {
        kal_uint8 error_cause;
        kal_uint8 is_chap = 0;
        kal_uint8 req_v6_dns = 0;

        kal_mem_set(&prco_req, 0, sizeof(l4ctcm_set_config_option_req_struct));

        /* cid */
        prco_req.prco.context_id = (kal_uint8) rmmi_int_validator(source_string_ptr, (kal_uint8) RMMI_COMMA);
        if (prco_req.prco.context_id == RMMI_VALIDATOR_ERROR)
        {
            // Reject Cause: cid missing or error
            return_error_cause = L4C_AT_CMD_INVALID_PARAMETER_OR_MISSING;
            break;
        }

        /* username */
        result = rmmi_string_validator_ext(
                     &error_cause,
                     source_string_ptr,
                     (kal_uint8) RMMI_COMMA,
                     MAX_GPRS_USER_NAME_LEN,
                     (kal_uint8*) prco_req.prco.user_name);

        if (result == RMMI_VALIDATOR_ERROR && error_cause != RMMI_PARSE_OK)
        {
            // Reject Cause: username error
            return_error_cause = L4C_AT_CMD_INVALID_PARAMETER;
            break;
        }

        /* passwd */
        result = rmmi_string_validator_ext(
                     &error_cause,
                     source_string_ptr,
                     (kal_uint8) RMMI_COMMA,
                     MAX_GPRS_PASSWORD_LEN,
                     (kal_uint8*) prco_req.prco.password);

        if (result == RMMI_VALIDATOR_ERROR && error_cause != RMMI_PARSE_OK)
        {
            // Reject Cause: passwd error
            return_error_cause = L4C_AT_CMD_INVALID_PARAMETER;
            break;
        }

        /* dns1 */
        result = rmmi_string_validator_ext(
                     &error_cause,
                     source_string_ptr,
                     (kal_uint8) RMMI_COMMA,
                     16,
                     (kal_uint8*) dns1_str);

        if (result == RMMI_VALIDATOR_ERROR && error_cause != RMMI_PARSE_OK)
        {
            // Reject Cause: dns1 error
            return_error_cause = L4C_AT_CMD_INVALID_PARAMETER;
            break;
        }

        //MAUI_02555586 mtk02126 refine check_dotted_value8
        result = check_dotted_value8(dns1_str, prco_req.prco.pri_dns, 4);
        if (RMMI_VALIDATOR_ERROR == result)
        {
            // Reject Cause: dns1 no dot
            return_error_cause = L4C_AT_CMD_INVALID_PARAMETER;
            break;
        }

        /* dns2 */
        result = rmmi_string_validator_ext(
                     &error_cause,
                     source_string_ptr,
                     (kal_uint8) RMMI_COMMA,
                     16,
                     (kal_uint8*) dns2_str);

        if (result == RMMI_VALIDATOR_ERROR && error_cause != RMMI_PARSE_OK)
        {
            // Reject Cause: dns2 error
            return_error_cause = L4C_AT_CMD_INVALID_PARAMETER;
            break;
        }

        //MAUI_02555586 mtk02126 refine check_dotted_value8
        result = check_dotted_value8(dns2_str, prco_req.prco.sec_dns, 4);
        if (RMMI_VALIDATOR_ERROR == result)
        {
            // Reject Cause: dns2 no dot
            return_error_cause = L4C_AT_CMD_INVALID_PARAMETER;
            break;
        }

        /* auth. type */
        is_chap = (kal_uint8) rmmi_int_validator_ext(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);
        if (is_chap == RMMI_VALIDATOR_ERROR && error_cause == RMMI_PARSE_NOT_FOUND)
        {
            is_chap = SM_GPRS_AUTHENTICATION_PAP;
        }
        //kal_prompt_trace(rmmi_current_mod_id, "is_chap=%d", is_chap);
        //Support: NONE, PAP, CHAP on FP
        if ((is_chap == SM_GPRS_AUTHENTICATION_PAP)
                || (is_chap == SM_GPRS_AUTHENTICATION_CHAP)
                || (is_chap == SM_GPRS_AUTHENTICATION_NONE)
                || (is_chap == SM_GPRS_AUTHENTICATION_PAP_CHAP) //Support one more: PAP/CHAP on SP
           )
        {
            prco_req.prco.is_chap = is_chap;
        }
        else
        {
            // Reject Cause: auth_type error, out of range
            return_error_cause = L4C_AT_CMD_INVALID_PARAMETER;
            break;
        }

#ifdef __IPV6__
        /* request V6 DNS */
        req_v6_dns = (kal_uint8)rmmi_int_validator_range_check(&error_cause, source_string_ptr, RMMI_COMMA, 1);
        if (error_cause == RMMI_PARSE_NOT_FOUND)
        {
            req_v6_dns = 1;
        }
        else if (error_cause != RMMI_PARSE_OK)
        {
            // Reject Cause: request V6 DNS error, not missing
            return_error_cause = L4C_AT_CMD_INVALID_PARAMETER;
            break;
        }
        //Note: The 0/1 meaning is opposite in <req_v6_dns> paramenter and TCM enum type
        //      The reason is that TCM hopes the NVRAM initial value (0) can be interpreted as "NEED_REQUEST_V6_DNS"
        prco_req.prco.act_pdp_cntxt_req_ipv6_dns = (req_v6_dns == 0)?(TCM_ACTIVATE_PDP_NOT_REQUEST_IPV6_DNS):(TCM_ACTIVATE_PDP_NEED_REQUEST_IPV6_DNS);
#endif

        ret_val = l4c_ps_set_config_option_req(source_string_ptr->src_id, &prco_req);

        if (ret_val == KAL_TRUE)
        {
            return;
        }

        break;
    }

    default:
    {
        /* unrecognized format of AT command line */
        break;
    }
    }   /* end of the switch */

    if (source_string_ptr->cmd_mode == RMMI_SET_OR_EXECUTE_MODE)
    {
        rmmi_result_code_fmttr(RMMI_RCODE_ERROR, return_error_cause);
    }
    else
    {
        rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    }
    return;

} /* end of rmmi_cgprco_hdlr */
#endif /* defined(__NDIS_SUPPORT__) */

#ifdef __MOBILE_BROADBAND_PROVISION_CONTEXT__
/*****************************************************************************
 * FUNCTION
 *  rmmi_mbpc_hdlr
 * DESCRIPTION
 *
 * PARAMETERS
 *  source_string_ptr       [?]
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_mbpc_hdlr(rmmi_string_struct *source_string_ptr)
{

    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
    kal_uint16 string_length = 0;
    kal_uint8 entry_id = 0;
    kal_uint32 pcid = 0;
    kal_uint8 result;

    switch (source_string_ptr->cmd_mode)
    {
    case RMMI_TEST_MODE:
    {
        /* User Query - Return all matched Provisioned Contexts - including both empty entries and applicable ones to the current PLMN */
        ret_val = l4c_ps_get_provision_context_req(source_string_ptr->src_id, KAL_TRUE);
        if (ret_val)
        {
            return;
        }
        else
        {
            break;
        }
    }

    case RMMI_READ_MODE:
    {
        /* User Query - Return all matched Provisioned Contexts - including both empty entries and applicable ones to the current PLMN */
        ret_val = l4c_ps_get_provision_context_req(source_string_ptr->src_id, KAL_FALSE);
        if (ret_val)
        {
            return;
        }
        else
        {
            break;
        }
    }

    case RMMI_SET_OR_EXECUTE_MODE:
    {
        /* User Set - If <pcid> is valid, it always overwrite entry and succeeds. Otherwise, return ERROR */
        kal_uint8 error_cause, pctype, compress, auth, opcode;
        kal_uint8 plmn_in_digit[7];
        kal_uint8 apn[MAX_APN_LEN];
        kal_uint8 user_name[MAX_GPRS_USER_NAME_LEN];
        kal_uint8 password[MAX_GPRS_PASSWORD_LEN];

        error_cause = pctype = compress = auth = opcode = 0;
        kal_mem_set(plmn_in_digit, 0, 7);
        kal_mem_set(apn, 0, MAX_APN_LEN);
        kal_mem_set(user_name, 0, MAX_GPRS_USER_NAME_LEN);
        kal_mem_set(password, 0, MAX_GPRS_PASSWORD_LEN);

        /* opcode - 0 for clear; 1 for set */
        opcode = (kal_uint8)rmmi_int_validator_range_check(&error_cause,
                 source_string_ptr, (kal_uint8) RMMI_COMMA, 1);
        if (error_cause != RMMI_PARSE_OK)
        {
            break;
        }

        /* entry_id - check it is between 1 to X */
        entry_id = (kal_uint8)rmmi_int_validator_range_check(&error_cause,
                   source_string_ptr, (kal_uint8) RMMI_COMMA, NVRAM_EF_MOBILE_BROADBAND_PROVISION_CONTEXT_TOTAL);
        if ((error_cause != RMMI_PARSE_OK) || (entry_id == 0))
        {
            break;
        }

        if (opcode == 1)
        {
            /* pcid - check it is less than ULONG */
            pcid = (kal_uint32)rmmi_int_validator_u32_check(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA);
            if ((error_cause != RMMI_PARSE_OK))
            {
                break;
            }

            /* pctype - only check not exceed kal_uint8 */
            pctype = (kal_uint8)rmmi_int_validator_range_check(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA, 0xFF);
            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }

            /* apn - check not to exceed MAX_APN_LEN */
            result = rmmi_string_validator_ext(&error_cause, source_string_ptr,
                                               (kal_uint8) RMMI_COMMA, MAX_APN_LEN, apn);
            if (result == RMMI_VALIDATOR_ERROR && error_cause != RMMI_PARSE_NOT_FOUND && error_cause != RMMI_PARSE_OK)
            {
                break;
            }

            /* username  - check not to exceed MAX_GPRS_USER_NAME_LEN */
            result = rmmi_string_validator_ext(&error_cause, source_string_ptr,
                                               (kal_uint8) RMMI_COMMA, MAX_GPRS_USER_NAME_LEN, user_name);
            if (result == RMMI_VALIDATOR_ERROR && error_cause != RMMI_PARSE_OK)
            {
                break;
            }

            /* passwd - check not to exceed MAX_GPRS_PASSWORD_LEN */
            result = rmmi_string_validator_ext(&error_cause, source_string_ptr,
                                               (kal_uint8) RMMI_COMMA, MAX_GPRS_PASSWORD_LEN, password);
            if (result == RMMI_VALIDATOR_ERROR && error_cause != RMMI_PARSE_OK)
            {
                break;
            }

            /* compress - only check not exceed kal_uint8 */
            compress = (kal_uint8)rmmi_int_validator_range_check(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA, 0xFF);
            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }

            /* auth - only check not exceed kal_uint8 */
            auth = (kal_uint8)rmmi_int_validator_range_check(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA, 0xFF);
            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }

            /* plmn_in_digit  - check not to exceed 7 */
            result = rmmi_string_validator_ext(&error_cause, source_string_ptr,
                                               (kal_uint8) RMMI_COMMA, 7, plmn_in_digit);
            if ((result == RMMI_VALIDATOR_ERROR && error_cause != RMMI_PARSE_OK)
                    || (KAL_FALSE == rmmi_is_number_string(plmn_in_digit)))
            {
                break;
            }
        } //(opcode==1)

        /* Write it to NVRAM */
        ret_val = l4c_ps_set_provision_context_req(
                      source_string_ptr->src_id, entry_id,
                      pcid, pctype, apn, user_name, password, compress, auth, plmn_in_digit, opcode);
        if (ret_val == KAL_TRUE)
        {
            return;
        }

        break;
    }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;

}
#endif /* __MOBILE_BROADBAND_PROVISION_CONTEXT__ */

#endif /* defined(__EXT_PDP_CONTEXT_ON__)*/

#if defined(__MONITOR_PAGE_DURING_TRANSFER__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_egtp_hdlr
 * DESCRIPTION
 *  proprietary AT command to Query/Reset GPRS Transfer Preference
 *  (CALL PREFER/DATA PREFER)
 * PARAMETERS
 *  source_string_ptr       [?]
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_egtp_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 state;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;

    switch (source_string_ptr->cmd_mode)
    {
#ifdef __test_mode__
    case RMMI_TEST_MODE:
    {
        rsp_str = (kal_uint8 const*)"+EGTP: (0-1)";
        string_length = strlen((char*)rsp_str);
        ret_val = KAL_TRUE;
        break;
    }
#endif
    case RMMI_READ_MODE:
    {
        kal_uint8 current_setting;
        ret_val = l4c_nw_get_gprs_transfer_preference_req(source_string_ptr->src_id, &current_setting);
        RMMI_PTR->arg_list[0] = (void*)&current_setting;
        string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+EGTP: %d", RMMI_PTR->arg_list, 1);
        rsp_str = &buffer[0];
        break;
    }
    case RMMI_SET_OR_EXECUTE_MODE:
    {
        state = (kal_uint8) rmmi_int_validator(source_string_ptr, (kal_uint8) RMMI_COMMA);

        if (state == RMMI_VALIDATOR_ERROR)
        {
            break;
        }
        else if (state > (kal_uint8)CALL_PREFER)
        {
            break;
        }

        ret_val = l4c_nw_set_gprs_transfer_preference_req(source_string_ptr->src_id, state);
        break;
    }
    default:
    {
        break; /* unrecognized format of AT command line */
    }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
} /* end of rmmi_egtp_hdlr */
#endif /* defined(__MONITOR_PAGE_DURING_TRANSFER__) */

#ifdef __HSPA_PREFERENCE_SETTING__
/*****************************************************************************
 * FUNCTION
 *  rmmi_ehsm_hdlr
 * DESCRIPTION
 *  proprietary AT command to Query/Set UE HSPA capability
 * PARAMETERS
 *  source_string_ptr       [?]
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_ehsm_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    switch (source_string_ptr->cmd_mode)
    {
    case RMMI_TEST_MODE:
    {
        /* "+EHSM: (0-2),(0-1)" */
			kal_uint8 max_hspa_mode = (kal_uint8)l4c_nw_get_max_hspa_support_mode();			
        rmmi_ptr->arg_list[0] = (void*)&max_hspa_mode;
        string_length = rmmi_fast_string_print(buffer,
                                               (kal_uint8*) "+EHSM: (0-%d), (0-1)", rmmi_ptr->arg_list, 1);
        ret_val = KAL_TRUE;
        break;
    }
    case RMMI_READ_MODE:
    {
        kal_uint8 hspa_mode = 0;
        ret_val = l4c_nw_get_hspa_mode_req(source_string_ptr->src_id, &hspa_mode);
        if(ret_val == KAL_TRUE)
        {
            rmmi_ptr->arg_list[0] = (void*)&hspa_mode;
            string_length = rmmi_fast_string_print(buffer,
                                                   (kal_uint8*) "+EHSM: %d", rmmi_ptr->arg_list, 1);
        }
        break;
    }
        #if !defined(__UMTS_TDD128_MODE__) || defined(__AT_EHSM_SET_SUPPORT__)
    case RMMI_SET_OR_EXECUTE_MODE:
    {
        kal_uint8 err_cause = 0;
        kal_uint8 hspa_mode, apply_mode;

        /* parse HSPA Access Mode */
        hspa_mode = rmmi_int_validator_u8_check(&err_cause, source_string_ptr, RMMI_COMMA);
        if (err_cause != RMMI_PARSE_OK)
        {
            break;
        }
            else if ((hspa_mode >= L4C_HSPA_INVLIAD) || (hspa_mode > l4c_nw_get_max_hspa_support_mode()))
        {
            break;
        }

        #if defined(__UMTS_FDD_MODE__) && defined(__UMTS_R7__) && !defined(__MTK_INTERNAL__)
            /* mtk80396: FDD does not support turn off HSPA+ for custom release load */
            if(hspa_mode == 2)
            {
                break;
            }
        #endif

        /* parse Apply Mode */
        apply_mode = rmmi_int_validator_u8_check(&err_cause, source_string_ptr, rmmi_ptr->s_reg.s3);
        if (err_cause != RMMI_PARSE_OK)
        {
            break;
        }
        else if (apply_mode >= L4C_APPLY_INVALID)
        {
            break;
        }

        /* Execution */
        ret_val = l4c_nw_set_hspa_mode_req(source_string_ptr->src_id, hspa_mode, apply_mode);
        if (ret_val == KAL_TRUE)
        {
            return;
        }
        break;
    }
#endif
    default:
    {
        break;
    }
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, buffer, string_length);
}
#endif /*  __HSPA_PREFERENCE_SETTING__ */

#ifdef __IPV4V6__
/*****************************************************************************
 * FUNCTION
 *  rmmi_egfb_hdlr
 * DESCRIPTION
 *  proprietary AT command
 *  1. to enable/disable IPV4V6 fallback
 *  2. to set fallback activation sequence (IPV4 then IPV6, or IPV6 then IPV4)
 * PARAMETERS
 *  source_string_ptr       [?]
 * RETURNS
 *  void
 * NOTE
 *  h1=284698, h2=0, AT+EGFB=<fallback_enable>, <ipv4_first>
 *****************************************************************************/
void rmmi_egfb_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    kal_bool fb_enable, fb_v4_first;
    l4c_common_context_struct* l4c_comm_ptr = L4C_COMM_PTR;

    switch (source_string_ptr->cmd_mode)
    {
    case RMMI_READ_MODE:
    {
        fb_enable = l4c_comm_ptr->ipv4v6_fallback_enable;
        fb_v4_first = l4c_comm_ptr->ipv4v6_fallback_v4_first;
        RMMI_PTR->arg_list[0] = (void*)&fb_enable;
        RMMI_PTR->arg_list[1] = (void*)&fb_v4_first;
        string_length = rmmi_fast_string_print(buffer,
                                               (kal_uint8*) "+EGFB: %d, %d", RMMI_PTR->arg_list, 2);
        ret_val = KAL_TRUE;
        break;
    }
    case RMMI_SET_OR_EXECUTE_MODE:
    {
        kal_uint8 err_cause = 0;
        kal_uint32 parse_token = 0;
        /* parse <fallback_enable> */
        parse_token = rmmi_int_validator_range_check(&err_cause, source_string_ptr, (kal_uint8)RMMI_COMMA, 1);
        if (err_cause != RMMI_PARSE_OK)
        {
            break;
        }
        fb_enable = (0==parse_token)?(KAL_FALSE):(KAL_TRUE);

        /* parse <ipv4_first> */
        parse_token = rmmi_int_validator_range_check(&err_cause, source_string_ptr, (kal_uint8)RMMI_COMMA, 1);
        if (err_cause != RMMI_PARSE_OK)
        {
            break;
        }
        fb_v4_first = (0==parse_token)?(KAL_FALSE):(KAL_TRUE);

        /* Execution */
        if (l4c_comm_ptr->v4v6_act_ptr == NULL)
        {
            l4c_comm_ptr->ipv4v6_fallback_enable = fb_enable;
            l4c_comm_ptr->ipv4v6_fallback_v4_first = fb_v4_first;
            ret_val = KAL_TRUE;
            break;
        }
        else
        {
            kal_brief_trace(TRACE_INFO, INFO_L4C_GPRS_IPV4V6_ALREADY_1_ONGOING_ACTIVATION,
                            l4c_comm_ptr->v4v6_act_ptr->init_cid, l4c_comm_ptr->v4v6_act_ptr->src_id);
        }
    }
    default:
    {
        break;
    }
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, buffer, string_length);
}
#endif /* __IPV4V6__ */

#ifdef __MEDIATEK_SMART_QOS__
void rmmi_msq_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
    kal_uint16 string_length = 0;

    switch (source_string_ptr->cmd_mode)
    {
    case RMMI_TEST_MODE:
    {
        /* User Query */
        //ret_val = l4c_ps_get_msq_entry_req(source_string_ptr->src_id);
        ret_val = KAL_TRUE;
        break;
    }

    case RMMI_READ_MODE:
    {
        /* User Query */
        ret_val = l4c_ps_get_msq_entry_req(source_string_ptr->src_id);
        break;
    }

    case RMMI_SET_OR_EXECUTE_MODE:
    {
        kal_uint8   error_cause, id, nw_on, sim_on;
        kal_uint8   plmn_in_digit[7] = {0};
        kal_uint8   result;

        error_cause = 0;

        /* id - valid if 1~MSQ_MAX_ENTRY_COUNT */
        id = (kal_uint8)rmmi_int_validator_range_check(&error_cause,
                source_string_ptr, (kal_uint8) RMMI_COMMA, MSQ_MAX_ENTRY_COUNT);
        if ((error_cause != RMMI_PARSE_OK) || (id==0)) break;

        /* plmn_in_digit  - check not to exceed 7 */
        result = rmmi_string_validator_ext(&error_cause, source_string_ptr,
                                           (kal_uint8) RMMI_COMMA, 7, plmn_in_digit);

        if ((result == RMMI_VALIDATOR_ERROR && error_cause != RMMI_PARSE_NOT_FOUND)
                || (KAL_FALSE == rmmi_is_number_string(plmn_in_digit)))
        {
            break;
        }

        if (result == RMMI_VALIDATOR_ERROR && error_cause == RMMI_PARSE_NOT_FOUND)
        {
            nw_on = 0;
            sim_on = 0;
        }
        else
        {
            /* nw_on */
            nw_on = (kal_uint8)rmmi_int_validator_range_check(&error_cause,
                    source_string_ptr, (kal_uint8) RMMI_COMMA, 1);
            if (error_cause == RMMI_PARSE_NOT_FOUND) nw_on=1;
            else if ((error_cause != RMMI_PARSE_OK) || (nw_on==0)) break;

            /* sim_on */
            sim_on = (kal_uint8)rmmi_int_validator_range_check(&error_cause,
                     source_string_ptr, (kal_uint8) RMMI_COMMA, 1);
            if (error_cause == RMMI_PARSE_NOT_FOUND) sim_on=1;
            else if ((error_cause != RMMI_PARSE_OK) || (sim_on==0)) break;
        }

        /* Send to TCM */
        ret_val = l4c_ps_set_msq_entry_req(source_string_ptr->src_id, id, plmn_in_digit, nw_on, sim_on);
        if (ret_val == KAL_TRUE) return;

        break;
    }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}

void rmmi_msqon_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
    kal_uint16 string_length = 0;

    switch (source_string_ptr->cmd_mode)
    {
    case RMMI_TEST_MODE:
    {
        /* User Query */
        //ret_val = l4c_ps_get_msq_mode_req(source_string_ptr->src_id);
        ret_val = KAL_TRUE;
        break;
    }

    case RMMI_READ_MODE:
    {
        /* User Query */
        ret_val = l4c_ps_get_msq_mode_req(source_string_ptr->src_id);
        break;
    }

    case RMMI_SET_OR_EXECUTE_MODE:
    {
        kal_uint8 error_cause, on;

        error_cause = 0;

        /* on */
        on = (kal_uint8)rmmi_int_validator_range_check(&error_cause,
                source_string_ptr, (kal_uint8) RMMI_COMMA, 1);
        if (error_cause != RMMI_PARSE_OK) break;

        /* Send to TCM */
        ret_val = l4c_ps_set_msq_mode_req(source_string_ptr->src_id, on);
        if (ret_val == KAL_TRUE) return;

        break;
    }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}
#endif


/*****************************************************************************
 * FUNCTION
 *  rmmi_egtype_hdlr
 * DESCRIPTION
 *  proprietary AT command to Query/Set GPRS Connection type
 *  (GPRS_ALWAYS / GPRS_WHEN_NEEDED)
 * PARAMETERS
 *  source_string_ptr       [?]
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_egtype_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
    l4c_gprs_connect_type_enum connect_type;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    switch (source_string_ptr->cmd_mode)
    {
    case RMMI_READ_MODE:
    {
        ret_val = l4c_nw_get_gprs_connect_type_req(&connect_type);
        rmmi_ptr->arg_list[0] = (void*)&connect_type;
        string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+EGTYPE: %d", rmmi_ptr->arg_list, 1);
        rsp_str = &buffer[0];
        break;
    }
    case RMMI_SET_OR_EXECUTE_MODE:
    {
#ifndef __MMI_FMI__
        kal_uint8 error_cause;
        kal_uint8 ps_detach;

        connect_type = (l4c_gprs_connect_type_enum)
                       rmmi_int_validator_range_check(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA, L4C_GPRS_CONN_TYPE_UNKNOWN - 1); //mtk02285, MAUI_02931839, 20110505

        if (error_cause != RMMI_PARSE_OK)
        {
            break;
        }

        ps_detach = (kal_uint8)rmmi_int_validator_range_check(&error_cause, source_string_ptr, rmmi_ptr->s_reg.s3, 1);

        if (error_cause != RMMI_PARSE_OK)
        {
            if (error_cause == RMMI_PARSE_NOT_FOUND)
            {
                ps_detach = 0;
            }
            else
            {
                break;
            }
        }

        if (connect_type == L4C_ALWAYS_FOR_GCF) //mtk02285, MAUI_02931839, 20110505
        {
            // Call RAC API to only modify RAC context to GPRS always
            // It does NOT change NVRAM setting at all
            ret_val = l4crac_save_auto_attach_context(KAL_TRUE);
        }
        else if ((connect_type == L4C_ALWAYS) ||
                 ((connect_type == L4C_WHEN_NEEDED) && (ps_detach == 0)))
        {
            /* Set from WHEN_NEEDED to ALWAYS, MM will auto attach PS service.
               Set from ALWAYS to WHEN_NEEDED but don't request to detach, MM will auto detach
               PS service if no PDP context exist.
            */
            ret_val = l4c_nw_set_gprs_connect_type_req(source_string_ptr->src_id, connect_type);
        }
        else //connect_type=L4C_WHEN_NEEDED and ps_detach=1
        {
            // Set from ALWAYS to WHEN_NEEDED, and perform PS detach
            ret_val = l4c_nw_abort_att_req(source_string_ptr->src_id, connect_type, (kal_bool)ps_detach);
            if (ret_val == KAL_TRUE)
            {
                return;
            }
        }
#endif /* !__MMI_FMI__ */
        break;
    }
    default:
    {
        break; /* unrecognized format of AT command line */
    }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
} /* end of rmmi_egtp_hdlr */


/*****************************************************************************
 * FUNCTION
 *  rmmi_psbearer_hdlr
 * DESCRIPTION
 *  proprietary AT command to Query/Set Current packet switch bearer (CPSB)
 *  (externed)
 *
 *
 * EXAMPLE
 *  AT+PSBEARER=0   -> turn off
 *  OK
 *
 *  AT+PSBEARER?
 *  +PSBEARER: <l4c_data_speed_support_enum>, <l4c_data_bearer_capablility_enum>
 *  OK
 *
 *  AT+PSBEARER=1   -> turn on
 *  OK
 *
 *  +PSBEARER: 176, 15   -> L4C_DC_HSDPAP_UPA_SUPPORT (0xb0), L4C_DC_HSDPAP_UPA_CAPABILITY
 *
 *
 * PARAMETERS
 *  source_string_ptr       [?]
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_psbearer_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim
    kal_uint8 onoff;
    kal_uint8 error_cause;
    l4c_data_speed_support_enum cell_data_speed;
    l4c_data_bearer_capablility_enum bearer_capability;
    l4c_data_bearer_capablility_enum max_bearer_capability;

    kal_trace(TRACE_FUNC, FUNC_RMMI_PSBEARER_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    case RMMI_ACTIVE_MODE:
    case RMMI_TEST_MODE:
    case RMMI_READ_MODE:
        cell_data_speed = rmmi_ptr->ps_register_status.cell_data_speed_support; //(l4c_data_speed_support_enum)l4crac_get_cell_data_speed_support();
        bearer_capability = l4c_ps_get_data_bearer_capability();

        if(L4C_NONE_ACTIVATE==bearer_capability && KAL_TRUE==check_pdp_context_exist_func())
        {
            // 2G (GPRS/EDGE) has no capability value (always L4C_NONE_ACTIVATE)
            // so align cell info (l4c_data_speed_support_enum 1 or 2)
            if( (L4C_EDGE_SUPPORT==cell_data_speed || L4C_GPRS_SUPPORT==cell_data_speed) )
            {
                bearer_capability = ((L4C_EDGE_SUPPORT==cell_data_speed) ? L4C_EDGE_CAPABILITY : L4C_GPRS_CAPABILITY );
            }
            // 3G temp status (2G inter rat to 3G, no capability)
            else if( L4C_UMTS_SUPPORT<=cell_data_speed )
            {
                bearer_capability = L4C_UMTS_CAPABILITY;
            }
        }
 
        // [MOLY00023330] @201305
        // When 3G2 and RAB hasn't been released yet, RAB doesn't send cap_ind to TCM. Causing the beader_cap isn't updated and retain in 3G.
        // L4C should check cell_data_speed and overwrite bearer_cap when cell_data_speed is on 2G
        if( (L4C_EDGE_SUPPORT==cell_data_speed || L4C_GPRS_SUPPORT==cell_data_speed) )
        {
            bearer_capability = ((L4C_EDGE_SUPPORT==cell_data_speed) ? L4C_EDGE_CAPABILITY : L4C_GPRS_CAPABILITY );
        }

        rmmi_ptr->arg_list[0] = (void*)&cell_data_speed;
        rmmi_ptr->arg_list[1] = (void*)&bearer_capability;
        string_length = rmmi_fast_string_print(buffer+string_length, (kal_uint8*) "+PSBEARER: %d, %d", rmmi_ptr->arg_list, 2);
        //rmmi_ptr->register_status.act; //this is result form RAC&TCM

//#if defined(__MTK_TARGET__) && defined(DRV_GPIO_FOR_LED_AND_15_SEGMENT)
        l4c_set_led_7_segment_debug((l4c_data_speed_support_enum)cell_data_speed,
                                    (l4c_data_bearer_capablility_enum)bearer_capability);
//#endif

        rsp_str = &buffer[0];
        ret_val = KAL_TRUE;
        break;

#if defined(__MOD_TCM__) //&& !defined(__MMI_FMI__)
    case RMMI_SET_OR_EXECUTE_MODE:
        onoff = (kal_uint8) rmmi_int_validator_range_check(
                    &error_cause,
                    source_string_ptr,
                    rmmi_ptr->s_reg.s3,
                    1);

        if(onoff == RMMI_VALIDATOR_ERROR)
        {
            break;
        }

        rmmi_ptr->report_mode.psbearer_indicate = onoff;
        ret_val = KAL_TRUE;
        break;
#endif
    default:
        /* unrecognized format of AT command line */
        break;
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
} /* end of rmmi_egtp_hdlr */


#endif /* !defined(__SLIM_AT__)*/
#endif /* defined(__MOD_TCM__) */
