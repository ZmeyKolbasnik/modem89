/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 * RMMI_VALIDATOR_CC.C
 *
 * Project:
 * --------
 *   MAUI
 *
 * Description:
 * ------------
 *   This file is intends for ...
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
#include <stdio.h>
#include <string.h>
//#include "kal_non_specific_general_types.h"
//#include "kal_release.h"
//#include "stack_common.h"
//#include "stack_msgs.h"
//#include "app_ltlcom.h" /* Task message communiction */
//#include "stacklib.h"   /* Basic type for dll, evshed, stacktimer */
//#include "app_buff_alloc.h"
//#include "stack_timer.h"
//#include "event_shed.h"
//#include "nvram_editor_data_item.h"
//#include "custom_nvram_editor_data_item.h"
//#include "ps_trace.h"
#include "kal_trace.h"

#ifdef __MOD_SMU__
//#include "ps2sim_struct.h"
//#include "sim_common_enums.h"
//#include "smu_common_enums.h"
#endif /* __MOD_SMU__ */ 
//#include "device.h"
//#include "csmss_common_enums.h"

//#include "mcd_l3_inc_struct.h"
//#include "mcd_l3_inc_gprs_struct.h"
//#include "l3_inc_enums.h"

//#include "mcd_l4_common.h"
 
#include "l4c_common_enum.h"
#include "rmmi_common_enum.h"
#include "rmmi_context.h"
#include "l4c_context.h"
#include "layer4_context.h"
//#include "l4c_rspfmttr.h"
//#include "l4c_msghdlr.h"
#include "l4_trc.h"
#include "atci_trc.h"

//#include "uart_sw.h"
//#include "l4_defs.h"
#include "csmcc_atfunc.h"
//#include "csmss_atfunc.h"
//#include "l4c_aux_struct.h"
//#include "l4c_ss_parse.h"

#ifdef __MOD_CSM__
//#include "mcd_ss_parameters.h"
//#include "mcd_ss_tcapmessages.h"
#include "l4c_common_enum.h"
#include "csmcc_enums.h"
#include "csmcc_common_enums.h"
//#include "ps2sat_struct.h"
//#include "l4c2csm_cc_struct.h"

//#include "l4c_ciss_cmd.h"
//#include "l4c2csm_ss_struct.h"
#include "l4c_cc_cmd.h"
#include "l4c_utility.h"
#endif /* __MOD_CSM__ */ 

#if defined (VM_SUPPORT)
//#include "med_struct.h"
#endif 
#ifdef __MOD_UEM__
//#include "device.h"
//#include "l4c2uem_struct.h"
//#include "uem_at_cmd.h"
//#include "custom_em.h"
//#include "l4c_eq_cmd.h"
#endif /* __MOD_UEM__ */ 
#ifdef __MOD_RAC__
//#include "l4crac_func.h"
//#include "l4c_nw_cmd.h"
//#include "l4crac_enums.h"
#endif /* __MOD_RAC__ */ 
#ifdef __MOD_PHB__
//#include "sim_common_enums.h"
//#include "l4c2phb_enums.h"
//#include "l4c2phb_struct.h"
//#include "phb_sap.h"
//#include "l4c_phb_cmd.h"
//#include "phb_defs.h"
//#include "phb_config.h"
#endif /* __MOD_PHB__ */ 
#ifdef __MOD_SMSAL__
//#include "l4c2smsal_struct.h"
//#include "smsal_l4c_defs.h"
//#include "smsal_l4c_funcs.h"
//#include "smsal_l4c_enum.h"
//#include "smsal_defs.h"
//#include "l4c_sms_cmd.h"
#endif /* __MOD_SMSAL__ */ 
#ifdef __MOD_SMU__
//#include "ps2sat_struct.h"
//#include "mcd_ps2sat_peer.h"
#include "l4c_sim_cmd.h"
#endif /* __MOD_SMU__ */ 
#ifdef __MOD_TCM__
//#include "mmi_l3_enums.h"
//#include "mmi_sm_enums.h"
//#include "ppp_l4_enums.h"
//#include "tcm_common_enums.h"
//#include "tcm_common.h"
//#include "custom_nvram_editor_data_item.h"
//#include "l4c2abm_struct.h"
//#include "abm2l4c_struct.h"
//#include "l4c2tcm_struct.h"
//#include "l4c2tcm_func.h"
//#ifdef __TCPIP__
//#include "l4c2abm_struct.h"
//#endif /* __TCPIP__ */
//#include "l4c_gprs_cmd.h"
#endif /* __MOD_TCM__ */ 
#ifdef __MODEM_EM_MODE__
//#include "em_struct.h"
//#include "l4c_em.h"
//#include "lmmi_rsp.h"
#endif /* __MODEM_EM_MODE__ */ 

//#include "l4c_utility.h"
#include "rmmi_rspfmttr.h"
#include "rmmi_utility.h"
//#include "rmmi_rsp.h"
//#include "rmmi_validator.h"
//#include "nvram_data_items.h"
//#include "custom_hw_default.h"
//#include "l4c_table.h"
#include "rmmi_parser.h"
//#include "resource_verno.h"     // for +EGMR read MMI resource version

#ifdef __CSD_FAX__
//#include "csm_data_enums.h"
//#include "l4c2t30_struct.h"
//#include "l4c_t30_cmd.h"
//#include "l4c2t30_enums.h"
#endif /* __CSD_FAX__ */ 
#include "rmmi_parser.h"
#ifndef MED_NOT_PRESENT
//#include "med_global.h"
//#include "med_main.h"
#endif /* MED_NOT_PRESENT */ 
//#ifdef __J2ME__
//#include "jam_msg_handler.h"
//#endif 

#if defined(__BT_SUPPORT__)
//#include "bluetooth_struct.h"
#endif 

#ifdef __CTM_SUPPORT__
//#include "med_struct.h"
#endif 
//#include "l4c_sendmsg.h"

#ifdef __CUST_NEW__
//#include "gpio_sw.h"
#endif 

/* for data item NVRAM_EF_IMEI_IMEISV_LID move */
//#include "nvram_user_defs.h"
#include "csmcc_defs.h"

//#include "keypad_sw.h"
//#include "l4c2smu_struct.h"
#include "lmmi_ind.h"

#include "csmcc_common_enums.h"

//#include "mncc_struct.h"
//#include "csmcc_bc_types.h"
#include "csmcc_types.h"
//#include "custom_em.h"
//#include "L4c_ctm_cmd.h"
#include "csmcc_utility.h"
//#include "sat_def.h"
//#include "uem_proc_cmd.h"
#include "rmmi_msghdlr.h"
#include "kal_general_types.h"
#include "kal_public_api.h"
#include "ps_public_enum.h"
#include "ps_public_struct.h"
#ifdef __ECALL_SUPPORT__
#include "md_sap.h"
#include "med_msgid.h"
#include "med_struct.h"
#include "sim_public_api.h"
#endif 



#ifdef __MOD_CSM__

#if !defined(__ULC_AT__)
#ifdef __AOC_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  rmmi_cacm_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cacm_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint32 acm;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_CACM_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_READ_MODE:
        {
            ret_val = l4c_cc_get_acm_value_req(source_string_ptr->src_id, &acm);
            if (ret_val == KAL_TRUE)
            {
                kal_sprintf((char*)buffer, "+CACM: \"%06X\"", acm);
                string_length = strlen((char*)buffer);
            }
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
        #ifdef __MOD_SMU__

            kal_uint8 passwd[9];
            kal_uint8 error_cause;
            kal_uint8 result;

            /* Get the speed from the command line and validate it */
            result = (kal_uint8) rmmi_string_validator_ext(
                                    &error_cause,
                                    source_string_ptr,
                                    rmmi_ptr->s_reg.s3, /* separator */
                                    9,
                                    (kal_uint8*) passwd);
            if (result == RMMI_VALIDATOR_ERROR)
            {
                if (error_cause == RMMI_PARSE_TEXT_TOO_LONG)
                {
                    rmmi_ptr->cmee_err = TEXT_ERRSTRING_TOO_LONG_ERR;
                }
                else
                {
                    rmmi_ptr->cmee_err = RMMI_ERR_SYNTEX_ERROR;
                }
                break;
            }

            ret_val = l4c_cc_exe_reset_acm_req(source_string_ptr->src_id, (kal_uint8*) passwd);

            if (ret_val == KAL_TRUE)
            {
                return;
            }
        #endif /* __MOD_SMU__ */ 
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) buffer, string_length);
    return;
}

/*
 * Set command sets the Advice of Charge related accumulated call meter maximum value in SIM file EFACMmax. ACMmax
 * contains the maximum number of home units allowed to be consumed by the subscriber. When ACM (refer +CACM)
 * reaches ACMmax calls are prohibited (see also GSM 02.24 [26]). SIM PIN2 is usually required to set the value.
 */


/*****************************************************************************
 * FUNCTION
 *  rmmi_camm_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_camm_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 result;
    kal_uint32 acmmax = 0;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_CAMM_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_READ_MODE:
        {
            ret_val = l4c_cc_get_acm_max_req(source_string_ptr->src_id, &acmmax);
            if (ret_val == KAL_TRUE)
            {
                kal_sprintf((char*)buffer, "+CAMM: \"%06X\"", acmmax);
                string_length = strlen((char*)buffer);
            }
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
        #ifdef __MOD_SMU__
            kal_uint8 passwd[9];
            kal_uint8 error_cause;
            kal_uint8 acmmax_str[7];
            kal_uint8 i;

            rmmi_ptr->cmee_err = INVALID_CHARACTERS_IN_TEXT_ERRSTRING_ERR;
            /* get acmmax */
            result = rmmi_string_validator(
                        source_string_ptr,
                        (kal_uint8) RMMI_COMMA, /* separator */
                        7,
                        (kal_uint8*) acmmax_str);
            if (result == RMMI_VALIDATOR_ERROR) //parser string error or exceed 6 characters
            {
                break;
            }
            else if (strlen((char*)acmmax_str) != 6)   // we only accept strlen= 6
            {
                break;
            }

            for (i = 0; i < 6; i++)     //convert hex value to kal_uint32
            {
                if (RMMI_IS_NUMBER(acmmax_str[i]))
                {
                    acmmax = (acmmax << 4) + (acmmax_str[i] - RMMI_CHAR_0);
                }
                else if ((acmmax_str[i] >= RMMI_CHAR_A) && (acmmax_str[i] <= RMMI_CHAR_F))
                {
                    acmmax = (acmmax << 4) + (acmmax_str[i] - RMMI_CHAR_A) + 10;
                }
                else if ((acmmax_str[i] >= rmmi_char_a) && (acmmax_str[i] <= rmmi_char_f))
                {
                    acmmax = (acmmax << 4) + (acmmax_str[i] - rmmi_char_a) + 10;
                }
                else
                {
                    break;
                }
            }

            /* Get the speed from the command line and validate it */
            result = rmmi_string_validator_ext(
                        &error_cause,
                        source_string_ptr,
                        rmmi_ptr->s_reg.s3, /* separator */
                        9,
                        (kal_uint8*) passwd);
            if (result == RMMI_VALIDATOR_ERROR)
            {
                if (error_cause == RMMI_PARSE_TEXT_TOO_LONG)
                {
                    rmmi_ptr->cmee_err = TEXT_ERRSTRING_TOO_LONG_ERR;
                }
                break;
            }

            ret_val = l4c_cc_set_acm_max_req(source_string_ptr->src_id, (kal_uint8*) passwd, acmmax);
            if (ret_val == KAL_TRUE)
            {
                return;
            }
            rmmi_ptr->cmee_err = RMMI_ERR_UNKNOWN;
        #endif /* __MOD_SMU__ */ 
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) buffer, string_length);
    return;
}
#endif /* __AOC_SUPPORT__ */
#endif /* !defined(__ULC_AT__) */


/*****************************************************************************
 * FUNCTION
 *  rmmi_clcc_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_clcc_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_CLCC_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
            return;
        }
    #endif /* __test_mode__ */ 
        case RMMI_ACTIVE_MODE:
        {
            l4c_cc_get_call_list_req(source_string_ptr->src_id, NULL);
            return;
        }
        default:
        {
            /* unrecognized format of AT command line */
            rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNSPECIFIED);
            return;
        }
    }
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_vts_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_vts_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
    kal_uint16 string_length = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_VTS_HDLR_ENTRY);
    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            ret_val = l4ccsm_cc_test_vts_mode(&rsp_str);
            string_length = strlen((char*)rsp_str);
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 digit;
            kal_uint8 is_CR;

            rmmi_skip_spaces(source_string_ptr);
            digit = source_string_ptr->string_ptr[source_string_ptr->index];
            is_CR = source_string_ptr->string_ptr[source_string_ptr->index + 1];

            if ((RMMI_IS_NUMBER(digit) ||
                 ((digit >= 'A') && (digit <= 'D')) || ((digit >= 'a') && (digit <= 'd')) || (digit == '#') || (digit == '*')) && (is_CR == 13))

            {
                if ((digit >= 'a') && (digit <= 'd'))
                {
                    digit += RMMI_CHAR_A - rmmi_char_a;
                }
		        //mtk01616_081119:if call_id is not specified,modem will decide the call_id            
                ret_val = l4c_cc_exe_send_dtmf_req(source_string_ptr->src_id, digit,0,RMMI_CMD_ATVTS);
            }
            if (ret_val == KAL_FALSE)
            {
                rmmi_ptr->cmee_err = RMMI_ERR_UNKNOWN;
            }
        #if defined(__VTS_LATE_RESPONSE__)
            else
            {
                return;
            }
        #endif			
            break;
        }
        default:
            break;
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


#if !defined(__UCM_SUPPORT__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_chup_hdlr
 * DESCRIPTION
 *  hand up an active call
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_chup_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_bool result;
    kal_uint8 call_id;
    l4c_call_entry_struct call_entry;
    kal_bool disc = KAL_FALSE;
    kal_bool call_exist = KAL_FALSE;

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_CHUP_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
            return;
        }
    #endif /* __test_mode__ */ 
        case RMMI_ACTIVE_MODE:
        {
            /* ATH should check source id */
            result = l4ccsm_cc_get_active_call(&call_id);
            if ((result == KAL_TRUE) && (call_id != CSMCC_INVALID_CALL_ID))
            {
                call_exist = KAL_TRUE;
                l4ccsm_cc_get_call_info(call_id, &call_entry, NULL);
                if (call_entry.src_id == source_string_ptr->src_id)
                {
                    disc = KAL_TRUE;
                }
            }

            if (csmcc_find_call(CSMCC_MO_CALL, (CSMCC_CALL_INIT | CSMCC_CALL_ALERT), &call_id) == CSMCC_NO_ERROR 
                || csmcc_find_call(CSMCC_ORIG_NONE, CSMCC_NW_CALL_DISC, &call_id) == CSMCC_NO_ERROR)   //mtk00924: the call disconnect by network but waiting for user's response, ex:unassigned number
            {
                call_exist = KAL_TRUE;
                l4ccsm_cc_get_call_info(call_id, &call_entry, NULL);
                if (call_entry.src_id == source_string_ptr->src_id)
                {
                    disc = KAL_TRUE;    //mtk00924 2005_0427 : for abort MO call which is setup by AT only
                }
            }

            if (l4ccsm_cc_get_mt_call(&call_id) == KAL_TRUE)
            {
                call_exist = KAL_TRUE;
                disc = KAL_TRUE;
            }

            if (disc == KAL_FALSE)
            {
                if (call_exist == KAL_FALSE)
                {
                    kal_brief_trace(TRACE_WARNING, WARNING_CHUP_NO_CALL_TO_HANGUP);
                    rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
                    return;
                }
                else
                {
                    kal_brief_trace(TRACE_WARNING, WARNING_CHUP_DISCONNECT_AT_INITIAL_CALL);
                    ret_val = KAL_FALSE;
                }
            }
            else
            {
                ret_val = l4c_cc_exe_chld_req(source_string_ptr->src_id, CSMCC_REL_ALL, call_id);
            }

            if (ret_val == KAL_FALSE)
            {
                rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_PTR->cmee_err);
            }
            return;
        }
        default:
        {
            /* unrecognized format of AT command line */
            rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNSPECIFIED);
            return;
        }
    }

}


/*****************************************************************************
 * FUNCTION
 *  rmmi_chld_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_chld_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 action;
    kal_uint8 opcode;
    kal_uint8 call_id = 255;
    kal_uint8 const *rsp_str = NULL;
    kal_uint16 string_length = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

#if defined (__CHLD_UDUB_MT_CALL_SUPPORT__) || !defined(__MMI_FMI__)
    kal_uint8 tmp_call_id = 255;
#endif 

#ifdef __VOIP__
    rmmi_string_struct *string_ptr = NULL;
    rmmi_multiple_basic_cmd_struct *node_ptr = NULL;
    rmmi_err_id_enum *id = 0;
#endif /* __VOIP__ */ 

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_CHLD_HDLR_ENTRY);

#ifdef __VOIP__
    if (!RMMI_PTR->cm_cmd_approve)
    {   //cmd not approved, send to MMI CM to check the call status
        RMMI_PTR->string_ptr = (rmmi_string_struct*) get_ctrl_buffer(sizeof(rmmi_string_struct));
        RMMI_PTR->node_ptr = (rmmi_multiple_basic_cmd_struct*) get_ctrl_buffer(sizeof(rmmi_multiple_basic_cmd_struct));
        RMMI_PTR->id = (rmmi_err_id_enum*) get_ctrl_buffer(sizeof(rmmi_err_id_enum));

        kal_mem_cpy(RMMI_PTR->string_ptr, source_string_ptr, sizeof(rmmi_string_struct));
        ((rmmi_string_struct*) RMMI_PTR->string_ptr)->string_ptr = (kal_uint8*) get_ctrl_buffer(50);
        kal_mem_cpy(((rmmi_string_struct*) RMMI_PTR->string_ptr)->string_ptr, source_string_ptr->string_ptr, 50);

        L4C_PTR->route_thru_lmmi = KAL_TRUE;
        L4C_PTR->route_thru_lmmi_user = source_string_ptr->src_id;

        l4c_mmi_voip_at_call_ctrl_approve_lind(RMMI_CM_CHLD, (void*)string_ptr, (void*)node_ptr, (void*)id);
        while (source_string_ptr->string_ptr[source_string_ptr->index] != RMMI_PTR->s_reg.s3)
        {
            source_string_ptr->index++;
        }
        return;
    }
    else
    {
        RMMI_PTR->cm_cmd_approve = KAL_FALSE;
    }
#endif /* __VOIP__ */ 

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            ret_val = l4ccsm_cc_test_chld_mode(&rsp_str);
            string_length = strlen((char*)rsp_str);
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            l4c_call_entry_struct call_entry;
            kal_uint8 index = 255, next_index;
            kal_bool resp;
            kal_bool isValidCid = KAL_FALSE;

            /* Get the speed from the command line and validate it */
            opcode = (kal_uint8) rmmi_int_validator(
                                    source_string_ptr,
                                    rmmi_ptr->s_reg.s3 /* separator */ );
            if (opcode == RMMI_VALIDATOR_ERROR)
            {
                break;
            }

            action = check_chld_opcode(opcode, &call_id);

            /* mtk00714 add: for SCR403 , check if <cid> really exists */
            if (call_id != 0)
            {
                while (1)
                {
                    kal_mem_set(&call_entry, 0, sizeof(l4c_call_entry_struct));
                    resp = l4ccsm_cc_get_call_info(index, &call_entry, &next_index);

                    if (resp == KAL_FALSE)      // no call exist, but <call id> exists => ERROR
                    {
                        break;
                    }
                    else        //call exist, check if <call id> is one of them.
                    {
                        if (call_id == call_entry.call_id)
                        {
                            if (call_entry.call_type == CSMCC_CSD_CALL)
                            {
                                break;
                            }

                            //mtk01616_070511: use 1x to release a specific active call with <call_id> , but there is no active call or this <call_id> is not the active call                                                  
                            if (action == CSMCC_REL_SPECIFIC_ACTIVE_CALL)
                            {

                                if (call_entry.call_state != CLCC_CALL_ACTIVE)
                                {
                                    kal_brief_trace(TRACE_WARNING, CHLD_EQUAL_1X, call_entry.call_state);
                                    break;
                                }

                                //mtk01616_070822: fix BQB HFP 1.5 fail testcase 
                            #if defined(__BT_SUPPORT__)
                                if (source_string_ptr->src_id == RMMI_COMM_PTR->rmmi_hf_src)
                                {
                                    kal_uint8 hold_call_id;

                                    /* HFP 1.5 section 4.32.1 . chld=1x shall retrieve held call if exist 
                                       but when releasing specific active call_id is in mpty call , 1H should not be retrieved */
                                    if (call_entry.mpty != CLCC_MPTY &&
                                        l4ccsm_cc_get_hold_call(&hold_call_id) == KAL_TRUE)
                                    {
                                        kal_brief_trace(TRACE_INFO, FOR_BT_HFP_CHLD_EQUAL_1X);
                                        action = CSMCC_REL_ACTIVE_AND_ACCEPT;
                                    }
                                }
                            #endif /* defined(__BT_SUPPORT__) */ 

                            }

                            /* <call id> is current call */
                            isValidCid = KAL_TRUE;
                            break;
                        }

                        index = next_index;
                        if (index == 255)
                        {
                            /* last_flag=1 */
                            break;
                        }
                    }
                }
                
            #if defined(__CHLD_1x_REL_SPECIFIC_CALL__) || !defined(__MMI_FMI__)
                if (action == CSMCC_REL_SPECIFIC_CALL)
                {
                    if((call_id == L4C_PTR->mo_call_id) && (L4C_PTR->retry_cc == KAL_TRUE))
                        isValidCid = KAL_TRUE;						
                }
            #endif                
                
                if (isValidCid == KAL_FALSE)    //currently there's no call with <call_id>. return Error.
                {
                    rmmi_ptr->cmee_err = RMMI_ERR_INVALID_INDEX;
                    break;
                }
            }
            else
            {
                call_id = 0xff; //CSMCC_INVALID_CALL_ID
            }

            /* end: mtk00714 */

        #if defined (__CHLD_UDUB_MT_CALL_SUPPORT__) || !defined(__MMI_FMI__)
            if (action == CSMCC_REL_HELD_OR_UDUB && (l4ccsm_cc_get_mt_call(&tmp_call_id) == KAL_TRUE && 
                (l4ccsm_cc_get_in_call(&tmp_call_id) == KAL_FALSE && 
                 l4ccsm_cc_get_hold_call(&tmp_call_id) == KAL_FALSE)))      /* chld=0 to reject MT call */
            {
                ret_val = l4c_cc_exe_ath_req(source_string_ptr->src_id, L4C_DISCONNECT_NONE);
            }
            else
            {
                ret_val = l4c_cc_exe_chld_req(source_string_ptr->src_id, action, call_id);

        #if defined(__BT_SUPPORT__) 
                if ((ret_val == KAL_TRUE )&&(source_string_ptr->src_id == RMMI_COMM_PTR->rmmi_hf_src)&&
                    (action == CSMCC_HOLD_ACTIVE_AND_ACCEPT))
                {
                    rmmi_ptr->send_ciev_callheld = KAL_TRUE;
                }
        #endif				
            }
        #else
            ret_val = l4c_cc_exe_chld_req(source_string_ptr->src_id, action, call_id);

        #if defined(__BT_SUPPORT__) 
            if ((ret_val == KAL_TRUE )&&(source_string_ptr->src_id == RMMI_COMM_PTR->rmmi_hf_src)&&
                (action == CSMCC_HOLD_ACTIVE_AND_ACCEPT))
            {
                rmmi_ptr->send_ciev_callheld = KAL_TRUE;
            }
        #endif
        #endif

            if (ret_val == KAL_TRUE)
            {
                return;
            }
            else
            {
                rmmi_ptr->cmee_err = RMMI_ERR_UNKNOWN;
            }
        }
        default:
            break;
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}

#else /* __UCM_SUPPORT__ */ 


/*****************************************************************************
 * FUNCTION
 *  rmmi_chup_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_chup_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_CHUP_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
            return;
        }
    #endif /* __test_mode__ */ 
        case RMMI_ACTIVE_MODE:
        {
        #if defined(__BT_SUPPORT__)
            if (source_string_ptr->src_id == RMMI_COMM_PTR->rmmi_hf_src)
            {
                //mtk01616_071013: ath from bt handling is done by UCM , action UCM_ATH is only for BT Handfree
                l4c_mmi_ucm_at_req_lind(RMMI_UCM_ATH, source_string_ptr->src_id, KAL_TRUE, 0, NULL, 0, 0);
            }
            else
        #endif /* defined(__BT_SUPPORT__) */ 
            {
                l4c_mmi_ucm_at_req_lind(
                    RMMI_UCM_CHLD,
                    source_string_ptr->src_id,
                    KAL_FALSE,
                    0,
                    NULL,
                    CSMCC_REL_ALL,
                    CSMCC_INVALID_CALL_ID);
                RMMI_PTR->is_ucm_action = KAL_TRUE;
                L4C_PTR->route_thru_lmmi = KAL_TRUE;
                L4C_PTR->route_thru_lmmi_user = source_string_ptr->src_id;
                return;
            }
        }

        default:
        {
            /* unrecognized format of AT command line */
            rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNSPECIFIED);
            return;
        }
    }

}


/*****************************************************************************
 * FUNCTION
 *  rmmi_chld_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_chld_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 action;
    kal_uint8 opcode;
    kal_uint8 call_id = 255;
    kal_uint8 const *rsp_str = NULL;
    kal_uint16 string_length = 0;
    kal_bool cmd_from_bt = KAL_FALSE;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    //remove VOIP code here

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_CHLD_HDLR_ENTRY);

#if defined(__BT_SUPPORT__)
    if (source_string_ptr->src_id == RMMI_COMM_PTR->rmmi_hf_src)
    {
        cmd_from_bt = KAL_TRUE;
    }
#endif /* defined(__BT_SUPPORT__) */ 

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            ret_val = l4ccsm_cc_test_chld_mode(&rsp_str);
            string_length = strlen((char*)rsp_str);
            break;
        }
    #endif /* __test_mode__ */ 

        case RMMI_SET_OR_EXECUTE_MODE:
        {
            /* Get the speed from the command line and validate it */
            opcode = (kal_uint8) rmmi_int_validator(
                                    source_string_ptr,
                                    rmmi_ptr->s_reg.s3 /* separator */ );
            if (opcode == RMMI_VALIDATOR_ERROR)
            {
                break;
            }

            action = check_chld_opcode(opcode, &call_id);

	    if(action == 0xff)
            {
                break;
            }

#if defined(__BT_SUPPORT__)
            //MAUI_01784989: for BQB TWC/BV/03.Send +ceiv:<callheld> for AT+CHLD=2 (see HFP sepc 4.31.2)
            if((cmd_from_bt == KAL_TRUE) && (action == CSMCC_HOLD_ACTIVE_AND_ACCEPT))
            {
                rmmi_ptr->send_ciev_callheld = KAL_TRUE;
            }

            /* MAUI_02016224 UCM will separate compound action
               L4C helps to prevent send +CIEV before receiving GENERAL_RCODE_REQ */
            if ((cmd_from_bt == KAL_TRUE) && (action == CSMCC_REL_ACTIVE_AND_ACCEPT))
            {
                rmmi_ptr->is_compound_action = KAL_TRUE;
            }
#endif /* __BT_SUPPORT__ */ 
                
            l4c_mmi_ucm_at_req_lind(RMMI_UCM_CHLD, source_string_ptr->src_id, cmd_from_bt, 0, NULL, action, call_id);
            rmmi_ptr->is_ucm_action = KAL_TRUE;
            L4C_PTR->route_thru_lmmi = KAL_TRUE;
            L4C_PTR->route_thru_lmmi_user = source_string_ptr->src_id;
            return;
        }
        default:
            break;
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}

#endif /* __UCM_SUPPORT__ */ 


/*****************************************************************************
 * FUNCTION
 *  rmmi_ecpi_hdlr
 * DESCRIPTION
 *  This is for DTE to enable/disable call progress information
 *  add by mtk00714 20041123
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_ecpi_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint8 string_length = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            kal_sprintf((kal_char*) buffer, "+ECPI: (0-4294967295)");
            string_length = strlen((char*)buffer);
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_READ_MODE:
        {
	        rmmi_ptr->arg_list[0] = (void*)&(rmmi_ptr->report_mode.ecpi);
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+ECPI: %e", rmmi_ptr->arg_list, 1);
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
	    //mtk01616_081215:0xffffffff = 4294967295 (32 digit bitwise setting)
            kal_uint32 mode;

            mode = (kal_uint32) rmmi_int_validator(source_string_ptr, (kal_uint8) rmmi_ptr->s_reg.s3);
            if (mode <= 0xffffffff)
            {
                ret_val = KAL_TRUE;
                rmmi_ptr->report_mode.ecpi = mode;
            }
            break;
        }
        default:
            break;
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, buffer, string_length);
}


#if defined(__BT_SUPPORT__)

#if !defined(__UCM_SUPPORT__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_bldn_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_bldn_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 string_length = 0;
    kal_uint8 length;
    rmmi_string_struct ss_string;
    l4c_ss_string_info_struct info;
    kal_uint8 cid;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

#ifdef __VOIP__
    rmmi_string_struct *string_ptr = NULL;
    rmmi_multiple_basic_cmd_struct *node_ptr = NULL;
    rmmi_err_id_enum *id = NULL;
#endif /* __VOIP__ */ 

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_BLDN_HDLR_ENTRY);

#ifdef __VOIP__
    if (!RMMI_PTR->cm_cmd_approve)
    {   //cmd not approved, send to MMI CM to check the call status
        RMMI_PTR->string_ptr = (rmmi_string_struct*) get_ctrl_buffer(sizeof(rmmi_string_struct));
        RMMI_PTR->node_ptr = (rmmi_multiple_basic_cmd_struct*) get_ctrl_buffer(sizeof(rmmi_multiple_basic_cmd_struct));
        RMMI_PTR->id = (rmmi_err_id_enum*) get_ctrl_buffer(sizeof(rmmi_err_id_enum));

        kal_mem_cpy(RMMI_PTR->string_ptr, source_string_ptr, sizeof(rmmi_string_struct));
        ((rmmi_string_struct*) RMMI_PTR->string_ptr)->string_ptr = (kal_uint8*) get_ctrl_buffer(50);
        kal_mem_cpy(((rmmi_string_struct*) RMMI_PTR->string_ptr)->string_ptr, source_string_ptr->string_ptr, 50);
        //kal_mem_cpy(node_ptr, head_node_ptr, sizeof(rmmi_multiple_basic_cmd_struct));
        //kal_mem_cpy(id, err_id, sizeof(rmmi_err_id_enum));

        L4C_PTR->route_thru_lmmi = KAL_TRUE;
        L4C_PTR->route_thru_lmmi_user = source_string_ptr->src_id;

        l4c_mmi_voip_at_call_ctrl_approve_lind(RMMI_CM_BLDN, (void*)string_ptr, (void*)node_ptr, (void*)id);
        while (source_string_ptr->string_ptr[source_string_ptr->index] != RMMI_PTR->s_reg.s3)
        {
            source_string_ptr->index++;
        }
        return;
    }
    else
    {
        RMMI_PTR->cm_cmd_approve = KAL_FALSE;
    }
#endif /* __VOIP__ */ 
    cid = rmmi_srcid_2_cid(source_string_ptr->src_id);

    //mtk01616_070516: now always return OK for ATD at l4cphb_approve_cnf
#ifndef __ALLOW_BLDN_WITHOUT_SIM__ 
    if (L4C_PTR->sim_detected == KAL_TRUE)
#endif
    {
        //if (cid < RMMI_MAX_CHANNEL_NUMBER) 
        {
            RMMI_COMM_PTR->isAtdAction_flag |= (0x01 << cid);
        }

        switch (source_string_ptr->cmd_mode)
        {
            case RMMI_ACTIVE_MODE:
            {
                ss_string.index = 0;
                ss_string.string_ptr = get_ctrl_buffer(50);
                ss_string.ip_string = get_ctrl_buffer(21);
                ss_string.ip_string[0] = 0 /* NULL */ ;

                kal_mem_cpy(ss_string.string_ptr, rmmi_ptr->last_number_dialed, MAX_CC_ADDR_LEN);
                length = strlen((char*)ss_string.string_ptr);
                if (length > 0)
                {
                    ret_val = l4c_ss_string_parsing(source_string_ptr->src_id, 0x0f, &ss_string, (kal_uint8) length,
                                                    &info, CSMCC_VOICE_CALL, KAL_FALSE,ALS_DIAL_BY_SETTING,INFO_ECC_CHECK_BY_MODEM);

                    if (info.opcode != CC_OPERATION)
                    {
                        RMMI_COMM_PTR->isAtdAction_flag &= ~(0x01 << cid);
                    }
                }
                else
                {
                    ret_val = KAL_FALSE;
                    kal_brief_trace(TRACE_WARNING, BLDN_NO_LAST_NUMBER_DIALED_EXIST);
                }

                free_ctrl_buffer(ss_string.string_ptr);
                free_ctrl_buffer(ss_string.ip_string);

                source_string_ptr->index++;
                while (source_string_ptr->string_ptr[source_string_ptr->index] != rmmi_ptr->s_reg.s3)
                {
                    source_string_ptr->index++;
                    rmmi_skip_spaces(source_string_ptr);
                }
                if (ret_val == KAL_TRUE)
                {
                    return;
                }
                else
                {
                    break;
                }

            }
            default:
            {
                break;
            }
        }
    }

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;

}

#else /* __UCM_SUPPORT__ */ 


/*****************************************************************************
 * FUNCTION
 *  rmmi_bldn_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_bldn_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 cid;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim
#ifndef __ALLOW_BLDN_WITHOUT_SIM__
    kal_bool sim_detected = KAL_FALSE;
    kal_uint8 index;
#endif
    

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_BLDN_HDLR_ENTRY);

    //remove VOIP code here

    cid = rmmi_srcid_2_cid(source_string_ptr->src_id);

    //mtk01616_070516: now always return OK for ATD at l4cphb_approve_cnf

#ifndef __ALLOW_BLDN_WITHOUT_SIM__
    for (index = 0; index < L4_MAX_SIM_NUM; index++)
    {
        module_type this_l4c = L4_MODULE(MOD_L4C, index);
		l4c_context_struct* this_l4c_ptr = get_l4c_ptr_by_mod(this_l4c);
        if (this_l4c_ptr->sim_detected == KAL_TRUE)
        {
            sim_detected = KAL_TRUE;
            break;
        }
    }
    
    if (sim_detected == KAL_TRUE)
#endif
    {
        //if (cid < RMMI_MAX_CHANNEL_NUMBER)
        {
            RMMI_COMM_PTR->isAtdAction_flag |= (0x01 << cid);
        }

        switch (source_string_ptr->cmd_mode)
        {
            case RMMI_ACTIVE_MODE:
            {
                //after MAUI_02825164, BLDN is route to UCM directly. UCM decides the last dialed number of MS
                l4c_mmi_ucm_at_req_lind(RMMI_UCM_BLDN, source_string_ptr->src_id, KAL_TRUE, 0, NULL, 0, 0);
                rmmi_ptr->is_ucm_action = KAL_TRUE;
                L4C_PTR->route_thru_lmmi = KAL_TRUE;
                L4C_PTR->route_thru_lmmi_user = source_string_ptr->src_id;
                return;
            }
            default:
            {
                break;
            }
        }
    }

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;

}
#endif /* __UCM_SUPPORT__ */ 

#if defined(VRSI_ENABLE) || defined(VR_ENABLE)  //guoming        //hogan: MMI will handle MSG_ID_MMI_L4_BT_SET_VR_REQ_IND when VRSI is enable
/*****************************************************************************
 * FUNCTION
 *  rmmi_bvra_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_bvra_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
    kal_uint16 string_length = 0;
    kal_uint8 on_off;

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_BVRA_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {

        case RMMI_SET_OR_EXECUTE_MODE:
        {
            on_off = (kal_uint8) rmmi_int_validator(
                                    source_string_ptr,
                                    RMMI_PTR->s_reg.s3 /* separator */ );

            if (on_off > 1)
            {
                break;  //error handling
            }

            l4c_bt_set_vr_req_ind((kal_bool) on_off);
            L4C_PTR->route_thru_lmmi = KAL_TRUE;
            L4C_PTR->route_thru_lmmi_user = source_string_ptr->src_id;			
            return;

        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}
#endif /* defined(VRSI_ENABLE) */ 

#endif /* __BT_SUPPORT__ */

#ifdef __ECALL_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  rmmi_emsd_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_emsd_hdlr(rmmi_string_struct * source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 mode;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim
    kal_uint8 const *rsp_str = NULL;
    media_aud_emsd_monitor_req_struct *param_ptr; 

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_EMSD_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;
            /* Get the speed from the command line and validate it */
            mode = (kal_uint8) rmmi_int_validator_ext(
                                &error_cause,
                                source_string_ptr,
                                rmmi_ptr->s_reg.s3 /* separator */ );
            if (is_cmd_conflict(source_string_ptr->src_id,EMSD_EXE)== KAL_TRUE) 
            {
                    break; 
            }
         
            param_ptr = (media_aud_emsd_monitor_req_struct*)
                      construct_local_para((kal_uint16) sizeof(media_aud_emsd_monitor_req_struct), TD_RESET);
            
            switch (mode)
            {
                
                case 0:
                {
                    param_ptr->monitor = KAL_FALSE;
                    param_ptr->src_id = source_string_ptr->src_id;
                    msg_send6(MOD_ATCI, MOD_MED, ATCI_SAP, MSG_ID_MEDIA_AUD_EMSD_MONITOR_REQ,(local_para_struct *) param_ptr, NULL);
                    ret_val = KAL_TRUE;
                    l4c_set_user_action(L4C_CC, source_string_ptr->src_id, EMSD_EXE);
                    break;
                }
                case 1:
                {
                    param_ptr->monitor = KAL_TRUE;
                    param_ptr->src_id = source_string_ptr->src_id;
                    msg_send6(MOD_ATCI, MOD_MED, ATCI_SAP, MSG_ID_MEDIA_AUD_EMSD_MONITOR_REQ,(local_para_struct *) param_ptr, NULL);
                    ret_val = KAL_TRUE;
                    l4c_set_user_action(L4C_CC, source_string_ptr->src_id, EMSD_EXE);
                    break;
                }
                default:
                { 
                    free_local_para((local_para_struct *)param_ptr);
                    ret_val= KAL_FALSE;
                    break;
                }
            }
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    if (ret_val==KAL_FALSE)
    {
        rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, 0);
    }
    return;
}

/*****************************************************************************
 * FUNCTION
 *  rmmi_emsdpush_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_emsdpush_hdlr(rmmi_string_struct * source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 mode;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim
    kal_uint8 const *rsp_str = NULL;
    media_aud_emsd_push_req_struct *param_ptr;
    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_EMSDPUSH_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_ACTIVE_MODE:
        {
            kal_uint8 error_cause;
            /* Get the speed from the command line and validate it */
            mode = (kal_uint8) rmmi_int_validator_ext(
                                &error_cause,
                                source_string_ptr,
                                rmmi_ptr->s_reg.s3 /* separator */ );
            if (is_cmd_conflict(source_string_ptr->src_id,EMSDPUSH_EXE)== KAL_TRUE) 
            {
                    break; 
            }
         
            param_ptr = (media_aud_emsd_push_req_struct*)
                      construct_local_para((kal_uint16) sizeof(media_aud_emsd_monitor_req_struct), TD_RESET);
            param_ptr->src_id = source_string_ptr->src_id;
            l4c_set_user_action(L4C_CC, source_string_ptr->src_id, EMSDPUSH_EXE);
            msg_send6(MOD_ATCI, MOD_MED, ATCI_SAP, MSG_ID_MEDIA_AUD_EMSD_PUSH_REQ, (local_para_struct *)param_ptr, NULL);
            ret_val = KAL_TRUE;
            break;

        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    if (ret_val==KAL_FALSE)
    {
        rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, 0);
    }
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_emsdset_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_emsdset_hdlr(rmmi_string_struct * source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 length;
    kal_uint8 addr[EMSD_DATA_LEN]={0};
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim
    media_aud_emsd_set_req_struct *param_ptr;
    kal_uint8 const *rsp_str = NULL;

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_EMSDSET_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;
            /* Get the speed from the command line and validate it */
            //pohan, convert bytestring 
            if (is_cmd_conflict(source_string_ptr->src_id,EMSDSET_EXE)== KAL_TRUE) 
            {
                    break; 
            }
            ret_val = rmmi_emsd_hex_validator(source_string_ptr, RMMI_END_OF_STRING_CHAR, EMSD_DATA_LEN, addr);
            if (ret_val == KAL_TRUE)
            {
                param_ptr = (media_aud_emsd_set_req_struct*)
                      construct_local_para((kal_uint16) sizeof(media_aud_emsd_set_req_struct), TD_RESET);
                param_ptr->src_id = source_string_ptr->src_id;
                kal_mem_cpy(param_ptr->data, addr, sizeof(addr));
                msg_send6(MOD_ATCI, MOD_MED, ATCI_SAP, MSG_ID_MEDIA_AUD_EMSD_SET_REQ, (local_para_struct *)param_ptr, NULL);
                l4c_set_user_action(L4C_CC, source_string_ptr->src_id, EMSDSET_EXE);
                ret_val=KAL_TRUE;
            }
            else
            {
                ret_val=KAL_FALSE;
            }
           
            
            
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    if (ret_val==KAL_FALSE)
    {
        rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, 0);
    }
    return;
}

/*****************************************************************************
 * FUNCTION
 *  rmmi_emsdmod_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_emsdmod_hdlr(rmmi_string_struct * source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 mode;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim
    kal_uint8 const *rsp_str = NULL;

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_EMSDMOD_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;
            /* Get the speed from the command line and validate it */
            mode = (kal_uint8) rmmi_int_validator_ext(
                                &error_cause,
                                source_string_ptr,
                                rmmi_ptr->s_reg.s3 /* separator */ );

            if(mode<=3)
            {
                sim_set_ecall_test_mode((sim_interface_enum)(rmmi_current_mod_id-MOD_ATCI),mode);
                ret_val= KAL_TRUE;
            }
            break;
            
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, 0);

    return;
}

/*****************************************************************************
 * FUNCTION
 *  rmmi_emsdtnum_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_emsdtnum_hdlr(rmmi_string_struct * source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 mode;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim
    kal_uint16 count = 0;
    kal_uint8 tmp_index =0;
    l4_addr_bcd_struct test_number;
    kal_uint8 number[MAX_CC_ADDR_LEN];
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 temp_count=0;

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_EMSDTNUM_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_ACTIVE_MODE:
        {
            L4C_COMM_PTR->l4c_use_tnum =KAL_FALSE;

            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;

            tmp_index = source_string_ptr->index;
            while (source_string_ptr->string_ptr[tmp_index] != rmmi_ptr->s_reg.s3)
            {
                tmp_index++;
                count++;
            }
            kal_mem_set(&test_number, 0, sizeof(l4_addr_bcd_struct));
               //mtk01616_081221: atd is used to dial voice call ,we don't support too long called number 
            if(count > MAX_CC_ADDR_LEN)
                   count = MAX_CC_ADDR_LEN;     
            kal_mem_cpy(number, &(source_string_ptr->string_ptr[source_string_ptr->index]), count);
            if (number[0]== 43)
            {
                test_number.addr_bcd[0] = 145; 
            }
            else
            {
                test_number.addr_bcd[0] = 129;
            }
            temp_count = convert_to_bcd(number, (kal_uint8*) & (test_number.addr_bcd[1]), MAX_CC_ADDR_LEN - 1);
            test_number.addr_length = count + 1;
            L4C_COMM_PTR->l4c_tnum= test_number;
            L4C_COMM_PTR->l4c_use_tnum =KAL_TRUE;
            ret_val = KAL_TRUE;
            break;
            
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, 0);

    return;
}

/*****************************************************************************
 * FUNCTION
 *  rmmi_emsdrnum_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_emsdrnum_hdlr(rmmi_string_struct * source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 mode;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim
    kal_uint16 count = 0;
    kal_uint8 tmp_index =0;
    l4_addr_bcd_struct test_number;
    kal_uint8 number[50];
    kal_uint8 const *rsp_str = NULL;

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_EMSDRNUM_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_ACTIVE_MODE:
        {
            L4C_COMM_PTR->l4c_use_rnum =KAL_FALSE;

            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;

            tmp_index = source_string_ptr->index;
            while (source_string_ptr->string_ptr[tmp_index] != rmmi_ptr->s_reg.s3)
            {
                tmp_index++;
                count++;
            }
            kal_mem_set(&test_number, 0, sizeof(l4_addr_bcd_struct));
               //mtk01616_081221: atd is used to dial voice call ,we don't support too long called number 
            if(count > MAX_CC_ADDR_LEN)
                   count = MAX_CC_ADDR_LEN;     
            kal_mem_cpy(number, &(source_string_ptr->string_ptr[source_string_ptr->index]), count);
            if (number[0]== 43)
            {
                test_number.addr_bcd[0] = 145; 
            }
            else
            {
                test_number.addr_bcd[0] = 129;
            }
            count = convert_to_bcd(number, (kal_uint8*) & (test_number.addr_bcd[1]), MAX_CC_ADDR_LEN - 1);
            test_number.addr_length = count + 1;
            L4C_COMM_PTR->l4c_rnum = test_number; 
            L4C_COMM_PTR->l4c_use_rnum =KAL_TRUE;
            ret_val = KAL_TRUE;
            break;
            
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, 0);

    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_cecall_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cecall_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool is_ecall_exist;
    kal_uint8 ecall_type;

    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;

    is_ecall_exist = csmcc_is_any_call_exist();

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:
        {
            kal_brief_trace(TRACE_INFO, INFO_ECALL_TYPE, ecall_type);

            if (is_ecall_exist)
            {
                kal_sprintf((char*)buffer, "+CECALL: %d", ecall_type);
            }
            else
            {
                kal_sprintf((char*)buffer, "+CECALL:");
            }
            
            rsp_str = &buffer[0];
            string_length = strlen((char*)rsp_str);

            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;
            kal_uint8 ecall_mode = 0;

            /* currently, ecall can't coexist with other call */
            if (is_ecall_exist == KAL_TRUE)
            {
                break;
            }

            ecall_mode = (kal_uint8) rmmi_int_validator_range_check(
                                    &error_cause,
                                    source_string_ptr,
                                    (kal_uint8) RMMI_COMMA /* separator */,
                                    3);

            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }

            //if () API check here
            if (ecall_mode <= ECALL_AUTOMATICALLY_INITIATED)
            {
                //0: test
                //1: reconfiguration
                //2: manually
                //3: automatically

                rmmi_string_struct ss_string;
                l4c_ss_string_info_struct info;
                kal_uint16 length;
                
                ss_string.index = 0;
                ss_string.string_ptr = get_ctrl_buffer(50);
                ss_string.ip_string = get_ctrl_buffer(21);
                ss_string.ip_string[0] = 0;

                if (ecall_mode > ECALL_RECONFIGURATION)
                {
                    unsigned char *ecc_num_1, *ecc_num_2;
                    ecc_custom_get_first_2_default_num(&ecc_num_1, &ecc_num_2);

                    strcpy(ss_string.string_ptr, ecc_num_1);
                    length = strlen((char*)ss_string.string_ptr);
                }

                info.opcode = CC_OPERATION;

                if (length > 0)
                {
                    #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
                    #endif

                    kal_brief_trace(TRACE_INFO, INFO_ECALL_TYPE, ecall_mode);

                    ret_val = l4c_ss_string_parsing(source_string_ptr->src_id,
                                                    0x0f,
                                                    &ss_string,
                                                    (kal_uint8) length,
                                                    &info,
                                                    CSMCC_VOICE_CALL,
                                                    KAL_FALSE,
                                                    ALS_DIAL_BY_SETTING,
                                                    ecall_mode + INFO_ECALL_START);
                }

                free_ctrl_buffer(ss_string.string_ptr);
                free_ctrl_buffer(ss_string.ip_string);

                /* l4cphb_approve_cnf_hdlr will return OK */
                return;
            }
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


#endif /*__ECALL_SUPPORT__*/
/*****************************************************************************
 * FUNCTION
 *  rmmi_eccp_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_eccp_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint32 capability;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    switch (source_string_ptr->cmd_mode)
    {
        //case RMMI_READ_MODE:  //curently, no read mode.
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;
            capability = rmmi_int_validator_ext(&error_cause, source_string_ptr, rmmi_ptr->s_reg.s3);

            if (capability == RMMI_VALIDATOR_ERROR)
            {
                break;
            }
            ret_val = l4c_cc_set_call_capability(capability);
            if (ret_val == KAL_FALSE)
            {
                rmmi_ptr->cmee_err = RMMI_ERR_UNKNOWN;
            }
            break;
        }
        default:
            break;
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}
#ifdef __ECALL_PSAP_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  rmmi_epsap_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_epsap_hdlr(rmmi_string_struct * source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 mode;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim
    kal_uint8 const *rsp_str = NULL;
    media_aud_emsd_psap_monitor_req_struct *param_ptr; 

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_EPSAP_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;
            /* Get the speed from the command line and validate it */
            mode = (kal_uint8) rmmi_int_validator_ext(
                                &error_cause,
                                source_string_ptr,
                                rmmi_ptr->s_reg.s3 /* separator */ );
            if (is_cmd_conflict(source_string_ptr->src_id,EPSAP_EXE)== KAL_TRUE) 
            {
                    break; 
            }
         
            param_ptr = (media_aud_emsd_psap_monitor_req_struct*)
                      construct_local_para((kal_uint16) sizeof(media_aud_emsd_psap_monitor_req_struct), TD_RESET);
            
            switch (mode)
            {
                
                case 0:
                {
                    param_ptr->monitor = KAL_FALSE;
                    param_ptr->src_id = source_string_ptr->src_id;
                    msg_send6(MOD_ATCI, MOD_MED, ATCI_SAP, MSG_ID_MEDIA_AUD_EMSD_PSAP_MONITOR_REQ,(local_para_struct *) param_ptr, NULL);
                    ret_val = KAL_TRUE;
                    l4c_set_user_action(L4C_CC, source_string_ptr->src_id, EPSAP_EXE);
                    break;
                }
                case 1:
                {
                    param_ptr->monitor = KAL_TRUE;
                    param_ptr->src_id = source_string_ptr->src_id;
                    msg_send6(MOD_ATCI, MOD_MED, ATCI_SAP, MSG_ID_MEDIA_AUD_EMSD_PSAP_MONITOR_REQ,(local_para_struct *) param_ptr, NULL);
                    ret_val = KAL_TRUE;
                    l4c_set_user_action(L4C_CC, source_string_ptr->src_id, EPSAP_EXE);
                    break;
                }
                default:
                { 
                    free_local_para((local_para_struct *)param_ptr);
                    ret_val= KAL_FALSE;
                    break;
                }
            }
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    if (ret_val==KAL_FALSE)
    {
        rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, 0);
    }
    return;
}

/*****************************************************************************
 * FUNCTION
 *  rmmi_epsappull_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_epsappull_hdlr(rmmi_string_struct * source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 mode;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim
    kal_uint8 const *rsp_str = NULL;
    media_aud_emsd_psap_pull_req_struct *param_ptr;
    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_EPSAPPULL_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_ACTIVE_MODE:
        {
            kal_uint8 error_cause;
            /* Get the speed from the command line and validate it */
            mode = (kal_uint8) rmmi_int_validator_ext(
                                &error_cause,
                                source_string_ptr,
                                rmmi_ptr->s_reg.s3 /* separator */ );
            if (is_cmd_conflict(source_string_ptr->src_id,EPSAPPULL_EXE)== KAL_TRUE) 
            {
                    break; 
            }
         
            param_ptr = (media_aud_emsd_psap_pull_req_struct*)
                      construct_local_para((kal_uint16) sizeof(media_aud_emsd_psap_pull_req_struct), TD_RESET);
            param_ptr->src_id = source_string_ptr->src_id;
            l4c_set_user_action(L4C_CC, source_string_ptr->src_id, EPSAPPULL_EXE);
            msg_send6(MOD_ATCI, MOD_MED, ATCI_SAP, MSG_ID_MEDIA_AUD_EMSD_PSAP_PULL_REQ, (local_para_struct *)param_ptr, NULL);
            ret_val = KAL_TRUE;
            break;

        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    if (ret_val==KAL_FALSE)
    {
        rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, 0);
    }
    return;
}


#endif 


#if !defined(__SLIM_AT__)//mtk01616_091211
#ifdef __AOC_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  rmmi_caoc_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_caoc_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 mode;
    kal_uint32 ccm = 0;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    kal_uint8 aoc_str[7];
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_CAOC_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            ret_val = l4ccsm_cc_test_aoc_mode(&rsp_str);
            if (ret_val == KAL_TRUE)
            {
                string_length = strlen((char*)rsp_str);
            }
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_READ_MODE:
        {
            mode = rmmi_ptr->report_mode.ccm + 1;

            rmmi_ptr->arg_list[0] = (void*)&mode;
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CAOC: %d", rmmi_ptr->arg_list, 1);
            rsp_str = &buffer[0];
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_ACTIVE_MODE:
        {
            ret_val = l4c_cc_get_ccm_value_req(source_string_ptr->src_id, &ccm);
            if(ccm >= 0x00ffffff)//three bytes (spec 27.007)
            {
                ccm = 0;
            }
            if (ret_val == KAL_FALSE)
            {
                break;
            }

            kal_sprintf((char*)aoc_str, "%06X", ccm);
            toUpper(aoc_str);

            rmmi_ptr->arg_list[0] = (void*)&aoc_str;
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CAOC: \"%s\"", rmmi_ptr->arg_list, 1);
            rsp_str = &buffer[0];
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            /* Get the speed from the command line and validate it */
            mode = (kal_uint8) rmmi_int_validator(
                                source_string_ptr,
                                rmmi_ptr->s_reg.s3 /* separator */ );
            switch (mode)
            {
                case 0:
                {
                    ret_val = l4c_cc_get_ccm_value_req(source_string_ptr->src_id, &ccm);
                    if(ccm >= 0x00ffffff)//three bytes (spec 27.007)
                    {
                        ccm = 0;
                    }
                    if (ret_val == KAL_FALSE)
                    {
                        break;
                    }

                    kal_sprintf((char*)aoc_str, "%06x", ccm);
                    toUpper(aoc_str);

                    rmmi_ptr->arg_list[0] = (void*)&aoc_str;
                    string_length = rmmi_fast_string_print(
                                        buffer,
                                        (kal_uint8*) "+CAOC: \"%s\"",
                                        rmmi_ptr->arg_list,
                                        1);
                    rsp_str = &buffer[0];
                    ret_val = KAL_TRUE;
                    break;
                }
                case 1:
                {
                    rmmi_ptr->report_mode.ccm = RMMI_DISABLE_REPORT;
                    ret_val = KAL_TRUE;
                    break;
                }
                case 2:
                {
                    rmmi_ptr->report_mode.ccm = RMMI_ENABLE_REPORT;
                    ret_val = KAL_TRUE;
                    break;
                }
                default:
                    break;
            }
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}

/*
 * Shortly before the ACM (Accumulated Call Meter) maximum value is reached, an unsolicited result code +CCWV will
 * be sent, if enabled by this command. The warning is issued approximately when 30 seconds call time remains. It is also
 * issued when starting a call if less than 30 s call time remains.
 */


/*****************************************************************************
 * FUNCTION
 *  rmmi_ccwe_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_ccwe_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 mode;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_CCWE_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            rsp_str = (kal_uint8 const*)"+CCWE: (0-1)";
            string_length = strlen((char*)rsp_str);
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_READ_MODE:
        {
            mode = rmmi_ptr->report_mode.acm_warning;

            rmmi_ptr->arg_list[0] = (void*)&mode;
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CCWE: %d", rmmi_ptr->arg_list, 1);
            rsp_str = &buffer[0];
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            /* Get the speed from the command line and validate it */
            mode = (kal_uint8) rmmi_int_validator(
                                source_string_ptr,
                                rmmi_ptr->s_reg.s3 /* separator */ );
            if (mode > 1)
            {
                break;
            }

            rmmi_ptr->report_mode.acm_warning = mode;
            ret_val = KAL_TRUE;
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}
#endif /* __AOC_SUPPORT__ */

/*****************************************************************************
 * FUNCTION
 *  rmmi_ccug_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_ccug_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 index, mode, info;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_CCUG_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:
        {
            ret_val = l4c_cc_get_cug_params_req(source_string_ptr->src_id, &index, &mode, &info);
            if (ret_val == KAL_FALSE)
            {
                break;
            }
            rmmi_ptr->arg_list[0] = (void*)&mode;
            rmmi_ptr->arg_list[1] = (void*)&index;
            rmmi_ptr->arg_list[2] = (void*)&info;
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CCUG: %d, %d, %d", rmmi_ptr->arg_list, 3);
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            mode = (kal_uint8) rmmi_int_validator(
                                source_string_ptr,
                                (kal_uint8) RMMI_COMMA /* separator */ );
            if (mode == RMMI_VALIDATOR_ERROR)
            {
                break;
            }

            index = (kal_uint8) rmmi_int_validator(
                                    source_string_ptr,
                                    (kal_uint8) RMMI_COMMA /* delimiter */ );
            if (index == RMMI_VALIDATOR_ERROR)
            {
                break;
            }

            info = (kal_uint8) rmmi_int_validator(source_string_ptr, rmmi_ptr->s_reg.s3);
            if (info == RMMI_VALIDATOR_ERROR)
            {
                break;
            }

            ret_val = l4c_cc_set_cug_params_req(source_string_ptr->src_id, index, mode, info);
            if (ret_val == KAL_FALSE)
            {
                rmmi_ptr->cmee_err = RMMI_ERR_UNKNOWN;
            }
            break;
        }
        default:
            break;
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) buffer, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_cpas_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cpas_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 act;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_CPAS_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            ret_val = l4ccsm_cc_test_cpas_mode(&rsp_str);
            string_length = strlen((char*)rsp_str);

            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_ACTIVE_MODE:
        {
            if (source_string_ptr->string_ptr[source_string_ptr->index] == rmmi_ptr->s_reg.s3)
            {
                ret_val = l4c_cc_get_phone_activity_req(source_string_ptr->src_id, &act);

                if (ret_val == KAL_FALSE)
                {
                    break;
                }
                rmmi_ptr->arg_list[0] = (void*)&act;
                string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CPAS: %d", rmmi_ptr->arg_list, 1);
                rsp_str = &buffer[0];
                break;

            }
            else
            {

                /* unrecognized format of AT command line */
                rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNSPECIFIED);
                return;
            }
        }
        default:
            break;
    }   /* end of the switch */

    if (ret_val == KAL_TRUE)
    {
        rmmi_write_to_uart((kal_uint8*) rsp_str, string_length, KAL_TRUE);
        rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
    }
    else
    {
        rmmi_result_code_fmttr(RMMI_RCODE_ERROR, RMMI_ERR_UNSPECIFIED);
    }

    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_cvhu_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for +CVHU (voice hang up control)
 *  mtk00714 add on 2004/03/02
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cvhu_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 buffer[10];
    kal_uint16 string_length = 0;
    kal_uint8 mode;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:    /* at+cvhu?  */
        {
		    rmmi_ptr->arg_list[0] = (void*)&(rmmi_ptr->cvhu_mode); //MAUI_02862643, mtk02285, support CVHU=1 to ignore ATH
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CVHU: %d", rmmi_ptr->arg_list, 1);
            ret_val = KAL_TRUE;
            break;			
        }
        case RMMI_SET_OR_EXECUTE_MODE:  /* at+cvhu=<mode> */
        {
            kal_uint8 error_cause;
            mode = (kal_uint8) rmmi_int_validator_ext(
                                &error_cause,
                                source_string_ptr,
                                rmmi_ptr->s_reg.s3 /* separator */ );
            if (mode == RMMI_VALIDATOR_ERROR)
            {
                if (error_cause != RMMI_PARSE_NOT_FOUND)
                {
                    break;
                }
            }
            else
            {
                if (mode > 1) //MAUI_02862643, mtk02285, support CVHU=1 to ignore ATH
                {
                    break;
                }
            }
			rmmi_ptr->cvhu_mode = mode; 
            ret_val = KAL_TRUE;
            break;
        }
        default:
            break;
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) buffer, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_ctfr_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_ctfr_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_bool sub_addr_flag = KAL_FALSE;
    kal_uint8 result;
    l4c_number_struct addr;
    l4c_sub_addr_struct sub_addr;
    kal_uint8 error_cause;

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_CTFR_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            /* get <number> */
            result = rmmi_string_validator_ext(
                        (kal_uint8*) & error_cause,
                        source_string_ptr,
                        (kal_uint8) RMMI_COMMA, /* separator */
                        MAX_CC_ADDR_LEN,
                        (kal_uint8*) addr.number);
            if (result == RMMI_VALIDATOR_ERROR)
            {
                break;
            }

            addr.length = strlen((char*)addr.number);

            /* get <type> */
            addr.type = (kal_uint8) rmmi_int_validator_ext(
                                        (kal_uint8*) & error_cause,
                                        source_string_ptr,
                                        (kal_uint8) RMMI_COMMA);

            if (addr.type != RMMI_VALIDATOR_ERROR)      //type is present
            {
                if ((addr.type != 145) && (addr.type != 129))
                {
                    break;
                }
            }
            else if (error_cause == RMMI_PARSE_NOT_FOUND)       //type is not present
            {
                addr.type = 129;        //default
            }
            else        //type is parsing error
            {
                break;
            }

            if (addr.number[0] == RMMI_CHAR_PLUS)       //eg. +886 xxxxx => 145
            {
                kal_uint8 temp_num[MAX_CC_ADDR_LEN];
                kal_uint8 len;

                addr.type = 145;
                len = strlen((char*)addr.number);
				if(len > MAX_CC_ADDR_LEN)
				{
		    		ASSERT(0);
				}
		  			
                kal_mem_cpy((kal_uint8*) temp_num, (kal_uint8*) & addr.number[1], len - 1);
                kal_mem_cpy((kal_uint8*) addr.number, (kal_uint8*) temp_num, len - 1);
                addr.number[len - 1] = 0;
            }

            /* GET <subaddr> */
            result = rmmi_string_validator_ext(
                        (kal_uint8*) & error_cause,
                        source_string_ptr,
                        (kal_uint8) RMMI_COMMA, /* separator */
                        MAX_CC_ADDR_LEN,
                        (kal_uint8*) sub_addr.number);

            if (result == RMMI_VALIDATOR_ERROR)
            {
                if ((error_cause == RMMI_PARSE_NOT_FOUND) || (error_cause == RMMI_PARSE_OK))
                {
                    sub_addr_flag = KAL_FALSE;
                }
                else
                {
                    break;
                }
            }
            else
            {
                sub_addr_flag = KAL_TRUE;
                sub_addr.length = strlen((char*)sub_addr.number);
            }

            /* get <subtype> */
            sub_addr.type = (kal_uint8) rmmi_int_validator_ext(
                                            (kal_uint8*) & error_cause,
                                            source_string_ptr,
                                            RMMI_PTR->s_reg.s3);
            if ((result == RMMI_VALIDATOR_ERROR) && (error_cause == RMMI_PARSE_ERROR))  //Parse Error
            {
                break;
            }

            ret_val = l4c_cc_exe_call_deflect_req(source_string_ptr->src_id, addr, sub_addr_flag, sub_addr);
            if (ret_val == KAL_TRUE)
            {
                return;
            }
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_ciwf_hdlr
 * DESCRIPTION
 *  This command is used to select interconnection function
 *  add by mtk00924 20060919
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_ciwf_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint8 string_length = 0;
    kal_uint8 iwf;
    l4c_number_struct dest;
    kal_uint8 inter_working_func = 0;

    kal_mem_set(&dest, 0, sizeof(l4c_number_struct));

    switch (source_string_ptr->cmd_mode)
    {

        case RMMI_READ_MODE:
        {

            ret_val = l4c_cc_get_inter_working_func_req(RMMI_SRC, &iwf);

            if (iwf == CSMCC_ITC_3_1_K_AUDIO)
            {
                inter_working_func = 0;
            }
            else if (iwf == CSMCC_ITC_UDI)
            {
                inter_working_func = 1;
            }
            else
            {
                ret_val = KAL_FALSE;
            }

            if (ret_val == KAL_TRUE)
            {
                kal_sprintf((kal_char*) buffer, "+CIWF: %d", inter_working_func);
                string_length = strlen((char*)buffer);
            }
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {

            iwf = (kal_uint8) rmmi_int_validator(source_string_ptr, (kal_uint8) RMMI_PTR->s_reg.s3);

            if (iwf == 0)
            {
                inter_working_func = CSMCC_ITC_3_1_K_AUDIO;
            }
            else if (iwf == 1)
            {
                inter_working_func = CSMCC_ITC_UDI;
            }
            else
            {
                break;
            }

            ret_val = l4c_cc_set_inter_working_func_req(RMMI_SRC, inter_working_func);

            if (ret_val == KAL_TRUE)
            {
                RMMI_PTR->rmmi_current_profile.rmmi_ciwf = inter_working_func;
            }

            break;
        }
        default:
            break;
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, buffer, string_length);
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_crc_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for +CRC (Cellur Result code)
 *  mtk00714 add on 2004/03/02
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_crc_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;    /* response string and initialization */
    kal_uint16 string_length = 0;       /* string length variable */
    kal_uint8 mode;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    //kal_trace(TRACE_FUNC, FUNC_RMMI_CRC_HDLR_ENTRY);

    /* checking the command mode */
    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:    /* at+crc=? */
        {
            rsp_str = (kal_uint8 const*)"+CRC: (0, 1)"; /* prepare the response string */
            string_length = strlen((char*)rsp_str);     /* type casting */
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_READ_MODE:    /* at+crc?  */
        {
            ret_val = KAL_TRUE;
            rmmi_ptr->arg_list[0] = (void*)&rmmi_ptr->report_mode.crc;
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CRC: %d", rmmi_ptr->arg_list, 1);
            rsp_str = &buffer[0];
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:  /* at+crc = [<1 or 0>] */
        {
            kal_uint8 error_cause;

            mode = (kal_uint8) rmmi_int_validator_range_check(
                                &error_cause,
                                source_string_ptr,
                                rmmi_ptr->s_reg.s3 /* separator */,
                                1);

            if (mode == RMMI_VALIDATOR_ERROR)
            {
                if (error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    rmmi_ptr->report_mode.crc = RMMI_DISABLE_REPORT;
                }
                else
                {
                    break;
                }
            }
            else
            {
                if (mode > 1)
                {
                    break;
                }
                else
                {
                    rmmi_ptr->report_mode.crc = mode;
                }
            }
            ret_val = KAL_TRUE;
            break;
        }
        default:
            break;
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_cr_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for +CR (service reporting control for data call) in 07.07
 *  mtk00714 add on 2004/03/02
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cr_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
    kal_uint16 string_length = 0;
    kal_uint8 mode;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_CR_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:    /* at+cr=? */
        {
            rsp_str = (kal_uint8 const*)"+CR: (0, 1)";  /* prepare the response string */
            string_length = strlen((char*)rsp_str);     /* type casting */
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_READ_MODE:    /* at+cr?  */
        {
            ret_val = KAL_TRUE;
            rmmi_ptr->arg_list[0] = (void*)&rmmi_ptr->report_mode.cr;
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CR: %d", rmmi_ptr->arg_list, 1);
            rsp_str = &buffer[0];
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:  /* at+cr = [<1 or 0>] */
        {
            kal_uint8 error_cause;

            mode = (kal_uint8) rmmi_int_validator_ext(
                                &error_cause,
                                source_string_ptr,
                                rmmi_ptr->s_reg.s3 /* separator */ );
            if (mode == RMMI_VALIDATOR_ERROR)
            {
                if (error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    rmmi_ptr->report_mode.cr = RMMI_DISABLE_REPORT;
                }
                else
                {
                    break;
                }
            }
            else
            {
                if (mode > 1)
                {
                    break;
                }
                else
                {
                    rmmi_ptr->report_mode.cr = mode;
                }
            }
            ret_val = KAL_TRUE;
            break;
        }
        default:
            break;
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_csta_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for +CSTA
 *  mtk02508 add on 2010/11/10
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_csta_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
    kal_uint16 string_length = 0;
    kal_uint8 type;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim

    //kal_trace(TRACE_FUNC, FUNC_RMMI_CRC_HDLR_ENTRY);

    /* checking the command mode */
    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:    /* at+csta? */
        {
            ret_val = l4c_cc_get_ton_req(&type); //always returns KAL_TRUE
            rmmi_ptr->arg_list[0] = (void*)&type;
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CSTA: %d", rmmi_ptr->arg_list, 1);
            rsp_str = &buffer[0];
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:  /* at+csta = [<128-255>] */
        {
            kal_uint8 error_cause;

            type = rmmi_int_validator_u8_check(
                    &error_cause,
                    source_string_ptr,
                    rmmi_ptr->s_reg.s3 /* separator */);

            if (error_cause != RMMI_PARSE_OK)
            {
                if (error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    type = 129;
                }
                else
                {
                    break;
                }
            }
            ret_val = l4c_cc_set_ton_req(type);
            break;
        }
        default:
            break;
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


#if !defined(__MMI_FMI__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_evts_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_evts_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
    kal_uint16 string_length = 0;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 digit[2];
            kal_uint8 mode;		
            kal_uint8 error_cause;
            kal_uint8 result;

            kal_mem_set(digit, 0, 2);

            mode = (kal_uint8) rmmi_int_validator_ext(
                                    (kal_uint8*) & error_cause,
                                    source_string_ptr,
                                    (kal_uint8) RMMI_COMMA);

            if ((error_cause == RMMI_PARSE_ERROR) || (error_cause == RMMI_PARSE_NOT_FOUND) || (mode > 1))
            {
                break;
            }

            /* for START DTMF */
            if(mode == 0)
            {
                result = rmmi_string_validator_ext(
                        &error_cause,
                        source_string_ptr,
                        (kal_uint8) RMMI_COMMA, /* separator */
                        2,
                        (kal_uint8*) digit);

                if (result == RMMI_VALIDATOR_ERROR)
                {
                    break;                
                }
            }
			
            if(mode == 0)
            {
                if ((RMMI_IS_NUMBER(digit[0]) || 
					((digit[0] >= 'A') && (digit[0] <= 'D')) || 
                    ((digit[0] >= 'a') && (digit[0] <= 'd')) || (digit[0] == '#') || (digit[0] == '*')))
                {       
                    if ((digit[0] >= 'a') && (digit[0] <= 'd'))
                    {
                        digit[0] += RMMI_CHAR_A - rmmi_char_a;
                    }
                    //mtk01616_081119:if call_id is not specified,modem will decide the call_id                            
                    ret_val = l4c_cc_exe_send_dtmf_req(source_string_ptr->src_id, digit[0],0,RMMI_CMD_ATEVTS);

                #if defined(__VTS_LATE_RESPONSE__)
                    if (ret_val == KAL_TRUE)
                    {
                        return;
                    }
                #endif
                }
            }
            else if(mode == 1)
            {
                ret_val = l4c_cc_exe_stop_dtmf_req(source_string_ptr->src_id, 0);
            }					
		 
            if (ret_val == KAL_FALSE)
            {
                RMMI_PTR->cmee_err = RMMI_ERR_UNKNOWN;
            }

            break;
        }
        default:
            break;
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_eals_hdlr
 * DESCRIPTION
 *  used to set/get line id
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_eals_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    kal_uint8 line_id = 0;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:
        {

            line_id = csmcc_get_line_id();

            kal_sprintf((char*)buffer, "+EALS: %d", line_id);
            rsp_str = &buffer[0];
            string_length = strlen((char*)rsp_str);

            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;

            line_id = (kal_uint8) rmmi_int_validator_ext(
                                    &error_cause,
                                    source_string_ptr,
                                    RMMI_PTR->s_reg.s3 /* separator */ );

            if (line_id != 0 && line_id != 1)
            {
                break;
            }

            ret_val = l4c_cphs_update_als_req(source_string_ptr->src_id, line_id);

            if (ret_val == KAL_FALSE)
            {
                break;
            }
            else
            {
                return;
            }
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_echup_hdlr
 * DESCRIPTION
 *  used to force release a specific call
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_echup_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 call_id = CSMCC_INVALID_CALL_ID;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;

            call_id = (kal_uint8) rmmi_int_validator_range_check(
                                    &error_cause,
                                    source_string_ptr,
                                    RMMI_PTR->s_reg.s3 /* separator */,
                                    7);

            if ((error_cause != RMMI_PARSE_OK) || (call_id == 0))
            {
                break;
            }

            /* always return OK */
            ret_val = l4c_cc_rel_comp_req(source_string_ptr->src_id, call_id);
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}
#endif /* !defined(__MMI_FMI__) */


#if defined(__AUTO_CALL_REJECTION__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_eaic_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_eaic_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:
        {

            kal_sprintf((char*)buffer, "+EAIC: %d", L4C_PTR->mt_call_approval);
            rsp_str = &buffer[0];
            string_length = strlen((char*)rsp_str);

            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;
            kal_uint8 mode;
            kal_uint8 call_id = 0;
            kal_uint8 seq_no = 0;

            mode = (kal_uint8) rmmi_int_validator_range_check(
                                    &error_cause,
                                    source_string_ptr,
                                    (kal_uint8) RMMI_COMMA /* separator */,
                                    3);

            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }
            else if (mode < 2)
            {
                call_id = rmmi_int_validator_u8_check(
                                        &error_cause,
                                        source_string_ptr,
                                        (kal_uint8) RMMI_COMMA /* separator */);
                if (error_cause != RMMI_PARSE_OK)
                {
                    break;
                }
                
                seq_no = rmmi_int_validator_u8_check(
                                        &error_cause,
                                        source_string_ptr,
                                        RMMI_PTR->s_reg.s3 /* separator */);
                if (error_cause != RMMI_PARSE_OK)
                {
                    break;
                }
            }

            l4c_cc_call_present_res_req(mode, call_id, seq_no);
            ret_val = KAL_TRUE;
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}
#endif
/*****************************************************************************
 * FUNCTION
 *  rmmi_crm_hdlr
 * DESCRIPTION
 *  used to force release a specific call
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_crm_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    //kal_uint8 call_id = CSMCC_INVALID_CALL_ID;

    switch (source_string_ptr->cmd_mode)
    {

        case RMMI_ACTIVE_MODE:
        {
#ifdef __OP01__
            ret_val = KAL_TRUE;
#else
            ret_val = KAL_FALSE;
#endif 
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}


#endif /* !defined(__SLIM_AT__) */

/*****************************************************************************
 * FUNCTION
 *  rmmi_evdlcall_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_evdlcall_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR; //for slim
    kal_uint8 mode;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    
    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_READ_MODE:
        {
            kal_sprintf((char*)buffer, "+EVDLCALL: %d", L4C_PTR->evdl_mode);
            rsp_str = &buffer[0];
            string_length = strlen((char*)rsp_str);
            ret_val = KAL_TRUE;
            
            break;
        }    
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            mode = (kal_uint8) rmmi_int_validator(
                                source_string_ptr,
                                rmmi_ptr->s_reg.s3);

            if(mode<=1)
            {
                l4c_cc_set_evdlcall_mode_req(mode);
                ret_val = KAL_TRUE;
            }
            
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


#endif /* __MOD_CSM__ */ 



