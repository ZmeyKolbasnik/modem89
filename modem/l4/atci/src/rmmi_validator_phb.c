/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 * RMMI_VALIDATOR_PHB.C
 *
 * Project:
 * --------
 *   MAUI
 *
 * Description:
 * ------------
 *   This file is intends for ï¿½K.
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
#include <stdio.h>
#include <string.h>
//#include "kal_release.h"
//#include "stack_common.h"
//#include "stack_msgs.h"
//#include "app_ltlcom.h" /* Task message communiction */
//#include "stacklib.h"   /* Basic type for dll, evshed, stacktimer */
//#include "app_buff_alloc.h"
//#include "stack_timer.h"
//#include "event_shed.h"
//#include "nvram_editor_data_item.h"
//#include "custom_nvram_editor_data_item.h"
#include "l4_msgid.h"

#ifdef __MOD_SMU__
//#include "ps2sim_struct.h"
//#include "sim_common_enums.h"
//#include "smu_common_enums.h"
#endif /* __MOD_SMU__ */ 
#include "device.h"
//#include "csmss_common_enums.h"

//#include "mcd_l3_inc_struct.h"
//#include "mcd_l3_inc_gprs_struct.h"
//#include "l3_inc_enums.h"

#include "mcd_l4_common.h"

//#include "l4c_common_enum.h"
#include "rmmi_common_enum.h"
#include "rmmi_context.h"
#include "l4c_context.h"
#include "layer4_context.h"
//#include "l4c_rspfmttr.h"
//#include "l4c_msghdlr.h"
#include "l4_trc.h"
#include "atci_trc.h"

//#include "uart_sw.h"
#include "l4_defs.h"
//#include "csmcc_atfunc.h"
//#include "csmss_atfunc.h"
//#include "l4c_aux_struct.h"
//#include "l4c_ss_parse.h"

#ifdef __MOD_CSM__
//#include "mcd_ss_parameters.h"
//#include "mcd_ss_tcapmessages.h"
//#include "l4c_common_enum.h"
//#include "csmcc_enums.h"
//#include "csmcc_common_enums.h"
//#include "ps2sat_struct.h"
//#include "l4c2csm_cc_struct.h"

//#include "l4c_ciss_cmd.h"
//#include "l4c2csm_ss_struct.h"
//#include "l4c_cc_cmd.h"
#endif /* __MOD_CSM__ */ 

#if defined (VM_SUPPORT)
//#include "med_struct.h"
#endif 
#ifdef __MOD_UEM__
#include "device.h"
//#include "l4c2uem_struct.h"
//#include "uem_at_cmd.h"
//#include "custom_em.h"
#include "l4c_eq_cmd.h"
#endif /* __MOD_UEM__ */ 
#ifdef __MOD_RAC__
//#include "l4crac_func.h"
//#include "l4c_nw_cmd.h"
//#include "l4crac_enums.h"
#endif /* __MOD_RAC__ */ 
#ifdef __MOD_PHB__
//#include "sim_common_enums.h"
//#include "l4c2phb_enums.h"
//#include "l4c2phb_struct.h"
//#include "phb_sap.h"
#include "l4c_phb_cmd.h"
//#include "phb_defs.h"
//#include "phb_config.h"
#endif /* __MOD_PHB__ */ 
#ifdef __MOD_SMSAL__
//#include "l4c2smsal_struct.h"
//#include "smsal_l4c_defs.h"
//#include "smsal_l4c_funcs.h"
//#include "smsal_l4c_enum.h"
//#include "smsal_defs.h"
//#include "l4c_sms_cmd.h"
#endif /* __MOD_SMSAL__ */ 
#ifdef __MOD_SMU__
//#include "ps2sat_struct.h"
//#include "mcd_ps2sat_peer.h"
//#include "l4c_sim_cmd.h"
#endif /* __MOD_SMU__ */ 
#ifdef __MOD_TCM__
//#include "mmi_l3_enums.h"
//#include "mmi_sm_enums.h"
//#include "ppp_l4_enums.h"
//#include "tcm_common_enums.h"
//#include "tcm_common.h"
//#include "custom_nvram_editor_data_item.h"
//#include "l4c2abm_struct.h"
//#include "abm2l4c_struct.h"
//#include "l4c2tcm_struct.h"
//#include "l4c2tcm_func.h"
//#ifdef __TCPIP__
//#include "l4c2abm_struct.h"
//#endif /* __TCPIP__ */
//#include "l4c_gprs_cmd.h"
#endif /* __MOD_TCM__ */ 


#include "l4c_utility.h"
#include "rmmi_rspfmttr.h"
#include "rmmi_utility.h"

//#include "rmmi_validator.h"
//#include "nvram_data_items.h"
//#include "custom_hw_default.h"
//#include "l4c_table.h"
#include "rmmi_parser.h"
//#include "resource_verno.h"     // for +EGMR read MMI resource version

#ifdef __CSD_FAX__
//#include "csm_data_enums.h"
//#include "l4c2t30_struct.h"
//#include "l4c_t30_cmd.h"
//#include "l4c2t30_enums.h"
#endif /* __CSD_FAX__ */ 
#include "rmmi_parser.h"
#ifndef MED_NOT_PRESENT
//#include "med_global.h"
//#include "med_main.h"
#endif /* MED_NOT_PRESENT */ 
/*#ifdef __J2ME__
#include "jam_msg_handler.h"
#endif */

#ifdef __CTM_SUPPORT__
//#include "med_struct.h"
#endif 
//#include "l4c_sendmsg.h"

#ifdef __CUST_NEW__
//#include "gpio_sw.h"
#endif 

/* for data item NVRAM_EF_IMEI_IMEISV_LID move */
//#include "nvram_user_defs.h"
//#include "csmcc_defs.h"

//#include "keypad_sw.h"
//#include "l4c2smu_struct.h"
//#include "lmmi_ind.h"

//#include "csmcc_common_enums.h"

//#include "mncc_struct.h"
//#include "csmcc_bc_types.h"
//#include "csmcc_types.h"
//#include "custom_em.h"
//#include "L4c_ctm_cmd.h"
//#include "csmcc_utility.h"

//#include "sat_def.h"

//#include "uem_proc_cmd.h"

//#include "rmmi_msghdlr.h"

//#include "kal_non_specific_general_types.h"
//#include "ps_trace.h"
#include "kal_trace.h"
#include "kal_public_defs.h" //MSBB change #include "stack_config.h"

#include "kal_general_types.h"
#include "kal_public_api.h"
#include "ps_public_enum.h"
#include "ps_public_struct.h"

#include "rmmi_rsp.h"

#include "l4c_sendmsg.h"

extern kal_uint8 custom_wild_char(void);
extern kal_uint8 custom_auto_dtmf_modifier(void);           
extern kal_bool l4_custom_is_phb_valid_char(kal_uint8 ch);
extern kal_bool applib_is_valid_email_address(const char *str);


#ifdef __MOD_PHB__

/*****************************************************************************
 * FUNCTION
 *  rmmi_cpbr_read_with_type
 * DESCRIPTION
 * This function is used to dispatch the read action to PHB or call log related function
 * PARAMETERS
 * src_id        [IN]
 * storage      [IN]
 * index         [IN]   begin_index
 * index2       [IN]    end_index
 * cmd_index    [IN]    AT command type
 * RETURNS
 *  kal_bool
 *****************************************************************************/
static kal_bool rmmi_cpbr_read_with_type(
        kal_uint8  src_id, 
        kal_uint8 storage, 
        kal_uint16 index, 
        kal_uint16 index2, 
        rmmi_cmd_id_enum cmd_index)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 type = 0;
    kal_uint8 tmp_storage = rmmi_phb_get_sim_storage_by_current_module();
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    rmmi_ptr->cpbr_range[0] = index;
    rmmi_ptr->cpbr_range[1] = index2;

    switch (storage)
    {
        case RMMI_PHB_SM:
        case RMMI_PHB_ME:
        case RMMI_PHB_FD:
    #if defined(__SP_RIL_SUPPORT__)
        case RMMI_PHB_EN:
    #endif
        case RMMI_PHB_ON:
        {
            if (storage == RMMI_PHB_SM || storage == RMMI_PHB_ME)
            {
                type = PHB_PHONEBOOK;
            }
            else if(storage == RMMI_PHB_FD)
                type = PHB_FDN;
            #if defined(__SP_RIL_SUPPORT__)
            else if(storage == RMMI_PHB_EN)
                type = PHB_ECC;
            #endif 
            else if(storage == RMMI_PHB_ON)
                type = PHB_MSISDN;

            if (storage == RMMI_PHB_ME)
            {
                tmp_storage = PHB_STORAGE_NVRAM;
            }

            #ifdef __OP01__
            if (cmd_index == RMMI_CMD_ATSCPBR)
            {
                rmmi_ptr->scpbr_num_index = 0;
                rmmi_ptr->scpbr_entry_found = KAL_FALSE;
                ret_val = l4c_phb_get_entry_for_op01_req(src_id, type, (phb_storage_enum)tmp_storage, 0, index);
            }
            else
            #endif
            {
                ret_val = l4c_phb_get_entry_by_range_req(src_id, type, tmp_storage, 0xffff, index, 1);
            }

            break;
        }        
        case RMMI_PHB_LD:
        case RMMI_PHB_DC:
        case RMMI_PHB_MC:
        case RMMI_PHB_RC:
        case RMMI_PHB_LA:
        {
            #ifndef __CLOG_STORAGE_BY_MMI__ 
            kal_uint8 seq_id = 1;
                        /* mtk00924_060109:AT always read the first 10 entries even if there are more than 10 entries 
                           in LD, MC, RC storage, if wants to read others, the seq_id should be 2, 3... */
            #endif
        
            if (storage == RMMI_PHB_LD || storage == RMMI_PHB_DC)
            {
                type = PHB_LND;
            }
            else if (storage == RMMI_PHB_MC)
            {
                type = PHB_LNM;
            }
            else if (storage == RMMI_PHB_RC)
            {
                type = PHB_LNR;
            }
            #ifdef __PHB_STORAGE_LA__
            else if (storage == RMMI_PHB_LA)
            {				                
                type=PHB_LND;
            }
            #endif /* __PHB_STORAGE_LA__ */

            #ifndef __CLOG_STORAGE_BY_MMI__ 
            rmmi_ptr->cpbr_ln_base_index = 1;
            ret_val = l4c_phb_exe_read_ln_entry_req(src_id, type, seq_id);
            #else
            if (storage == RMMI_PHB_LA)
            {
                rmmi_ptr->cpbr_ln_base_index = 1;
                ret_val = l4c_mmi_read_clog_entry_req(src_id, type, 0);
            }
            else
            {
                rmmi_ptr->cpbr_ln_base_index = index;
                ret_val = l4c_mmi_read_clog_entry_req(src_id, type, index-1);
            }
            #endif

            break;
        }
        default:
            rmmi_ptr->cpbr_range[0] = 0;
            rmmi_ptr->cpbr_range[1] = 0;
            break;
    }
    return ret_val;
}

/*****************************************************************************
 * FUNCTION
 *  rmmi_cpbr_read
 * DESCRIPTION
 *  
 * PARAMETERS
 *  src_id      [IN]        
 *  storage     [IN]        
 *  index       [IN]        
 *  index2      [IN]        
 * RETURNS
 *  
 *****************************************************************************/
kal_bool rmmi_cpbr_read(kal_uint8 src_id, kal_uint8 storage, kal_uint16 index, kal_uint16 index2)
{
    return rmmi_cpbr_read_with_type(src_id, storage, index, index2, RMMI_CMD_ATCPBR);
}

#if !defined(__ULC_AT__) 
/*****************************************************************************
 * FUNCTION
 *  rmmi_cpbr_hdlr
 * DESCRIPTION
 * This function handles the AT+CPBR input String
 * The command is used to read PHB entries
 * PARAMETERS
 *  source_string_ptr       [IN]     At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cpbr_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint16 index, index2;
    kal_uint8 const *rsp_str = NULL;
    kal_uint16 string_length = 0;
    kal_uint16 total, used;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint8 alpha_length;
    kal_uint8 num_length;  
    kal_uint16 cmd_index;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    l4c_context_struct *l4c_ptr = L4C_PTR;

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_CPBR_HDLR_ENTRY);

    cmd_index = source_string_ptr->cmd_index;
    if (l4c_ptr->phb_ready_flag == KAL_FALSE)
    {
        rmmi_ptr->cmee_err = OPERATION_NOT_ALLOWED_ERR;
    }
    #ifdef __OP01__ //mtk02514_plutommi_usim
    else if (cmd_index == RMMI_CMD_ATSCPBR
            && rmmi_ptr->phb_storage_type != RMMI_PHB_SM)
    {
        rmmi_ptr->cmee_err = OPERATION_NOT_ALLOWED_ERR;
    }
    #endif
    else
    {
        switch (source_string_ptr->cmd_mode)
        {
            case RMMI_TEST_MODE:
            {  
                if ( !l4c_phb_get_storage_info(source_string_ptr->src_id, rmmi_ptr->phb_storage_type, &used, &total) )
                {
                    break;
                }
                
                if (rmmi_is_valid_phb_storage(rmmi_ptr->phb_storage_type) == KAL_TRUE)
                {
                    rmmi_get_phb_length(&alpha_length, &num_length);

                    #ifdef __OP01__
                    if (cmd_index == RMMI_CMD_ATSCPBR)
                    {
                        if (total ==0)
                        {
                            kal_sprintf((kal_char*) buffer, "+CPBR: (0), %d, %d, %d",
                                        num_length,alpha_length,rmmi_ptr->phb_info.sim_email_len);
                        }
                        else
                        {
                            kal_sprintf((kal_char*) buffer, "^SCPBR: (1-%d), %d, %d, %d", 
                                        total, num_length,alpha_length, rmmi_ptr->phb_info.sim_email_len);
                        }
                    }
                    else
                    #endif
                    {
                        if (total == 0)
                        {
                            kal_sprintf((kal_char*) buffer, "+CPBR: (0), %d, %d",num_length,alpha_length);
                        }
                        else
                        {
                            kal_sprintf((kal_char*) buffer, "+CPBR: (1-%d), %d, %d", total, num_length,alpha_length);
                        }
                    }
                }
                else
                {
                    break;
                }

                ret_val = KAL_TRUE;
                rsp_str = &buffer[0];
                string_length = strlen((char*)rsp_str);
                break;
            }
            case RMMI_SET_OR_EXECUTE_MODE:
            {
                kal_uint8 error_cause;

                /* mtk02514 *** MAUI_01724861 *** 090313 *************
                * we reset cmee_err here to prevent that
                * there is any confused error indication when there
                * is any error in the AT+CPBR string string
                ******************************************************/
                rmmi_ptr->cmee_err = RMMI_ERR_UNKNOWN;


                /* get total for different storage */   
                if (!l4c_phb_get_storage_info(source_string_ptr->src_id, rmmi_ptr->phb_storage_type, &used, &total) )
                {
                    break;
                }

                /* parse <index> and <index2> */
                index = (kal_uint16) rmmi_int_validator(source_string_ptr, (kal_uint8) RMMI_COMMA);
                if ((index > total) || (index == 0))
                {
                    rmmi_ptr->cmee_err = RMMI_ERR_INVALID_INDEX;
                    break;
                }

                index2 = (kal_uint16) rmmi_int_validator_ext(&error_cause, source_string_ptr, rmmi_ptr->s_reg.s3);
                if (index2 != RMMI_VALIDATOR_ERROR)
                {
                    if (index2 > total || index2 < index)
                    {
                        rmmi_ptr->cmee_err = RMMI_ERR_INVALID_INDEX;
                        break;
                    }
                }
                else
                {
                    if (error_cause == RMMI_PARSE_NOT_FOUND)
                    {
                        index2 = 0;
                    }
                    else if (error_cause == RMMI_PARSE_OK)
                    {
                        index2 = 255;
                    }
                    else
                    {
                        break;
                    }

                }

                /* READ entry */
                ret_val = rmmi_cpbr_read_with_type(
                        source_string_ptr->src_id, 
                        rmmi_ptr->phb_storage_type, 
                        index, index2, (rmmi_cmd_id_enum)cmd_index);
                if (ret_val == KAL_TRUE)
                {
                    return;
                }
            }
                break;
            default:
            {
                /* unrecognized format of AT command line */
                break;
            }
        }   /* end of the switch */
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_cpbs_hdlr
 * DESCRIPTION
 * This function handle the AT+CPBS input String
 * The command is used to select PHB storage
 * PARAMETERS
 *  source_string_ptr       [IN]     At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cpbs_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 result;
    kal_uint8 storage;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 storage_code[3];

    //kal_uint8        passwd[MAX_SIM_PASSWD_LEN];
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    kal_uint16 used, total, argc;
    kal_char *print_string;
   

    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    l4c_context_struct *l4c_ptr = L4C_PTR;

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_CPBS_HDLR_ENTRY);
    if (l4c_ptr->phb_ready_flag == KAL_FALSE)
    {
        rmmi_ptr->cmee_err = OPERATION_NOT_ALLOWED_ERR;
    }
    else
    {
        switch (source_string_ptr->cmd_mode)
        {
        #ifdef __test_mode__
            case RMMI_TEST_MODE:
            {
                rsp_str = (kal_uint8 const*)"+CPBS: (\"ME\", \"SM\", \"LD\", \"MC\", \"RC\",\"FD\")";  /* prepare the response string */
                string_length = strlen((char*)rsp_str);
                ret_val = KAL_TRUE;
                break;
            }
        #endif /* __test_mode__ */ 
            case RMMI_READ_MODE:
            {
                check_phb_storage_name(rmmi_ptr->phb_storage_type, storage_code);
                if (rmmi_is_valid_phb_storage(rmmi_ptr->phb_storage_type) == KAL_TRUE )
                {
                    ret_val = l4c_phb_get_storage_info(source_string_ptr->src_id, rmmi_ptr->phb_storage_type, &used, &total);
                    if (ret_val == KAL_FALSE)
                    {
                        break;
                    }
                    rmmi_ptr->arg_list[0] = (void*)storage_code;
                    rmmi_ptr->arg_list[1] = (void*)&used;
                    rmmi_ptr->arg_list[2] = (void*)&total;

                    print_string = "+CPBS: \"%s\", %u, %u";
                    argc = 3;
                }
                else
                {
                    rmmi_ptr->arg_list[0] = (void*)storage_code;

                    print_string = "+CPBS: \"%s\"";
                    argc = 1;
                }
                string_length = rmmi_fast_string_print(
                    buffer,
                    (kal_uint8*) print_string,
                    rmmi_ptr->arg_list,
                    argc);
                
                rsp_str = &buffer[0];
                ret_val = KAL_TRUE;
                break;
            }
            case RMMI_SET_OR_EXECUTE_MODE:
            {
                result = rmmi_string_validator(
                            source_string_ptr,
                            rmmi_ptr->s_reg.s3, /* separator */
                            3,
                            (kal_uint8*) & storage_code);

                if (result == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }

                /* convert storage_code to storage */
                storage = check_phb_storage_code(storage_code);
                if (storage == 0xff)
                {
                    break;
                }

                if ( !is_sim_verified() ) 
                {
                    if (storage == RMMI_PHB_SM ||
                        storage == RMMI_PHB_FD || 
                        storage == RMMI_PHB_ON ||
                        storage == RMMI_PHB_EN)
                        break;
                }
                
                rmmi_ptr->phb_storage_type = (rmmi_phb_type_enum) storage;
                /*
                 * if((storage == RMMI_PHB_SM) || (storage == RMMI_PHB_ME))
                 * l4c_phb_set_storage_req (source_string_ptr->src_id, storage); 
                 */

                ret_val = KAL_TRUE;
                break;
            }
            default:
                break;
        }   /* end of the switch */
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}

/*****************************************************************************
 * FUNCTION
 *  rmmi_set_valid_tel_number
 * DESCRIPTION
 * This function is used to set and check if the input number is vaild or not
 * PARAMETERS
 * tel              [OUT]        destination
 * src_num      [IN]        source input number
 * RETURNS
 *  KAL_TRUE    vaild
 *  KAL_FALSE   invalid
 *****************************************************************************/
static kal_bool rmmi_set_valid_tel_number(l4c_number_struct *tel, kal_uint8 *src_num)
{
    kal_uint16 i, maxlength;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;
    kal_bool result = KAL_FALSE;

    if (*src_num == RMMI_CHAR_PLUS)
    {
        src_num++;
        tel->type = 145;
    }

    maxlength = strlen((char*) src_num);
    if (maxlength > (L4_MAX_ADDR_BCD - 1) )
    {
        rmmi_ptr->cmee_err = DIAL_ERRSTRING_TOO_LONG_ERR;
    }
    /*we don't allow to input the number '+' */
    else if ( maxlength == 0 && tel->type == 0x91)
    {
        ;// do nothing
    }
    else 
    {
        /* Here, there should be no any '+' in the tel number */
        for (i = 0;  i  <  maxlength ; i++)
        {
            if (src_num[i] >= 'A' && src_num[i] <= 'Z')
            {
                src_num[i] = src_num[i] - 'A' + 'a';
            }

            /* mtk01616_080428: wild character input (sync with MMI behavior)
            Only allow input number with wild character when storage is  FDN/BDN
            Only allow input number with character 'w' when storage is ME         */
            #ifndef __SP_RIL_SUPPORT__
            if (src_num[i] == custom_wild_char())
            {
                kal_trace(TRACE_ERROR, ERROR_RMMI_INVALID_NUMBER, src_num[i]);
                if (rmmi_ptr->phb_storage_type != RMMI_PHB_FD)
                {
                    break;
                }
            }
            else if(l4c_check_auto_dtmf_modifier(src_num[i]) == KAL_TRUE) 
            {
                kal_trace(TRACE_ERROR, ERROR_RMMI_INVALID_NUMBER, src_num[i]);
                
                if (rmmi_ptr->phb_storage_type != RMMI_PHB_ME)
                {
                    break;
                }
                
            }
            else
            #endif
            if (src_num[i] == RMMI_CHAR_PLUS || 
                        l4_custom_is_phb_valid_char(src_num[i]) == KAL_FALSE )
            {
                break;
            }
        }               

        if(i < maxlength)
        {
            ;   
        }
        #ifndef __SP_RIL_SUPPORT__
        else if (src_num[0] == 'p' || src_num[0]==custom_auto_dtmf_modifier())
        {
            ;
        }
        #endif
        else
        {
            kal_mem_cpy((kal_uint8*) tel->number, src_num, MAX_CC_ADDR_LEN);
            tel->length = maxlength;
            result = KAL_TRUE;
        }
    }

    return result;
}

/*****************************************************************************
 * FUNCTION
 *  rmmi_phb_parse_number
 * DESCRIPTION
 * This function is used to get tel number from input string
 * PARAMETERS
 * tel                          [OUT]        destination
 * source_string_ptr      [IN]        source input string
 * RETURNS
 *  rmmi_validator_cause_enum
 *****************************************************************************/
static rmmi_validator_cause_enum rmmi_phb_parse_number(l4c_number_struct *tel, rmmi_string_struct *source_string_ptr)
{
    rmmi_validator_cause_enum error_cause;
    kal_uint8 temp_num[MAX_CC_ADDR_LEN+1];
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;

    /* <number>, <ton> */

    /* get number */
    rmmi_string_validator_ext(
            &error_cause,
            source_string_ptr,
            (kal_uint8) RMMI_COMMA,
            L4_MAX_ADDR_BCD + 1,                // one for plus, one for null terminator
            (kal_uint8*) temp_num);    

    if (error_cause == RMMI_PARSE_TEXT_TOO_LONG)
    {
        rmmi_ptr->cmee_err = DIAL_ERRSTRING_TOO_LONG_ERR;
        
    }
    else if (error_cause == RMMI_PARSE_OK)
    {
        /* get type */
        tel->type = (kal_uint8) rmmi_int_validator_ext(
                &error_cause,
                source_string_ptr,
                (kal_uint8) RMMI_COMMA);

        if (error_cause == RMMI_PARSE_NOT_FOUND)
        {
            tel->type = 129;
            error_cause = RMMI_PARSE_OK;
        }

        if (error_cause == RMMI_PARSE_OK)
        {        
            #if defined(__WM_RIL_SUPPORT__)
            if ((tel->type != 145) && (tel->type != 129) && (tel->type != 161))
            {
                error_cause = RMMI_PARSE_ERROR;  /* mtk00924: type=161 is for WM CETK test */
            }
            #else /* __WM_RIL_SUPPORT__ */ 
            if ((tel->type != 145) && (tel->type != 129))
            {
                error_cause = RMMI_PARSE_ERROR;
            }
            #endif /* __WM_RIL_SUPPORT__ */ 
            else
            {
                if (rmmi_set_valid_tel_number(tel, temp_num) == KAL_FALSE) 
                {
                    error_cause = RMMI_PARSE_ERROR;
                }
            }
        }
    }

    return error_cause;
}

/*****************************************************************************
 * FUNCTION
 *  rmmi_phb_parse_email
 * DESCRIPTION
 * This function is used to get email from input string
 * PARAMETERS
 * email                       [OUT]        destination
 * source_string_ptr      [IN]        source input string
 * RETURNS
 *  rmmi_validator_cause_enum
 *****************************************************************************/
rmmi_validator_cause_enum rmmi_phb_parse_email(phb_email_struct *email, rmmi_string_struct *source_string_ptr)
{
    kal_uint8 result;
    rmmi_validator_cause_enum error_cause;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];

    result = rmmi_string_validator_ext(
            &error_cause,
            source_string_ptr,
            (kal_uint8) RMMI_COMMA, /* separator */
            PHB_MAX_EMAIL_LENGTH,
            (kal_uint8*) email->email_address);

    if (result == RMMI_VALIDATOR_ERROR)
    {
        if (error_cause == RMMI_PARSE_NOT_FOUND || error_cause == RMMI_PARSE_OK)
        {                   
            email->email_address[0] = '\0';
            email->email_length = 0;
            error_cause = RMMI_PARSE_OK;
        }
        else if (error_cause == RMMI_PARSE_TEXT_TOO_LONG)
        {
            rmmi_ptr->cmee_err = TEXT_ERRSTRING_TOO_LONG_ERR;
        }
        else
        {
            ;
        }
    }
    else 
    {

        #ifdef __MMI_FMI__
        if (applib_is_valid_email_address(email->email_address) == KAL_FALSE)
        {
            error_cause = RMMI_PARSE_ERROR;
        }
        else
        #endif                
        {
            kal_uint8 temp_char_set = rmmi_ptr->char_set;

            rmmi_ptr->char_set = RMMI_CHSET_IRA;
            email->email_length = 
                    check_IRA_toGsm7bit(email->email_address, buffer); 
            rmmi_ptr->char_set = temp_char_set;
        
            if (email->email_length >  rmmi_ptr->phb_info.sim_email_len)
            {
                rmmi_ptr->cmee_err = TEXT_ERRSTRING_TOO_LONG_ERR;
                error_cause = RMMI_PARSE_TEXT_TOO_LONG;
            }
            else
            {
                kal_mem_cpy(email->email_address, 
                        buffer, email->email_length);
                email->email_address[email->email_length] = '\0';
            }
        }
    }
    return error_cause;
}

/*****************************************************************************
 * FUNCTION
 *  rmmi_phb_parse_text
 * DESCRIPTION
 * This function is used to get text from input string
 * PARAMETERS
 * text                       [OUT]        destination
 * source_string_ptr      [IN]        source input string
 * cmd_idnex                [IN]        AT command type
 * RETURNS
 *  rmmi_validator_cause_enum
 *****************************************************************************/
static rmmi_validator_cause_enum rmmi_phb_parse_text(
        l4_name_struct *text, 
        rmmi_string_struct *source_string_ptr, 
        rmmi_cmd_id_enum cmd_index)
{
    kal_uint8 result;
    rmmi_validator_cause_enum error_cause;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;
    kal_uint8 hexname[MAX_PS_NAME_SIZE * 2]; /* save as USC2 format or HEX */
    kal_uint8 final_name[MAX_PS_NAME_SIZE*2];
    #if defined(__CPBW_SUPPORT_ENCODING_FIELD__) || defined(__OP01__) || defined(__AT_EPBUM_SUPPORT__)
    kal_uint8 chset = RMMI_CPBW_ENCODE_MAX;
    kal_bool is_ira_dcs;
    #endif
    #ifdef __CPBW_SUPPORT_ENCODING_FIELD__
    kal_uint8 hidden;
    #endif
    kal_uint8 alpha_length, maxlength;
    kal_uint8 name_dcs = PHB_ASCII;
    kal_bool is_hex_dcs;
    
    do {
        if ((rmmi_ptr->char_set == RMMI_CHSET_UCS2)     //read (L4_MAX_NAME * 2)
            || (rmmi_ptr->char_set == RMMI_CHSET_HEX)
            #ifdef __PHB_0x81_SUPPORT__
            || (rmmi_ptr->char_set == RMMI_CHSET_UCS2_0X81)
            #endif 
            )
        {
            maxlength = MAX_PS_NAME_SIZE * 2;
        }
        else
        {
            maxlength = MAX_PS_NAME_SIZE - 1;
        }

        #if defined(__CPBW_SUPPORT_ENCODING_FIELD__) || defined(__OP01__) || defined(__AT_EPBUM_SUPPORT__)
        maxlength = MAX_PS_NAME_SIZE * 2 ;
        #endif
        result = rmmi_string_validator_ext(
                &error_cause,
                source_string_ptr,
                (kal_uint8) RMMI_COMMA, /* separator */
                maxlength,
                (kal_uint8*) hexname);

        if (result == RMMI_VALIDATOR_ERROR)
        {
            if (error_cause == RMMI_PARSE_NOT_FOUND || error_cause == RMMI_PARSE_OK)
            {
                text->name[0] = 0;
                text->name_length = 0;
                text->name_dcs = PHB_ASCII;
            }
            else if (error_cause == RMMI_PARSE_TEXT_TOO_LONG)
            {
                rmmi_ptr->cmee_err = TEXT_ERRSTRING_TOO_LONG_ERR;
                break;
            }
            else
            {
                break;
            }
        }

        #ifdef __CPBW_SUPPORT_ENCODING_FIELD__
        if (cmd_index == RMMI_CMD_ATCPBW || cmd_index == RMMI_CMD_ATEPBW)
        {
            /* get hidden */
            hidden = (kal_uint8) rmmi_int_validator_ext(
                    &error_cause,
                    source_string_ptr,
                    (kal_uint8) RMMI_COMMA);

            if (hidden != 0 && error_cause != RMMI_PARSE_NOT_FOUND)
            {
                error_cause = RMMI_PARSE_ERROR;
                break;
            }
        }
        #endif /*__CPBW_SUPPORT_ENCODING_FIELD__*/

        is_hex_dcs = KAL_TRUE;
        
        #if defined(__CPBW_SUPPORT_ENCODING_FIELD__) || defined(__OP01__) || defined(__AT_EPBUM_SUPPORT__)
        is_ira_dcs = KAL_FALSE;

        /* get chset */    
        #ifndef __CPBW_SUPPORT_ENCODING_FIELD__
        if (cmd_index != RMMI_CMD_ATCPBW && cmd_index != RMMI_CMD_ATEPBW)
        #endif
        {
            chset = (kal_uint8) rmmi_int_validator_ext(
                    &error_cause,
                    source_string_ptr,
                    RMMI_COMMA);

            if (error_cause == RMMI_PARSE_NOT_FOUND)
            {
                chset = 0;//default value
            }
            else if (chset >= RMMI_CPBW_ENCODE_MAX || error_cause != RMMI_PARSE_OK)
            {
                error_cause = RMMI_PARSE_ERROR;
                break;
            }
            
            error_cause = RMMI_PARSE_ERROR; //reset error cause
            maxlength = strlen((char*)hexname);
            if (chset == RMMI_CPBW_ENCODE_IRA) /* IRA */
            {
                if (maxlength > MAX_PS_NAME_SIZE - 1)
                {
                    rmmi_ptr->cmee_err = TEXT_ERRSTRING_TOO_LONG_ERR;
                    break;
                }
                name_dcs = PHB_ASCII;
                is_hex_dcs = KAL_FALSE;
                is_ira_dcs = KAL_TRUE;
            }
            else if (chset == RMMI_CPBW_ENCODE_UCS2)    /* UCS2 */
            {
                if (maxlength > MAX_PS_NAME_SIZE * 2)
                {
                    rmmi_ptr->cmee_err = TEXT_ERRSTRING_TOO_LONG_ERR;
                    break;
                }
                name_dcs = PHB_UCS2;
            }
            #ifdef __PHB_0x81_SUPPORT__
            else if (chset == RMMI_CPBW_ENCODE_UCS2_81)
            {
                name_dcs = PHB_UCS2_81;
            }
            else if (chset == RMMI_CPBW_ENCODE_UCS2_82)
            {
                name_dcs = PHB_UCS2_82;
            }
            #endif
        }

        if (chset != RMMI_CPBW_ENCODE_MAX)
        {
            ;// do nothing
        }
        else
        #endif /* defined(__CPBW_SUPPORT_ENCODING_FIELD__) || defined(__OP01__) || defined(__AT_EPBUM_SUPPORT__)*/
        if (rmmi_ptr->char_set == RMMI_CHSET_UCS2)
        {
            /* convert to ucs2 value and store in alpha_id */
            name_dcs = PHB_UCS2;                                                     
        }
        else if (rmmi_ptr->char_set == RMMI_CHSET_HEX)
        {
            /* convert to ucs2 value and store in alpha_id */
            name_dcs = PHB_ASCII;                                                     
        }
        #ifdef __PHB_0x81_SUPPORT__
        else if (rmmi_ptr->char_set == RMMI_CHSET_UCS2_0X81)
        {
            name_dcs = PHB_UCS2_81;                               
        }
        #endif /* __PHB_0x81_SUPPORT__ */ 
        else        //GSM or IRA
        {
            name_dcs = PHB_ASCII;                  
            is_hex_dcs = KAL_FALSE;
        }

        if (is_hex_dcs == KAL_TRUE)
        {
            is_hex_dcs = check_hex_value_ext((kal_uint8*) hexname, (kal_uint8*) text->name);

            if (is_hex_dcs == KAL_FALSE)
                break;
            alpha_length = strlen((char*)hexname) / 2;
            
            #if defined(__CPBW_ASCII_UCS2_CONVERT__) && !defined(__CPBW_SUPPORT_ENCODING_FIELD__)
            if (rmmi_ptr->char_set == RMMI_CHSET_UCS2) 
            {
                kal_bool pure_gsm;

                kal_mem_set(final_name, 0, MAX_PS_NAME_SIZE);
                pure_gsm = check_UCS2_toGsm7bit(
                        text->name, alpha_length, final_name, &alpha_length);
                if (pure_gsm) 
                {
                    kal_brief_trace(TRACE_INFO, INFO_RMMI_PURE_ASCII, pure_gsm);
                    name_dcs = PHB_ASCII;
                    kal_mem_cpy(text->name, final_name, MAX_PS_NAME_SIZE);
                }
                else
                {
                    alpha_length = strlen((char*)hexname) / 2;
                }
            }
            #endif

            text->name_length = alpha_length;
            text->name_dcs = name_dcs;
            text->name[text->name_length] = 0;
        }
        else
        {    
            #if defined(__CPBW_SUPPORT_ENCODING_FIELD__) || defined(__OP01__) || defined(__AT_EPBUM_SUPPORT__)
            if (is_ira_dcs == KAL_TRUE)
                text->name_length = check_IRA_toGsm7bit(hexname, final_name); 
            else
            #endif
                text->name_length = check_dcs_toGsm7bit(hexname, final_name); 

            if (text->name_length >= MAX_PS_NAME_SIZE) 
            {
                rmmi_ptr->cmee_err = TEXT_ERRSTRING_TOO_LONG_ERR;
                break;
            }
            else
            {
                kal_mem_cpy(text->name, final_name, text->name_length);
            }
            text->name[text->name_length] = 0;
            text->name_dcs = name_dcs;
        }
        error_cause = RMMI_PARSE_OK;
    }while(0);

    return error_cause;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_cpbw_delete
 * DESCRIPTION
 * this function is a sub function to handle the deletion of the PHB entry 
 * which is trigger by AT+CPBW
 *  
 * PARAMETERS
 *  src_id      [IN]       the source id
 *  storage    [IN]       the storage type of the deleted entry
 *  index       [IN]       the index of the deleted entry
 * RETURNS
 *  KAL_TRUE or KAL_FALSE to indicate if the action request is success or not
 *****************************************************************************/
static kal_bool rmmi_cpbw_delete(kal_uint8 src_id, kal_uint8 storage, kal_uint16 index)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 type=PHB_NONE;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;
    
    switch (storage)
    {
        case RMMI_PHB_SM:
        case RMMI_PHB_ME:
        case RMMI_PHB_FD:
        case RMMI_PHB_ON:
        {
            if (storage == RMMI_PHB_SM || storage == RMMI_PHB_ME)
            {
                type = PHB_PHONEBOOK;
            }
            else if (storage == RMMI_PHB_FD)
            {
                type = PHB_FDN;
            }
            else if (storage == RMMI_PHB_ON)
            {
                type = PHB_MSISDN;
            }

            if (storage != RMMI_PHB_ME)
            {
                storage = rmmi_phb_get_sim_storage_by_current_module();
            }
            else
            {
                storage = PHB_STORAGE_NVRAM;
            }

            /* mtk00714 : 2004/10/21  : we need to remember the record_index and use it to update MMI after receiving CNF */
            rmmi_ptr->phb_del_index = index;
            rmmi_ptr->phb_del_storage = storage;

            ret_val = l4c_phb_exe_delete_entry_req(src_id, type, 0, 0xffff, 1, storage, KAL_FALSE, index);
            break;
        }
        case RMMI_PHB_LD:
        case RMMI_PHB_MC:
        case RMMI_PHB_RC:
        case RMMI_PHB_DC:
        {
            if (rmmi_ptr->phb_storage_type == RMMI_PHB_LD || rmmi_ptr->phb_storage_type == RMMI_PHB_DC)
            {
                type = PHB_LND;
            }
            else if (rmmi_ptr->phb_storage_type == RMMI_PHB_MC)
            {
                type = PHB_LNM;
            }
            else if (rmmi_ptr->phb_storage_type == RMMI_PHB_RC)
            {
                type = PHB_LNR;
            }
            #if defined(__AT_EPBW_SUPPORT__)
            rmmi_ptr->phb_del_index = index; 
            #endif

            #ifndef __CLOG_STORAGE_BY_MMI__
            ret_val = l4c_phb_exe_delete_ln_entry_req(src_id, type, (kal_uint8) (index - 1), 0);        //index start from 0, and no_data = 0 by Josephine's request
            #else
            ret_val = l4c_mmi_delete_clog_entry_req(src_id, type, index-1); /* no_data = 0 by Josephine's request */
            #endif
        }
        default:
            break;
    }
    return ret_val;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_cpbw_write
 * DESCRIPTION
 * this function is a sub function to handle the writing action of the PHB entry 
 * which is trigger by AT+CPBW
 *  
 * PARAMETERS
 *  src_id      [IN]       the source id
 *  storage    [IN]       the storage type of the deleted entry
 *  entry       [IN]       the index of the deleted entry
 * RETURNS
 *  KAL_TRUE or KAL_FALSE to indicate if the action request is success or not
 *****************************************************************************/
static kal_bool rmmi_cpbw_write(
            kal_uint8 src_id, 
            kal_uint8 storage, 
            l4c_phb_entry_struct *entry,
            rtc_format_struct *rtc_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 type=PHB_NONE;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;
    
    switch (storage)
    {
        case RMMI_PHB_SM:
        case RMMI_PHB_ME:
        case RMMI_PHB_FD:
        case RMMI_PHB_ON:
        {
            entry->index = 0xffff;
            if(storage == RMMI_PHB_SM || storage == RMMI_PHB_ME)
            {
                type = PHB_PHONEBOOK;
            }
            else if(storage == RMMI_PHB_FD)
            {
                type = PHB_FDN;
                rmmi_ptr->is_cpbw_phb_fdn = KAL_TRUE;
            }
            else if(storage ==  RMMI_PHB_ON)
            {
                type = PHB_MSISDN;
            }

            if (storage != RMMI_PHB_ME)
            {
                entry->storage = rmmi_phb_get_sim_storage_by_current_module();
            }
            else
            {
                entry->storage = PHB_STORAGE_NVRAM;
            }
            entry->num_index = 0;   
            ret_val = l4c_phb_exe_write_entry_req(src_id, type, 1, entry);
            break;
        }
        case RMMI_PHB_LD:
        case RMMI_PHB_MC:
        case RMMI_PHB_RC:
        case RMMI_PHB_DC:
        {
            l4c_phb_ln_entry_struct ln_entry;
            rtc_alarm_info_struct rtc;
            kal_uint8 num;

            if (rmmi_ptr->phb_storage_type == RMMI_PHB_LD || rmmi_ptr->phb_storage_type == RMMI_PHB_DC)
            {
                type = PHB_LND;
            }
            else if (rmmi_ptr->phb_storage_type == RMMI_PHB_MC)
            {
                type = PHB_LNM;
            }
            else if (rmmi_ptr->phb_storage_type == RMMI_PHB_RC)
            {
                type = PHB_LNR;
            }
            kal_mem_set(&ln_entry, 0, sizeof(l4c_phb_ln_entry_struct));
            
            //set alpha id
            kal_mem_cpy((void*)&ln_entry.alpha_id, (void*)&entry->alpha_id, sizeof(l4_name_struct));

            // set tel number
        #if defined(__VOIP__) || defined(__VIDEO_CALL_SUPPORT__)
            kal_mem_cpy((void*)&ln_entry.address.tel, (void*)&entry->tel, sizeof(l4c_number_struct));
        #else 
            kal_mem_cpy((void*)&ln_entry.tel, (void*)&entry->tel, sizeof(l4c_number_struct));
        #endif 
        #ifdef __MODEM_CARD__
            if (rtc_ptr != NULL)
            {
                kal_mem_cpy((void*)&ln_entry.time, (void*)rtc_ptr, sizeof(rtc_format_struct));
            }
            else
        #endif
            {
                l4c_eq_get_rtc_time_req(src_id, RTC_TIME_CLOCK_IND, &num, (rtc_alarm_info_struct*) & rtc);
                kal_mem_cpy((void*)&ln_entry.time, (void*)&rtc.data_time, sizeof(rtc_format_struct));
            }

            #ifndef __CLOG_STORAGE_BY_MMI__
            ret_val = l4c_phb_exe_write_ln_entry_req(src_id, type, 0, 0xff, &ln_entry); /* no_data = 0 by Josephine's request */
            #else
            ret_val = l4c_mmi_write_clog_entry_req(src_id, type, 0xffff, &ln_entry); /* no_data = 0 by Josephine's request */
            #endif
        }
        default:
            break;
    }
    return ret_val;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_cpbw_hdlr
 * DESCRIPTION
 * This function is used to handle AT+CPBW command string
 * The command is used to delete or write PHB entries to the PHB storage which is selected by AT+CPBS  
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]     AT cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cpbw_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
    kal_uint16 string_length = 0;
    l4c_phb_entry_struct *entry;
    l4c_number_struct *tel;
    rmmi_phb_cpbw_struct cpbw_entry;
    kal_uint16 used, total;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint8 maxlength;
    kal_uint8 error_cause;
    kal_uint8 alpha_length;
    kal_uint8 num_length;  
    kal_uint8 i = 0;

    kal_uint8 head = 'C';
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;
    l4c_context_struct *l4c_ptr = L4C_PTR;
    kal_uint8 num_of_tel = 1;
    kal_uint16 cmd_index = source_string_ptr->cmd_index;

#ifdef __MODEM_CARD__
    kal_uint8 time[25];
    rtc_format_struct rtc;
#endif
    rtc_format_struct* rtc_ptr=NULL;

    #if defined(__AT_EPBW_SUPPORT__)
    if( cmd_index == RMMI_CMD_ATEPBW)
    {
        head = 'E';
    }
    #endif
    #ifdef __OP01__
    if (cmd_index == RMMI_CMD_ATSCPBW)
    {
        num_of_tel = 4;
    }
    #endif


    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_CPBW_HDLR_ENTRY);
    if (l4c_ptr->phb_ready_flag == KAL_FALSE)
    {
        rmmi_ptr->cmee_err = OPERATION_NOT_ALLOWED_ERR;
    }
    #ifdef __OP01__ 
    else if (cmd_index == RMMI_CMD_ATSCPBW
            && rmmi_ptr->phb_storage_type != RMMI_PHB_SM)
    {
        rmmi_ptr->cmee_err = OPERATION_NOT_ALLOWED_ERR;
    }
    #endif
    else
    {
        switch (source_string_ptr->cmd_mode)
        {
            case RMMI_TEST_MODE:
            {
                if( !l4c_phb_get_storage_info(source_string_ptr->src_id, rmmi_ptr->phb_storage_type, &used, &total) )
                {
                    break;
                }
                
                if (rmmi_is_valid_phb_storage(rmmi_ptr->phb_storage_type) == KAL_TRUE  ) 
                {
                    rmmi_get_phb_length(&alpha_length, &num_length);

                    #ifdef __OP01__
                    if (cmd_index == RMMI_CMD_ATSCPBW)
                    {
                        if (total == 0) 
                        {
                            kal_sprintf((kal_char*) buffer, "^SCPBW: (0), %d, (129,145), %d, %d", 
                                    num_length, alpha_length, rmmi_ptr->phb_info.sim_email_len);
                        }
                        else
                        {
                            kal_sprintf((kal_char*) buffer, "^SCPBW: (1-%d), %d, (129,145), %d, %d", 
                                    total, num_length,alpha_length, rmmi_ptr->phb_info.sim_email_len);
                        }
                    }
                    else
                    #endif
                    {
                        if (total == 0)
                        {
                            kal_sprintf((kal_char*) buffer, "+%cPBW: (0), %d, (129,145), %d", head, num_length, alpha_length);
                        }
                        else
                        {
                            kal_sprintf((kal_char*) buffer, "+%cPBW: (1-%d), %d, (129,145), %d", head, total, num_length, alpha_length);
                        }
                    }
                }
                else
                {
                    break;
                }

                rsp_str = &buffer[0];
                string_length = strlen((char*)rsp_str);
                ret_val = KAL_TRUE;
                break;
            }
            case RMMI_SET_OR_EXECUTE_MODE:
            {
                // reset cmee_err
                rmmi_ptr->cmee_err = RMMI_ERR_UNKNOWN;

                /* get total for different storage */
                if (!l4c_phb_get_storage_info(source_string_ptr->src_id, rmmi_ptr->phb_storage_type, &used, &total) ) 
                    break;

                entry = &cpbw_entry.entry;

                /* get index */
                entry->record_index = (kal_uint16) rmmi_int_validator_range_check(
                                                    &error_cause,
                                                    source_string_ptr,
                                                    (kal_uint8) RMMI_COMMA,
                                                    total);
                if (error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    entry->record_index = 0xffff;    /* which means write to first free location */
                } 
                else if (error_cause != RMMI_PARSE_OK || entry->record_index == 0 || entry->record_index > total)
                {
                    rmmi_ptr->cmee_err = RMMI_ERR_INVALID_INDEX;
                    break;
                }

                /* get tel number */
                for (i=0; i<num_of_tel;i++) 
                {
                    tel = &cpbw_entry.entry.tel;
                    #ifdef __OP01__
                    if (cmd_index == RMMI_CMD_ATSCPBW && i > 0)
                    {
                        tel = &cpbw_entry.num[i-1];
                    }
                    #endif
                    
                    error_cause = rmmi_phb_parse_number(tel, source_string_ptr);
                    
                    if (error_cause == RMMI_PARSE_NOT_FOUND && i==0)
                    {
                        if (entry->record_index > total) 
                        {
                            rmmi_ptr->cmee_err = RMMI_ERR_INVALID_INDEX;
                            break;
                        }
                    
                        /* only <index> is present, DELETE entry */
                        ret_val = rmmi_cpbw_delete(
                                    source_string_ptr->src_id,
                                    rmmi_ptr->phb_storage_type,
                                    entry->record_index);
                        if (ret_val == KAL_TRUE)
                        {
                            /*** mtk02514 * 090804 * MAUI_01933133 *********************
                            * The following code is used to output index when deleting using AT+EPBW
                            * But since it is no use now, we just comment it
                            *******************************************************/
                            #if 0
                            #if defined(__AT_EPBW_SUPPORT__)                        
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
                            #endif
                            #endif

                            return;
                        }
                        else
                        {
                            break;
                        }
                    }
                    else if (error_cause != RMMI_PARSE_OK)
                    {
                        break;
                    }
                }
                if (i != num_of_tel)
                {
                    break;
                }
                    
                /* get <name> */
                error_cause = rmmi_phb_parse_text(
                        &entry->alpha_id, 
                        source_string_ptr, 
                        (rmmi_cmd_id_enum) cmd_index);
                if (error_cause != RMMI_PARSE_OK)
                {
                    break;
                }

                /* Begin : mtk00714 2004/03/30 */
                if (rmmi_ptr->phb_storage_type == RMMI_PHB_SM)    //SIM
                {
                    maxlength = rmmi_ptr->phb_info.sim_phb_len;
                }
                else if (rmmi_ptr->phb_storage_type == RMMI_PHB_FD)
                {
                    maxlength = rmmi_ptr->phb_info.sim_fdn_len;
                }
                else if (rmmi_ptr->phb_storage_type == RMMI_PHB_ON)
                {
                    maxlength = rmmi_ptr->phb_info.msisdn_alpha_length;
                }
                else        //ME , LD, MC, RC
                {
                    #if defined(__PHB_STORAGE_BY_MMI__)
                        /* mtk02514 * 091218 * MAUI_02127577 *********
                        * For PHB2.0 where MMI will manager ME PHB stroage,
                        * the alpha ID will be stored using UCS2 coding.
                        * If the length of alpha ID which is encoded using ASCII/GSM7bit
                        * is more than MAX_PS_NAME_SIZE/2 -1, we will truncate the remaining ones.
                        * So here we need to guarantee that the number of characters
                        * is less than or equal to MAX_PS_NAME_SIZE/2 -1
                        ****************************************/
                    if (entry->alpha_id.name_dcs == PHB_ASCII && rmmi_ptr->phb_storage_type == RMMI_PHB_ME)
                        {
                            maxlength = (MAX_PS_NAME_SIZE >> 1) - 1;
                        }
                        else
                    #endif
                    maxlength = MAX_PS_NAME_SIZE - 1;
                }

                /* mtk02514 * 090513 * MAUI_01685786 *********
                * For the dcs PHB_UCS2, 
                * the L4 PHB will add 0x80 at the head of the name field
                * so we need to minus one to check if the length is
                * valid or not
                ****************************************/
                if ( (entry->alpha_id.name_length > maxlength) || 
                     ((entry->alpha_id.name_length > (maxlength-1)) && (entry->alpha_id.name_dcs == PHB_UCS2)) )
                {
                    rmmi_ptr->cmee_err = TEXT_ERRSTRING_TOO_LONG_ERR;
                    break;
                }
                

                if (entry->tel.length == 0 && entry->alpha_id.name_length == 0)
                {
                    break;
                }

                /* read email */
                #ifdef __OP01__
                if (cmd_index == RMMI_CMD_ATSCPBW)
                {
                    error_cause = rmmi_phb_parse_email(&cpbw_entry.email, source_string_ptr);

                    if (error_cause != RMMI_PARSE_OK)
                    {
                        break;
                    }
                    cpbw_entry.email.adn_record_index = entry->record_index;
                }
                #endif
                /* WRITE phonebook */

                #ifdef __MODEM_CARD__
                if (rmmi_ptr->phb_storage_type == RMMI_PHB_LD ||
                    rmmi_ptr->phb_storage_type == RMMI_PHB_MC ||
                    rmmi_ptr->phb_storage_type == RMMI_PHB_RC ||
                    rmmi_ptr->phb_storage_type == RMMI_PHB_DC)
                {
                    rmmi_string_validator_ext(
                        &error_cause,
                        source_string_ptr,
                        rmmi_ptr->s_reg.s3, /* separator */
                        25,
                        time);

                    if (error_cause == RMMI_PARSE_OK)
                    {

                        /* transform time into rtc format */
                        ret_val = string_to_rtc_format(&rtc, (kal_uint8*) time);
                        if (ret_val == KAL_FALSE)
                        {
                            break;
                        }
                        rtc_ptr = &rtc;
                    }
                    else if (error_cause != RMMI_PARSE_NOT_FOUND)
                    {
                        break;
                    }
                }
                #endif

                ret_val = rmmi_cpbw_write(source_string_ptr->src_id, rmmi_ptr->phb_storage_type, entry, rtc_ptr);
                if (ret_val == KAL_TRUE)
                {
                    #if defined(__AT_EPBW_SUPPORT__)                        
                    if (cmd_index == RMMI_CMD_ATEPBW)
                    {
                        rmmi_ptr->phb_is_epbw = KAL_TRUE;
                    }
                    #endif
                    #ifdef __OP01__
                    if (cmd_index == RMMI_CMD_ATSCPBW)
                    {
                        rmmi_ptr->scpbw_entry_ptr = get_ctrl_buffer(sizeof(rmmi_phb_cpbw_struct));
                        kal_mem_cpy(rmmi_ptr->scpbw_entry_ptr, &cpbw_entry, sizeof(rmmi_phb_cpbw_struct));
                    }
                    #endif
                    return;
                }
                break;
            }
            default:    /* unrecognized format of AT command line */
                break;
        }               /* end of the switch */
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}
#endif /* !defined(__ULC_AT__) */

#ifdef __AT_EPBUM_SUPPORT__

/*****************************************************************************
 * FUNCTION
 *  rmmi_phb_parse_text
 * DESCRIPTION
 * This function is used to check if the input index is valid or not according to the phb_type
 * PARAMETERS
 * phb_type            [IN]        PHB type
 * index1                [IN]        with different meaning accordint to the PHB type
 * index2                [IN]        with different meaning accordint to the PHB type
 * RETURNS
 *  KAL_TRUE        valid
 *  KAL_FALSE       invalid
 *****************************************************************************/
static kal_bool rmmi_phb_check_index_valid(phb_type_enum phb_type, kal_uint16 index1, kal_uint16 index2)
{
    kal_uint16 total;
    kal_bool result = KAL_FALSE;
    l4cphb_file_info_struct file_info;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;
    
    if (!l4c_phb_get_type_info(PHB_PHONEBOOK, &file_info, 1))
        return KAL_FALSE;
    
    total = file_info.total_num;
    switch (phb_type)
    {
    
        case PHB_SNE:
            if ( !(index1 == 0 || index1 > total 
                || index2 == 0 || index2 > rmmi_ptr->phb_sne_occurrence) )
            {
                result = KAL_TRUE;
            }
            break;
        case PHB_AAS:
            l4c_phb_get_type_info(PHB_AAS, &file_info, 1);
            if ( !(index1 == 0 || index1 > file_info.total_num)  )
            {
                result = KAL_TRUE;
            }
            break;
        case PHB_ANR:
            if ( !(index1 == 0 || index1 > total 
                || index2 == 0 || index2 > rmmi_ptr->phb_anr_occurrence) )
            {
                result = KAL_TRUE;
            }
            break;
        case PHB_GAS:
            l4c_phb_get_type_info(PHB_GAS, &file_info, 1);
            if ( !(index1 == 0 || index1 > file_info.total_num)  )
            {
                result = KAL_TRUE;
            }
            break;
         case PHB_GRP:
            if ( !(index1 == 0 || index1 > total) )
            {
                result = KAL_TRUE;
            }
            break;
         case PHB_EMAIL:
            if ( !(index1 == 0 || index1 > total 
                || index2 == 0 || index2 > rmmi_ptr->phb_email_occurrence) )
            {
                result = KAL_TRUE;
            }
            break;
         default:
            break;
    }
    return result;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_epbum_hdlr
 * DESCRIPTION
 * This function is used to handle AT+EPBUM command string
 *
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_epbum_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    l4c_context_struct *l4c_ptr = L4C_PTR;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;
    rmmi_epbum_op_enum op;
    rmmi_epbum_ef_type_enum ef_type;
    kal_uint8 error_cause, i;
    kal_uint16 index1, index2, length=0;
    phb_type_enum phb_type;
    phb_storage_enum storage = rmmi_phb_get_sim_storage_by_current_module();
    l4cphb_file_info_struct file_info;
    l4c_phb_entry_struct entry;
    l4c_phb_usim_entry usim_entry;
    
    //kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    //kal_uint16 string_length = 0;
    
    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_EPBUM_HDLR_ENTRY);
    if (l4c_ptr->phb_ready_flag == KAL_FALSE)
    {
        rmmi_ptr->cmee_err = OPERATION_NOT_ALLOWED_ERR;
    }
    else
    {
        switch (source_string_ptr->cmd_mode)
        {
            case RMMI_TEST_MODE:
            {
                
                /*AT+EPBUM?
                +EPBUM: <N_ANR>,<N_EMAIL>,<N_SNE>,<N_AAS>,<L_AAS>,<N_GAS>,<L_GAS>,<N_GRP>
                OK*/
                rmmi_header_rrsp("+EPBUM:");
                //<N_ANR>
                rmmi_int_space_rrsp(rmmi_ptr->phb_anr_occurrence);
                //<N_EMAIL>
                rmmi_int_comma_rrsp(rmmi_ptr->phb_email_occurrence);
                //<N_SNE>
                rmmi_int_comma_rrsp(rmmi_ptr->phb_sne_occurrence);
                //<N_AAS>
                l4c_phb_get_type_info(PHB_AAS, &file_info, 1);
                rmmi_int_comma_rrsp(file_info.total_num);
                //<L_AAS>
                rmmi_int_comma_rrsp(file_info.max_name_len);
                //<N_GAS>
                l4c_phb_get_type_info(PHB_GAS, &file_info, 1);
                rmmi_int_comma_rrsp(file_info.total_num);
                //<L_GAS>
                rmmi_int_comma_rrsp(file_info.max_name_len);
                //<N_GRP> // max group for an entry
                rmmi_tail_int_comma_rrsp(rmmi_ptr->phb_grp_length);

                ret_val = KAL_TRUE;
                break;
            }
            case RMMI_SET_OR_EXECUTE_MODE:
            {
                /*AT+EPBUM=<op>, <type>, <INDEX1>, <INDEX2>, <number/email/text/grp_list>*/

                /* get op */
                op = (rmmi_epbum_op_enum) rmmi_int_validator_range_check(
                                                    &error_cause,
                                                    source_string_ptr,
                                                    (kal_uint8) RMMI_COMMA,
                                                    RMMI_EPBUM_OP_MAX-1);
                if (error_cause != RMMI_PARSE_OK)
                {

                    break;
                }
                
                /* get type */
                ef_type = (rmmi_epbum_ef_type_enum) rmmi_int_validator_range_check(
                                                    &error_cause,
                                                    source_string_ptr,
                                                    (kal_uint8) RMMI_COMMA,
                                                    RMMI_EPBUM_EF_MAX-1);
                if (error_cause != RMMI_PARSE_OK)
                {

                    break;
                }
                phb_type = rmmi_epbum_type_to_phb_type(ef_type);

                /* get index1 */
                index1 = (kal_uint16) rmmi_int_validator_ext(
                        &error_cause,
                        source_string_ptr,
                        RMMI_COMMA);
                if (error_cause != RMMI_PARSE_OK)
                {

                    break;
                }

/*=====QUERY BEGIN====*/
                if (op == RMMI_EPBUM_OP_QUERY)
                {
                    /*AT+EPBUM=0, <type>, <INDEX1>
                       +EPBUM: <type>, <INDEX1>, <type_info>
                       OK 

                       <type_info>
                       EF_ANR	<M_NUM>, <A_NUM>, <L_ANR>
                       EF_EMAIL	<M_NUM>, <A_NUM>, <L_EMAIL>
                       EF_SNE	<M_NUM>, <A_NUM>, <L_SNE>*/

                    /* index1 is ef_index*/

                    if ( (ef_type == RMMI_EPBUM_EF_ANR && index1 > rmmi_ptr->phb_anr_occurrence) 
                        || (ef_type == RMMI_EPBUM_EF_EMAIL && index1 > rmmi_ptr->phb_email_occurrence)
                        || (ef_type == RMMI_EPBUM_EF_SNE && index1 > rmmi_ptr->phb_sne_occurrence) 
                        || (ef_type == RMMI_EPBUM_EF_AAS || ef_type == RMMI_EPBUM_EF_GAS || ef_type == RMMI_EPBUM_EF_GRP))
                    {
                        break;
                    }                    
                    l4c_phb_get_type_info(phb_type, &file_info, index1);

                    rmmi_header_rrsp("+EPBUM:");

                    //<type>
                    rmmi_int_space_rrsp(ef_type);
                    
                    //<INDEX1>
                    rmmi_int_comma_rrsp(index1);
                    
                    //<M_NUM>
                    rmmi_int_comma_rrsp(file_info.total_num);

                    //<A_NUM>
                    rmmi_int_comma_rrsp(file_info.free_num);
                    
                    //<L_XXX>
                    if (ef_type == RMMI_EPBUM_EF_ANR)
                    {
                        length = L4_MAX_ADDR_BCD-1;
                    }
                    else if (ef_type == RMMI_EPBUM_EF_EMAIL || ef_type == RMMI_EPBUM_EF_SNE)
                    {
                        length = file_info.max_name_len;
                    }
                    rmmi_tail_int_comma_rrsp(length);

                    ret_val = KAL_TRUE;
                }
/*=====QUERY END====*/                
/*=====READ BEGIN====*/
                else if (op == RMMI_EPBUM_OP_READ)
                {
                    /*AT+EPBUM=<op>, <type>, <index1>, <index2> */
                    
                    /* index1 is record_index*/

                    /* get index2, number_index*/
                    index2 = (kal_uint16) rmmi_int_validator_ext(
                                                    &error_cause,
                                                    source_string_ptr,
                                                    (kal_uint8) rmmi_ptr->s_reg.s3);
                    if (error_cause == RMMI_PARSE_NOT_FOUND)
                    {
                        index2 = 0;
                    }
                    else if (error_cause != RMMI_PARSE_OK)
                    {

                        break;
                    }

                    if (rmmi_phb_check_index_valid(phb_type, index1, index2) == KAL_FALSE)
                    {
                        rmmi_ptr->cmee_err = RMMI_ERR_INVALID_INDEX;
                        break;
                    }

                    if (ef_type == RMMI_EPBUM_EF_ANR)
                    {
                        ret_val = l4c_phb_read_req(
                            source_string_ptr->src_id, 
                            PHB_ANR, 
                            storage, 
                            index2 ,            // entry_index
                            0xffff, 
                            index1,             // adn_index
                            1, 
                            EPBUM_EXE);
                    }
                    else
                    {
                        ret_val = l4c_phb_read_usim_req(
                            source_string_ptr->src_id,
                            phb_type, 
                            index2, 
                            index1);
                    }

                    if (ret_val == KAL_TRUE)
                    {
                        return;
                    }

                }
/*=====READ END====*/
/*=====WRITE BEGIN====*/
                else if (op == RMMI_EPBUM_OP_WRITE)
                {
                    /*AT+EPBUM=<op>, <type>, <INDEX1>, <INDEX2>, <number/email/text/grp_list>*/

                    /* index1 is record_index */

                    /* get index2, number_index*/
                    index2 = (kal_uint16) rmmi_int_validator_ext(
                                                    &error_cause,
                                                    source_string_ptr,
                                                    (kal_uint8) RMMI_COMMA);

                    if (error_cause == RMMI_PARSE_NOT_FOUND)
                    {
                        index2 = 0;
                    }
                    else if (error_cause != RMMI_PARSE_OK)
                    {

                        break;
                    }
                    
                    if (rmmi_phb_check_index_valid(phb_type, index1, index2) == KAL_FALSE)
                    {
                        rmmi_ptr->cmee_err = RMMI_ERR_INVALID_INDEX;
                        break;
                    }
                    
                    if (ef_type == RMMI_EPBUM_EF_ANR)
                    {
                        /*<number/email/text/grp_list> : <number>, <ton>, <ass_id>*/
                        error_cause = rmmi_phb_parse_number(&entry.tel, source_string_ptr);
                        if (error_cause != RMMI_PARSE_OK)
                        {

                            break;
                        }

                        /* get aas_id*/
                        entry.aas_id = (kal_uint16) rmmi_int_validator_ext(
                                                    &error_cause,
                                                    source_string_ptr,
                                                    (kal_uint8) RMMI_COMMA);

                        /* write ANR */
                        entry.index = 0xffff;
                        entry.record_index= index1;
                        entry.num_index = index2;
                        entry.storage = storage;
                        entry.type = PHB_ANR;
                                              
                    }
                    else if (ef_type == RMMI_EPBUM_EF_EMAIL)
                    {
                        /*<number/email/text/grp_list> : <email>*/
                        error_cause = rmmi_phb_parse_email(&usim_entry.field.email, source_string_ptr);
                        if (error_cause != RMMI_PARSE_OK)
                        {
                            break;
                        }
                        usim_entry.field.email.adn_record_index = index1;
                    }
                    else if (ef_type == RMMI_EPBUM_EF_SNE ||
                            ef_type == RMMI_EPBUM_EF_AAS ||
                            ef_type == RMMI_EPBUM_EF_GAS)
                    {
                        /*<number/email/text/grp_list> : <TEXT>, <Encode method>*/
                        error_cause = rmmi_phb_parse_text(
                                &usim_entry.field.sne, 
                                source_string_ptr, 
                                source_string_ptr->cmd_index);

                        if (error_cause != RMMI_PARSE_OK)
                        {
                            break;
                        }

                        l4c_phb_get_type_info(phb_type, &file_info, 1);
                        if (file_info.max_name_len < usim_entry.field.sne.name_length)
                        {
                            rmmi_ptr->cmee_err = TEXT_ERRSTRING_TOO_LONG_ERR;
                            break;
                        }
                    }
                    else if (ef_type == RMMI_EPBUM_EF_GRP)
                    {
                        /*<number/email/text/grp_list> : <GRP1>, <GRP2>, ¡K,<GRP_n>*/
                        for (i=0; i<rmmi_ptr->phb_grp_length && i<PHB_MAX_ASSOCIATE_GRP; i++)
                        {
                            usim_entry.field.grp.gas_id[i]= (kal_uint8) rmmi_int_validator_ext(
                                    &error_cause,
                                    source_string_ptr,
                                    (kal_uint8) RMMI_COMMA);
                            if (error_cause != RMMI_PARSE_OK)
                            {
                                break;
                            }
                        }

                        rmmi_int_validator_ext(
                                    &error_cause,
                                    source_string_ptr,
                                    (kal_uint8) RMMI_COMMA);
                        if (i != rmmi_ptr->phb_grp_length || error_cause != RMMI_PARSE_NOT_FOUND)
                        {
                            break;
                        }

                    }
                    else
                    {
                        break;
                    }

                    if (ef_type == RMMI_EPBUM_EF_ANR)
                    {
                        ret_val = l4c_phb_exe_write_entry_req(
                                source_string_ptr->src_id, PHB_ANR, 1, &entry);
                    }
                    else
                    {
                        ret_val = l4c_phb_write_usim_req(
                                source_string_ptr->src_id,
                                phb_type, 
                                index2,         // number_index
                                index1,         // record_index
                                &usim_entry);
                    }

                    if (ret_val == KAL_TRUE)
                    {
                        return;
                    }                    

                }
/*=====WRITE END====*/
/*=====DELETE BEGIN====*/
                else if (op == RMMI_EPBUM_OP_DELETE)
                {
                    /*AT+EPBUM=<op>, <type>, <index1>, <index2> */
                    
                    /* index1 is record_index*/

                    /* get index2, number_index*/
                    index2 = (kal_uint16) rmmi_int_validator_ext(
                                                    &error_cause,
                                                    source_string_ptr,
                                                    (kal_uint8) rmmi_ptr->s_reg.s3);
                    if (error_cause == RMMI_PARSE_NOT_FOUND)
                    {
                        index2 = 0;
                    }
                    else if (error_cause != RMMI_PARSE_OK)
                    {

                        break;
                    }

                    if (rmmi_phb_check_index_valid(phb_type, index1, index2) == KAL_FALSE)
                    {
                        rmmi_ptr->cmee_err = RMMI_ERR_INVALID_INDEX;
                        break;
                    }

                    if (ef_type == RMMI_EPBUM_EF_ANR)
                    {
                        ret_val = l4c_phb_exe_delete_entry_req(
                                source_string_ptr->src_id, 
                                PHB_ANR, 
                                index2, 
                                0xffff, 
                                1, 
                                storage, 
                                KAL_FALSE, 
                                index1);
                    }
                    else
                    {
                        ret_val = l4c_phb_delete_usim_req(
                            source_string_ptr->src_id, 
                            phb_type, 
                            index2, 
                            index1);
                    }

                    if (ret_val == KAL_TRUE)
                    {
                        return;
                    }

                }
/*=====DELETE END====*/
                else
                {
                    ;// do nothing
                }
                
                break;
            }
            default:
            {
                /* unrecognized format of AT command line */
                break;
            }
        }
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;

}
#endif /* __AT_EPBUM_SUPPORT__*/

/*****************************************************************************
 * FUNCTION
 *  rmmi_cnum_hdlr
 * DESCRIPTION
 * This function is used to handle AT+CNUM command string
 *  request IMSI
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cnum_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    l4c_context_struct *l4c_ptr = L4C_PTR;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_CNUM_HDLR_ENTRY);
    if (l4c_ptr->phb_ready_flag == KAL_FALSE)
    {
        rmmi_ptr->cmee_err = OPERATION_NOT_ALLOWED_ERR;
    }
    else
    {
        switch (source_string_ptr->cmd_mode)
        {
        #ifdef __test_mode__
            case RMMI_TEST_MODE:
            {
                ret_val = KAL_TRUE;
                break;
            }
        #endif /* __test_mode__ */ 
            case RMMI_ACTIVE_MODE:
            {
                rmmi_ptr->cpbr_range[0] = 1;
                rmmi_ptr->cpbr_range[1] = 4;
                ret_val = l4c_phb_get_entry_by_index_req(
                    source_string_ptr->src_id, 
                    PHB_MSISDN, 
                    rmmi_phb_get_sim_storage_by_current_module(),
                    0, 0xffff, 1, 1);
                if (ret_val == KAL_TRUE)
                {
                    return;
                }
                break;
            }
            default:
            {
                /* unrecognized format of AT command line */
                break;
            }
        }
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}


#if !defined(__SLIM_AT__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_cpbf_hdlr
 * DESCRIPTION
 * This function is used to handle AT+CPBF command string
 * which is supported in the project which defines __PHB_SORT_ENABLE__
 * The command is used to search PHB entries
 *  
 * PARAMETERS
 *  source_string_ptr       [IN]     AT cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cpbf_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
    kal_uint16 string_length = 0;
#if defined(__PHB_SORT_ENABLE__)				
    kal_uint8 result;
    kal_uint8 length;
    kal_uint8 text[32];
    l4_name_struct name;
#endif
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint8 alpha_length;
    kal_uint8 num_length;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;
    l4c_context_struct *l4c_ptr = L4C_PTR;


    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_CPBF_HDLR_ENTRY);
    if (l4c_ptr->phb_ready_flag == KAL_FALSE)
    {
        rmmi_ptr->cmee_err = OPERATION_NOT_ALLOWED_ERR;
    }
    else
    {
        switch (source_string_ptr->cmd_mode)
        {
            case RMMI_TEST_MODE:
            {
                if (rmmi_is_valid_phb_storage(rmmi_ptr->phb_storage_type) == KAL_TRUE)
                {               
                    rmmi_get_phb_length(&alpha_length, &num_length);
			  
                    kal_sprintf((kal_char*) buffer, "+CPBF: %d, %d",num_length,alpha_length);
                    ret_val = KAL_TRUE;
                    rsp_str = &buffer[0];
                    string_length = strlen((char*)rsp_str);					
                }
				
                break;
            }
            case RMMI_SET_OR_EXECUTE_MODE:
            {
#if defined(__PHB_SORT_ENABLE__)				
                result = rmmi_string_validator(
                            source_string_ptr,
                            rmmi_ptr->s_reg.s3, /* separator */
                            30,
                            (kal_uint8*) text);

                if (result == RMMI_VALIDATOR_ERROR)
                {
                    break;
                }

                if ((rmmi_ptr->char_set == RMMI_CHSET_UCS2) || (rmmi_ptr->char_set == RMMI_CHSET_HEX))
                {
                    // we don't support +CPBF for UCS2.
                    rmmi_ptr->cmee_err = RMMI_ERR_OPERATION_NOT_SUPPORTED;
                    break;

                    /* convert to ucs2 value and store in alpha_id 
                       isUCS2format = check_ucs2_value((kal_uint8 *)text, (kal_uint8 *)name.name);
                       if(isUCS2format == KAL_FALSE) break;
                       name.name_length = strlen((char *)text)/2;
                       name.name_dcs = PHB_UCS2; */
                }
                else
                {
                    length = strlen((char*)text);
                    name.name_length = length;
                    kal_mem_cpy((kal_uint8*) name.name, (kal_uint8*) text, length);
                    name.name_dcs = PHB_ASCII;
                    name.name[length] = '\0';
                }

                ret_val = l4c_phb_get_entry_by_prefix_text_req(
                            source_string_ptr->src_id,
                            PHB_PHONEBOOK,
                            15,
                            (l4_name_struct*) & name);

                if (ret_val == KAL_TRUE)
                {
                    return;
                }
                else
                {
                    rmmi_ptr->cmee_err = RMMI_ERR_COMMAND_CONFLICT;
                }
#else /* __PHB_SORT_ENABLE__ */
                 /* mtk01616_081106: search function need turn on compile option __PHB_SORT_ENABLE__ to support */
                rmmi_ptr->cmee_err = RMMI_ERR_OPERATION_NOT_SUPPORTED;
#endif /* __PHB_SORT_ENABLE__ */
                break;
            }
            default:
            {
                /* unrecognized format of AT command line */
                break;
            }
        }   /* end of the switch */
    }
    //#endif
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}

#endif /* !defined(__SLIM_AT__) */ 


#if !defined(__MMI_FMI__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_esln_hdlr
 * DESCRIPTION
 *  This is rmmi function to sync LN
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_esln_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
    kal_uint16 string_length = 0;
    rmmi_context_struct* rmmi_ptr = RMMI_PTR;
    l4c_context_struct *l4c_ptr = L4C_PTR;
    
    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_ESLN_HDLR_ENTRY);
    
    if (l4c_ptr->phb_ready_flag == KAL_FALSE)
    {
        rmmi_ptr->cmee_err = OPERATION_NOT_ALLOWED_ERR;
    }
    else
    {
        switch (source_string_ptr->cmd_mode)
        {
            case RMMI_ACTIVE_MODE:
            {
                l4c_set_user_action(L4C_PHB, source_string_ptr->src_id, SYNC_LN);

                l4c_send_msg_to_phb(MSG_ID_L4CPHB_SYNC_REQ, NULL, NULL);
                return;
            }
            default:
            {
                /* unrecognized format of AT command line */
                break;
            }
        }
    }
    rmmi_sms_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
}
#endif


/*mtk01616_100303: we plan to phase out the commands below and they are not used by MTK internally.
   And they don't listed in AT document. So we remove them directly. */
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #ifdef __test_mode__
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif /* __test_mode__ */ 
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
#endif /* __MOD_PHB__ */ 

