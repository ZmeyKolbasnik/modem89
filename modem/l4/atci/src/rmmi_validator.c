/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 * RMMI_VALIDATOR.C
 *
 * Project:
 * --------
 *   MT6208
 *
 * Description:
 * ------------
 *   This file is intends for ...
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/********************************************************************************
*  Copyright Statement:
*  --------------------
*
*  This product has been developed using a protocol stack
*  developed by Sasken Communication Technologies Limited.
*
********************************************************************************/

#define RMMI_VALIDATOR_C
#include <stdio.h>
#include <string.h>
//#include "kal_non_specific_general_types.h"
#include "kal_public_defs.h" //MSBB change #include "stack_config.h"
//#include "ps_trace.h"
#include "kal_trace.h"
//#include "kal_release.h"
//#include "stack_common.h"
#include "kal_public_defs.h" //MSBB change #include "stack_msgs.h"
//#include "stack_ltlcom.h" /* Task message communiction */
//#include "stacklib.h"   /* Basic type for dll, evshed, stacktimer */
//#include "app_buff_alloc.h"
//#include "stack_timer.h"
//#include "event_shed.h"
//#include "nvram_editor_data_item.h"
//#include "custom_nvram_editor_data_item.h"

#ifdef __MOD_SMU__
//#include "ps2sim_struct.h"
//#include "sim_common_enums.h"
//#include "smu_common_enums.h"
#endif /* __MOD_SMU__ */ 
#include "device.h"
//#include "csmss_common_enums.h"

//#include "mcd_l3_inc_struct.h"
//#include "mcd_l3_inc_gprs_struct.h"
//#include "l3_inc_enums.h" 

//#include "mcd_l4_common.h"
 
#include "l4c_common_enum.h"
#include "rmmi_common_enum.h"
#include "rmmi_context.h"
#include "l4c_context.h"
#include "layer4_context.h"
//#include "l4c_rspfmttr.h"
#include "l4c_msghdlr.h"
#include "l4_trc.h"
#include "atci_trc.h"

//#include "uart_sw.h"
#include "dcl.h"
//#include "l4_defs.h"
//#include "csmcc_atfunc.h"
//#include "csmss_atfunc.h"
//#include "l4c_aux_struct.h"
//#include "l4c_ss_parse.h"

#ifdef __MOD_CSM__
//#include "mcd_ss_parameters.h"
//#include "mcd_ss_tcapmessages.h"
#include "l4c_common_enum.h"
//#include "csmcc_enums.h"
//#include "csmcc_common_enums.h"
//#include "ps2sat_struct.h"
//#include "l4c2csm_cc_struct.h"

//#include "l4c_ciss_cmd.h"
//#include "l4c2csm_ss_struct.h"
//#include "l4c_cc_cmd.h"
#endif /* __MOD_CSM__ */ 

#if defined (VM_SUPPORT)
//#include "med_struct.h"
#endif 
#ifdef __MOD_UEM__
#include "device.h"
//#include "l4c2uem_struct.h"
#include "uem_at_cmd.h"
//#include "custom_em.h"
#include "l4c_eq_cmd.h"
#endif /* __MOD_UEM__ */ 
#ifdef __MOD_RAC__
//#include "l4crac_func.h"
//#include "l4c_nw_cmd.h"
//#include "l4crac_enums.h"
#endif /* __MOD_RAC__ */ 
#ifdef __MOD_PHB__
//#include "sim_common_enums.h"
//#include "l4c2phb_enums.h"
//#include "l4c2phb_struct.h"
//#include "phb_sap.h"
//#include "l4c_phb_cmd.h"
//#include "phb_defs.h"
//#include "phb_config.h"
#endif /* __MOD_PHB__ */ 
#ifdef __MOD_SMSAL__
//#include "l4c2smsal_struct.h"
//#include "smsal_l4c_defs.h"
//#include "smsal_l4c_funcs.h"
//#include "smsal_l4c_enum.h"
//#include "smsal_defs.h"
#include "l4c_sms_cmd.h"
#endif /* __MOD_SMSAL__ */ 
#ifdef __MOD_SMU__
//#include "ps2sat_struct.h"
//#include "mcd_ps2sat_peer.h"
//#include "l4c_sim_cmd.h"
#endif /* __MOD_SMU__ */ 
#ifdef __MOD_TCM__
//#include "mmi_l3_enums.h"
//#include "mmi_sm_enums.h"
//#include "ppp_l4_enums.h"
//#include "tcm_common_enums.h"
//#include "tcm_common.h"
//#include "custom_nvram_editor_data_item.h"
//#include "l4c2abm_struct.h"
//#include "abm2l4c_struct.h"
//#include "l4c2tcm_struct.h"
//#include "l4c2tcm_func.h"
//#ifdef __TCPIP__
//#include "l4c2abm_struct.h"
//#endif /* __TCPIP__ */
//#include "l4c_gprs_cmd.h"
#endif /* __MOD_TCM__ */ 
#ifdef __MODEM_EM_MODE__
#include "em_struct.h"
#include "l4c_em.h"
//#include "lmmi_rsp.h"
#endif /* __MODEM_EM_MODE__ */ 

#include "l4c_utility.h"
#include "rmmi_rspfmttr.h"
#include "rmmi_utility.h"
//#include "rmmi_rsp.h"
//#include "rmmi_validator.h"
//#include "nvram_data_items.h"
//#include "custom_hw_default.h"
//#include "l4c_table.h"
#include "rmmi_parser.h"
//#include "resource_verno.h"     // for +EGMR read MMI resource version

#ifdef __CSD_FAX__
//#include "csm_data_enums.h"
//#include "l4c2t30_struct.h"
//#include "l4c_t30_cmd.h"
//#include "l4c2t30_enums.h"
#endif /* __CSD_FAX__ */ 
//#include "rmmi_parser.h"
#ifndef MED_NOT_PRESENT
//#include "med_global.h"
//#include "med_main.h"
#endif /* MED_NOT_PRESENT */ 

#ifdef __CTM_SUPPORT__
//#include "med_struct.h"
#endif 
#include "l4c_sendmsg.h"

#ifdef __CUST_NEW__
//#include "gpio_sw.h"
#endif 

/* for data item NVRAM_EF_IMEI_IMEISV_LID move */
//#include "nvram_user_defs.h"
//#include "csmcc_defs.h"

//#include "keypad_sw.h"
//#include "l4c2smu_struct.h"
#include "lmmi_ind.h"

//#include "csmcc_common_enums.h"

//#include "mncc_struct.h"
//#include "csmcc_bc_types.h"
//#include "csmcc_types.h"
//#include "custom_em.h"
//#include "L4c_ctm_cmd.h"
//#include "csmcc_utility.h"

//#include "sat_def.h"

#include "uem_proc_cmd.h"

#include "rmmi_msghdlr.h"

//#include "smsal_l4c_funcs.h"

#include "l4c2dt_struct.h" 

#include "kal_general_types.h"
#include "kal_public_api.h"
#include "ps_public_struct.h"
#include "rmmi_sio.h"
#include "dcl.h"

#include "rmmi_root.h"

#include "l4_msgid.h"

extern UART_PORT PS_UART_PORT;

extern void toUpper(kal_uint8 *str);
extern kal_bool rmmi_translate_oper_name(
                    kal_uint8 format1,
                    kal_uint8 *oper_str1,
                    kal_uint8 format2,
                    kal_uint8 *oper_str2);

extern kal_char* l4_custom_get_cscs_support_string(void);


/*****************************************************************************
 * FUNCTION
 *  rmmi_cscs_hdlr
 * DESCRIPTION
 *  Select TE character set
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cscs_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 result;
    kal_uint8 chset_str[10];
    kal_uint8 chset;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    
    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_CSCS_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_TEST_MODE:
        {
            rsp_str = (kal_uint8 *)l4_custom_get_cscs_support_string();
            string_length = strlen((char*)rsp_str);
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_READ_MODE:
        {
            check_char_set_name(rmmi_ptr->char_set, chset_str);
            rmmi_ptr->arg_list[0] = (void*)chset_str;
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CSCS: \"%s\"", rmmi_ptr->arg_list, 1);
            rsp_str = &buffer[0];
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 error_cause;

            result = rmmi_string_validator_ext(
                        &error_cause,
                        source_string_ptr,
                        rmmi_ptr->s_reg.s3,
                        10,
                        (kal_uint8*) chset_str);

            if (result == RMMI_VALIDATOR_ERROR)
            {
                // hogan: for blank input , should return OK
                if (error_cause == RMMI_PARSE_NOT_FOUND)
                {
                    ret_val = KAL_TRUE;
                }
                break;
            }

            chset = check_char_set_code(chset_str);
            if (chset == 0xff)
            {
                break;
            }

            rmmi_ptr->char_set = chset;
            ret_val = KAL_TRUE;
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_cmee_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cmee_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 n;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            rsp_str = (kal_uint8 const*)"+CMEE: (0-2)"; /* prepare the response string */
            string_length = strlen((char*)rsp_str);     /* type casting */
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_READ_MODE:
        {
            rmmi_ptr->arg_list[0] = (void*)&rmmi_ptr->error_report_mode;
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CMEE: %d", rmmi_ptr->arg_list, 1);
            ret_val = KAL_TRUE;
            rsp_str = &buffer[0];
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            if (source_string_ptr->string_ptr[source_string_ptr->index] == rmmi_ptr->s_reg.s3)
            {
                rmmi_ptr->error_report_mode = RMMI_SIMPLE_ERROR;        //+CMEE=[<n>] no parameter case , using 0 as defaule
                ret_val = KAL_TRUE;
            }
            else
            {
                n = (kal_uint8) rmmi_int_validator(source_string_ptr, (kal_uint8) RMMI_COMMA);
                if (n > 2)
                {
                    rmmi_ptr->cmee_err = RMMI_ERR_SYNTEX_ERROR;
                    break;
                }
                rmmi_ptr->error_report_mode = n;
                ret_val = KAL_TRUE;
            }
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            rmmi_ptr->cmee_err = RMMI_ERR_UNSPECIFIED;
            break;
        }
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_cind_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cind_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 buffer[132];  /* temp buffer for response format usage, Maximum charactor num is 130 */
    kal_uint16 string_length = 0;       /* string length variable */
    #ifdef __BT_SUPPORT__
    kal_uint8 type = 0; /* normal CIND in spec 27.007 */
    #endif
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    l4c_context_struct *l4c_ptr = L4C_PTR;

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_CIND_HDLR_ENTRY);

    #if defined(__BT_SUPPORT__)
    if(source_string_ptr->src_id == RMMI_COMM_PTR->rmmi_hf_src)
    {
        #ifdef __HF_V15__
        type = 1; //CIND in BT HFP v1.5
        #else
        type = 2; //CIND in BT HFP v1.0    
        #endif
    }
    #endif 
        
    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_TEST_MODE:
        {
        #if defined(__BT_SUPPORT__)
        #ifdef __HF_V15__        
            if(type == 1)
            {
                kal_sprintf((char*)buffer, "+CIND: (\"service\",(0-1)),(\"call\",(0-1)),(\"call_setup\",(0-3),(\"callheld\",(0-2)),(\"battchg\",(0-5)),(\"signal\",(0-5)),(\"roam\",(0-1)))");            

            }
            else 
        #else
            if(type == 2)
            {
                kal_sprintf((char*)buffer, "+CIND: (\"call\",(0-1)),(\"service\",(0-1)),(\"call_setup\",(0-3))");
            }
            else
        #endif                
        #endif /* defined(__BT_SUPPORT__) */                
            {
                kal_sprintf(
                    (char*)buffer,
                    "+CIND:(\"battchg\",(0-5)), (\"signal\",(0-5)), (\"service\",(0,1)), (\"message\",(0,1)),(\"call\",(0,1)), (\"roam\",(0,1)), (\"smsfull\",(0,1))");
            }
            
            string_length = strlen((char*)buffer);
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_READ_MODE:
        {
            kal_uint8 message_ind;
            kal_bool is_sim_card_change;
            kal_uint16 in_sim_no, in_me_no, out_sim_no, out_me_no;
            kal_uint16 unread_msg_num = 0;
            kal_uint16 total_sim_num, total_me_num;
            kal_uint8 signal_level= 0;

        #ifdef __GEMINI__  
	    #ifdef __BT_SUPPORT__
            kal_uint8 service, roam, call, callsetup, callheld;
	    #endif
        #endif 

        #if defined(__BT_SUPPORT__)
        #ifdef __HF_V15__
            if(type == 1)
            {        
            #if defined(__GEMINI__) && !defined(__DISABLE_SIM2_AT_SUPPORT__)
                /* For passing SIM2 PTS test case TWC_BV_04: MPTY call handling
                   PTS will send AT+CIND? to read the call status at the beginning
                   L4C shall collect all information and report
                */
                l4c_unified_ciev_staus(&service, &signal_level, &roam, &call, &callsetup, &callheld);
                
                rmmi_ptr->arg_list[0] = (void*)&service;
                rmmi_ptr->arg_list[1] = (void*)&call;
                rmmi_ptr->arg_list[2] = (void*)&callsetup;
                rmmi_ptr->arg_list[3] = (void*)&callheld;
                //UEM always update battery status in L4C_1 context
                rmmi_ptr->arg_list[4] = (void*)&((&rmmi_cntxt_g[0])->indicators.battchg);
                rmmi_ptr->arg_list[5] = (void*)&signal_level;
                rmmi_ptr->arg_list[6] = (void*)&roam;
            #else 
                if (l4c_ptr->cfun_state == 4)
                {
                    signal_level = 0;
                }
                else
                {
                    signal_level = rmmi_ptr->indicators.signal;
                }
    
                rmmi_ptr->arg_list[0] = (void*)&rmmi_ptr->indicators.service;
                rmmi_ptr->arg_list[1] = (void*)&rmmi_ptr->indicators.call;
                rmmi_ptr->arg_list[2] = (void*)&rmmi_ptr->indicators.callsetup;
                rmmi_ptr->arg_list[3] = (void*)&rmmi_ptr->indicators.callheld;
                rmmi_ptr->arg_list[4] = (void*)&rmmi_ptr->indicators.battchg;
                rmmi_ptr->arg_list[5] = (void*)&signal_level;
                rmmi_ptr->arg_list[6] = (void*)&rmmi_ptr->indicators.roam;
            #endif /* __GEMINI__ */ 
        
                string_length = rmmi_fast_string_print(
                                    buffer,
                                    (kal_uint8*) "+CIND: %d,%d,%d,%d,%d,%d,%d",
                                    rmmi_ptr->arg_list,
                                    7);        
            }
            else 
        #else /* __HF_V15__ */
            if(type == 2)
            {
            #if defined(__GEMINI__) && !defined(__DISABLE_SIM2_AT_SUPPORT__)
                l4c_unified_ciev_staus(&service, &signal_level, &roam, &call, &callsetup, &callheld);
                rmmi_ptr->arg_list[0] = (void*)&call;
                rmmi_ptr->arg_list[1] = (void*)&service;
                rmmi_ptr->arg_list[2] = (void*)&callsetup;
            #else 
                rmmi_ptr->arg_list[0] = (void*)&rmmi_ptr->indicators.call;
                rmmi_ptr->arg_list[1] = (void*)&rmmi_ptr->indicators.service;
                rmmi_ptr->arg_list[2] = (void*)&rmmi_ptr->indicators.callsetup;
            #endif

                string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CIND: %d,%d,%d", rmmi_ptr->arg_list, 3);
            }else
        #endif /* __HF_V15__ */ 
        #endif /* defined(__BT_SUPPORT__) */                        
            {
                /* when SIM PIN is not verified yet, do not allow read mode due to L4C and SMSAL 
                   is not initialized, indicator of smsfill will always retun 1 */
                /* [MAUI_01888350], mtk02480, allow AT+CIND? when no SIM inserted */   
                if (is_sim_verified() == KAL_FALSE && l4c_ptr->sim_detected == KAL_TRUE)
                {   
                    rmmi_result_code_fmttr(RMMI_RCODE_ERROR, rmmi_ptr->cmee_err);
                    return;
                }

                /* get message */
                l4c_sms_get_no_msgs_req(
                    source_string_ptr->src_id,
                    &is_sim_card_change,
                    &in_sim_no,
                    &in_me_no,
                    &out_sim_no,
                    &out_me_no,
                    &unread_msg_num,
                    &total_sim_num,
                    &total_me_num);
                
                if (unread_msg_num > 0)
                {
                    message_ind = 1;
                }
                else
                {
                    message_ind = 0;
                }
    
                #if !defined(__SMS_STORAGE_BY_MMI__) 
                if (total_sim_num > (in_sim_no + out_sim_no) || total_me_num > (in_me_no + out_me_no))
                {
                    rmmi_ptr->indicators.smsfull = 0;
                }
                else
                {
                    rmmi_ptr->indicators.smsfull = 1;
                }
                #endif

                if (l4c_ptr->cfun_state == 4)
                {
                    signal_level = 0;
                }
                else
                {
                    signal_level = rmmi_ptr->indicators.signal;
                }

        #if defined(__GEMINI__) && !defined(__DISABLE_SIM2_AT_SUPPORT__)		
                //UEM always update battery status in L4C_1 context
      		    rmmi_ptr->arg_list[0] = (void *)&((&rmmi_cntxt_g[0])->indicators.battchg);
        #else
                rmmi_ptr->arg_list[0] = (void*)&rmmi_ptr->indicators.battchg;
        #endif
        
                rmmi_ptr->arg_list[1] = (void*)&signal_level;
                rmmi_ptr->arg_list[2] = (void*)&rmmi_ptr->indicators.service;
                rmmi_ptr->arg_list[3] = (void*)&message_ind;
                rmmi_ptr->arg_list[4] = (void*)&rmmi_ptr->indicators.call;
                rmmi_ptr->arg_list[5] = (void*)&rmmi_ptr->indicators.roam;
                rmmi_ptr->arg_list[6] = (void*)&rmmi_ptr->indicators.smsfull;
                
                string_length = rmmi_fast_string_print(
                                    buffer,
                                    (kal_uint8*) "+CIND: %d,%d,%d,%d,%d,%d,%d",
                                    rmmi_ptr->arg_list,
                                    7);
            }
 
            string_length = strlen((char*)buffer);
            ret_val = KAL_TRUE;
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }   /* end of the switch */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) buffer, string_length);
    return;
}


/*****************************************************************************
* FUNCTION
*  rmmi_esuo_hdlr
*
* DESCRIPTION
*   This is rmmi function handler to set uart owner 
*   
* PARAMETERS
*  source_string_ptr		IN		at cmd string
*
* RETURNS
*  none.
*
* GLOBALS AFFECTED
*  none.
*****************************************************************************/
void rmmi_esuo_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val  = KAL_FALSE;
    kal_uint8 const  *rsp_str = NULL; 
    kal_uint16 string_length = 0; 
    kal_uint8	buffer[RMMI_SHORT_RSP_LEN];
    kal_uint32 owner_id=4;

    
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
#ifdef __MMI_FMI__
    l4c_context_struct *l4c_ptr = L4C_PTR;
#endif

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_ESUO_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_TEST_MODE:    
        {
            #if defined(__DT_SUPPORT__)                    
                kal_sprintf((char*)buffer, "+ESUO: (3-%d)", (RMMI_MAX_SIM_NUM+3));
            #else
                kal_sprintf((char*)buffer, "+ESUO: (4-%d)", (RMMI_MAX_SIM_NUM+3));              
            #endif
            rsp_str = &buffer[0];
            string_length = strlen((char*)rsp_str);
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_READ_MODE :
        {
            kal_uint8 current_owner_id;
            kal_uint8 default_owner_id;

            #ifndef __GEMINI__
                current_owner_id = 4;
                default_owner_id = 4;
            #else
                default_owner_id = RMMI_COMM_PTR->sim_uart_setting + 4;
                current_owner_id = rmmi_root_get_uart_owner_by_srcid(source_string_ptr->src_id) + 4;
            #endif
            
            rmmi_ptr->arg_list[0] = &current_owner_id;
            rmmi_ptr->arg_list[1] = &default_owner_id;
		
            string_length = rmmi_fast_string_print ( 
                              buffer,
                              (kal_uint8 *)"+ESUO: %d, %d",
                              rmmi_ptr->arg_list,
                              2
                             );
            rsp_str = &buffer[0];					
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {

            #ifdef __MMI_FMI__
            //DT will not init in USB_BOOT mode , we cannot send msg to DT. There is no USB_BOOT mode in SP project.
            if (!(l4c_ptr->cfun_state == 1 || l4c_ptr->cfun_state == 4))
            {
                break;
            }
            #endif

            if (RMMI_COMM_PTR->transfer.dest_mod != MOD_NIL)
            {
                // transfer ongoing, reject this ESUO
                break;
            }
            
            owner_id = (kal_uint8)rmmi_int_validator(source_string_ptr, (kal_uint8)RMMI_COMMA);
            if (owner_id > (RMMI_MAX_SIM_NUM + 3) ||
                #ifdef __DT_SUPPORT__
                owner_id < 3
                #else
                owner_id < 4
                #endif
                )
            {
                break;
            }       

            
            //mapping owner_id and module_id
            #ifdef __DT_SUPPORT__
            if(owner_id == 3)
            {
                kal_uint8 port;
                l4cdt_uart_transfer_req_struct *msg_ptr; 

                port = rmmi_cid_2_port (rmmi_srcid_2_cid(source_string_ptr->src_id));
                msg_ptr = (l4cdt_uart_transfer_req_struct*)
                            construct_local_para((kal_uint16) sizeof(l4cdt_uart_transfer_req_struct), TD_RESET);
                msg_ptr->port = port;

                RMMI_COMM_PTR->transfer.dest_mod = MOD_DT;   
                RMMI_COMM_PTR->transfer.port = (UART_PORT)port;

                rmmi_send_ilm(MOD_DT, MSG_ID_ATCIDT_UART_TRANSFER_REQ, 1, msg_ptr, NULL);     
                return;	
            }
            else
            #endif
            {
                ret_val = KAL_TRUE;            
            }
        }
        default :
        {
            break;
        }
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*)rsp_str, string_length);

    //update sim owner
    //If we update sim owner before output "OK"
    //"OK" would not be outputed because UART owner is changed
    if (source_string_ptr->cmd_mode == RMMI_SET_OR_EXECUTE_MODE &&
        ret_val == KAL_TRUE)
    {
        rmmi_root_set_uart_owner_by_srcid(source_string_ptr->src_id, owner_id-4);
    }

    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_equery_hdlr
 * DESCRIPTION
 *  This is rmmi function handler to read autotest report
 *  add by mtk00714 04/05/21
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_equery_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;

    //kal_uint8 const  *rsp_str = NULL; 
    kal_uint16 string_length = 0;
    kal_uint8 index;
    kal_bool result;
    kal_uint8 buffer[MAX_UART_LENGTH];
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    l4c_context_struct *l4c_ptr = L4C_PTR;

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_EQUERY_HDLR_ENTRY);

    buffer[0] = '\0';
    switch (source_string_ptr->cmd_mode)
    {

        case RMMI_SET_OR_EXECUTE_MODE:
        {
            index = (kal_uint8) rmmi_int_validator(
                                    source_string_ptr,
                                    rmmi_ptr->s_reg.s3 /* separator */ );
            if (index > 7)
            {
                break;
            }

            if (index == 0)
            {
                //rsp_str=(kal_uint8 const *)"+CMGW: (0-3)"; 
                kal_sprintf((char*)buffer, "+CMGW: (0-3)");
                ret_val = KAL_TRUE;
                break;
            }
            else if (index == 1)
            {
                //call charger status
                result = l4cuem_at_query_is_charging();
                kal_sprintf((char*)buffer, "+CHAR: %d", result);
                ret_val = KAL_TRUE;
                break;
            }
            else if (index == 2)
            {
                //query clam status
                result = l4cuem_at_query_is_clam_open();
                kal_sprintf((char*)buffer, "+CLAM: %d", result);
                ret_val = KAL_TRUE;
                break;
            }
            else if (index == 3)
            {
                //query if SMS is ready
                if (l4c_ptr->sms_ready_flag == KAL_TRUE)
                {
                    ret_val = KAL_TRUE;
                }
                break;
            }
            else if (index == 4)
            {
                //query if PHB is ready
                if (l4c_ptr->phb_ready_flag == KAL_TRUE)
                {
                    ret_val = KAL_TRUE;
                }
                break;
            }
	     else if (index == 5)
            {
            	  /*This command is for phone suite to use. 
                  If Gemini and ME (not ME1+ME2) return +EQMO:1 , else return +EQMO:0
                  Old design, smsal handle storage ME, so Gemini is ME1+ME2
                  New design, mmi handle storage ME, so Gemini is ME, not ME1+ME2
                  This command is used for query supporting new design or not*/
            	  #if defined(__SMS_STORAGE_BY_MMI__) && defined(__GEMINI__) 
		  {
                	kal_sprintf((char*)buffer, "+EQMO: 1");
		  }
		  #else 
		  {
                	kal_sprintf((char*)buffer, "+EQMO: 0");
		  }
		  #endif
                ret_val = KAL_TRUE;
                break;
            }
            else if (index == 6)
            {
                #if defined(__PHB_STORAGE_BY_MMI__)
                    /*mtk02514 * 100414 * MAUI_02395980 *********
                    * For the new feature "PHB Dynamic num type", in
                    * order to let phonesuit know that PlutoMMI has this feature
                    * to seperate it from old version, we modify the output
                    * of +EPBV to 3 which means that the phone has this
                    * feature while we still have the feature PHB_STORAGE_BY_MMI
                    ****************************************/
                    kal_sprintf((char*)buffer, "+EPBV: 3");
                
                    /* mtk02514 * 091218 * MAUI_02127577 *********
                    * For PHB2.0 where MMI will manager ME PHB stroage,
                    * the alpha ID will be stored using UCS2 coding.
                    * In the old version, this can't be supportted by phonesuit.
                    * So we need to let it know that our phone is using phb2.0 or not
                    *
                    * Don't remove the following comment!
                    * it is a history to let other maintainer to know that 
                    * we have +EPBV:2 before
                    ****************************************/
                    //kal_sprintf((char*)buffer, "+EPBV: 2");
                #else
                    kal_sprintf((char*)buffer, "+EPBV: 1");
                #endif
                ret_val = KAL_TRUE;
                break;
            }
            else if (index == 7)
            {
                 /*This command is for phone suite to use. 
                   If sms2.0 return +ESMSV: 2 , else return +ESMSV: 1
                   Old design, smsal handle sms storage, so draft = draft + unsent without da
                   New design, mmi handle sms storage, so draft = draft
                   This command is used for query supporting sms2.0 design or not*/
                #if defined(__SMS_STORAGE_BY_MMI__) 
                {
                    kal_sprintf((char*)buffer, "+ESMSV: 2");
                }
                #else
                {
                    kal_sprintf((char*)buffer, "+ESMSV: 1");
                }
                #endif
                ret_val = KAL_TRUE;
                break;
            }		
        }
        default:
        {
            break;
        }
    }

    string_length = strlen((char*)buffer);
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) buffer, string_length);
}


#if !defined(__SLIM_AT__)

/*****************************************************************************
 * FUNCTION
 *  rmmi_eboot_hdlr 
 * DESCRIPTION
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_eboot_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 error_cause; 

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint8 mode;

            // <mode>
            //  0 : normal boot up
            //  1 : silent boot up (verify PIN by modem internally)

            mode = (kal_uint8)rmmi_int_validator_range_check(
                                &error_cause,
                                source_string_ptr,
                                RMMI_PTR->s_reg.s3,  /* separator */
                                1);

            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }

            ret_val = l4c_eq_set_boot_mode_req(source_string_ptr->src_id, mode);
            break;
        }
        default:
        {
            ret_val = KAL_FALSE;
            break;
        }
    }
    /* Return OK first, then use URC to notify later response from lower layer */
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
    return;
}

/*****************************************************************************
 * FUNCTION
 *  rmmi_ceer_hdlr
 * DESCRIPTION
 *  This is rmmi function handler for +CEER , which reports the last failure of call setup of call release
 *  mtk00714 add on 2004/03/03
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_ceer_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    l4c_context_struct *l4c_ptr = L4C_PTR;

    const kal_char *const RMMI_CEER_STR_TABLE[130] = 
    {
        "NONE",
        "CM_UNASSIGNED_NUM",    // 1                   
        "",
        "CM_NO_ROUTE_TO_DESTINATION",   // 3        
        "", "",
        "CM_CHANNEL_UN_ACCP",   // 6                
        "",
        "CM_OPR_DTR_BARRING",   // 8                 
        "",
        "CM_CALL_BARRED",       //10  
        "CM_RESERVED",  //11
        "", "", "", "",
        // "Class(001): 16-31 -> normal event
        "CM_NORMAL_CALL_CLR",   //16                  
        "CM_USER_BUSY",
        "CM_NO_USER_RESPONDING",
        "CM_NO_ANSWER_ON_ALERT",
        "",     //20
        "CM_CALL_REJECTED",     //21
        "CM_NUMBER_CHANGED",
        "", "",
        "CM_PRE_EMPTION",       //25   
        "CM_NON_SEL_USER_CLEAR",
        "CM_DEST_OUT_OF_ORDER",
        "CM_INVALID_NUMBER_FORMAT",
        "CM_FACILITY_REJECT",
        "CM_RES_STATUS_ENQ",
        "CM_NORMAL_UNSPECIFIED",
        // Class(010): 32-48 -> resource unavailable
        "", "",
        "CM_NO_CIRCUIT_CHANNEL_AVAIL",  //34
        "", "", "",
        "CM_NETWORK_OUT_OF_ORDER",      //38
        "", "",
        "CM_TEMPORARY_FAILURE", //41
        "CM_SWITCH_EQUIPMENT_CONGESTION",       //42
        "CM_ACCESS_INFO_DISCARDED",
        "CM_REQUESTED_CKT_CHANEL_NOT_AVIL",     //44
        "", "",
        "CM_RESOURCE_UNAVAIL_UNSPECIFIED",      //47
        "",
        // Class(011): 49-64 -> service or option not available
        "CM_QOS_UNAVAIL",       //49
        "CM_REQ_FAC_NOT_SUBS",  //50
        "", "", "", "",
        "CM_IC_BAR_CUG",        //55
        "",
        "CM_BEARER_CAP_NOT_AUTHORISED", //57
        "CM_BEARER_CAP_NOT_AVAIL",
        "", "", "", "",
        "CM_SER_UNAVAILABLE",   //63
        "",
        // Class(100): 65-80 -> service or option not implementated
        "CM_BEARER_SER_UNIMPL", //65
        "", "",
        "CM_ACM_EXCEEDED",      //68
        "CM_REQ_FACILITY_UNAVAIL",
        "CM_RESTR_DIGITAL_INFO",        //70
        "", "", "", "", "", "", "", "",
        "CM_SER_OPT_UNIMPL",    //79
        "",
        // Class(101): 81-95 -> invalid message
        "CM_INVALID_TI_VALUE",  //81
        "", "", "", "", "",
        "CM_USER_NOT_IN_CUG",   //87
        "CM_INCOMPATIBLE_DEST", //88
        "", "",
        "CM_INVALID_TRANSIT_NW_SEL",    //91
        "", "", "",
        "CM_SEMANTIC_ERR",      //95
        // Class(110): 96-112 -> protocol error
        "CM_INVALID_MANDATORY_INF",     //96
        "CM_MSG_TYPE_UNIMPL",   //97           
        "CM_MSG_TYPE_NOT_COMPATIBLE",   //98
        "CM_IE_NON_EX",
        "CM_COND_IE_ERR",
        "CM_INCOMP_MESG_WITH_STATE",
        "CM_RECOVERY_ON_TIMER_EXPIRY",  //102
        "", "", "", "", "", "", "", "",
        "CM_PROTOCOL_ERR_UNSPECIFIED",  //111
        // Class(111): 113-127 -> interworking
        "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
        "CM_INTER_WRK_UNSPECIFIED",     //127
        "ERROR_CAUSE_UNKNOWN"   //128,proprietary cause for error cause other than 24.008 call control casue
    };

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_CEER_HDLR_ENTRY);

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_ACTIVE_MODE:
        {
            kal_uint16 unknown_cause_idx = 128;
			
            if (l4c_ptr->ceer_report <= 127)
            {
                rmmi_ptr->arg_list[0] = (void*)&l4c_ptr->ceer_report;
                rmmi_ptr->arg_list[1] = (void*)RMMI_CEER_STR_TABLE[l4c_ptr->ceer_report];								
            }	
            else 
            {//MAUI_02397275
                rmmi_ptr->arg_list[0] = (void*)&l4c_ptr->ceer_report;
                rmmi_ptr->arg_list[1] = (void*)RMMI_CEER_STR_TABLE[unknown_cause_idx];
            }
	        //MAUI_02397275
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CEER: %u, %s", rmmi_ptr->arg_list, 2);
            ret_val = KAL_TRUE;
            rsp_str = &buffer[0];
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            rmmi_ptr->cmee_err = RMMI_ERR_UNSPECIFIED;
            break;
        }
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_gcap_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_gcap_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint16 string_length = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_ACTIVE_MODE:
        {
            #ifdef __AT_LINUX_DATA_PORT__
            /*
            * In linux, to let modem-manager detect which USB COM is used for data.
            * they will use AT+GCAP to query the capability of the modem.
            * So, if we return ERROR for this command if the USB COM is not used for data.
            * they would not treat it as the data port to avoid missed use.
            */
            kal_uint8 port;    
            port = rmmi_cid_2_port(rmmi_srcid_2_cid(source_string_ptr->src_id));
            if (port != uart_port_null && RMMI_UART_is_usb_cdc_acm(port) == KAL_FALSE)
            {
                ret_val = KAL_FALSE;
                return;
            }
            else
            #endif
            {
                string_length = rmmi_fast_string_print(
                                buffer,
                                (kal_uint8*) "+GCAP: +FCLASS, +CGSM",
                                rmmi_ptr->arg_list,
                                0);
                ret_val = KAL_TRUE;
                rsp_str = &buffer[0];
            }
            break;
        }
        default:
        {
            /* unrecognized format of AT command line */
            rmmi_ptr->cmee_err = RMMI_ERR_UNSPECIFIED;
            break;
        }
    }

    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_eind_hdlr
 * DESCRIPTION
 *  This is for DTE to set General indication
 *  add by mtk00714 20041123
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_eind_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint8 string_length = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    switch (source_string_ptr->cmd_mode)
    {
        #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
	    //EIND setting support up to 32 bits(event) ,4294967295(0xffffffff)
            kal_sprintf((kal_char*) buffer, "+EIND: (0-4294967295)");
            string_length = strlen((char*)buffer);
            ret_val = KAL_TRUE;
            break;
        }
	#endif
        case RMMI_READ_MODE:
        {
            rmmi_ptr->arg_list[0] = (void*)&(rmmi_ptr->report_mode.eind);
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+EIND: %e", rmmi_ptr->arg_list, 1);			
            ret_val = KAL_TRUE;
            break;
        }
	 case RMMI_ACTIVE_MODE:
        {
	    rmmi_ptr->arg_list[0] = (void*)&(rmmi_ptr->eind_ready_flag);
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+EIND: %e", rmmi_ptr->arg_list, 1);		
            ret_val = KAL_TRUE;
            break;		
	 }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint32 mode;
            kal_uint8 error_cause;

            mode = rmmi_int_validator_ext(
                                &error_cause,
                                source_string_ptr,
                                rmmi_ptr->s_reg.s3 /* separator */ );
            if (error_cause == RMMI_PARSE_OK)
            {
                rmmi_ptr->report_mode.eind = mode;
                ret_val = KAL_TRUE;
            }
            break;
        }
        default:
            break;
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, buffer, string_length);
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_einfo_hdlr
 * DESCRIPTION
 *  This is for DTE to enable Proprietary URC (ex: +ESMLA,+ECFU,etc)
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_einfo_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint8 string_length = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    switch (source_string_ptr->cmd_mode)
    {
        #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            kal_sprintf((kal_char*) buffer, "+EINFO: (0-4294967295)");
            string_length = strlen((char*)buffer);
            ret_val = KAL_TRUE;
            break;
        }
	#endif		
        case RMMI_READ_MODE:
        {
	    rmmi_ptr->arg_list[0] = (void*)&(rmmi_ptr->report_mode.einfo);
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+EINFO: %e", rmmi_ptr->arg_list, 1);
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            kal_uint32 mode;
            kal_uint8 error_cause;

            mode =  rmmi_int_validator_ext(
                                &error_cause,
                                source_string_ptr,
                                (kal_uint8) RMMI_COMMA /* separator */ );
			
            if (error_cause == RMMI_PARSE_OK)
            {

		  #ifndef __MMI_FMI__		  
	      #ifdef __MODEM_EM_MODE__
		  if (mode & (INFO_REPORT_MASK << RMMI_ENWINFO_BIT)) // if 4th bit set, always perform em_update_req
		  {
			kal_uint8 info_request[NUM_OF_EM_INFO];
			kal_uint8 type,n;
			kal_uint8 i;
			kal_bool unchange = KAL_FALSE;
			
	 	       // get <type>
 	              type = (kal_uint8) rmmi_int_validator_ext(&error_cause, source_string_ptr, (kal_uint8) RMMI_COMMA /* separator */ );		   

 	       	if (error_cause == RMMI_PARSE_NOT_FOUND)
 	              {
			    unchange = KAL_TRUE;
 	              }
			else if (type>=NUM_OF_EM_INFO)
			{
   	                  	ret_val = KAL_FALSE;
	 	              break;			
			}

		 	// get <n>
 	              n = (kal_uint8) rmmi_int_validator_ext(&error_cause, source_string_ptr, rmmi_ptr->s_reg.s3 /* separator */ );		   

 	       	if (error_cause == RMMI_PARSE_NOT_FOUND)
 	              {
			    unchange = KAL_TRUE;
 	              }
			else if (n>2)
			{
   	                  	ret_val = KAL_FALSE;
	 	              break;			
			}				

			if (!unchange)
			{
				for (i=0; i<NUM_OF_EM_INFO; i++)
				{
					info_request[i] = EM_NC;  // defaut is No Change
				}

				info_request[type] = n;
				//kal_prompt_trace(MOD_L4C,"reg NW info: %d %d",type,n);
				l4c_em_update_req(EM_FROM_RMMI,  info_request);
			}
		  }		

  		  if (!(mode & (INFO_REPORT_MASK << RMMI_ENWINFO_BIT)) && (rmmi_ptr->report_mode.einfo & (INFO_REPORT_MASK << RMMI_ENWINFO_BIT))) // 1->0
  		  {
			kal_uint8 info_request[NUM_OF_EM_INFO];  		  
			kal_uint8 i;

			for (i=0; i<NUM_OF_EM_INFO; i++)
			{
				info_request[i] = EM_OFF;  // close all nw info
			}
			
			//kal_prompt_trace(MOD_L4C,"dereg NW info");
			l4c_em_update_req(EM_FROM_RMMI,  info_request);					
  		  }
		  #endif /* __MODEM_EM_MODE__ */

		  #ifdef __NBR_CELL_INFO__
		  if ((mode & (INFO_REPORT_MASK << RMMI_ECELLINFO_BIT)) && !(rmmi_ptr->report_mode.einfo & (INFO_REPORT_MASK << RMMI_ECELLINFO_BIT))) // 0->1
		  {
			//kal_prompt_trace(MOD_L4C,"reg cell info");
			l4c_nbr_cell_info_reg_req_hdlr(MOD_ATCI, NULL, NULL);
		  }

 		  if (!(mode & (INFO_REPORT_MASK << RMMI_ECELLINFO_BIT)) && (rmmi_ptr->report_mode.einfo & (INFO_REPORT_MASK << RMMI_ECELLINFO_BIT))) // 1->0
		  {
			//kal_prompt_trace(MOD_L4C,"dereg cell info");
			l4c_nbr_cell_info_dereg_req_hdlr(MOD_ATCI, NULL, NULL);
		  }
		  #endif /* __NBR_CELL_INFO__ */		  
  		  #endif /* __MMI_FMI__ */
  
			
                rmmi_ptr->report_mode.einfo = mode;
                ret_val = KAL_TRUE;
            }			
            break;
        }
        default:
            break;
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, buffer, string_length);
}

/*****************************************************************************
 * FUNCTION
 *  rmmi_epon_hdlr
 * DESCRIPTION
 *  This is rmmi function to Power off
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_epon_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_ACTIVE_MODE:
        {
            rmmi_final_rsp_generator(source_string_ptr->src_id, KAL_TRUE, NULL, 0);
            kal_sleep_task(KAL_TICKS_100_MSEC * 5);
            l4c_target_reset(3);
            return;
        }
        default:
        {
            /* unrecognized format of AT command line */
            rmmi_ptr->cmee_err = RMMI_ERR_UNSPECIFIED;
            break;
        }
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
}

#ifdef __CMUX_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  rmmi_cmux_hdlr
 * DESCRIPTION
 *  to enable CMUX
 * PARAMETERS
 *  source_string_ptr       [IN]        At cmd string
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_cmux_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 string_length = 0;
    kal_uint8 const *rsp_str = NULL;
    kal_uint8 mode = 255;   /* 255 is just initail value */
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    switch (source_string_ptr->cmd_mode)
    {
    #ifdef __test_mode__
        case RMMI_TEST_MODE:
        {
            rsp_str = (kal_uint8 const*)"+CMUX: (0)";   /* prepare the response string */
            string_length = strlen((char*)rsp_str);     /* type casting */
            ret_val = KAL_TRUE;
            break;
        }
    #endif /* __test_mode__ */ 
        case RMMI_SET_OR_EXECUTE_MODE:
        {

            mode = rmmi_int_validator(source_string_ptr, RMMI_COMMA);
            if ((mode == 0) || (mode == 2))
            {
                if ( source_string_ptr->src_id != RMMI_SRC ) 
                {
                    //kal_sys_trace( "AT+CMUX isn't allowed on USB2" );
                    kal_brief_trace(TRACE_WARNING, WARNING_CMUX_PORT_ERROR);
                    rmmi_ptr->cmee_err = RMMI_ERR_OPERATION_NOT_SUPPORTED;
                    break;
                }            
                else if ( (RMMI_COMM_PTR->cmux_enable == KAL_TRUE && mode == 0) ||
                    (RMMI_COMM_PTR->cmux_enable == KAL_FALSE && mode == 2) )
                {
                    rmmi_ptr->cmee_err = RMMI_ERR_UNKNOWN;
                    break;
                }
				else
				{
                    ret_val = KAL_TRUE;
                    break;
				}
            }
            else
            {
                rmmi_ptr->cmee_err = RMMI_ERR_SYNTEX_ERROR;
                break;
            }
        }
        default:
        {
            /* unrecognized format of AT command line */
            rmmi_ptr->cmee_err = RMMI_ERR_UNSPECIFIED;
            break;
        }
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    /* DO NOT move the code here !!   Return OK first is necessary for AT+CMUX.
       Due to CMUX (higher priority task) will get UART owner , CMUX is not responsible for return result code 'OK' */
    if ( ret_val == KAL_TRUE ) 
    {
        if (mode == 0)
        {
            l4c_cmux_startup_req(PS_UART_PORT);
            RMMI_COMM_PTR->physical_port = PS_UART_PORT;
        }
        else if (mode == 2)
        {
            RMMI_COMM_PTR->cmux_enable = KAL_FALSE;
            l4c_cmux_closedown_req();
        }
    }
    return;

}
#endif /* __CMUX_SUPPORT__ */ 


#ifdef __CLAC_SUPPORT__


const kal_char *const rmmi_clac_table[ /* RMMI_TOT_EXTEND_CMD + RMMI_TOT_BASIC_CMD */ ] =
{
    #define BASIC_CMD(AT_NAME, AT_HASH, FUNC, ENUM) AT_NAME,
    #define EXTEND_CMD(AT_NAME, HASH1, HASH2, TEST_STRING, ENUM, FUNC) AT_NAME,
    #define CMD_ENUM(ENUM)
        #include "at_cmd.def"
        #include "at_custom_cmd_op01.h"
    #undef BASIC_CMD
    #undef EXTEND_CMD
    #define CMD_ENUM
};


/*****************************************************************************
 * FUNCTION
 *  rmmi_clac_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  source_string_ptr       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_clac_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    kal_uint8 const *rsp_str = NULL;
    kal_uint16 string_length = 0;
    kal_bool is_list = KAL_TRUE;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_CLAC_HDLR_ENTRY);
	
    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_TEST_MODE:
        {
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_ACTIVE_MODE:
        {
    	     kal_uint16 string_length = 0;
    	     kal_char const *rsp_str = NULL;
    	     kal_uint16 cmd_index;
	     kal_char *add_cmd[100];
	     kal_uint16	add_cmd_number=0;
		 
    	     for (cmd_index = 0; cmd_index < (RMMI_TOT_EXTEND_CMD + RMMI_TOT_BASIC_CMD); cmd_index++)  ////mtk02514_cmd
	     {
	     		rsp_str = rmmi_clac_table[cmd_index];		

	     		is_list = rmmi_remove_listing_at_command(rsp_str);

            		if (is_list == KAL_TRUE)
	     		{
       			string_length = strlen(rsp_str);
              		rmmi_write_to_uart(&rmmi_ptr->s_reg.s3, 1, KAL_FALSE);
              		rmmi_write_to_uart(&rmmi_ptr->s_reg.s4, 1, KAL_FALSE);
				rmmi_write_to_uart((kal_uint8*)"at", 2, KAL_FALSE);
				if (cmd_index >= RMMI_TOT_BASIC_CMD)
				{
		      			rmmi_write_to_uart((kal_uint8*)"+", 1, KAL_FALSE);
				}
       			rmmi_write_to_uart((kal_uint8*) rsp_str, string_length, KAL_FALSE);
			}
    	     }
			
	     add_cmd_number = rmmi_add_listing_at_command(add_cmd);
            for (cmd_index = 0; cmd_index < add_cmd_number; cmd_index++)
	     {
	     	     rmmi_write_to_uart(&rmmi_ptr->s_reg.s3, 1, KAL_FALSE);
                   rmmi_write_to_uart(&rmmi_ptr->s_reg.s4, 1, KAL_FALSE);
		     string_length = strlen(add_cmd[cmd_index]);
	            rmmi_write_to_uart((kal_uint8*) add_cmd[cmd_index], string_length, KAL_FALSE);
            }

	     rmmi_write_to_uart(&rmmi_ptr->s_reg.s3, 1, KAL_FALSE);
            rmmi_write_to_uart(&rmmi_ptr->s_reg.s4, 1, KAL_FALSE);
				   
	     ret_val = KAL_TRUE;
            break;
        }	
	 default:
        {
            /* unrecognized format of AT command line */
            break;
        }
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, (kal_uint8*) rsp_str, string_length);
    return;
}


#endif /*__CLAC_SUPPORT__*/

#endif /* !defined(__SLIM_AT__) */ 

#if defined(__OP11_ATK__) || defined(__AUTO_ATK__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_ecpu_hdlr
 * DESCRIPTION
 *   This cmd is used to get cpu usage in percetage
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_ecpu_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_uint8 percentage = 0;
    kal_bool ret_val = KAL_FALSE;
    kal_uint16 string_length = 0;
    kal_uint8 buffer[12];
    float usage = -1;
    kal_int32 test;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    
    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_ECPU_HDLR_ENTRY);
    
    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_ACTIVE_MODE:
        {
            #if defined(__MTK_TARGET__)
            /* Enable CPU profile query on run time */
            kal_profile_enable();
            #endif
            ret_val = KAL_TRUE;
            break;
        }
        case RMMI_READ_MODE:
        {
            #if defined(__MTK_TARGET__)
            usage = kal_profile_get_cpu_usage();
            #else
            usage = 0;
            #endif
            //#if 0
            if(usage < 0 || usage > 1)
            {
                /* error happened */
                //kal_prompt_trace(MOD_L4C, "system return value %f ", usage);
                break;
            }
            percentage = (usage * 100)/1;
            
            rmmi_ptr->arg_list[0] = (void *)&percentage;
            string_length = rmmi_fast_string_print(buffer, (kal_uint8 *)"+ECPU: %d", (void *)rmmi_ptr->arg_list, 1);
            buffer[string_length] = 0x25; /* add % to the end of the string */
            string_length += 1;
            ret_val = KAL_TRUE;
            break;
            //#endif
            //usage *= 100;
            //test = (kal_int32)usage;
            //RMMI_PTR->arg_list[0] = (void *)&test;
            //string_length = rmmi_fast_string_print(buffer, (kal_uint8 *)"%g", (void *)RMMI_PTR->arg_list,1);
            //ret_val = KAL_TRUE;
            //break;
            
            
        }
        default:
        {
            /* Unsupported command type */
            break;
        }    
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, buffer, string_length);
}


#if defined(PLUTO_MMI)
/*****************************************************************************
 * FUNCTION
 *  rmmi_eram_hdlr
 * DESCRIPTION
 *   This cmd is used to get RAM usage in Bytes
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_eram_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_uint8 type = 0xff;
    l4c_context_struct *l4c_ptr = L4C_PTR;

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_ERAM_HDLR_ENTRY);
    
    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_ACTIVE_MODE:
        {
            /* Send indication message to MMI & handle response in l4c_eq_ram_usage_res_req */
            l4c_eq_ram_usage_req_lind(type);
            l4c_ptr->route_thru_lmmi = KAL_TRUE;
            l4c_ptr->route_thru_lmmi_user = source_string_ptr->src_id;
            return;
        }
        default:
        {
            /* Unsupported command type */
            break;
        }    
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, KAL_FALSE, NULL, 0);
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_elaunch_hdlr
 * DESCRIPTION
 *   This cmd is used to launch a Java/VRE application
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
 void rmmi_elaunch_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_uint8 type = 0xff;
    kal_uint8 error_cause;
    kal_uint16 appName[260];
    kal_uint8 result;
    kal_uint8 mids_idx;
    kal_uint16 midlet_idx;
    kal_uint8 mode;
    kal_uint8 mre_action;
    kal_uint8 *nameBuffer = NULL;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    l4c_context_struct *l4c_ptr = L4C_PTR;

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_ELAUNCH_HDLR_ENTRY);
    
    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            type = rmmi_int_validator_range_check(&error_cause, source_string_ptr, RMMI_COMMA, 1);
            if(type == RMMI_VALIDATOR_ERROR)
            {
                break;
            }
            if(type == 0)
            {
                /* Launch Java application */
                mids_idx = (kal_uint8)rmmi_int_validator_range_check(&error_cause, source_string_ptr, RMMI_COMMA, 0xff);
                if((mids_idx == RMMI_VALIDATOR_ERROR) && (error_cause != RMMI_PARSE_OK))
                {
                    break;
                }
                midlet_idx = (kal_uint16)rmmi_int_validator_range_check(&error_cause, source_string_ptr, RMMI_COMMA, 0xffff);
                if((midlet_idx == RMMI_VALIDATOR_ERROR) && (error_cause != RMMI_PARSE_OK))
                {
                    if(error_cause == RMMI_PARSE_NOT_FOUND)
                    {
                        midlet_idx = 1;/* Set default value */
                    }
                    else
                    {
                    break;
                    }
                    
                }
                else if(midlet_idx == 0)
                {
                    /* midlet_idx should start from 1 */
                    break;
                }
                mode = (kal_uint8)rmmi_int_validator_range_check(&error_cause, source_string_ptr, rmmi_ptr->s_reg.s3, 0xff);
                if((mode == RMMI_VALIDATOR_ERROR) && (error_cause != RMMI_PARSE_OK))
                {
                    break;
                }
                l4c_eq_launch_app_req_lind(type, mids_idx, midlet_idx, mode, NULL);
                //break;
            }
            else
            {
                /* Launch VRE application */
                mre_action = (kal_uint8)rmmi_int_validator_range_check(&error_cause, source_string_ptr, RMMI_COMMA, 2);
                if(error_cause != RMMI_PARSE_OK)
                {
                    break;
                }
                if(mre_action == 0)
                {
                    //Clear context here
                    if(rmmi_ptr->appName != NULL)
                    {
                        free_ctrl_buffer(rmmi_ptr->appName);
                        rmmi_ptr->appName = NULL;
                    }
                    rmmi_ptr->appName_len = 0;
                    rmmi_final_rsp_generator(source_string_ptr->src_id, KAL_TRUE, NULL, 0);
                    return;
                }
                else if(mre_action == 1)
                {
                    nameBuffer = get_ctrl_buffer(240);
                    result = rmmi_string_validator(source_string_ptr, rmmi_ptr->s_reg.s3, 241, nameBuffer);
                    if((result == RMMI_VALIDATOR_ERROR) || (strlen((kal_char *)nameBuffer)%4 != 0))
                    {
                        if(rmmi_ptr->appName != NULL)
                        {
                            free_ctrl_buffer(rmmi_ptr->appName);
                            rmmi_ptr->appName = NULL;
                            rmmi_ptr->appName_len = 0;
                        }

                        free_ctrl_buffer(nameBuffer);
                        break;
                    }
                    else
                    {
                        if(rmmi_ptr->appName == NULL)
                        {
                            rmmi_ptr->appName = (kal_uint8 *)get_ctrl_buffer(520);
                        }
                        else if((rmmi_ptr->appName_len + strlen((kal_char *)nameBuffer)/2) > 520)
                        {
                            /* file path total length exceed max length */
                            free_ctrl_buffer(rmmi_ptr->appName);
                            rmmi_ptr->appName = NULL;
                            free_ctrl_buffer(nameBuffer);
                            rmmi_ptr->appName_len = 0;
                            break;
                        }
                        check_hex_value(nameBuffer, (rmmi_ptr->appName + rmmi_ptr->appName_len));
                        rmmi_ptr->appName_len += (strlen((kal_char *)nameBuffer)/2); /* counted in Unit of a Byte */
                        free_ctrl_buffer(nameBuffer);
                        rmmi_final_rsp_generator(source_string_ptr->src_id, KAL_TRUE, NULL, 0);
                        return;
                    }
                }
                else
                {
                    if(rmmi_ptr->appName != NULL)
                    {
                        kal_mem_set(appName, 0, sizeof(appName));
                        kal_mem_cpy(appName, rmmi_ptr->appName, rmmi_ptr->appName_len);
                        rmmi_byte_order_reverse((kal_uint8 *)appName, rmmi_ptr->appName_len);
                        free_ctrl_buffer(rmmi_ptr->appName);
                        rmmi_ptr->appName = NULL;
                        rmmi_ptr->appName_len = 0;
                        l4c_eq_launch_app_req_lind(type, 0, 0, 0, appName);
                    }
                    else
                    {
                        /* No Name stored before, return ERROR */
                        break;
                    }
                }
            }

            l4c_ptr->route_thru_lmmi = KAL_TRUE;
            l4c_ptr->route_thru_lmmi_user = source_string_ptr->src_id;
            return;
        }
        default:
        {
            /* Unsupported command type */
            break;
        }    
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, KAL_FALSE, NULL, 0);
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_elog_hdlr
 * DESCRIPTION
 *   This cmd is used to turn on/off Java/VRE application standard/error info output
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
void rmmi_elog_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_uint8 type = 0xff;
    kal_uint8 op = 0xff;
    kal_uint8 error_cause;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    
    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_ELOG_HDLR_ENTRY);
    
    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            type = rmmi_int_validator_range_check(&error_cause, source_string_ptr, RMMI_COMMA, 1);
            if(type == RMMI_VALIDATOR_ERROR)
            {
                break;
            }
            op = rmmi_int_validator_range_check(&error_cause, source_string_ptr, rmmi_ptr->s_reg.s3, 1);
            if(op == RMMI_VALIDATOR_ERROR)
            {
                break;
            }
            rmmi_final_rsp_generator(source_string_ptr->src_id, KAL_TRUE, NULL, 0);
            /* Send message to MMI here */
            l4c_eq_app_info_output_req_lind(type, op);
            return;
            
        }
        default:
        {
            /* Unsupported command type */
            break;
        }
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, KAL_FALSE, NULL, 0);
}
#endif /* defined(PLUTO_MMI) */
#endif /* defined(__OP11_ATK__) || defined(__AUTO_ATK__) */


#if defined(__DUAL_TALK_MODEM_SUPPORT__)
/*****************************************************************************
 * FUNCTION
 *  rmmi_espeech_hdlr
 * DESCRIPTION
 *   This cmd is used to invoke l1Audio function Spc_Speech_On/Spc_Speech_Off
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
 void rmmi_espeech_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    rmmi_spc_espeech_param_struct param;
    kal_uint8 error_cause;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
//    l4c_context_struct *l4c_ptr = L4C_PTR;

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_ESPEECH_HDLR_ENTRY);
    
    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            param.speech_mode = (kal_uint8)rmmi_int_validator_range_check(&error_cause, 
                                                                          source_string_ptr, 
                                                                          RMMI_COMMA, 
                                                                          1);
            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }
            else
            {
                if (param.speech_mode == 1)
                {
                    /* get rat_mode from AP
                       RAT_2G_MODE, RAT_3G_MODE, RAT_3G324M_MODE defined in l1audio.h
                    */
                    param.rat_mode = rmmi_int_validator_u8_check(&error_cause, 
                                                           source_string_ptr, 
                                                           rmmi_ptr->s_reg.s3);
                    if (error_cause != RMMI_PARSE_OK)
                    {
                        break;
                    }
                }
                ret_val = l4c_med_in_proc_call_req(source_string_ptr->src_id, 
                                                   source_string_ptr->cmd_index,
                                                   &param,
                                                   sizeof(rmmi_spc_espeech_param_struct));
                if (ret_val == KAL_TRUE)
                {
                    return; //response OK after L1Audio return
                }
            }
            break;
        }
        default:
        {
            /* Unsupported command type */
            break;
        }    
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_esstv_hdlr
 * DESCRIPTION
 *   This cmd is used to invoke l1Audio function Spc_SetSidetoneVolume
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
 void rmmi_esstv_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    rmmi_spc_esstv_param_struct param;
    kal_uint8 error_cause;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_ESSTV_HDLR_ENTRY);
    
    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            param.sidetone = rmmi_int_validator_u8_check(&error_cause, source_string_ptr, rmmi_ptr->s_reg.s3);
            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }
            else
            {
                ret_val = l4c_med_in_proc_call_req(source_string_ptr->src_id,
                                                   source_string_ptr->cmd_index,
                                                   &param,
                                                   sizeof(rmmi_spc_esstv_param_struct));
                if (ret_val == KAL_TRUE)
                {
                    return; //response OK after L1Audio return
                }
            }
            break;
        }
        default:
        {
            /* Unsupported command type */
            break;
        }    
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_edtp_hdlr
 * DESCRIPTION
 *   This cmd is used to invoke l1Audio function Spc_Default_Tone_Play
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
 void rmmi_edtp_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    rmmi_spc_edtp_param_struct param;
    kal_uint8 error_cause;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_EDTP_HDLR_ENTRY);
    
    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            param.tone_id = rmmi_int_validator_u8_check(&error_cause, source_string_ptr, rmmi_ptr->s_reg.s3);
            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }
            else
            {
                ret_val = l4c_med_in_proc_call_req(source_string_ptr->src_id,
                                                   source_string_ptr->cmd_index,
                                                   &param,
                                                   sizeof(rmmi_spc_edtp_param_struct));
                if (ret_val == KAL_TRUE)
                {
                    return; //response OK after L1Audio return
                }
            }
            break;
        }
        default:
        {
            /* Unsupported command type */
            break;
        }    
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_edts_hdlr
 * DESCRIPTION
 *   This cmd is used to invoke l1Audio function Spc_Default_Tone_Stop
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
 void rmmi_edts_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_EDTS_HDLR_ENTRY);
    
    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_ACTIVE_MODE:
        {
            ret_val = l4c_med_in_proc_call_req(source_string_ptr->src_id,
                                               source_string_ptr->cmd_index,
                                               NULL,
                                               0);
            if (ret_val == KAL_TRUE)
            {
                return; //response OK after L1Audio return
            }
            break;
        }
        default:
        {
            /* Unsupported command type */
            break;
        }    
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_esetdev_hdlr
 * DESCRIPTION
 *   This cmd is used to invoke l1Audio function Spc_SetInputSource/
*    Spc_SetOutputDevice
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
 void rmmi_esetdev_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    rmmi_spc_esetdev_param_struct param;
    kal_uint8 error_cause;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_EDSETDEV_HDLR_ENTRY);
    
    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            param.esetdev_mode = rmmi_int_validator_range_check(&error_cause, 
                                                  source_string_ptr, 
                                                  RMMI_COMMA, 
                                                  1);
            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }
            else
            {
                param.src_dev = rmmi_int_validator_u8_check(&error_cause, 
                                                    source_string_ptr, 
                                                    rmmi_ptr->s_reg.s3);
                if (error_cause != RMMI_PARSE_OK)
                {
                    break;
                }
                ret_val = l4c_med_in_proc_call_req(source_string_ptr->src_id,
                                                   source_string_ptr->cmd_index,
                                                   &param,
                                                   sizeof(rmmi_spc_esetdev_param_struct));
                if (ret_val == KAL_TRUE)
                {
                    return; //response OK after L1Audio return
                }
            }
            break;
        }
        default:
        {
            /* Unsupported command type */
            break;
        }    
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_esov_hdlr
 * DESCRIPTION
 *   This cmd is used to invoke l1Audio function Spc_SetOutputVolume
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
 void rmmi_esov_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    rmmi_spc_esov_param_struct param;
    kal_uint8 error_cause;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_ESOV_HDLR_ENTRY);
    
    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            param.volume = rmmi_int_validator_u8_check(&error_cause, 
                                                 source_string_ptr, 
                                                 RMMI_COMMA);
            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }
            else
            {
                param.gain_id = rmmi_int_validator_u8_check(&error_cause, 
                                                      source_string_ptr, 
                                                      rmmi_ptr->s_reg.s3);
                if (error_cause != RMMI_PARSE_OK)
                {
                    break;
                }
                ret_val = l4c_med_in_proc_call_req(source_string_ptr->src_id,
                                                   source_string_ptr->cmd_index,
                                                   &param,
                                                   sizeof(rmmi_spc_esov_param_struct));
                if (ret_val == KAL_TRUE)
                {
                    return; //response OK after L1Audio return
                }
            }
            break;
        }
        default:
        {
            /* Unsupported command type */
            break;
        }    
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_esmv_hdlr
 * DESCRIPTION
 *   This cmd is used to invoke l1Audio function Spc_SetMicrophoneVolume
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
 void rmmi_esmv_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    rmmi_spc_esmv_param_struct param;
    kal_uint8 error_cause;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_ESMV_HDLR_ENTRY);
    
    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            param.mic_volume= rmmi_int_validator_u8_check(&error_cause, source_string_ptr, rmmi_ptr->s_reg.s3);
            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }
            else
            {
                ret_val = l4c_med_in_proc_call_req(source_string_ptr->src_id,
                                                   source_string_ptr->cmd_index,
                                                   &param,
                                                   sizeof(rmmi_spc_esmv_param_struct));
                if (ret_val == KAL_TRUE)
                {
                    return; //response OK after L1Audio return
                }
            }
            break;
        }
        default:
        {
            /* Unsupported command type */
            break;
        }    
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
}


/*****************************************************************************
 * FUNCTION
 *  rmmi_essma_hdlr
 * DESCRIPTION
 *   This cmd is used to invoke l1Audio function Spc_SetSpeechMode_Adaptation
 * PARAMETERS
 *  source_string_ptr       [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
 void rmmi_essma_hdlr(rmmi_string_struct *source_string_ptr)
{
    kal_bool ret_val = KAL_FALSE;
    rmmi_spc_essma_param_struct param;
    kal_uint8 error_cause;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    kal_brief_trace(TRACE_FUNC, FUNC_RMMI_ESSMA_HDLR_ENTRY);
    
    switch (source_string_ptr->cmd_mode)
    {
        case RMMI_SET_OR_EXECUTE_MODE:
        {
            param.mode = rmmi_int_validator_u8_check(&error_cause, source_string_ptr, rmmi_ptr->s_reg.s3);
            if (error_cause != RMMI_PARSE_OK)
            {
                break;
            }
            else
            {
                ret_val = l4c_med_in_proc_call_req(source_string_ptr->src_id,
                                                   source_string_ptr->cmd_index,
                                                   &param,
                                                   sizeof(rmmi_spc_essma_param_struct));
                if (ret_val == KAL_TRUE)
                {
                    return; //response OK after L1Audio return
                }
            }
            break;
        }
        default:
        {
            /* Unsupported command type */
            break;
        }    
    }
    rmmi_final_rsp_generator(source_string_ptr->src_id, ret_val, NULL, 0);
}

#endif /* defined(__DUAL_TALK_MODEM_SUPPORT__) */
