/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 * RMMI_IND.C
 *
 * Project:
 * --------
 *   MT6208
 *
 * Description:
 * ------------
 *   This file is intends for ...
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/********************************************************************************
*  Copyright Statement:
*  --------------------
*
*  This product has been developed using a protocol stack
*  developed by Sasken Communication Technologies Limited.
*
********************************************************************************/

#define RMMI_IND_C
//#include "kal_non_specific_general_types.h"
//#include "kal_release.h"        /* Basic data type */
//#include "stack_common.h"
//#include "stack_msgs.h"
//#include "app_buff_alloc.h"     /* Declaration of buffer management API */
//#include "stacklib.h"   /* Basic type for dll, evshed, stacktimer */
//#include "stack_timer.h"
//#include "event_shed.h"
#include "string.h"
//#include "ps_trace.h"
#include "kal_trace.h"

#ifdef __MOD_TCM__
//#include "mmi_l3_enums.h"
#endif

#ifdef __MOD_SMU__
//#include "ps2sim_struct.h"
#include "sim_common_enums.h"
//#include "smu_common_enums.h"
#endif /* __MOD_SMU__ */ 
//#include "csmss_common_enums.h"
#include "csmcc_common_enums.h"


#include "mcd_l4_common.h"

#include "l4c_common_enum.h"
#include "rmmi_common_enum.h"
#include "rmmi_context.h"
//#include "l4c_rspfmttr.h"
#include "l4c_context.h"
#include "layer4_context.h"
//#include "l4c_msghdlr.h"
#include "l4_trc.h"
#include "atci_trc.h"

//#include "l4c_aux_struct.h"
/////////add to provide SAT sturcture ///////////////////

#include "sim_common_enums.h"

//#include "mcd_ss_parameters.h"  /* csm */
//#include "mcd_ss_tcapmessages.h"

#include "l4c_common_enum.h"
//#include "csmcc_enums.h"
#include "csmcc_common_enums.h"
#include "ps2sat_struct.h"
#include "l4c2csm_cc_struct.h"

//#include "l4c2csm_ss_struct.h"
#include "l4c2smsal_struct.h"
#include "ps2sat_struct.h"

#include "mcd_ps2sat_peer.h"

#include "l4c_sim_cmd.h"
#include "l4c_nw_cmd.h"
//#include "l4c_rspfmttr.h"
//  SAT 
//#include "l4_defs.h"
#include "csmcc_atfunc.h"

//#include "mcd_l3_inc_struct.h"
 
#ifdef __MOD_SMSAL__
#include "smsal_l4c_enum.h"
#include "smsal_l4c_defs.h"
//#include "smsal_defs.h"
#include "l4c2smsal_struct.h"
//#include "mcd_l4c2smsal_peer.h"
#endif /* __MOD_SMSAL__ */ 
#ifdef __MOD_UEM__
#include "device.h"
//#include "l4c2uem_struct.h"
#endif /* __MOD_UEM__ */ 

#include "l4c_utility.h"
#include "rmmi_utility.h"
#include "rmmi_rspfmttr.h"
//#include "aud_defs.h"
#include "sat_def.h"
#include "keypad_sw.h"
#include "l4crac_enums.h"
//#include "l4c2phb_enums.h"

#include "l3_inc_enums.h"

//#include "mnsms_struct.h"
//#include "smsal_peer_struct.h"
//#include "smsal_structs.h"
#include "smsal_cb.h"
#include "stdlib.h"
#include "rmmi_analyzer.h"
#include "stdio.h"
#include "l3_inc_enums.h"
#include "rmmi_msghdlr.h"
#include "kal_general_types.h"
#include "kal_public_api.h"
#include "ps_public_struct.h"
#include "ps_public_enum.h"
#include "sim_ps_enum.h" 
#include "dcl.h"

#ifdef __ACMT_SUPPORT__
#include "nas2l4c_struct.h"
#endif

#include "l4c2tcm_func.h"
#include "rmmi_rsp.h"

extern kal_bool l4ccsm_cc_get_hold_call(kal_uint8 *call_id);
extern kal_bool l4ccsm_cc_get_active_call(kal_uint8 *call_id);
extern kal_uint8 l4_custom_battery_cind_value(kal_uint8 battery_voltage);
extern kal_bool l4c_kbd_getkeydata(kbd_data *keydata);
extern kal_uint8 custom_ciev_signal_variance(void); //hong_rx_level

/*****************************************************************************
 * FUNCTION
 *  l4c_at_ready_rind
 * DESCRIPTION
 *  This function indicates TE side that ME is ready to receive AT commands
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_at_ready_rind(void)
{
#if !defined(__SLIM_AT__) || defined(__UE_SIMULATOR__)
    kal_uint16 string_length;
    kal_uint8 buffer[MAX_UART_LENGTH];
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

#if defined(__GEMINI__) && defined(__DISABLE_SIM2_AT_SUPPORT__)//mtk01616_100511: prevent SIM2 event to update RMMI context
    if(l4c_current_mod_id == MOD_L4C_2)
        return;		
#endif

    rmmi_ptr->eind_ready_flag |= (INFO_REPORT_MASK << RMMI_EIND_AT_READY_BIT);

    if (rmmi_ptr->report_mode.eind & (INFO_REPORT_MASK << RMMI_EIND_AT_READY_BIT)) 
    {
        kal_sprintf((kal_char*) buffer, "+EIND: 128");
        string_length = (kal_uint16)strlen((char*)buffer);
        rmmi_write_to_uart(buffer, string_length, KAL_TRUE);
    }
#endif /* !defined(__SLIM_AT__) */ 
}

#if !defined(__MMI_FMI__) || defined(__ECFU_URC_SUPPORT__)
/*****************************************************************************
 * FUNCTION
 *  l4c_cphs_display_cfu_rind
 * DESCRIPTION
 *  This function indicates TE to show CFU icon
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_cphs_display_cfu_rind(kal_uint8 action, kal_uint8 line_num)
{
    kal_uint16 string_length;
    kal_uint8 buffer[MAX_UART_LENGTH];
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    if (rmmi_ptr->report_mode.einfo & (INFO_REPORT_MASK << RMMI_ECFU_BIT)) 
    {
    	kal_sprintf((kal_char*) buffer, "+ECFU: %d, %d",action,line_num);	
	    string_length = (kal_uint16)strlen((char*)buffer);
    	rmmi_write_to_uart(buffer, string_length, KAL_TRUE);
    }
	
}
#endif


#if !defined(__MMI_FMI__) || defined(__ESPEECH_URC_SUPPORT__)
/*****************************************************************************
 * FUNCTION
 *  l4c_cc_speech_rind
 * DESCRIPTION
 *  This function indicates TE to turn on/off speech
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_cc_speech_rind(kal_bool on_off, kal_uint8 rat,kal_uint8 irho_speech_on_off)
{
    kal_uint16 string_length;
    kal_uint8 buffer[MAX_UART_LENGTH];
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    if (rmmi_ptr->report_mode.einfo & (INFO_REPORT_MASK << RMMI_ESPEECH_BIT)) 
    {
    	kal_sprintf((kal_char*) buffer, "+ESPEECH: %d, %d, %d",on_off,rat,irho_speech_on_off);	
        string_length = (kal_uint16)strlen((char*)buffer);
    	rmmi_write_to_uart(buffer, string_length, KAL_TRUE);
    }	
}
#endif

/*****************************************************************************
 * FUNCTION
 *  l4c_phb_startup_begin_rind
 * DESCRIPTION
 *  
 * PARAMETERS
 *
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_phb_startup_begin_rind()
{
    /*+EIND: 32*/
    RMMI_PTR->eind_ready_flag &= ~(INFO_REPORT_MASK << RMMI_EIND_PHB_READY_BIT); 

    if (RMMI_PTR->report_mode.eind & (INFO_REPORT_MASK << RMMI_EIND_PHB_NOT_READY_BIT))
    {
        rmmi_header_rrsp("+EIND:");
        rmmi_tail_int_space_rrsp(32);
    }
}


/*****************************************************************************
 * FUNCTION
 *  l4c_phb_startup_finish_rind
 * DESCRIPTION
 *  
 * PARAMETERS
 *  sim_max_num     [IN]        
 *  phb_max_num     [IN]        
 *  phb_len         [IN]        
 *  fdn_len         [IN]        
 *  bdn_len         [IN]        
 *  owner_len       [IN]        
 *  email_len          [IN]
 *  desc                [IN]
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_phb_startup_finish_rind(
        kal_uint16 sim_max_num,
        kal_uint16 phb_max_num,
        kal_uint8 phb_len,
        kal_uint8 fdn_len,
        kal_uint8 bdn_len,
        kal_uint8 owner_len,  
        kal_uint8 email_len,
        l4c_phb_desc_struct *desc)
{
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

#if !defined(__SLIM_AT__) && !defined(__UE_SIMULATOR__)
    kal_uint8 buffer[MAX_UART_LENGTH];
    kal_uint8 string_length;

#if defined(__GEMINI__) && defined(__DISABLE_SIM2_AT_SUPPORT__)//mtk01616_100511: prevent SIM2 event to update RMMI context
    if(l4c_current_mod_id == MOD_L4C_2)
        return;		
#endif

    rmmi_ptr->eind_ready_flag |= (INFO_REPORT_MASK << RMMI_EIND_PHB_READY_BIT);

    if (rmmi_ptr->report_mode.eind & (INFO_REPORT_MASK << RMMI_EIND_PHB_READY_BIT))
    {
        kal_sprintf((kal_char*) buffer, "+EIND: 2");
        string_length = (kal_uint8)strlen((char*)buffer);
        rmmi_write_to_uart(buffer, string_length, KAL_TRUE);
    }
#endif /* !defined(__SLIM_AT__) */ 
    rmmi_ptr->phb_info.sim_phb_len = phb_len;
    rmmi_ptr->phb_info.sim_fdn_len = fdn_len;
    rmmi_ptr->phb_info.msisdn_alpha_length = owner_len;	
    rmmi_ptr->phb_info.sim_email_len = email_len;

    #ifdef __AT_EPBUM_SUPPORT__
    rmmi_ptr->phb_anr_occurrence = desc[PHB_ANR-1].occurrence;
    rmmi_ptr->phb_email_occurrence = desc[PHB_EMAIL-1].occurrence > 1 ? 1 : desc[PHB_EMAIL-1].occurrence;
    rmmi_ptr->phb_sne_occurrence = desc[PHB_SNE-1].occurrence > 1 ? 1 : desc[PHB_SNE-1].occurrence;
    rmmi_ptr->phb_grp_length = (kal_uint8)desc[PHB_GRP-1].record_size;
    #endif /*__AT_EPBUM_SUPPORT__*/
}

#ifdef __MOD_CSM__


/*****************************************************************************
 * FUNCTION
 *  l4c_cc_call_meter_rind
 * DESCRIPTION
 *  This is l4c_cc_call_meter_rind function of L4C module.
 *  construct +CCCM unsolicited result code for RMMI
 * PARAMETERS
 *  call_id     [IN]        
 *  ccm         [IN]        Current call meter value
 *  warning     [IN]        Acm close to ACM MAX or not
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_cc_call_meter_rind(kal_uint8 call_id, kal_uint32 ccm, kal_uint8 warning)
{
#if !defined(__SLIM_AT__) && defined(__AOC_SUPPORT__)
    kal_uint16 string_length;
    kal_uint8 buffer[MAX_UART_LENGTH];
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    kal_brief_trace(TRACE_FUNC, FUNC_L4C_CC_CALL_METER_RIND_ENTRY);
    if (rmmi_ptr->report_mode.ccm == RMMI_ENABLE_REPORT)
    {
        rmmi_ptr->arg_list[0] = (void*)&ccm;
        string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CCCM: %e", rmmi_ptr->arg_list, 1);

        rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
    }

    if (warning == KAL_TRUE)    		
    {
        if (rmmi_ptr->report_mode.acm_warning == RMMI_ENABLE_REPORT)
        {
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CCWV", rmmi_ptr->arg_list, 0);

            rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
        }
    }
    return;
#endif /* !defined(__SLIM_AT__) && defined(__AOC_SUPPORT__) */
}


/*****************************************************************************
 * FUNCTION
 *  l4c_cc_call_wait_rind
 * DESCRIPTION
 *  This is l4c_cc_call_wait_rind function of L4C module.
 *  construct +CCWA unsolicited result code for RMMI
 * PARAMETERS
 *  call_id             [IN]        
 *  num                 [IN]        Phone number of the waiting call
 *  call_type           [IN]        
 *  name                [IN]        Corresponding name of num if stored in PHB
 *  cli_validity        [IN]        Caller id is available or not
 *  bclass(?)           [IN]        Call class of the waiting call
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_cc_call_wait_rind(
        kal_uint8 call_id,
        l4c_number_struct *num,
        kal_uint8 call_type,
        kal_uint8 *name,
        kal_uint8 cli_validity)
{
    kal_uint16 string_length;
    kal_uint8 buffer[MAX_UART_LENGTH];
    kal_uint16 bclass; // for WM propriety Line2 waiting call
    kal_uint8 type;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    //kal_uint8 addr_type;

    kal_brief_trace(TRACE_FUNC, FUNC_L4C_CC_CALL_WAIT_RIND_ENTRY);
    ASSERT((num != NULL) && (name != NULL));

    if (rmmi_ptr->report_mode.call_wait == 0)   //unsolicited code is disabled.
    {
        return;
    }

    switch (call_type)
    {
        case CSMCC_VOICE_CALL:
        case CSMCC_AUX_VOICE_CALL:
            bclass = 1;
            /* 
             * Referring to WM smaple code. we use
             * +CRING: AUX VOICE for line2 incoming call
             * +CCWA: <num>,<type>,<class>...  set <class>=256 for Line2 waiting call  
             */
    #if defined(__SP_RIL_SUPPORT__)
            if (call_type == CSMCC_AUX_VOICE_CALL)
            {
                bclass = 256;
            }
    #endif /* __SP_RIL_SUPPORT__ */ 
            break;
        case CSMCC_DATA_CALL:
        case CSMCC_CSD_CALL:
            bclass = 2;
            break;
        case CSMCC_FAX_CALL:
            bclass = 4;
            break;
    #if defined(__VT_TRANSPORT_SUPPORT__)
        case CSMCC_VIDEO_CALL:
            bclass = 512; //0x0200
            break;
    #endif /* __VT_TRANSPORT_SUPPORT__ */
        default:
            bclass = 255;
    }

    /* refer to 24.008 section 10.5.4.9 and handfree profile spec ,<type> in +CLIP shall range from 128~175 */
    if (num->type < 0x80)
    {
        type = num->type + 0x80;
    }
    else
    {
        type = num->type;
    }

    rmmi_ptr->arg_list[0] = (void*)num->number;
    rmmi_ptr->arg_list[1] = (void*)&type;
    rmmi_ptr->arg_list[2] = (void*)&bclass;

    /* marked by mtk00714 (2004/03/16) : we don't support name and cli_validity */
#if 1
    string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CCWA: \"%s\",%d,%u", rmmi_ptr->arg_list, 3);
#endif 

    rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);

    return;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_cc_call_ring_rind
 * DESCRIPTION
 *  This is l4c_cc_call_ring_rind function of L4C module.
 *  construct RING & +CLIP unsolicited result code for RMMI
 * PARAMETERS
 *  call_id             [IN]        
 *  num                 [IN]        Phone number of the incoming call
 *  sub_addr            [IN]        Sub address of the incoming call
 *  name                [IN]        Corresponding name of num if stored in PHB
 *  cli_validity        [IN]        Caller id is available or not
 *  call_type           [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_cc_call_ring_rind(
        kal_uint8 call_id,
        l4c_number_struct *num,
        l4c_sub_addr_struct *sub_addr,
        kal_uint8 *name,
        kal_uint8 cli_validity,
        kal_uint8 call_type)
{
    l4c_call_entry_struct call_entry;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    kal_brief_trace(TRACE_FUNC, FUNC_L4C_CC_CALL_RING_RIND_ENTRY);
    ASSERT((num != NULL) && (sub_addr != NULL) && (name != NULL));

#if defined(__GEMINI__) && defined(__DISABLE_SIM2_AT_SUPPORT__)//mtk01616_100511: prevent SIM2 event to update RMMI context
    if(l4c_current_mod_id == MOD_L4C_2)
        return;		
#endif

    /* mtk00714 (2004/03/02) add for +CRC */
    l4ccsm_cc_get_call_info(call_id, &call_entry, NULL);
    rmmi_ptr->cring_type = call_entry.call_mode;    /* needed when +CRC = 1 */

#if defined(__SP_RIL_SUPPORT__)
    if (rmmi_ptr->cring_type == SINGLE_VOICE_CALL && call_type == CSMCC_AUX_VOICE_CALL)
    {
        rmmi_ptr->cring_type = RMMI_CRING_VOICE_AUX;
    }
#endif /* __SP_RIL_SUPPORT__ */ 

#if defined(__VT_TRANSPORT_SUPPORT__)
    if (call_entry.call_type == CSMCC_VIDEO_CALL)
    {
        rmmi_ptr->cring_type = RMMI_CRING_VIDEO;
    }
#endif /* __VT_TRANSPORT_SUPPORT__ */

    /* refer to 24.008 section 10.5.4.9 and handfree profile spec ,<type> in +CLIP shall range from 128~175 */
    if (num->type < 0x80)
    {
        rmmi_ptr->clip_info.type = num->type + 0x80;
    }
    else
    {
        rmmi_ptr->clip_info.type = num->type;
    }

    if( strlen((char*)num->number) >  MAX_CC_ADDR_LEN || 		//mtk02514_081216
	  strlen((char*)sub_addr->number) > MAX_CC_ADDR_LEN )
    {
    	ASSERT(0);
    }
    
    strncpy((char*)rmmi_ptr->clip_info.number, (char*)num->number,MAX_CC_ADDR_LEN-1);
    strncpy((char*)rmmi_ptr->clip_info.subaddr, (char*)sub_addr->number,MAX_CC_ADDR_LEN-1);
    rmmi_ptr->clip_info.satype = sub_addr->type;
    rmmi_ptr->clip_info.cli_validity = cli_validity;

#ifndef __DISABLE_AT_URC__
    rmmi_result_code_fmttr(RMMI_RCODE_RING, L4C_NO_CAUSE);
#endif 

    return;

}


/*****************************************************************************
 * FUNCTION
 *  l4c_cc_call_release_rind
 * DESCRIPTION
 *  This is l4c_cc_call_release_rind function of L4C module.
 *  construct NO CARRIER unsolicited result code for RMMI
 *  when call is released
 * PARAMETERS
 *  call_id     [IN]        Cal id of the released call
 *  cause       [IN]        The reason that the call is released
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_cc_call_release_rind(kal_uint8 call_id, kal_uint16 cause)
{
    kal_brief_trace(TRACE_FUNC, FUNC_L4C_CC_CALL_RELEASE_RIND_ENTRY);
    //for module: Maui_sw 9943
    //L4C_PTR->cc_sub_state[RMMI_SRC] = L4C_IDLE_STATE; 
    //for module: Maui_sw 9943
    if (cause == CM_USER_BUSY)
    {
        rmmi_result_code_fmttr(RMMI_RCODE_BUSY, RMMI_ERR_UNKNOWN);
    }
    else
    {
        rmmi_result_code_fmttr(RMMI_RCODE_NO_CARRIER, RMMI_ERR_UNKNOWN);
    }

    return;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_cc_call_info_rind
 * DESCRIPTION
 *  This is l4c_cc_call_info_rind function of L4C module.
 *  to give unsolicited result code for +CMER
 * PARAMETERS
 *  call_exist      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_cc_call_info_rind(kal_bool call_exist)
{
#if !defined(__BT_SUPPORT__)

    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    /* unsolicited result code for +CMER */
    if (call_exist != rmmi_ptr->indicators.call)
    {
        /* update indicators.call  */
        rmmi_ptr->indicators.call = call_exist;
        if (rmmi_ptr->report_mode.cmer_ind > 0) //cmer_revise == 2)
        {
            /* send unsolicited result code */
            kal_sprintf((kal_char*) buffer, "+CIEV: 5, %d", call_exist);       //  5: <call> in +CIND
            rmmi_write_unsolicitedResultCode(
                (kal_uint8*) buffer,
                (kal_uint16) strlen((char*)buffer),
                KAL_TRUE,
                rmmi_ptr->report_mode.cmer_mode,
                (void*)&rmmi_ptr->CNMI_ResultCodeBuffer);
        }
    }
#endif /* !defined(__BT_SUPPORT__) */ 
}

#ifdef __BT_SUPPORT__


/*****************************************************************************
 * FUNCTION
 *  l4c_cc_handfree_rind
 * DESCRIPTION
 *  
 * PARAMETERS
 *  ind_type        [IN]        
 *  event           [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_cc_handfree_rind(kal_uint8 ind_type, kal_uint8 event)
{
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
#ifdef __BT_SUPPORT__
    rmmi_common_context_struct *rmmi_comm_ptr = RMMI_COMM_PTR;
#endif

    kal_brief_trace(TRACE_GROUP_1, RMMI_CIEV, ind_type, event);

#if defined(__GEMINI__) && defined(__DISABLE_SIM2_AT_SUPPORT__)//mtk01616_100511: prevent SIM2 event to update RMMI context
    if(l4c_current_mod_id == MOD_L4C_2)
        return;		
#endif
	
    switch (ind_type)
    {
        case RMMI_CIND_SERVICE:
            if (rmmi_ptr->indicators.service == event)
            {
                return;
            }
            rmmi_ptr->indicators.service = event;
            break;
        case RMMI_CIND_CALL:
            if (rmmi_ptr->indicators.call == event)
            {
                return;
            } 
            rmmi_ptr->indicators.call = event;
            break;

        case RMMI_CIND_CALLSETUP:
            if (rmmi_ptr->indicators.callsetup == event)
            {
                return;
            }
            rmmi_ptr->indicators.callsetup = event;
            break;
        #ifdef __HF_V15__
        case RMMI_CIND_CALLHELD:
            //mtk01616_090923: to explictly send redundant +ciev:<callheld>. see MAUI_01784989
            if (rmmi_ptr->send_ciev_callheld == KAL_TRUE)
            {
                kal_brief_trace(TRACE_INFO, RMMI_EXPLICT_SEND_CIEV, ind_type, event);
                rmmi_ptr->send_ciev_callheld = KAL_FALSE;
            }
            else
            {
                if (rmmi_ptr->indicators.callheld == event)
                {
                    return;
				}
            }
            rmmi_ptr->indicators.callheld = event;
            break;
        case RMMI_CIND_SIGNAL:
            if (rmmi_ptr->indicators.signal == event)
            {
                return;
            }
            rmmi_ptr->indicators.signal = event;
            break;
        case RMMI_CIND_ROAM:
            if (rmmi_ptr->indicators.roam == event)
            {
                return;
            }
            rmmi_ptr->indicators.roam = event;
            break;
        case RMMI_CIND_BATTCHG:
            if (rmmi_ptr->indicators.battchg == event)
            {
                return;
            }
            rmmi_ptr->indicators.battchg = event;
            break;
        #endif /* __HF_V15__ */ 
        default:
            return;
    }

    if (rmmi_ptr->report_mode.cmer_ind == 0 || rmmi_ptr->report_mode.cmer_ind > 2)
    {
        return;
    }

#ifdef __BT_SUPPORT__
    //mtk01616_070722: prevent sending +ciev URC before bt hfp ready
    if (rmmi_comm_ptr->hf_urc_report_flag == KAL_FALSE)
    {
        kal_brief_trace(TRACE_INFO, INFO_HF_IS_NOT_READY_TO_RECIEVE_URC_REPORT);
        return;
    }
#endif /* __BT_SUPPORT__ */

    kal_sprintf((kal_char*) buffer, "+CIEV:%d,%d", ind_type, event);
    rmmi_write_unsolicitedResultCode(
        (kal_uint8*) buffer,
        (kal_uint16) strlen((char*)buffer),
        KAL_TRUE,
        rmmi_ptr->report_mode.cmer_mode,
        (void*)&rmmi_ptr->CNMI_ResultCodeBuffer);

}

//mtk01616_070722


/*****************************************************************************
 * FUNCTION
 *  l4c_cc_handfree_callheld_rind
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_cc_handfree_callheld_rind()
{
#ifdef __HF_V15__
    kal_uint8 call_id;
    kal_bool active;
    kal_uint8 event;
    kal_bool hold;

    kal_brief_trace(TRACE_FUNC, FUNC_L4C_CC_HANDFREE_CALLHELD_RIND);

    active = l4ccsm_cc_get_active_call(&call_id);
    hold = l4ccsm_cc_get_hold_call(&call_id);

    if ((active == KAL_TRUE) && (hold == KAL_TRUE))
    {
        event = RMMI_CIND_HELD_ACTIVE_HOLD;
    }
    else if ((active == KAL_FALSE) && (hold == KAL_TRUE))
    {
        event = RMMI_CIND_HELD_HOLD;
    }
    else
    {
        event = RMMI_CIND_HELD_NONE;
    }

    l4c_cc_handfree_rind(RMMI_CIND_CALLHELD, event);

#endif /* __HF_V15__ */ 
}
#endif /* __BT_SUPPORT__ */ 


/*****************************************************************************
 * FUNCTION
 *  l4c_cc_call_modify_rind
 * DESCRIPTION
 *  
 * PARAMETERS
 *  call_mode       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_cc_call_modify_rind(kal_uint8 call_mode)
{
    kal_brief_trace(TRACE_FUNC, FUNC_L4C_CC_CALL_MODIFY_RIND_ENTRY);
    if ((call_mode == SINGLE_VOICE_CALL) ||
        (call_mode == FOLLOW_VOICE_CALL) || (call_mode == ALT_DATA_VOICE_CALL) || (call_mode == ALT_FAX_VOICE_CALL))
    {
        rmmi_result_code_fmttr(RMMI_RCODE_OK, L4C_NO_CAUSE);
    }
    else
    {
        /* voice -> data */
        rmmi_result_code_fmttr(RMMI_RCODE_CONNECT, L4C_GEN_CAUSE);
    }

    return;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_cc_call_connect_rind
 * DESCRIPTION
 *  This is l4c_cc_call_connect_rind function of L4C module.
 *  construct CONNECT unsolicited result code for RMMI for a MO call
 * PARAMETERS
 *  call_mode       [IN]        Call mode of the successful MO call
 *  call_id         [IN]        
 *  num(?)          [IN]        Phone number of the successful MO call
 *  name(?)         [IN]        Corresponding name of num if stored in PHB
 *  sub_addr(?)     [IN]        Sub address of the successful MO call
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_cc_call_connect_rind(kal_uint8 call_mode, kal_uint8 call_id)
{
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    kal_brief_trace(TRACE_FUNC, FUNC_L4C_CC_CALL_CONNECT_RIND_ENTRY);

    if ((call_mode == SINGLE_VOICE_CALL) ||
        (call_mode == FOLLOW_VOICE_CALL) || (call_mode == ALT_DATA_VOICE_CALL) || (call_mode == ALT_FAX_VOICE_CALL))
    {

    }
#ifdef __CSD_FAX__      /* add by mtk00714 */
    else if ((call_mode == ALT_FAX_FAX_CALL) || (call_mode == SINGLE_FAX_CALL))
    {
        return; //response nothing, ( wait for msg : L4CCSM_CC_CSD_EST_IND )
    }
#endif /* __CSD_FAX__ */ 
    else
    {
        /* mtk00714: 2004/03/02 add +CR service report for data call */
        if (rmmi_ptr->report_mode.cr == RMMI_ENABLE_REPORT)
        {
            rmmi_cr_result_code_fmttr();
        }

        rmmi_result_code_fmttr(RMMI_RCODE_CONNECT, L4C_GEN_CAUSE);
    }

    return;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_cc_notify_ss_rind
 * DESCRIPTION
 *  This is l4c_cc_notify_ss_rind function of L4C module.
 *  construct +CSSI, +CSSU unsolicited result code for RMMI
 * PARAMETERS
 *  call_id      [IN]        
 *  type         [IN]
 *  notification [IN]
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_cc_notify_ss_rind(kal_uint8 call_id, kal_uint8 type, kal_uint8 notification)
{
#if !defined(__SLIM_AT__)

    kal_uint8 code1 = 255;
    kal_uint8 code2 = 255;
    kal_bool is_MOsetup;
    l4c_call_entry_struct call_info;
    kal_uint8 string_length;
    kal_uint8 buffer[20];
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    //kal_brief_trace(TRACE_FUNC, FUNC_L4C_CC_NOTIFY_SS_RIND_ENTRY);
    l4ccsm_cc_get_call_info(call_id, &call_info, NULL);

    if ((rmmi_ptr->report_mode.ss_mo == RMMI_DISABLE_REPORT) && (rmmi_ptr->report_mode.ss_mt == RMMI_DISABLE_REPORT))
    {
        return;
    }

    if ((call_info.call_state == CLCC_CALL_DIALING) || (call_info.call_state == CLCC_CALL_ALERTING))
    {
        is_MOsetup = KAL_TRUE;  //MO call setup
    }
    else
    {
        is_MOsetup = KAL_FALSE; //MT call setup or during a call
    }

    switch (type)
    {
        case CSMCC_NOTIFY_CFU:
        {
            code1 = CSSI_CFU_ACTIVE;    // 0
            break;
        }
        case CSMCC_NOTIFY_CFC:
        {
            code1 = CSSI_CFC_ACTIVE;    // 1
            break;
        }
        case CSMCC_NOTIFY_CF:
        case CSMCC_NOTIFY_CF_CFU:
        case CSMCC_NOTIFY_CF_CFC:
        case CSMCC_NOTIFY_CF_CFB:
        case CSMCC_NOTIFY_CF_CFNRY:
        case CSMCC_NOTIFY_CF_CFNRC:
        {
            if (is_MOsetup == KAL_TRUE)
            {
                code1 = CSSI_CALL_FORWARDED;    // 2, notification=4
            }
            else
            {
                //according to TS 24.080 the coding of SS-Notification
                if (notification == 1)
                {
                #ifdef __SP_RIL_SUPPORT__
                /* for FTA test 31.2.1.7.1.1
                   MT call is a forwarded call:
                   11: Call Forwarded
                   12: Call Forwarded Unconditional
                   13: Call Forwarded Conditional
                   14: Call Busy Forwarded
                   15: Call Forwarded on No Reply
                   16: Call Forwarded on Not Reachable
                 */
                    code2 = 11 + (type - CSMCC_NOTIFY_CF); //11~16 proprietary <code2>
                #else
                    code2 = CSSU_FORWARDED_CALL;    //0
                #endif
                }
                else if (notification == 2)
                {
                    code2 = CSSU_INCOMING_FORWARDED; //10
                }
            }
            break;
        }
            //case CSMCC_NOTIFY_BAC:
        case CSMCC_NOTIFY_BAOC:
        {
            code1 = CSSI_OUTGOING_BARRED;       // 5
            break;
        }
        case CSMCC_NOTIFY_BAIC:
        {
            code1 = CSSI_INCOMING_BARRED;       // 6
            break;
        }
        case CSMCC_NOTIFY_CW:
        {
            code1 = CSSI_CALL_WAITING;  // 3
            break;
        }
        case CSMCC_NOTIFY_CALL_HELD:
        {
            code2 = CSSU_CALL_HOLD;     // 2
            break;
        }
        case CSMCC_NOTIFY_CALL_RETRIEVED:
        {
            code2 = CSSU_CALL_RETRIEVED;        // 3
            break;
        }
        case CSMCC_NOTIFY_CLIR_REJECT:
        {
            code1 = CSSI_CLIR_REJECTED; // 7 
            break;
        }
        case CSMCC_NOTIFY_MPTY:
        {
            code2 = CSSU_MPTY_CALL;     // 4
            break;
        }
        case CSMCC_NOTIFY_CD:
        {
            if (is_MOsetup == KAL_TRUE)
            {
                code1 = CSSI_CALL_DEFLECTED;    // 8
            }
            else
            {
                code2 = CSSU_DEFLECTED_CALL;    // 9
            }
            break;
        }
        case CSMCC_NOTIFY_HELD_CALL_RELEASED:
        {
            code2 = CSSU_HOLDCALL_RELEASED;     //5
            break;
        }
        default:
            break;
    }

    /* unsolicited code: +CSSI: <code1> */
    if ((code1 != 255) && (rmmi_ptr->report_mode.ss_mo == RMMI_ENABLE_REPORT))
    {
        rmmi_ptr->arg_list[0] = (void*)&code1;
        string_length = (kal_uint8)rmmi_fast_string_print(buffer, (kal_uint8*) "+CSSI: %d", rmmi_ptr->arg_list, 1);
        rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
    }

    /* unsolicited code: +CSSU: <code1> */
    if ((code2 != 255) && (rmmi_ptr->report_mode.ss_mt == RMMI_ENABLE_REPORT))
    {
        rmmi_ptr->arg_list[0] = (void*)&code2;
        string_length = (kal_uint8)rmmi_fast_string_print(buffer, (kal_uint8*) "+CSSU: %d", rmmi_ptr->arg_list, 1);
        rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
    }
    return;
#endif /* !defined(__SLIM_AT__) */ 
}


/*****************************************************************************
 * FUNCTION
 *  l4c_cc_notify_ss_cug_rind
 * DESCRIPTION
 *  This is l4c_cc_notify_ss_cug_rind function of L4C module.
 *  construct +CSSI, +CSSU unsolicited result code for RMMI for CUG
 * PARAMETERS
 *  call_id     [IN]        
 *  index       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_cc_notify_ss_cug_rind(kal_uint8 call_id, kal_uint16 index)
{
#if !defined(__SLIM_AT__)
    //kal_brief_trace(TRACE_FUNC, FUNC_L4C_CC_NOTIFY_SS_CUG_RIND_ENTRY);
    kal_uint8 code1 = 255;
    kal_uint8 code2 = 255;
    kal_bool is_MOcall;
    l4c_call_entry_struct call_info;
    kal_uint8 string_length;
    kal_uint8 buffer[20];
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    l4ccsm_cc_get_call_info(call_id, &call_info, NULL);

    if ((rmmi_ptr->report_mode.ss_mo == RMMI_DISABLE_REPORT) && (rmmi_ptr->report_mode.ss_mt == RMMI_DISABLE_REPORT))
    {
        return;
    }

    if (call_info.call_orig == CLCC_MO_CALL)
    {
        is_MOcall = KAL_TRUE;
    }
    else
    {
        is_MOcall = KAL_FALSE;
    }

    if (is_MOcall == KAL_TRUE)
    {
        code1 = CSSI_CUG_CALL;  // 4 
    }
    else
    {
        code2 = CSSU_CUG_CALL;  // 1
    }

    /* unsolicited code: +CSSI: <code1> */
    if ((code1 != 255) && (rmmi_ptr->report_mode.ss_mo == RMMI_ENABLE_REPORT))
    {
        rmmi_ptr->arg_list[0] = (void*)&code1;
        rmmi_ptr->arg_list[1] = (void*)&index;
        string_length = (kal_uint8)rmmi_fast_string_print(buffer, (kal_uint8*) "+CSSI: %d, %d", rmmi_ptr->arg_list, 2);
        rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
    }

    /* unsolicited code: +CSSU: <code1> */
    if ((code2 != 255) && (rmmi_ptr->report_mode.ss_mt == RMMI_ENABLE_REPORT))
    {
        rmmi_ptr->arg_list[0] = (void*)&code2;
        rmmi_ptr->arg_list[1] = (void*)&index;
        string_length = (kal_uint8)rmmi_fast_string_print(buffer, (kal_uint8*) "+CSSU: %d, %d", rmmi_ptr->arg_list, 2);
        rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
    }
    return;
#endif /* !defined(__SLIM_AT__) */ 
}


/*****************************************************************************
 * FUNCTION
 *  l4c_cc_notify_ss_ect_rind
 * DESCRIPTION
 *  This is l4c_cc_notify_ss_ect_lind function of L4C module.
 *  construct +CSSI, +CSSU unsolicited result code for RMMI for ECT
 * PARAMETERS
 *  call_id         [IN]        
 *  present         [IN]        
 *  addr            [?]         
 *  sub_addr        [?]         
 *  type            [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_cc_notify_ss_ect_rind(
        kal_uint8 call_id,
        kal_bool present,
        l4c_number_struct *addr,
        l4c_sub_addr_struct *sub_addr,
        kal_uint8 type)
{
#if !defined(__SLIM_AT__)
    kal_uint8 code2;
    kal_uint8 string_length;
    kal_uint8 buffer[MAX_CC_ADDR_LEN + 20];
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    //kal_brief_trace(TRACE_FUNC, FUNC_L4C_CC_NOTIFY_SS_ECT_RIND_ENTRY);

    if (rmmi_ptr->report_mode.ss_mt == RMMI_DISABLE_REPORT)
    {
        return;
    }

    switch (type)
    {
        case CSMCC_NOTIFY_ECT_ACTIVE:
        {
            code2 = CSSU_ECT_ACTIVE;    //rmmi_cssu_enum: 8
            break;
        }
        case CSMCC_NOTIFY_ECT_ALERTING:
        {
            code2 = CSSU_ECT_ALERTING;  //rmmi_cssu_enum : 7
            break;
        }
        default:
            code2 = 255;
    }
    if (code2 == 255)
    {
        return;
    }

    if (present == KAL_TRUE)    //address is present
    {
        rmmi_ptr->arg_list[0] = (void*)&code2;
        rmmi_ptr->arg_list[1] = (void*)addr->number;
        rmmi_ptr->arg_list[2] = (void*)&(addr->type);
        string_length = (kal_uint8)rmmi_fast_string_print(buffer, (kal_uint8*) "+CSSU: %d, , %s, %d", rmmi_ptr->arg_list, 3);
        rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
    }
    else
    {
        rmmi_ptr->arg_list[0] = (void*)&code2;
        string_length = (kal_uint8)rmmi_fast_string_print(buffer, (kal_uint8*) "+CSSU: %d", rmmi_ptr->arg_list, 1);
        rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
    }
    return;
#endif /* !defined(__SLIM_AT__) */ 
}


/*****************************************************************************
 * FUNCTION
 *  l4c_cc_cpi_rind
 * DESCRIPTION
 *  This is l4c_cc_cpi_rind function of L4C module.
 *  construct +ECPI unsolicited result code for RMMI
 *  mtk00714 add 20041210 for +ECPI
 * PARAMETERS
 *  call_info       [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_cc_cpi_rind(l4ccsm_cc_cpi_ind_struct *call_info)
{
    kal_uint8 string_length;
    kal_uint8 buffer[MAX_UART_LENGTH];
    kal_uint8 type;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    if (rmmi_ptr->report_mode.ecpi == 0)    /* disable */
    {
        return;
    }

    /* msg_type=DISCONNECT_MSG or ALL_CALLS_DISC_MSG */
    if(call_info->msg_type == CSMCC_DISCONNECT_MSG || call_info->msg_type == CSMCC_ALL_CALLS_DISC_MSG)
    {
        rmmi_ptr->arg_list[0] = (void*)&call_info->call_entry.call_id;
        rmmi_ptr->arg_list[1] = (void*)&call_info->msg_type;
        rmmi_ptr->arg_list[2] = (void*)&call_info->is_ibt;
        rmmi_ptr->arg_list[3] = (void*)&call_info->is_tch;
    #if defined(__CPI_SUPPORT__) 
        rmmi_ptr->arg_list[4] = (void*)&call_info->disc_cause;
    #endif 
        string_length = (kal_uint8)rmmi_fast_string_print(buffer,
    #if defined(__CPI_SUPPORT__) 
                                               (kal_uint8*) "+ECPI: %d,%d,%d,%d,,,\"\",,\"\",%u",
    #else 
                                               (kal_uint8*) "+ECPI: %d,%d,%d,%d",
    #endif 
                                               rmmi_ptr->arg_list, 4);
    }
    else
    {
        l4c_number_struct addr;

        rmmi_ptr->arg_list[0] = (void*)&call_info->call_entry.call_id;
        rmmi_ptr->arg_list[1] = (void*)&call_info->msg_type;
        rmmi_ptr->arg_list[2] = (void*)&call_info->is_ibt;
        rmmi_ptr->arg_list[3] = (void*)&call_info->is_tch;
        rmmi_ptr->arg_list[4] = (void*)&call_info->call_entry.call_orig;
        rmmi_ptr->arg_list[5] = (void*)&call_info->call_entry.call_mode;

        if (call_info->numberP)
        {
            addr.type = call_info->number.addr_bcd[0];
            addr.length = convert_to_digit(&call_info->number.addr_bcd[1], addr.number);

            if (addr.type == 0x11)
            {
                type = 0x91;    //international +...
            }
            else if (addr.type == 0x01)
            {
                type = 0x81;    //national
            }
            else
            {
                type = addr.type;
            }

            rmmi_ptr->arg_list[6] = (void*)addr.number;
            rmmi_ptr->arg_list[7] = (void*)&type;

            string_length = (kal_uint8)rmmi_fast_string_print(buffer,
        #if defined(__CPI_SUPPORT__) 
                                                   (kal_uint8*) "+ECPI: %d,%d,%d,%d,%d,%d,\"%s\",%d,\"\"",
        #else 
                                                   (kal_uint8*) "+ECPI: %d,%d,%d,%d,%d,%d,\"%s\",%d",
        #endif 
                                                   rmmi_ptr->arg_list, 8);
        }
        else
        {
            //kal_sprintf((kal_char*)addr.number, "number not present");
            //addr.number ="number not present"; 
            //RMMI_PTR->arg_list[6] = (void *)addr.number;
            string_length = (kal_uint8)rmmi_fast_string_print(buffer,
        #if defined(__CPI_SUPPORT__) 
                                                   (kal_uint8*) "+ECPI: %d,%d,%d,%d,%d,%d,\"\",,\"\"",
        #else 
                                                   (kal_uint8*) "+ECPI: %d,%d,%d,%d,%d,%d",
        #endif 
                                                   rmmi_ptr->arg_list, 6);
        }
    }

    rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
    return;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_cc_update_call_state_rind
 * DESCRIPTION
 *  Origin: CSMCC will notify ACTIVE/HELD status of each call for WM7 RIL to update the call table,
 *  this URC is not necessary, but if we have this, RIL can reduce modification effort, otherwise, RIL can
 *  know each call status when sending AT command(AT+CHLD=x) to modem
 *  Now: we use this to update call state 
 * PARAMETERS
 *  msg_type       [IN]     
 *  call_id        [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_cc_update_call_state_rind(kal_uint8 msg_type,kal_uint8 call_id)
{
    kal_uint16 string_length;
    kal_uint8 buffer[MAX_UART_LENGTH];
    kal_uint8 msg_bit = 0;	
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    msg_bit = msg_type - CSMCC_ALL_CALLS_DISC_MSG + 7;	

    if(rmmi_ptr->report_mode.ecpi & (INFO_REPORT_MASK << msg_bit))			
    {
        rmmi_ptr->arg_list[0] = (void*)&call_id;
        rmmi_ptr->arg_list[1] = (void*)&msg_type;

        string_length = rmmi_fast_string_print(buffer, (kal_uint8*) (kal_uint8*) "+ECPI: %d,%d,,,,,\"\",,\"\"", rmmi_ptr->arg_list, 2);

        rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
    }
    return;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_ss_ussr_rind
 * DESCRIPTION
 *  This is l4c_ss_ussr_rind function of L4C module.
 *  construct +CUSD unsolicited result code for RMMI when recieve
 *  USSD Request from the network
 * PARAMETERS
 *  dcs                     [IN]        Data coding scheme of the incoming USSD string
 *  ussd_string             [IN]        The incoming USSD string
 *  ussd_string_length      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_ss_ussr_rind(kal_uint8 dcs, kal_uint8 *ussd_string, kal_uint8 ussd_string_length)
{
#if !defined(__SLIM_AT__)
    kal_uint8 mode = 1;
    kal_uint16 string_length;
    kal_uint8 *buffer;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    kal_brief_trace(TRACE_FUNC, FUNC_L4C_SS_USSR_RIND_ENTRY);
    ASSERT(ussd_string != NULL);

    buffer = get_ctrl_buffer(MAX_DIGITS_USSD*4+30); 
    kal_mem_set(buffer, 0x00, MAX_DIGITS_USSD*4+30);     

    if (rmmi_ptr->report_mode.ussd == RMMI_ENABLE_REPORT)
    {
        kal_uint8 rsp_string[MAX_DIGITS_USSD * 4 + 1];
    #if !defined(__SP_RIL_SUPPORT__)
        kal_uint8 lang_type;
        smsal_dcs_enum alphabet_type;
        smsal_msg_class_enum mclass;
        kal_bool is_compress;
        kal_bool is_reserved;

        //mtk00924_20051230: decode CB DCS. CISS gives DCS according to spec23.038
        // but AT uses smsal defined enum, so AT has to transfer DCS to what smsal used
        smsal_decode_cbsdcs(dcs, &lang_type, &alphabet_type, &mclass, &is_compress, &is_reserved);

        /* 23.038 : if dcs is 8-bit data coding scheme or UCS2 */
        check_dcs_toCscs((kal_uint8) alphabet_type, ussd_string_length, ussd_string, rsp_string);
    #else
        //mtk02508_090220: copy to RIL the ussd_string receiving from NW, it will decode according to the dcs
        print_hex_value_ext(ussd_string, rsp_string, ussd_string_length);
    #endif /*__SP_RIL_SUPPORT__*/

        rmmi_ptr->arg_list[0] = (void*)&mode;
        rmmi_ptr->arg_list[1] = (void*)rsp_string;
        rmmi_ptr->arg_list[2] = (void*)&dcs;
        string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CUSD: %d,\"%s\", %d",    //vito remove space
                                               rmmi_ptr->arg_list, 3);
        rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
    }

    free_ctrl_buffer(buffer);
#endif /* !defined(__SLIM_AT__) */ 
}


/*****************************************************************************
 * FUNCTION
 *  l4c_ss_ussn_rind
 * DESCRIPTION
 *  This is l4c_ss_ussn_rind function of L4C module.
 *  construct +CUSD unsolicited result code for RMMI when receive
 *  USSD Notify from the network
 * PARAMETERS
 *  dcs                 [IN]        Data coding scheme of the incoming USSD string
 *  ussd_string         [IN]        The incoming USSD string
 *  ussd_string_length  [IN]
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_ss_ussn_rind(kal_uint8 dcs, kal_uint8 *ussd_string, kal_uint8 ussd_string_length)
{
#if !defined(__SLIM_AT__)
    kal_uint8 mode = 0;
    kal_uint16 string_length;
    kal_uint8 *buffer;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    kal_brief_trace(TRACE_FUNC, FUNC_L4C_SS_USSN_RIND_ENTRY);
    ASSERT(ussd_string != NULL);
   
    buffer = get_ctrl_buffer(MAX_DIGITS_USSD*4+30); 
    kal_mem_set(buffer, 0x00, MAX_DIGITS_USSD*4+30);   
      
    if (rmmi_ptr->report_mode.ussd == RMMI_ENABLE_REPORT)
    {
        kal_uint8 rsp_string[MAX_DIGITS_USSD * 4 + 1];
    #if !defined(__SP_RIL_SUPPORT__)
        kal_uint8 lang_type;
        smsal_dcs_enum alphabet_type;
        smsal_msg_class_enum mclass;
        kal_bool is_compress;
        kal_bool is_reserved;

        //mtk01616_080217: decode CB DCS. CISS gives DCS according to spec23.038
        // but AT uses smsal defined enum, so AT has to transfer DCS to what smsal used
        smsal_decode_cbsdcs(dcs, &lang_type, &alphabet_type, &mclass, &is_compress, &is_reserved);

        /* 23.038 : if dcs is 8-bit data coding scheme or UCS2 */
        check_dcs_toCscs(alphabet_type, ussd_string_length, ussd_string, rsp_string);
    #else
        //mtk02508_090220: copy to RIL the ussd_string receiving from NW, it will decode according to the dcs
        print_hex_value_ext(ussd_string, rsp_string, ussd_string_length);
    #endif /* __SP_RIL_SUPPORT__ */

        rmmi_ptr->arg_list[0] = (void*)&mode;
        rmmi_ptr->arg_list[1] = (void*)rsp_string;
        rmmi_ptr->arg_list[2] = (void*)&dcs;

        string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CUSD: %d,\"%s\", %d",    //vito remve space
                                               rmmi_ptr->arg_list, 3);

        rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
    }
    
    free_ctrl_buffer(buffer);  
#endif /* !defined(__SLIM_AT__) */ 
}


#if defined(__VT_TRANSPORT_SUPPORT__)
/*****************************************************************************
 * FUNCTION
 *  l4c_cc_video_call_status_rind
 * DESCRIPTION
 *  This is l4c_cc_video_call_status_rind function of L4C module.
 *  
 * PARAMETERS
 *  
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_cc_video_call_status_rind(kal_uint8 call_id, kal_uint8 action, kal_bool result)
{
    kal_uint16 string_length;
    kal_uint8 buffer[MAX_UART_LENGTH];

    kal_sprintf((kal_char*) buffer, "+EVTSTATUS: %d", action); //csmcc_video_call_action_enum
    string_length = (kal_uint16)strlen((char*)buffer);
    rmmi_write_to_uart(buffer, string_length, KAL_TRUE);
}
#endif /* __VT_TRANSPORT_SUPPORT__ */


#if defined(__AUTO_CALL_REJECTION__)
/*****************************************************************************
 * FUNCTION
 *  l4c_cc_call_present_rind
 * DESCRIPTION
 *  This is l4c_cc_call_present_rind function of L4C module.
 *  
 * PARAMETERS
 *  
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_cc_call_present_rind(kal_uint8 call_id, l4c_number_struct *addr, kal_uint8 seq_no)
{
    kal_uint16 string_length;
    kal_uint8 buffer[MAX_UART_LENGTH];
    kal_uint8 call_mode = csmcc_get_clcc_mode(call_id);

    kal_sprintf((kal_char*) buffer, 
                "+EAIC: %d, \"%s\", %d, %d, %d", call_id, addr->number, addr->type, call_mode, seq_no);
    string_length = (kal_uint16)strlen((char*)buffer);
    rmmi_write_to_uart(buffer, string_length, KAL_TRUE);
}
#endif /* __AUTO_CALL_REJECTION__ */


#ifdef __OP01__
/*****************************************************************************
 * FUNCTION
 *  l4c_cc_dsci_rind
 * DESCRIPTION
 *  This is l4c_cc_dsci_rind function of L4C module.
 *  construct ^DSCI unsolicited result code for RMMI
 *  
 * PARAMETERS
 *  call_id
 *  call_orig     [IN]
 *  call_state    [IN]
 *  call_type     [IN]
 *  mpty          [IN]
 *  number        [IN]
 *  disc_cause    [IN]
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_cc_dsci_rind(kal_uint8 call_id, 
                      clcc_dir_enum call_orig,
                      rmmi_dsci_call_state_enum call_state,
                      csmcc_call_type_enum call_type,
                      clcc_mpty_enum mpty,
                      l4_addr_bcd_struct number,
                      kal_uint16 disc_cause)
{
    kal_uint8 string_length;
    kal_uint8 buffer[MAX_UART_LENGTH];
    rmmi_dsci_call_type_enum dsci_call_type;
    l4c_number_struct addr;
    kal_uint8 data_call_info;
    rmmi_dsci_data_type_enum bs_type = RMMI_DSCI_UNKNOWN_DATA_TYPE;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    //kal_trace(TRACE_FUNC, FUNC_RMMI_CLCC_READ_RSP_FMTTR_ENTRY);

    kal_mem_set(&addr, 0, sizeof(l4c_number_struct));
    
    if ((call_type == CSMCC_VOICE_CALL) || (call_type == CSMCC_AUX_VOICE_CALL))
    {
        dsci_call_type = RMMI_DSCI_TYPE_VOICE;
    }
    else
    {
        l4ccsm_cc_get_data_call_info(&data_call_info);
        switch (data_call_info)
        {
            case L4C_ASYNC_T:
                bs_type = RMMI_DSCI_ASYNC;
                break;
            case L4C_SYNC_T:
                bs_type = RMMI_DSCI_SYNC;
                break;
            case L4C_ASYNC_NT:
                bs_type = RMMI_DSCI_REL_ASYNC;
                break;
            case L4C_SYNC_NT:
                bs_type = RMMI_DSCI_REL_SYNC;
                break;
        }
        dsci_call_type = RMMI_DSCI_TYPE_DATA;
    } 

    if (number.addr_length != 0)
    {
        addr.type = number.addr_bcd[0];
        addr.length = convert_to_digit((kal_uint8*) & (number.addr_bcd[1]), (kal_uint8*) addr.number);

        if ((addr.type & 0x70) == 0x10)
        {
            addr.type = 145; //international number
        }
        else
        {
            addr.type = 129; //national number      
        }
    }

    rmmi_ptr->arg_list[0] = (void*)&call_id;
    rmmi_ptr->arg_list[1] = (void*)&call_orig;
    rmmi_ptr->arg_list[2] = (void*)&call_state;
    rmmi_ptr->arg_list[3] = (void*)&dsci_call_type;
    rmmi_ptr->arg_list[4] = (void*)&mpty;
    rmmi_ptr->arg_list[5] = (void*)addr.number;
    rmmi_ptr->arg_list[6] = (void*)&(addr.type);
    
    string_length = (kal_uint8)rmmi_fast_string_print(buffer, 
                        (kal_uint8*) "^DSCI: %d,%d,%d,%d,%d,\"%s\",%d,", 
                        rmmi_ptr->arg_list, 
                        7);
    
    if (dsci_call_type == RMMI_DSCI_TYPE_DATA)
    {
        kal_sprintf((char*)(buffer + string_length), "%d", bs_type);
        string_length = (kal_uint8)strlen((char*)buffer);
    }

    if (call_state == RMMI_DSCI_STATE_CALL_END)
    {
        kal_sprintf((char*)(buffer + string_length), ",%d", disc_cause);
        string_length = (kal_uint8)strlen((char*)buffer);
    }
    
    rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);

    return;
}

/*****************************************************************************
 * FUNCTION
 *  l4c_cc_call_state_rind
 * DESCRIPTION
 *  This is l4c_cc_call_state_rind function of L4C module.
 *  construct ^ORIG, ^CONF, ^CONN, and ^CEND unsolicited result code for RMMI
 *  
 * PARAMETERS
 *  state       [IN] mo call state
 *  call_id     [IN]
 *  reserve     [IN] call duration
 *  end_status  [IN] call end reason, used in ^CEND
 *  cc_cause    [IN] refers to cause in TS 24.008 section 10.5.4.11
 *  call_type   [IN] call type
 *  is_ecc      [IN] to figure out ECC
 *
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_cc_call_state_rind(rmmi_mo_state_enum state,
                          kal_uint8 call_id,
                          kal_uint8 reserve,
                          rmmi_cm_call_end_status_enum end_status,
                          kal_bool cause_present,
                          ps_cause_enum cc_cause,
                          csmcc_call_type_enum call_type,
                          kal_bool is_ecc)
{
    kal_uint8 string_length;
    kal_uint8 buffer[MAX_UART_LENGTH];
    kal_uint8 mo_state[5]; //for temporarily store state string
    rmmi_mo_call_type_enum mo_call_type;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    switch (state)
    {
        case RMMI_MO_STATE_ORIG:
        {
            kal_sprintf((char*)mo_state, "%s", "ORIG");
            break;
        }
        case RMMI_MO_STATE_CONF:
        {
            kal_sprintf((char*)mo_state, "%s", "CONF");
            break;
        }
        case RMMI_MO_STATE_CONN:
        {
            kal_sprintf((char*)mo_state, "%s", "CONN");
            break;
        }
        case RMMI_MO_STATE_CEND:
        {
            kal_sprintf((char*)mo_state, "%s", "CEND");
            break;
        }
        default: 
            break; 
    }
    
    switch (call_type)
    {
        case CSMCC_VOICE_CALL:
        case CSMCC_AUX_VOICE_CALL:
        {
            mo_call_type = (is_ecc == KAL_TRUE)? RMMI_MO_CALL_TYPE_EMERGENCY : RMMI_MO_CALL_TYPE_VOICE;
            break;
        }
        case CSMCC_DATA_CALL:
        case CSMCC_FAX_CALL:
        case CSMCC_CSD_CALL:
        case CSMCC_SAT_DATA_CALL:
        case CSMCC_VIDEO_CALL:
        {
            mo_call_type = RMMI_MO_CALL_TYPE_CS_DATA;
            break;
        }
        default:
            mo_call_type = RMMI_MO_CALL_TYPE_UNKNOWN;
            break;
    }

    if (state == RMMI_MO_STATE_CEND)
    {
        rmmi_ptr->arg_list[0] = (void*)mo_state;
        rmmi_ptr->arg_list[1] = (void*)&call_id;
        rmmi_ptr->arg_list[2] = (void*)&reserve;
        rmmi_ptr->arg_list[3] = (void*)&end_status;
        if (cause_present == KAL_TRUE)
        {
            rmmi_ptr->arg_list[4] = (void*)&cc_cause;

            string_length = (kal_uint8)rmmi_fast_string_print(buffer, 
                            (kal_uint8*) "^%s: %d, %d, %d, %d", 
                            rmmi_ptr->arg_list, 
                            5);
        }
        else
        {
            string_length = (kal_uint8)rmmi_fast_string_print(buffer, 
                            (kal_uint8*) "^%s: %d, %d, %d,", 
                            rmmi_ptr->arg_list, 
                            4);
        }
    }
    else
    {
        rmmi_ptr->arg_list[0] = (void*)mo_state;
        rmmi_ptr->arg_list[1] = (void*)&call_id;
        
        string_length = (kal_uint8)rmmi_fast_string_print(buffer, 
                        (kal_uint8*) "^%s: %d", 
                        rmmi_ptr->arg_list, 
                        2);
    }

    if (mo_call_type != RMMI_MO_CALL_TYPE_UNKNOWN)
    {
        kal_sprintf((char*)(buffer + string_length), ", %d", mo_call_type);
        string_length = (kal_uint8)strlen((char*)buffer);
    }
    
    rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);

    return;
}
#endif /* __OP01__ */

/*****************************************************************************
 * FUNCTION
 *  l4c_ps_activate_rind
 * DESCRIPTION
 * +EVDLCALL: <status>,<ti>,<is_mt_call>,<is_far_end>,<cause_len>,<cause>
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_sat_evdl_call_rind(kal_uint8 ti, kal_uint8 status, kal_bool is_mt_call, kal_bool is_far_end, kal_uint8 *cause, kal_uint8 cause_len)
{
    if(status == SAT_EVDL_CALL_CONNECT)
    {   /* call connect */
        /* +EVDLCALL: <status>,<ti>,<is_mt_call>,, */
        kal_uint8 at_buffer[32]; 

        kal_sprintf(at_buffer, "+EVDLCALL:0,%d,%d,0,0,0", ti, is_mt_call);
        rmmi_write_to_uart((kal_uint8*) at_buffer, strlen(at_buffer), KAL_TRUE);
    }
    else if(status == SAT_EVDL_CALL_DISCONNECT) 
    {   /* call disconnect */
        /* +EVDLCALL: <status>,<ti>,,<is_far_end>,<cause>,<cause_len> */
        kal_uint8 at_buffer[128];
        kal_uint8 hexchars[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
        kal_uint8 cause_buf[64] = {0};
        kal_uint8 buf_idx = 0;
        kal_uint8 cause_idx = 0;


        if(cause_len > 0 && cause_len <= 30)
        {
            for(;cause_idx < cause_len;cause_idx++)
            {
                cause_buf[buf_idx] = hexchars[(cause[cause_idx]>>4) & 0x0F];
                buf_idx++;

                cause_buf[buf_idx] = hexchars[cause[cause_idx] & 0x0F];
                buf_idx++;
            }

            kal_sprintf(at_buffer, "+EVDLCALL:1,%d,0,%d,%d,%s",ti, is_far_end, buf_idx, cause_buf);
        }
        else
        {
            kal_sprintf(at_buffer, "+EVDLCALL:1,%d,0,%d,%d,0",ti, is_far_end, cause_len);
        }

        rmmi_write_to_uart((kal_uint8*) at_buffer, strlen(at_buffer), KAL_TRUE);
    }
    else
    {
        /* error */
    }
}

#endif /* __MOD_CSM__ */ 

#ifdef __MOD_TCM__


/*****************************************************************************
 * FUNCTION
 *  l4c_ps_activate_rind
 * DESCRIPTION
 *  This is l4c_ps_activate_rind function of L4C module.
 *  construct RING unsolicited result code for RMMI when receive
 *  GPRS activate ind from the network
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_ps_activate_rind()
{
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    kal_brief_trace(TRACE_FUNC, FUNC_L4C_PS_ACTIVATE_RIND_ENTRY);

#if defined(__GEMINI__) && defined(__DISABLE_SIM2_AT_SUPPORT__)//mtk01616_100511: prevent SIM2 event to update RMMI context
    if(l4c_current_mod_id == MOD_L4C_2)
        return;		
#endif
    rmmi_ptr->cring_type = RMMI_CRING_GPRS;
    rmmi_result_code_fmttr(RMMI_RCODE_RING, L4C_NO_CAUSE);
}
#endif /* __MOD_TCM__ */ 

#ifdef __MOD_RAC__


/*****************************************************************************
 * FUNCTION
 *  l4c_nw_reg_state_rind
 * DESCRIPTION
 *  This is l4c_nw_reg_state_rind function of L4C module.
 *  construct +CREG/+CGREG unsolicited result code for RMMI when
 *  network registration status change
 * PARAMETERS
 *  lac                 [IN]        Current location area code
 *  cell_id             [IN]        Current cell id
 *  status              [IN]        
 *  gprs_state          [IN]        GPRS registration status
 *  rat                 [IN]        RAT
 *  cell_data_speed_support [IN]    data speed of current cell
 *  max_data_bearer_capa    [IN]
 *  domain              [IN]        CS or PS domain indication
 *  
 * RETURNS
 *  void
 *****************************************************************************/
#ifdef __REPORT_RAC__ 
void l4c_nw_reg_state_rind (kal_uint8 *lac,
                            kal_uint8 rac,
                            kal_uint32 cell_id,
                            kal_uint8 status,
                            kal_uint8 gprs_state,
                            kal_uint8 rat,
                            kal_uint8 cell_data_speed_support,  //l4c_data_speed_support_enum
                            kal_uint8 max_data_bearer_capa,     //l4c_data_bearer_capablility_enum
                            domain_id_enum domain)
#else
void l4c_nw_reg_state_rind (kal_uint8 *lac,
                            kal_uint32 cell_id,
                            kal_uint8 status,
                            kal_uint8 gprs_state,
                            kal_uint8 rat,
                            kal_uint8 cell_data_speed_support,  //l4c_data_speed_support_enum
                            kal_uint8 max_data_bearer_capa,     //l4c_data_bearer_capablility_enum
                            domain_id_enum domain)

#endif
{
    kal_uint16 string_length = 0;
    kal_uint8 buffer[MAX_UART_LENGTH];
    kal_uint16 lac_value = 0;
    kal_uint8 service;  //for update indicators in rmmi_cntxt_g
    kal_uint8 roam;     //for update indicators in rmmi_cntxt_g
    kal_uint8 act = 0; //GSM
    kal_uint16 rnc;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    rmmi_reg_state_enum creg_state;
#ifdef __MOD_TCM__
    rmmi_reg_state_enum cgreg_state;
    l4c_data_bearer_capablility_enum data_bearer_capablility;
#endif

    kal_brief_trace(TRACE_FUNC, FUNC_L4C_NW_REG_STATE_RIND_ENTRY);

    act = rmmi_current_access_technology(rat, cell_data_speed_support, max_data_bearer_capa); //hspa_mmi_h2

#if defined(__MOD_TCM__) //&& !defined(__MMI_FMI__)
    // print if status changes
    //if (KAL_TRUE == rmmi_ptr->report_mode.psbearer_indicate)
    {
        // temp used
        data_bearer_capablility = max_data_bearer_capa;

        if(L4C_NONE_ACTIVATE==max_data_bearer_capa && KAL_TRUE==check_pdp_context_exist_func())
        {
            // 2G (GPRS/EDGE) has no capability value (always L4C_NONE_ACTIVATE)
            // so align cell info (l4c_data_speed_support_enum 1 or 2)
            if( (L4C_EDGE_SUPPORT==cell_data_speed_support || L4C_GPRS_SUPPORT==cell_data_speed_support) )
            {
                data_bearer_capablility = ((L4C_EDGE_SUPPORT==cell_data_speed_support) ? L4C_EDGE_CAPABILITY : L4C_GPRS_CAPABILITY );
            }
            // 3G temp status (2G inter rat to 3G, no capability)
            else if( L4C_UMTS_SUPPORT<=cell_data_speed_support )
            {
                data_bearer_capablility = L4C_UMTS_CAPABILITY;
            }
        }
        
//#if defined(__MTK_TARGET__) && defined(DRV_GPIO_FOR_LED_AND_15_SEGMENT)
        l4c_set_led_7_segment_debug((l4c_data_speed_support_enum)cell_data_speed_support, data_bearer_capablility);
//#endif
    }

    if (KAL_TRUE == rmmi_ptr->report_mode.psbearer_indicate)
    {
        kal_sprintf((kal_char*) buffer, "+PSBEARER: %d, %d", cell_data_speed_support, data_bearer_capablility);
        string_length = (kal_uint16)strlen((char*)buffer);
        if (string_length > 0)
        {
            rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
            string_length = 0;
        }
    }
#endif

    /* translate state from RAC to what ATCI want */
    creg_state = rmmi_convert_reg_state_to_atci(status);
    cgreg_state = rmmi_convert_reg_state_to_atci(gprs_state);

    if (rat == RAT_UMTS)
    {
        rnc = (kal_uint16)(cell_id>>16);
    }
    else
    {
        rnc = 0x00;
    }

    /* convert lac to kal_uint16 for later use */
    if (lac != NULL)
    {
        lac_value = lac[0];
        lac_value = lac_value << 8 | lac[1];
    }

#if !defined(__ULC_AT__)
    /* print +CREG unsolicited result code */
    if ((domain == CS_DOMAIN) || (domain == CS_PS_DOMAIN))
    {
        if (rmmi_ptr->report_mode.cs_reg == RMMI_ENABLE_NW_REG_REPORT)
        {
            /* only print if status changes */
            if (creg_state != rmmi_ptr->cs_register_status.state)
            {
                kal_sprintf((kal_char*) buffer, "+CREG: %d", creg_state);
                string_length = (kal_uint16)strlen((char*)buffer);
            }
        }
        else if (rmmi_ptr->report_mode.cs_reg == RMMI_ENABLE_LOC_REPORT)
        {
            if (lac != NULL)
            {
                /* only print if cell_id changes */
                if ((cell_id != rmmi_ptr->cs_register_status.cell_id) 
                    || (creg_state != rmmi_ptr->cs_register_status.state)
                    #ifdef __ORANGE_H_PLUS__
                    || (act != rmmi_ptr->register_act)
                    #else
                    || (act != rmmi_ptr->cs_register_status.act) //hspa_mmi_h2
                    #endif
                    )
                {
                #if defined(__SP_RIL_SUPPORT__)
                    kal_sprintf((kal_char*)buffer,
                        "+CREG: %d, \"%04X\", \"%04X%04X\", %d, %d", 
                        creg_state, lac_value, rnc, (kal_uint16)cell_id, act, rmmi_ptr->cs_register_status.cause);
                #else
                    kal_sprintf((kal_char*)buffer,
                        "+CREG: %d, \"%04X\", \"%04X%04X\", %d", 
                        creg_state, lac_value, rnc, (kal_uint16)cell_id, act);
                #endif

                    string_length = (kal_uint16)strlen((char*)buffer);
                }
            }
            else
            {
                /* only print if status changes */
                if (creg_state != rmmi_ptr->cs_register_status.state)
                {
                    kal_sprintf((kal_char*) buffer, "+CREG: %d", creg_state);
                    string_length = (kal_uint16)strlen((char*)buffer);
                }
            }
        }
        if (string_length > 0)
        {
            rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
        }
    }

#ifdef __MOD_TCM__
    if ((domain == PS_DOMAIN) || (domain == CS_PS_DOMAIN))
    {
        string_length = 0;
        /* print +CGREG unsolicited result code */
        if (rmmi_ptr->report_mode.ps_reg == RMMI_ENABLE_NW_REG_REPORT)
        {
            /* only print if status changes */
            if (cgreg_state != rmmi_ptr->ps_register_status.state)
            {
                kal_sprintf((kal_char*) buffer, "+CGREG: %d", cgreg_state);
                string_length = (kal_uint16)strlen((char*)buffer);
            }
        }
        else if (rmmi_ptr->report_mode.ps_reg == RMMI_ENABLE_LOC_REPORT)
        {
            if (lac != NULL)
            {
                /* only print if cell_id changes */
                if ((cell_id != rmmi_ptr->ps_register_status.cell_id) 
                    || (cgreg_state != rmmi_ptr->ps_register_status.state)
                    #ifdef __ORANGE_H_PLUS__
                    || (act != rmmi_ptr->register_act)
                    #else
                    || (act != rmmi_ptr->ps_register_status.act) //hspa_mmi_h2
                    #endif
                    )
                {
                #ifdef __REPORT_RAC__
                    kal_sprintf((kal_char*)buffer,"+CGREG: %d, \"%04X\", \"%04X%04X\", %d, %d", cgreg_state, lac_value, rnc, (kal_uint16)cell_id, act, rac);
                #else
                    kal_sprintf((kal_char*)buffer,"+CGREG: %d, \"%04X\", \"%04X%04X\", %d", cgreg_state, lac_value, rnc, (kal_uint16)cell_id, act);
                #endif
                    string_length = (kal_uint16)strlen((char*)buffer);
                }
            }
            else
            {
                /* only print if status changes */
                if (cgreg_state != rmmi_ptr->ps_register_status.state)
                {
                    kal_sprintf((kal_char*) buffer, "+CGREG: %d", cgreg_state);
                    string_length = (kal_uint16)strlen((char*)buffer);
                }
            }
        }
        if (string_length > 0)
        {
            rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
        }
    }
#endif /* __MOD_TCM__ */
#endif /* !defined(__ULC_AT__) */

#if defined(__OP01__)
    string_length = 0;
    /* only print if status changes */
    if (creg_state != rmmi_ptr->cs_register_status.state 
#ifdef __MOD_TCM__
        || cgreg_state != rmmi_ptr->ps_register_status.state
#endif
        )
    {
        int sys_mode=0, sys_submode=0;

        if (creg_state == 1 || creg_state == 5)
        {
            // sys_mode
            switch(act)
            {
                case 0:
                case 1:
                case 3:
                    sys_mode = 3;
                    break;
                case 2:
                case 4:
                case 5:
                case 6:
                #ifdef __OP01_3G__
                    sys_mode = 15;
                #else
                    sys_mode = 5;
                #endif
                    break;
                default:
                    ASSERT(0);
                    break;
            }

            // sys_submode
            switch(act)
            {
                case 0:
                case 1:
                    sys_submode = 2;
                    break;
                case 3:
                    sys_submode = 3;
                    break;
                case 2:
                    sys_submode = 4;
                    break;
            #if defined(__OP01_3G__)
                case 4:
                case 5:
                case 6:
                    sys_submode = 8;
                    break;
            #else
                case 4:
                    sys_submode = 5;
                    break;
                case 5:
                    sys_submode = 6;
                    break;
                case 6:
                    sys_submode = 7;
                    break;
            #endif
                default:
                    ASSERT(0);
                    break;
            }            
        }
        else
        {
            sys_mode = 0;
            sys_submode = 0;        
        }

        kal_sprintf((kal_char*) buffer, "^MODE:%d,%d", sys_mode, sys_submode);
        string_length = (kal_uint16)strlen((char*)buffer);
    }

    if (string_length > 0)
    {
        rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
    }
#endif

    // update RMMI_context
    /* here is to update indicators in rmmi_cntxt_g, 
       as well as for +CMER unsolicited result code */
    if ((creg_state == 1) || (creg_state == 5))
    {
        service = 1;
    }
    else
    {
        service = 0;
    }

    if (creg_state == 5)
    {
        roam = 1;
    }
    else
    {
        roam = 0;
    }

    if ((domain == CS_DOMAIN) || (domain == CS_PS_DOMAIN))
    {
        rmmi_ptr->cs_register_status.state = creg_state;
        #ifdef __ORANGE_H_PLUS__
        rmmi_ptr->register_act = act;
        #else
        rmmi_ptr->cs_register_status.act = act; //hspa_mmi_h2
        #endif
        rmmi_ptr->cs_register_status.cell_data_speed_support = cell_data_speed_support;
        if (lac != NULL)
        {
            rmmi_ptr->cs_register_status.cell_id = cell_id;
            rmmi_ptr->cs_register_status.lac_value = lac_value;
        #ifdef __REPORT_RAC__
            rmmi_ptr->cs_register_status.rac_value = rac;
        #endif
        }
        else
        {
            rmmi_ptr->cs_register_status.cell_id = 0xffffffff;
            rmmi_ptr->cs_register_status.lac_value = 0xffff;
        #ifdef __REPORT_RAC__
            rmmi_ptr->cs_register_status.rac_value = 0xff;
        #endif
        }
    }

#ifdef __MOD_TCM__
    if ((domain == PS_DOMAIN) || (domain == CS_PS_DOMAIN))
    {
        rmmi_ptr->ps_register_status.state = cgreg_state;
        #ifdef __ORANGE_H_PLUS__
        rmmi_ptr->register_act = act;
        #else
        rmmi_ptr->ps_register_status.act = act; //hspa_mmi_h2
        #endif
        rmmi_ptr->ps_register_status.cell_data_speed_support = cell_data_speed_support;
        if (lac != NULL)
        {
            rmmi_ptr->ps_register_status.cell_id = cell_id;
            rmmi_ptr->ps_register_status.lac_value = lac_value;
        #ifdef __REPORT_RAC__
            rmmi_ptr->ps_register_status.rac_value = rac;
        #endif
        }
        else
        {
            rmmi_ptr->ps_register_status.cell_id = 0xffffffff;
            rmmi_ptr->ps_register_status.lac_value = 0xffff;
        #ifdef __REPORT_RAC__
            rmmi_ptr->ps_register_status.rac_value = 0xff;
        #endif
        }
    }
#endif

#ifdef __BT_SUPPORT__
    if (rmmi_ptr->report_mode.cmer_ind > 0)
    {
        /* send unsolicited result code */
        l4c_cc_handfree_rind(RMMI_CIND_SERVICE, service);
        l4c_cc_handfree_rind(RMMI_CIND_ROAM, roam);
    }

#else /* __BT_SUPPORT__ */ 

    if (rmmi_ptr->report_mode.cmer_ind > 0) //cmer_revise  == 2)
    {
        if (service != rmmi_ptr->indicators.service)
        {
            /* send unsolicited result code */
            kal_sprintf((kal_char*) buffer, "+CIEV: 3, %d", service);  // 3: <service> in +CIND
            rmmi_write_unsolicitedResultCode(
                (kal_uint8*) buffer,
                (kal_uint16) strlen((char*)buffer),
                KAL_TRUE,
                rmmi_ptr->report_mode.cmer_mode,
                (void*)&rmmi_ptr->CNMI_ResultCodeBuffer);
        }
        if (roam != rmmi_ptr->indicators.roam)
        {
            /* send unsolicited result code */
            kal_sprintf((kal_char*) buffer, "+CIEV: 6, %d", roam);     // 6: <roam> in +CIND
            rmmi_write_unsolicitedResultCode(
                (kal_uint8*) buffer,
                (kal_uint16) strlen((char*)buffer),
                KAL_TRUE,
                rmmi_ptr->report_mode.cmer_mode,
                (void*)&rmmi_ptr->CNMI_ResultCodeBuffer);
        }
    }

#endif /* __BT_SUPPORT__ */ 

    /* update indicators.service  */
    rmmi_ptr->indicators.service = service;
    rmmi_ptr->indicators.roam = roam;
    /* End mtk00714 20040601 */

    return;
}

/*****************************************************************************
 * FUNCTION
 *  l4c_nw_time_zone_rind
 * DESCRIPTION
 *  This is l4c_nw_time_zone_rind function of L4C module.
 *  construct +CTZV unsolicited result code for RMMI when
 *  receive time zone information from the network
 * PARAMETERS
 *  timezone        [IN]        Current timezone code
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_nw_time_zone_rind(kal_uint8 timezone,
					                kal_uint8 day_light_saving_timeP,							    
					                kal_uint8 day_light_saving_time)
{
#if !defined(__SLIM_AT__)
    kal_uint16 string_length;
    kal_uint8 buffer[MAX_UART_LENGTH];
    kal_uint8 tz_string[4];
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    kal_brief_trace(TRACE_FUNC, FUNC_L4C_NW_TIME_ZONE_RIND_ENTRY);
    if (rmmi_ptr->report_mode.timezone == RMMI_ENABLE_REPORT)
    {
        if (timezone & 0x08)
        {
            kal_sprintf((char*)&tz_string, "-%d", (timezone & 0x07)*10+(timezone >> 4));
        }
        else
        {
            kal_sprintf((char*)&tz_string, "+%d", (timezone & 0x07)*10+(timezone >> 4));
        }
     
        rmmi_ptr->arg_list[0] = (void*)tz_string;

        if (day_light_saving_timeP)
        {
            rmmi_ptr->arg_list[1] = (void*)&day_light_saving_time;
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CTZV: %s,%d", rmmi_ptr->arg_list, 2);
        }
        else
        {
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CTZV: %s", rmmi_ptr->arg_list, 1);
        }
        rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
    }
    return;
#endif /* !defined(__SLIM_AT__) */ 
}

/*****************************************************************************
 * FUNCTION
 *  l4c_nw_nitz_rind
 * DESCRIPTION
 * PARAMETERS
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_nw_nitz_rind(kal_uint8 year,
					    kal_uint8 month,
					    kal_uint8 day,
					    kal_uint8 hour,
					    kal_uint8 min,
					    kal_uint8 sec,
					    kal_uint8 timezone,
					    kal_uint8 day_light_saving_timeP,							    
					    kal_uint8 day_light_saving_time)
{
#if !defined(__SLIM_AT__)
    kal_uint16 string_length;
    kal_uint8 buffer[MAX_UART_LENGTH];
    kal_uint8 date_string[20];
    kal_uint8 tz_string[4];
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    kal_brief_trace(TRACE_FUNC, FUNC_L4C_NW_TIME_ZONE_RIND_ENTRY);

    /*  mtk02480, NITZ URC format: +CIEV: 9,"YY/MM/DD,HH:MM:SS",+4,1	*/

    if (rmmi_ptr->report_mode.timezone == RMMI_ENABLE_REPORT)
    {
	kal_sprintf((char*)&date_string[0], "%d", (year & 0x0F)); 
	kal_sprintf((char*)&date_string[1], "%d/", (year >> 4));	  
	kal_sprintf((char*)&date_string[3], "%d", (month & 0x0F)); 
	kal_sprintf((char*)&date_string[4], "%d/", (month >> 4));	 
	kal_sprintf((char*)&date_string[6], "%d", (day & 0x0F)); 
	kal_sprintf((char*)&date_string[7], "%d,", (day >> 4));	 
	kal_sprintf((char*)&date_string[9], "%d", (hour & 0x0F)); 
	kal_sprintf((char*)&date_string[10], "%d:", (hour >> 4));	 
	kal_sprintf((char*)&date_string[12], "%d", (min & 0x0F)); 
	kal_sprintf((char*)&date_string[13], "%d:", (min >> 4));	 
	kal_sprintf((char*)&date_string[15], "%d", (sec & 0x0F)); 
	kal_sprintf((char*)&date_string[16], "%d", (sec >> 4));	 

	rmmi_ptr->arg_list[0] = (void*)date_string;

	 if (timezone & 0x08)
	 {
	 	kal_sprintf((char*)&tz_string, "-%d", (timezone & 0x07)*10+(timezone >> 4));
	 }
	 else
	 {
	 	kal_sprintf((char*)&tz_string, "+%d", (timezone & 0x07)*10+(timezone >> 4));
	 }

	rmmi_ptr->arg_list[1] = (void*)tz_string;

	 if (day_light_saving_timeP)
	 {
	 	rmmi_ptr->arg_list[2] = (void*)&day_light_saving_time;
		string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CIEV: 9,\"%s\",%s,%d", rmmi_ptr->arg_list, 3); 
	 }
	 else
	 {
		string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CIEV: 9,\"%s\",%s", rmmi_ptr->arg_list, 2); 		
	 }
        rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
    }
    return;
#endif /* !defined(__SLIM_AT__) */ 

}


/*****************************************************************************
 * FUNCTION
 *  l4c_nw_oper_name_rind
 * DESCRIPTION
 * PARAMETERS
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_nw_oper_name_rind(kal_uint8 *plmn,
							kal_uint8 full_nw_nameP, 
							kal_uint8 full_nw_name_dcs,
							kal_uint8 *full_nw_name, 
							kal_uint8 full_nw_name_len,
							kal_uint8 short_nw_nameP, 
							kal_uint8 short_nw_name_dcs,							
							kal_uint8 *short_nw_name, 
							kal_uint8 short_nw_name_len)
{
#if !defined(__SLIM_AT__)
    kal_uint16 string_length;
    kal_uint8 buffer[MAX_UART_LENGTH];
    kal_uint8 plmn_str[7];
    kal_uint8 full_name_str[MAX_NW_NAME_LEN*2];
    kal_uint8 short_name_str[MAX_NW_NAME_LEN*2];
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    kal_uint8 is_full_name_hex_str = 0;
    kal_uint8 is_short_name_hex_str = 0;

    /*  mtk02480, NITZ operator name URC format: +CIEV: 10,"PLMN","long_name","short_name"  */

    if (rmmi_ptr->report_mode.timezone == RMMI_ENABLE_REPORT)
    {	
        kal_mem_cpy(plmn_str, plmn, 7);

        if (full_nw_nameP)
        {
            if (full_nw_name_dcs == SMSAL_DEFAULT_DCS)
            {
                rmmi_gsm7bit_to_IRA(full_nw_name, full_name_str, full_nw_name_len, MAX_NW_NAME_LEN*2);
            }
            else if (full_nw_name_dcs == SMSAL_UCS2_DCS)
            {
                rmmi_byte_order_reverse(
                    (kal_uint8*)full_nw_name,
                    (kal_uint16)full_nw_name_len);

                if (ucs2_to_ascii((kal_wchar *)full_nw_name, full_name_str) != KAL_TRUE)
                {
                    rmmi_byte_order_reverse((kal_uint8*)full_nw_name, (kal_uint16)full_nw_name_len);
            	    rmmi_print_ucs2(full_nw_name, full_name_str);
                    is_full_name_hex_str = 1;
                }
            }
        }
        else
        {
            full_name_str[0]='\0';
        }

        if (short_nw_nameP)
        {
            if (short_nw_name_dcs == SMSAL_DEFAULT_DCS)
            {	
                rmmi_gsm7bit_to_IRA(short_nw_name, short_name_str, short_nw_name_len, MAX_NW_NAME_LEN*2);
            }
            else if (short_nw_name_dcs == SMSAL_UCS2_DCS)
            {
                rmmi_byte_order_reverse(
                    (kal_uint8*)short_nw_name,
                    (kal_uint16)short_nw_name_len);

                if (ucs2_to_ascii((kal_wchar *)short_nw_name, short_name_str) != KAL_TRUE)
                {
                    rmmi_byte_order_reverse((kal_uint8*)short_nw_name, (kal_uint16)short_nw_name_len);
                    rmmi_print_ucs2(short_nw_name, short_name_str);
                    is_short_name_hex_str = 1;
                }
            }
        }
        else
        {
            short_name_str[0]='\0';
        }

        rmmi_ptr->arg_list[0] = (void*)plmn_str;
        rmmi_ptr->arg_list[1] = (void*)full_name_str;
        rmmi_ptr->arg_list[2] = (void*)short_name_str;
        rmmi_ptr->arg_list[3] = (void*)&is_full_name_hex_str;
        rmmi_ptr->arg_list[4] = (void*)&is_short_name_hex_str;
        string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CIEV: 10,\"%s\",\"%s\",\"%s\", %d, %d", rmmi_ptr->arg_list, 5);
        rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
    }
#endif /* !defined(__SLIM_AT__) */
}

/*****************************************************************************
 * FUNCTION
 *  l4c_nw_rx_level_rind
 * DESCRIPTION
 *  This is l4c_nw_rx_level_rind function
 *  to give unsolicited result code for +CMER
 * PARAMETERS
 *  level               [IN]    
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_nw_rx_level_rind(kal_uint8 signal_ind)
{
#if !defined(__BT_SUPPORT__) && defined(__MMI_FMI__)
    kal_uint8 buffer[MAX_UART_LENGTH];
#endif 
//hong_rx_level    kal_uint8 signal_ind;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

#if defined(__GEMINI__) && defined(__DISABLE_SIM2_AT_SUPPORT__)//mtk01616_100511: prevent SIM2 event to update RMMI context
    if(l4c_current_mod_id == MOD_L4C_2)
        return;		
#endif

#if 0 //hong_rx_level
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

    /* unsolicited result code for +CMER */
    if (signal_ind != rmmi_ptr->indicators.signal)
    {
    #if !defined(__BT_SUPPORT__) && defined(__MMI_FMI__)
        if (rmmi_ptr->report_mode.cmer_ind > 0 )
        {
            /* send unsolicited result code */
            kal_sprintf((kal_char*) buffer, "+CIEV: 2, %d", signal_ind); //2: <signal> in +CIND
            rmmi_write_unsolicitedResultCode(
                (kal_uint8*) buffer,
                (kal_uint16) strlen((char*)buffer),
                KAL_TRUE,
                rmmi_ptr->report_mode.cmer_mode,
                (void*)&rmmi_ptr->CNMI_ResultCodeBuffer);
        }
    #endif /* !defined(__BT_SUPPORT__) */ 

    #ifdef __BT_SUPPORT__
        if (rmmi_ptr->report_mode.cmer_ind > 0)
        {
            kal_uint8 diff = (signal_ind > rmmi_ptr->last_reported_ciev_signal)? 
            (signal_ind - rmmi_ptr->last_reported_ciev_signal) : (rmmi_ptr->last_reported_ciev_signal - signal_ind); //hong_rx_level

            if (diff > custom_ciev_signal_variance()) //hong_rx_level
            {
                /* send unsolicited result code */
                l4c_cc_handfree_rind(RMMI_CIND_SIGNAL, signal_ind);
                rmmi_ptr->last_reported_ciev_signal = signal_ind;
            }
        }
    #endif /* __BT_SUPPORT__ */ 

        /* update indicators.signal  */
        rmmi_ptr->indicators.signal = signal_ind;

    }
}


/*****************************************************************************
 * FUNCTION
 *  l4c_nw_signal_quality_rind
 * DESCRIPTION
 *  This function
 *  give unsolicited result code for +ECSQ
 * PARAMETERS
 *  rssi        [IN]        
 *  ber         [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_nw_signal_quality_rind(kal_uint8 rssi, kal_uint8 ber, kal_int32 rssi_in_qdbm, kal_int32 RSCP_in_qdbm, kal_int32 EcN0_in_qdbm, l4c_rat_enum rat)
{
#if !defined(__SLIM_AT__)
    kal_uint8 buffer[MAX_UART_LENGTH];
    kal_uint16 string_length;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

	#if defined(__GEMINI__) && defined(__DISABLE_SIM2_AT_SUPPORT__)//mtk01616_100511: prevent SIM2 event to update RMMI context
    if(l4c_current_mod_id == MOD_L4C_2)
    {
        return;		
    }
	#endif

    /* unsolicited result code for +ECSQ */
    if (rmmi_ptr->report_mode.ecsq == 1)
    {
        /* send unsolicited result code */
        if(rat == L4C_RAT_GSM)
        {
            kal_sprintf((kal_char*) buffer, "+ECSQ: %u, %u, %d", rssi, ber, rssi_in_qdbm);
        }
        else if(rat == L4C_RAT_UMTS)
        {
            kal_sprintf((kal_char*) buffer, "+ECSQ: %u, %u, %d, %d, %d", rssi, ber, rssi_in_qdbm, RSCP_in_qdbm, EcN0_in_qdbm);
        }
        string_length = (kal_uint16)strlen((char*)buffer);
        rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
    }
#if !defined(__MMI_FMI__)
    else if (rmmi_ptr->report_mode.ecsq == 2)
    {
        if (rmmi_ptr->report_mode.ecsq_count >= 10)
        {
            /* send unsolicited result code */
            if(rat == L4C_RAT_GSM)
            {
                kal_sprintf((kal_char*) buffer, "+ECSQ: %u, %u, %d", rssi, ber, rssi_in_qdbm);
            }
            else if(rat == L4C_RAT_UMTS)
            {
                kal_sprintf((kal_char*) buffer, "+ECSQ: %u, %u, %d, %d, %d", rssi, ber, rssi_in_qdbm, RSCP_in_qdbm, EcN0_in_qdbm);
            }
            string_length = (kal_uint16)strlen((char*)buffer);
            rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);

            // [ALPS00122589] mtk02480
            // If RSSI indicated unknow(99), indicate again next time
            if (rssi != 99)
            {
                rmmi_ptr->report_mode.ecsq_count = 0;
            }
        }
        else
        {
            rmmi_ptr->report_mode.ecsq_count++;
        }
    }
#endif /* __MMI_FMI__ */ 

#endif /* !defined(__SLIM_AT__) */ 
}

/*****************************************************************************
 * FUNCTION
 *  l4c_nw_gprs_event_report_rind
 * DESCRIPTION
 *  This is l4c_nw_gprs_event_report_rind function of L4C module.
 *  Indicate the GPRS status is changed.
 * PARAMETERS
 *  event_id            [IN]        
 *  context_id          [IN]        
 *  pdp_addr_len        [IN]        
 *  pdp_addr_type       [IN]        
 *  pdp_addr            [?]         
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_nw_gprs_event_report_rind(
        kal_uint8 event_id,
        kal_uint8 context_id,
        kal_uint8 pdp_addr_len,
        kal_uint8 pdp_addr_type,
        kal_uint8 *pdp_addr)
{
#if !defined(__SLIM_AT__) // at+cgerep is wrapped by SLIM
    kal_uint16 string_length = 0;
#ifndef __MOD_TCM__    
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
#else
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN+IPV4V6_ADDR_LEN*4+1];
    kal_uint8 pdp_type_str[10]; // 10 is only a temp number
    kal_uint8 pdp_addr_str[IPV4V6_ADDR_LEN*4+1];
#endif
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    if (rmmi_ptr->report_mode.cgerep < 1)
    {
        return;
    }

    if (event_id == NW_DETACH_EVENT)
    {
        // +CGEV: NW DETACH
        string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CGEV: NW DETACH", rmmi_ptr->arg_list, 0);
    }
    else if (event_id == ME_DETACH_EVENT)
    {
        // +CGEV: ME DETACH
        string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CGEV: ME DETACH", rmmi_ptr->arg_list, 0);

    }
#ifdef __MOD_TCM__    
	else if (event_id >= NW_CONTEXT_REJ_EVENT && event_id <= ME_CONTEXT_DEACT_EVENT) // related to: mmi_event_enum
	{
        check_pdp_type_name(pdp_addr_type, pdp_type_str);
        rmmi_u8_to_dotstring(pdp_addr, pdp_addr_str, pdp_addr_len);
        rmmi_ptr->arg_list[0] = (void*) pdp_type_str;
        rmmi_ptr->arg_list[1] = (void*) pdp_addr_str;
        rmmi_ptr->arg_list[2] = (void*) &context_id;

        if (event_id == NW_CONTEXT_REJ_EVENT)
        {
    	        // +CGEV: REJECT <PDP_TYPE>, <PDP_ADDR>     
    	        string_length = rmmi_fast_string_print(buffer, 
    	            (kal_uint8*) "+CGEV: REJECT \"%s\", \"%s\"", RMMI_PTR->arg_list, 2);
        }
        else if (event_id == NW_CONTEXT_REACT_EVENT)
        {
    	        // +CGEV: NW REACT <PDP_TYPE>, <PDP_ADDR>, [<CID>]
    	        string_length = rmmi_fast_string_print(buffer, 
    	            (kal_uint8*) "+CGEV: ME REACT \"%s\", \"%s\", %d", RMMI_PTR->arg_list, 3);
        }
        else if (event_id == NW_CONTEXT_DEACT_EVENT)
        {
    	        // +CGEV: NW DEACT <PDP_TYPE>, <PDP_ADDR>, [<CID>]
    	        string_length = rmmi_fast_string_print(buffer, 
    	            (kal_uint8*) "+CGEV: NW DEACT \"%s\", \"%s\", %d", RMMI_PTR->arg_list, 3);

        }
        else if (event_id == ME_CONTEXT_DEACT_EVENT)
        {
    	        // +CGEV: ME DEACT <PDP_TYPE>, <PDP_ADDR>, [<CID>]
    	        string_length = rmmi_fast_string_print(buffer, 
    	            (kal_uint8*) "+CGEV: ME DEACT \"%s\", \"%s\", %d", RMMI_PTR->arg_list, 3);
        }
    }
    else if (event_id == ME_PDN_ACT_EVENT)
    {
        //IPV6_TODO: "+CGEV: ME PDN ACT <cid>"
        kal_sprintf((kal_char*)buffer, "+CGEV: ME PDN ACT %d", context_id);
        string_length = (kal_uint16)strlen((char*)buffer);
    }
#endif // __MOD_TCM__
    else
    {
        return;
    }

    //kal_print((kal_char*)buffer);
    //string_length = strlen((char *)buffer);   
    rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
#endif /* !defined(__SLIM_AT__) */	
    return;
}

#if defined(__NO_PSDATA_SEND_SCRI__) || defined(__FAST_DORMANCY__)
/*****************************************************************************
 * FUNCTION
 *  l4c_nw_end_ps_data_session_rind
 * DESCRIPTION
 *  To send +ESCRI URC to indicate the SUCCESS or FAILURE of the action "end ps data session"
 * PARAMETERS
 *  kal_bool is_success: 0 (FAILED); 1 (SUCCESS)
 *  kal_uint8 reported_value
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_nw_end_ps_data_session_rind(kal_uint8 src_id, kal_uint8 reported_value)  
{
    kal_uint8 buffer[MAX_UART_LENGTH];
    kal_uint8 string_length;
    kal_sprintf((kal_char*) buffer, "+ESCRI: %d", reported_value);
    string_length = (kal_uint8)strlen((char*)buffer);
    rmmi_write_to_uart(buffer, string_length, KAL_TRUE);
}
#endif /* __NO_PSDATA_SEND_SCRI__ */


/*****************************************************************************
 * FUNCTION
 *  l4c_nw_invalid_sim_rind
 * DESCRIPTION
 *  To send +EIND: 64 URC to indicate that invalid SIM reject by network
 * PARAMETERS
 *  l4c_rac_response_enum cs_status
 *  l4c_rac_gprs_status_enum ps_status
 *  kal_uint8 cause: MM reject cause
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_nw_invalid_sim_rind(l4c_rac_response_enum cs_status, l4c_rac_gprs_status_enum ps_status, kal_uint8 cause)
{
    kal_uint8 buffer[MAX_UART_LENGTH];
    kal_uint8 string_length;
    kal_bool is_cs_invalid = KAL_FALSE, is_ps_invalid = KAL_FALSE;
    kal_uint8 oper[7];
    kal_uint8 temp_src = RMMI_PTR->current_src;    

    RMMI_PTR->current_src = RMMI_UNSOLICITED;

    l4c_nw_get_current_oper_req(RMMI_SRC, (kal_uint8*) oper);

    if (cs_status == L4C_RAC_INVALID_SIM)
    {
        is_cs_invalid = KAL_TRUE;
    }

    if (ps_status == GPRS_INVALID_SIM)
    {
        is_ps_invalid = KAL_TRUE;
    }
    
    if (RMMI_PTR->report_mode.eind & (INFO_REPORT_MASK << RMMI_EIND_INVALID_SIM_BIT)) 
    {
        kal_sprintf((kal_char*) buffer, "+EIND: 16,\"%s\",%d,%d,%d", oper, is_cs_invalid, is_ps_invalid, cause);
        string_length = (kal_uint8)strlen((char*)buffer);
        rmmi_write_to_uart(buffer, string_length, KAL_TRUE);
    }

    RMMI_PTR->current_src = temp_src;
}

#endif /* __MOD_RAC__ */ 

#ifdef __MOD_SMU__


/*****************************************************************************
 * FUNCTION
 *  l4c_sim_support_plmn_list_rind
 * DESCRIPTION
 *  This is l4c_sim_support_plmn_list_rind function of L4C module.
 *  save the number of plmns the current sim card supports in
 *  RMMI context
 * PARAMETERS
 *  length      [IN]        Number of plmns the current sim card supports
 * RETURNS
 *  void
 *****************************************************************************/
/*
void l4c_sim_support_plmn_list_rind(kal_uint16 length)
{
    kal_brief_trace(TRACE_FUNC, FUNC_L4C_SIM_SUPPORT_PLMN_LIST_RIND_ENTRY);
    RMMI_PTR->max_plmn_list_len = length;
}
*/

/*****************************************************************************
* FUNCTION
*  l4c_cphs_mmi_info_rind
*
* DESCRIPTION
*   Report autolock status to RMMI.
*
* PARAMETERS
*  is_autolock_enable   IN	Is autolock enabled or not. 
*  autolock_result	      IN     Autolock failed or successful.
* RETURNS
*  none.
*
* GLOBALS AFFECTED
*  none.
*****************************************************************************/
void l4c_cphs_mmi_info_rind(
                kal_uint8 is_autolock_enable, 
                kal_uint8 autolock_result, 
                kal_uint8 is_valid_csp, 
                kal_uint8 *csp,
                kal_uint8 is_spn_valid,
                kal_uint8 *spn)
{
#if !defined(__SLIM_AT__)
    kal_uint16 string_length;
    kal_uint8 buffer[MAX_UART_LENGTH];
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    if(rmmi_ptr->report_mode.einfo & (INFO_REPORT_MASK << RMMI_ESMLA_BIT))
    {
        kal_sprintf((kal_char*)buffer,"+ESMLA: %d, %d", is_autolock_enable, autolock_result);
        string_length = (kal_uint16)strlen((char *)buffer);		
        rmmi_write_to_uart(buffer, string_length, KAL_TRUE);
    }

    /* report is test SIM URC for IVSR feature */
    if (rmmi_ptr->report_mode.etestsim > 0)
    {
        kal_sprintf((kal_char*)buffer,"+ETESTSIM: %d", l4c_is_test_sim());
        string_length = (kal_uint16)strlen((char *)buffer);		
        rmmi_write_to_uart(buffer, string_length, KAL_TRUE);
    }

#if !defined(__MMI_FMI__)    
    RMMI_PTR->is_spn_valid = is_spn_valid;
    if (spn != NULL)
    {
        kal_mem_cpy(RMMI_PTR->spn, spn, 17);
    }
#endif

#if defined(__MODEM_CARD__) || defined(__SP_RIL_SUPPORT__)
    if (is_valid_csp == KAL_TRUE)
    {
        kal_uint16 string_length;
        kal_uint8 buffer[MAX_UART_LENGTH];
        kal_uint8 i, plmn_mode;

        for (i=0; i<=20; i+=2)
        {
            // Sevice group code C0 is for ValueAdded Services, defined in CPHS
            if (csp[i] == 0xC0)
            {
                // The next byte is real data, the Bit 8 is for plmn mode
                plmn_mode = (csp[i+1] & 0x80) >> 7;
                
                if (plmn_mode != rmmi_ptr->csp_plmn_mode)
                {
                    kal_sprintf((kal_char*)buffer,"+PACSP%d", plmn_mode);  // +PACSP0 or +PACSP1
                    string_length = (kal_uint16)strlen((char *)buffer);		
                    rmmi_write_to_uart(buffer, string_length, KAL_TRUE);

                    rmmi_ptr->csp_plmn_mode = plmn_mode;

                    // Change the selection to AUTO 
                    if (plmn_mode == 0)
                    {
                        l4c_nw_set_sel_mode_req(RMMI_SRC, AUTOMATIC_MODE);
                    }
                }
                break;
            }
        }
    }
#endif

    if (l4c_smu_file_idx_for_preferred_oper_list(FILE_PLMNSEL_IDX) != FILE_NONE || 
        l4c_smu_file_idx_for_preferred_oper_list(FILE_PLMNWACT_IDX) != FILE_NONE)
    {
        RMMI_PTR->cpls_selected = 0;
    }
    else if (l4c_smu_file_idx_for_preferred_oper_list(FILE_OPLMNWACT_IDX) != FILE_NONE)
    {
        RMMI_PTR->cpls_selected = 1;
    }
    else if (l4c_smu_file_idx_for_preferred_oper_list(FILE_HPLMNACT_IDX) != FILE_NONE)
    {
        RMMI_PTR->cpls_selected = 2;
    }
#endif
}

#if defined(__OP01__)
/*****************************************************************************
* FUNCTION
*  l4c_op01_cardmode_rind
*
* DESCRIPTION
* PARAMETERS
* RETURNS
*  none.
*
* GLOBALS AFFECTED
*  none.
*****************************************************************************/
void l4c_op01_cardmode_rind(kal_bool is_sim_verified, kal_bool is_usim)
{
    kal_uint16 string_length;
    kal_uint8 buffer[MAX_UART_LENGTH];
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    kal_uint8 temp_src = rmmi_ptr->current_src;    
    rmmi_ptr->current_src = RMMI_UNSOLICITED;

    // is_sim_verified=TRUE <=> SIM inserted and PIN CHV1 has been verfied

    if (rmmi_ptr->op01_report_mode.cardmode == 1)
    {
        int sim_state=0;

        if (is_sim_verified == KAL_FALSE)
        {
            sim_state = 255;
        }
        else
        {
            if (check_is_usim() == KAL_TRUE)
            {
                sim_state = 2;
            }
            else
            {
                sim_state = 1;
            }
        }

        kal_sprintf((kal_char*)buffer,"^CARDMODE:%d", sim_state);
        string_length = (kal_uint16)strlen((char *)buffer);		
        rmmi_write_to_uart(buffer, string_length, KAL_TRUE);
    }
    
    rmmi_ptr->current_src = temp_src;
}

/*****************************************************************************
* FUNCTION
*  l4c_op01_rfsw_rind
*
* DESCRIPTION
* PARAMETERS
* RETURNS
*  none.
*
* GLOBALS AFFECTED
*  none.
*****************************************************************************/
void l4c_op01_rfsw_rind(kal_bool is_radio_on)
{
    kal_uint16 string_length;
    kal_uint8 buffer[MAX_UART_LENGTH];
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    kal_uint8 temp_src = rmmi_ptr->current_src;    
    rmmi_ptr->current_src = RMMI_UNSOLICITED;

    if (rmmi_ptr->op01_report_mode.rfsw == 1)
    {
        int state=0;

        if (is_radio_on)
        {
            state = 1;
        }

        kal_sprintf((kal_char*)buffer,"^RFSW:%d", state);
        string_length = (kal_uint16)strlen((char *)buffer);		
        rmmi_write_to_uart(buffer, string_length, KAL_TRUE);
    }

    rmmi_ptr->current_src = temp_src;
}
#endif /* __OP01__ */

#endif /* __MOD_SMU__ */ 

#ifdef __MOD_SMSAL__


/*****************************************************************************
 * FUNCTION
 *  l4c_sms_ready_rind
 * DESCRIPTION
 *  This is to send +EIND indication to DTE when SMS is ready to read.
 * PARAMETERS
 *  result      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_sms_ready_rind(l4c_result_enum result)
{
#if !defined(__SLIM_AT__) && !defined(__UE_SIMULATOR__)
    kal_uint8 buffer[MAX_UART_LENGTH];
    kal_uint8 string_length;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

#if defined(__GEMINI__) && defined(__DISABLE_SIM2_AT_SUPPORT__)//mtk01616_100511: prevent SIM2 event to update RMMI context
    if(l4c_current_mod_id == MOD_L4C_2)
        return;		
#endif

    if (result == L4C_OK)
    {
        rmmi_ptr->eind_ready_flag |= (INFO_REPORT_MASK << RMMI_EIND_SMS_READY_BIT);

        if (rmmi_ptr->report_mode.eind & (INFO_REPORT_MASK << RMMI_EIND_SMS_READY_BIT))
        {
            kal_sprintf((kal_char*) buffer, "+EIND: 1");
            string_length = (kal_uint8)strlen((char*)buffer);
            rmmi_write_to_uart(buffer, string_length, KAL_TRUE);
        }
    }
#endif	
}


/*****************************************************************************
 * FUNCTION
 *  l4c_sms_new_msg_index_rind
 * DESCRIPTION
 *  This is l4c_sms_new_msg_index_rind function of L4C module.
 *  construct the +CMTI unsolicited result code for RMMI when
 *  a MT sms is received
 * PARAMETERS
 *  indx            [IN]        The index of the MT sms
 *  storage         [IN]        The storage where the MT sms is saved
 *  concat_info     [IN]        The concatenate info of the MT sms
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_sms_new_msg_index_rind(kal_uint16 indx, kal_uint8 storage, void *concat_info)
{
#if !defined(__SLIM_AT__)

    kal_uint16 string_length;
    kal_uint8 buffer[MAX_UART_LENGTH];
    kal_uint16 index;
    kal_uint8 mem_str[5];
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    kal_brief_trace(TRACE_FUNC, FUNC_L4C_SMS_NEW_MSG_INDEX_RIND_ENTRY);

    /* mtk00714 : convert storage code to string type */
    check_sms_storage_name(storage, mem_str);

    /* mtk00714 : convert index, start 0 => 1 */
    index = indx + 1;

    rmmi_ptr->arg_list[0] = (void*)mem_str;
    rmmi_ptr->arg_list[1] = (void*)&index;
    string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CMTI: \"%s\", %d", rmmi_ptr->arg_list, 2);
    rmmi_write_unsolicitedResultCode_plus(
        (kal_uint8*) buffer,
        string_length,
        KAL_TRUE,
        rmmi_ptr->CNMI_mode,
        (void*)&rmmi_ptr->CNMI_ResultCodeBuffer);
#endif /* !defined(__SLIM_AT__) */ 
}


/*****************************************************************************
 * FUNCTION
 *  l4c_sms_new_msg_text_rind
 * DESCRIPTION
 *  This is l4c_sms_new_msg_text_rind function of L4C module.
 *  construct the +CMT/+CDS unsolicited result code for RMMI when
 *  a text mode MT sms is received
 * PARAMETERS
 *  mti             [IN]        The type of the MT sms
 *  id              [IN]        The index of the MT sms
 *  hex_dspl        [IN]        Use hex to display the msg or not
 *  length          [IN]        
 *  msg_header      [?]         
 *  data            [IN]        The peer buffer of the MT sms
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_sms_new_msg_text_rind(
        kal_uint8 mti,
        kal_uint8 id,
        kal_uint8 hex_dspl,
        kal_uint16 length,
        void *msg_header,
        void *data)
{
#if !defined(__SLIM_AT__)

    kal_uint16 string_length;
    kal_uint8 scts[25];
    kal_uint8 buffer[SMSAL_MAX_MSG_LEN*4+30];//maximum sms length = 160 char = 160*4 ucs2, 30 is for header
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    kal_brief_trace(TRACE_FUNC, FUNC_L4C_SMS_NEW_MSG_TEXT_RIND_ENTRY);

    if (length > 0)
    {
        ASSERT(data != NULL);
    }

    switch (mti)
    {
        case SMSAL_MTI_DELIVER:
        {
            smsal_deliver_msg_hdr_struct *buff_ptr;
            l4c_number_struct addr, sca;

            buff_ptr = (smsal_deliver_msg_hdr_struct*) msg_header;
            addr.type = buff_ptr->oa.addr_bcd[0];
            addr.length = convert_to_digit(&(buff_ptr->oa.addr_bcd[1]), addr.number);
            if (buff_ptr->sca.addr_length > 0)
            {
                sca.type = buff_ptr->sca.addr_bcd[0];
                sca.length = convert_to_digit(&(buff_ptr->sca.addr_bcd[1]), sca.number);
            }
            //mtk00924: if not set to zero, there may no end of character when lenght=0              
            //kal_mem_set(temp_str, 0x00, SMSAL_ONE_MSG_LEN * 4 + 1);	// modifed by mtk02514_081216

            check_sms_scts(scts, buff_ptr->scts);

            /* mtk00714: add for +CDSH = 1 */
            if (rmmi_ptr->csdh_show == KAL_TRUE)
            {
                rmmi_ptr->arg_list[0] = (void*)addr.number;
                rmmi_ptr->arg_list[1] = (void*)scts;
                rmmi_ptr->arg_list[2] = (void*)&addr.type;
                rmmi_ptr->arg_list[3] = (void*)&buff_ptr->fo;
                rmmi_ptr->arg_list[4] = (void*)&buff_ptr->pid;
                rmmi_ptr->arg_list[5] = (void*)&buff_ptr->ori_dcs;
                rmmi_ptr->arg_list[6] = (void*)sca.number;
                rmmi_ptr->arg_list[7] = (void*)&sca.type;
                rmmi_ptr->arg_list[8] = (void*)&buff_ptr->no_msg_data;
                #ifdef __SMS_AT_DIRECT_OUTPUT_SUPPORT__
                string_length = rmmi_fast_string_print(
                                    buffer,
                                    (kal_uint8*) "+CMT: \"%s\", \"%s\", %d, %d, %d, %d, \"%s\", %d, %d,",
                                    rmmi_ptr->arg_list,
                                    9);
                #else
                rmmi_ptr->arg_list[9] = (void*)&rmmi_ptr->s_reg.s3;
                rmmi_ptr->arg_list[10] = (void*)&rmmi_ptr->s_reg.s4;

                string_length = rmmi_fast_string_print(
                                    buffer,
                                    (kal_uint8*) "+CMT: \"%s\", \"%s\", %d, %d, %d, %d, \"%s\", %d, %d%c%c",
                                    rmmi_ptr->arg_list,
                                    11);
                #endif           
            }
            else        //+CDSH = 0
            {
                rmmi_ptr->arg_list[0] = (void*)addr.number;
                rmmi_ptr->arg_list[1] = (void*)scts;
                /*         
                 * RMMI_PTR->arg_list[2] = (void *)&addr.type;
                 * RMMI_PTR->arg_list[3] = (void *)&buff_ptr->fo;
                 * RMMI_PTR->arg_list[4] = (void *)&buff_ptr->pid;
                 * RMMI_PTR->arg_list[5] = (void *)&buff_ptr->ori_dcs;
                 * RMMI_PTR->arg_list[6] = (void *)sca.number;
                 * RMMI_PTR->arg_list[7] = (void *)&sca.type;         
                 * RMMI_PTR->arg_list[8] = (void *)&buff_ptr->no_msg_data;
                 */
                #ifdef __SMS_AT_DIRECT_OUTPUT_SUPPORT__ 
                string_length = rmmi_fast_string_print(
                                    buffer,
                                    (kal_uint8*) "+CMT: \"%s\", ,\"%s\",",
                                    rmmi_ptr->arg_list,
                                    2);
                #else
                rmmi_ptr->arg_list[2] = (void*)&rmmi_ptr->s_reg.s3;
                rmmi_ptr->arg_list[3] = (void*)&rmmi_ptr->s_reg.s4;

                string_length = rmmi_fast_string_print(
                                    buffer,
                                    (kal_uint8*) "+CMT: \"%s\", ,\"%s\"%c%c",
                                    rmmi_ptr->arg_list,
                                    4);
                #endif
            }

	    if (length > 0)
            {
                if (hex_dspl == KAL_TRUE)
                {
                    check_sms_pdu_string(length, data, buffer+string_length);
                }
                else // dcs decoding
                {
                    check_dcs_toCscs(buff_ptr->dcs, length, data, buffer+string_length);
                }
            }

	    string_length = (kal_uint16)strlen((kal_char*)buffer);

            break;
        }
        case SMSAL_MTI_STATUS_REPORT:
        {
            smsal_status_report_msg_hdr_struct *buff_ptr;
            l4c_number_struct addr;
            kal_uint8 tp_dt[25];

            buff_ptr = (smsal_status_report_msg_hdr_struct*) msg_header;
            addr.type = buff_ptr->ra.addr_bcd[0];
            addr.length = convert_to_digit(&(buff_ptr->ra.addr_bcd[1]), addr.number);
            check_sms_scts(scts, buff_ptr->scts);
            check_sms_scts(tp_dt, buff_ptr->dt);

            rmmi_ptr->arg_list[0] = (void*)&buff_ptr->fo;
            rmmi_ptr->arg_list[1] = (void*)&buff_ptr->mr;
            rmmi_ptr->arg_list[2] = (void*)addr.number;
            rmmi_ptr->arg_list[3] = (void*)&addr.type;
            rmmi_ptr->arg_list[4] = (void*)scts;
            rmmi_ptr->arg_list[5] = (void*)tp_dt;
            rmmi_ptr->arg_list[6] = (void*)&buff_ptr->st;

            #ifdef __SMS_AT_DIRECT_OUTPUT_SUPPORT__ 
            string_length = rmmi_fast_string_print(
                                buffer,
                                (kal_uint8*) "+CDS: %d, %d, \"%s\", %d, \"%s\", \"%s\", %d,",
                                rmmi_ptr->arg_list,
                                7);
            #else
            rmmi_ptr->arg_list[7] = (void*)&rmmi_ptr->s_reg.s3;
            rmmi_ptr->arg_list[8] = (void*)&rmmi_ptr->s_reg.s4;
            string_length = rmmi_fast_string_print(
                                buffer,
                                (kal_uint8*) "+CDS: %d, %d, \"%s\", %d, \"%s\", \"%s\", %d%c%c",
                                rmmi_ptr->arg_list,
                                9);
            #endif

            /*         
             * RMMI_PTR->arg_list[7] = (void *)&buff_ptr->no_msg_data;
             * RMMI_PTR->arg_list[8] = (void *)&RMMI_PTR->s_reg.s3;
             * RMMI_PTR->arg_list[9] = (void *)&RMMI_PTR->s_reg.s4;
             * if (hex_dspl == KAL_TRUE)
             * check_sms_pdu_string (buff_ptr->no_msg_data,
             * buff_ptr->msg_data, 
             * temp_str);
             * else
             * // dcs decoding
             * check_dcs_toCscs (buff_ptr->dcs, buff_ptr->no_msg_data,
             * buff_ptr->msg_data, temp_str);
             * RMMI_PTR->arg_list[10] = (void *)temp_str;
             * 
             * string_length = rmmi_fast_string_print (
             * buffer,
             * (kal_uint8 *)"+CDS: %d, %d, \"%s\", %d, \"%s\", \"%s\", %d, %d%c%c%s",
             * RMMI_PTR->arg_list,
             * 11
             * );
             */
            break;
        }
        default:
            return;
    }

    rmmi_write_unsolicitedResultCode_plus(
        (kal_uint8*) buffer,
        string_length,
        KAL_TRUE,
        rmmi_ptr->CNMI_mode,
        (void*)&rmmi_ptr->CNMI_ResultCodeBuffer);
#endif /* !defined(__SLIM_AT__) */ 
}


/*****************************************************************************
 * FUNCTION
 *  l4c_sms_new_msg_pdu_rind
 * DESCRIPTION
 *  This is l4c_sms_new_msg_pdu_rind function of L4C module.
 *  construct the +CMT/+CDS unsolicited result code for RMMI when
 *  a pdu mode MT sms is received
 * PARAMETERS
 *  mti                         [IN]        The type of the MT sms
 *  length                      [IN]        The length of the MT sms pdu
 *  id                          [IN]        The index of the MT sms
 *  data                        [IN]        The peer buffer of the MT sms
 *  packed_peer_buff_len        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_sms_new_msg_pdu_rind(
        kal_uint8 mti,
        kal_uint16 length,
        kal_uint8 id,
        void *data,
        kal_uint16 packed_peer_buff_len)
{
#if !defined(__SLIM_AT__)

    kal_uint16 string_length;
    kal_uint8 buffer[SMSAL_MAX_TPDU_SIZE * 2 + 30];//30 for header
    kal_uint8 pdu_str[SMSAL_MAX_TPDU_SIZE * 2], tmp[3], len;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    kal_brief_trace(TRACE_FUNC, FUNC_L4C_SMS_NEW_MSG_PDU_RIND_ENTRY);
    ASSERT(data != NULL);
    // packed_peer_buff_len = sc address + pdu data
    check_sms_pdu_string(packed_peer_buff_len, (kal_uint8*) data, (kal_uint8*) pdu_str);
    //for module: Maui_sw 9943
    //length should exclude SC address.
    tmp[0] = pdu_str[0];
    tmp[1] = pdu_str[1];
    tmp[2] = '\0';
    len = (kal_uint8)(length - (atoi((char*)tmp) + 1));
    //for module: Maui_sw 9943
    switch (mti)
    {
        case SMSAL_MTI_DELIVER:
        {
            rmmi_ptr->arg_list[0] = (void*)&len;       //for module: Maui_sw 9943

            #ifdef __SMS_AT_DIRECT_OUTPUT_SUPPORT__ 
            rmmi_ptr->arg_list[1] = (void*)pdu_str;

            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CMT: ,%d,%s", rmmi_ptr->arg_list, 2);
            #else
            rmmi_ptr->arg_list[1] = (void*)&rmmi_ptr->s_reg.s3;
            rmmi_ptr->arg_list[2] = (void*)&rmmi_ptr->s_reg.s4;
            rmmi_ptr->arg_list[3] = (void*)pdu_str;

            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CMT: ,%d%c%c%s", rmmi_ptr->arg_list, 4);
            #endif

            break;
        }
        case SMSAL_MTI_STATUS_REPORT:
        {
            rmmi_ptr->arg_list[0] = (void*)&length;

            #ifdef __SMS_AT_DIRECT_OUTPUT_SUPPORT__ 
            rmmi_ptr->arg_list[1] = (void*)pdu_str;
            
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CDS: %d,%s", rmmi_ptr->arg_list, 2);
            #else
            rmmi_ptr->arg_list[1] = (void*)&rmmi_ptr->s_reg.s3;
            rmmi_ptr->arg_list[2] = (void*)&rmmi_ptr->s_reg.s4;
            rmmi_ptr->arg_list[3] = (void*)pdu_str;

            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CDS: %d%c%c%s", rmmi_ptr->arg_list, 4);
            #endif

            break;
        }
        default:
            return;
    }

    rmmi_write_unsolicitedResultCode_plus(
        (kal_uint8*) buffer,
        string_length,
        KAL_TRUE,
        rmmi_ptr->CNMI_mode,
        (void*)&rmmi_ptr->CNMI_ResultCodeBuffer);
#endif /* !defined(__SLIM_AT__) */ 

}


/*****************************************************************************
 * FUNCTION
 *  l4c_sms_mem_full_rind
 * DESCRIPTION
 *  Setup indicator for +CIND and +CMER
 *  mtk00714 : 2004/03/03
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_sms_mem_full_rind(void)
{
#if !defined(__BT_SUPPORT__)
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
#endif 
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

#if defined(__GEMINI__) && defined(__DISABLE_SIM2_AT_SUPPORT__)//mtk01616_100511: prevent SIM2 event to update RMMI context
    if(l4c_current_mod_id == MOD_L4C_2)
        return;		
#endif

    rmmi_ptr->indicators.smsfull = 1;

#if !defined(__BT_SUPPORT__)
    if (rmmi_ptr->report_mode.cmer_ind > 0) //cmer_revise == 2)
    {
        kal_sprintf((kal_char*) buffer, "+CIEV: %d, 1", RMMI_CIND_SMSMEMSTATUS); //  7: <smsfull> in +CIND
        rmmi_write_unsolicitedResultCode(
            (kal_uint8*) buffer,
            (kal_uint16) strlen((char*)buffer),
            KAL_TRUE,
            rmmi_ptr->report_mode.cmer_mode,
            (void*)&rmmi_ptr->CNMI_ResultCodeBuffer);
    }
#endif /* !defined(__BT_SUPPORT__) */ 
}


/*****************************************************************************
 * FUNCTION
 *  l4c_sms_mem_available_rind
 * DESCRIPTION
 *  Setup indicator for +CIND and +CMER
 *  mtk00714 : 2004/03/03
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_sms_mem_available_rind(void)
{
#if !defined(__BT_SUPPORT__)
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
#endif 
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

#if defined(__GEMINI__) && defined(__DISABLE_SIM2_AT_SUPPORT__)//mtk01616_100511: prevent SIM2 event to update RMMI context
    if(l4c_current_mod_id == MOD_L4C_2)
        return;		
#endif

    rmmi_ptr->indicators.smsfull = 0;

#if !defined(__BT_SUPPORT__)

    if (rmmi_ptr->report_mode.cmer_ind > 0) //cmer_revise == 2)
    {
        kal_sprintf((kal_char*) buffer, "+CIEV: %d, 0", RMMI_CIND_SMSMEMSTATUS);        //  7: <smsfull> in +CIND
        rmmi_write_unsolicitedResultCode(
            (kal_uint8*) buffer,
            (kal_uint16) strlen((char*)buffer),
            KAL_TRUE,
            rmmi_ptr->report_mode.cmer_mode,
            (void*)&rmmi_ptr->CNMI_ResultCodeBuffer);

    }
#endif /* !defined(__BT_SUPPORT__) */ 
}


#ifndef __MMI_FMI__
/*****************************************************************************
 * FUNCTION
 *  l4c_sms_mem_exceed_rind
 * DESCRIPTION
 *  Send memory exceed indication
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_sms_mem_exceed_rind(kal_uint8 exceed_type)
{
#if !defined(__SLIM_AT__)

#if !defined(__BT_SUPPORT__)
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    if (rmmi_ptr->report_mode.cmer_ind > 0) //cmer_revise == 2)
    {
        /*******************************
        * we should refer to the rmmi_cind_enum
        * which will define the meaning of the +CIEV: <n>
        ********************************/

        if (exceed_type == SMSAL_SM_EXCEED_WITH_CLASS2)
        {
            kal_sprintf((kal_char*) buffer, "+CIEV: %d, 2", RMMI_CIND_SMSMEMSTATUS); //  7: <smsfull> in +CIND
        }
        else //SMSAL_MEM_EXCEED_NORMAL
        {
            kal_sprintf((kal_char*) buffer, "+CIEV: %d, 3", RMMI_CIND_SMSMEMSTATUS); //  7: <smsfull> in +CIND
        }
        rmmi_write_unsolicitedResultCode(
            (kal_uint8*) buffer,
            (kal_uint16) strlen((char*)buffer),
            KAL_TRUE,
            rmmi_ptr->report_mode.cmer_mode,
            (void*)&rmmi_ptr->CNMI_ResultCodeBuffer);

    }
#endif /* !defined(__BT_SUPPORT__) */ 

#endif /* !defined(__SLIM_AT__) */ 

}
#endif


#ifdef __CB__


/*****************************************************************************
 * FUNCTION
 *  l4c_cb_msg_text_rind
 * DESCRIPTION
 *  
 * PARAMETERS
 *  sn              [IN]        
 *  mi              [IN]        
 *  dcs             [IN]        
 *  page            [IN]        
 *  pages           [IN]        
 *  rmi_use_hex     [IN]        
 *  data_length     [IN]        
 *  msg_data        [?]         
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_cb_msg_text_rind(
        kal_uint16 sn,
        kal_uint16 mi,
        kal_uint8 dcs,
        kal_uint8 page,
        kal_uint8 pages,
        kal_uint8 rmi_use_hex,
        kal_uint8 data_length,
        kal_uint8 *msg_data)
{
#if !defined(__SLIM_AT__)

    kal_uint16 string_length;
    kal_uint8 buffer[93*4+30];//30 for header
    kal_uint8 alphabet_type, lang_type, msg_class;
    kal_bool is_reserved, is_compress;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    rmmi_ptr->arg_list[0] = (void*)&sn;
    rmmi_ptr->arg_list[1] = (void*)&mi;
    rmmi_ptr->arg_list[2] = (void*)&dcs;
    rmmi_ptr->arg_list[3] = (void*)&page;
    rmmi_ptr->arg_list[4] = (void*)&pages;

    #ifdef __SMS_AT_DIRECT_OUTPUT_SUPPORT__ 
    string_length = rmmi_fast_string_print(
                        buffer,
                        (kal_uint8*) "+CBM: %u, %u, %d, %d, %d,",
                        rmmi_ptr->arg_list,
                        5);
    #else
    rmmi_ptr->arg_list[5] = (void*)&rmmi_ptr->s_reg.s3;
    rmmi_ptr->arg_list[6] = (void*)&rmmi_ptr->s_reg.s4;

    string_length = rmmi_fast_string_print(
                        buffer,
                        (kal_uint8*) "+CBM: %u, %u, %d, %d, %d%c%c",
                        rmmi_ptr->arg_list,
                        7);
    #endif

    if (rmi_use_hex == KAL_TRUE)
    {
        check_sms_pdu_string(data_length, msg_data, buffer+string_length);
    }
    else
    {
        rmmi_decode_cbsdcs(dcs, &lang_type, &alphabet_type, &msg_class, &is_compress, &is_reserved);
        check_dcs_toCscs(alphabet_type, data_length, msg_data, buffer+string_length);
    }

    string_length = (kal_uint16)strlen((kal_char*) buffer);

    rmmi_write_unsolicitedResultCode_plus(
        (kal_uint8*) buffer,
        string_length,
        KAL_TRUE,
        rmmi_ptr->CNMI_mode,
        (void*)&rmmi_ptr->CNMI_ResultCodeBuffer);
#endif /* !defined(__SLIM_AT__) */ 

}


/*****************************************************************************
 * FUNCTION
 *  l4c_cb_msg_pdu_rind
 * DESCRIPTION
 *  
 * PARAMETERS
 *  length      [IN]        
 *  data        [?]         
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_cb_msg_pdu_rind(kal_uint16 length, void *data)
{
#if !defined(__SLIM_AT__)

    kal_uint16 string_length;
    kal_uint8 buffer[88*2+20];//max length of one cb page is 88 bytes
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    ASSERT(data != NULL);

    rmmi_ptr->arg_list[0] = (void*)&length;

    #ifdef __SMS_AT_DIRECT_OUTPUT_SUPPORT__ 
    string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CBM: %d,", rmmi_ptr->arg_list, 1);
    #else
    rmmi_ptr->arg_list[1] = (void*)&rmmi_ptr->s_reg.s3;
    rmmi_ptr->arg_list[2] = (void*)&rmmi_ptr->s_reg.s4;

    string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CBM: %d%c%c", rmmi_ptr->arg_list, 3);
    #endif

    check_sms_pdu_string(length, (kal_uint8*) data, (kal_uint8*) buffer+string_length);

    string_length = (kal_uint16)strlen((kal_char*) buffer);

    rmmi_write_unsolicitedResultCode_plus(
        (kal_uint8*) buffer,
        string_length,
        KAL_TRUE,
        rmmi_ptr->CNMI_mode,
        (void*)&rmmi_ptr->CNMI_ResultCodeBuffer);
#endif /* !defined(__SLIM_AT__) */ 
}

#endif /* __CB__ */ 

#ifdef __ETWS_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  l4c_sms_etws_informaion_rind
 * DESCRIPTION
 *  
 * PARAMETERS
 *  length      [IN]        
 *  data        [?]         
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_sms_etws_informaion_rind(
        kal_uint16 warning_type,
        kal_uint16 message_id,
        kal_uint16 serial_nubmer,
        kal_bool is_security_information_valid,
        kal_uint8 etws_security_information[L4C_MAX_ETWS_SECURITY_INFO_LEN],
        kal_uint8 plmn_id[6])
{
    kal_uint8 i;
    kal_uint8 plmn_id_string[7];
    /*+ETWS: <warning type>,<message ID>,<serial number>, <PLMN_ID>[,<security info.>]*/
    rmmi_header_rrsp("+ETWS:");
    rmmi_int_space_rrsp(warning_type);
    rmmi_int_comma_rrsp(message_id);
    rmmi_int_comma_rrsp(serial_nubmer);

    for (i=0;i<6;i++)
    {
        if (plmn_id[i] >=0 && plmn_id[i]<10)
        {
            plmn_id_string[i] = plmn_id[i] + '0';
        }
        else
        {
            plmn_id_string[i] = 0;
        }
    }
    plmn_id_string[6] = '\0';

    if (is_security_information_valid)
    {
        rmmi_string_comma_rrsp((kal_char*)plmn_id_string);
        rmmi_tail_hex_comma_rrsp(
                etws_security_information, 
                L4C_MAX_ETWS_SECURITY_INFO_LEN, 
                KAL_TRUE);
    }
    else
    {
        rmmi_tail_string_comma_rrsp((kal_char*)plmn_id_string);
    }
}

#endif /* __ETWS_SUPPORT__ */

#endif /* __MOD_SMSAL__ */ 


/*****************************************************************************
 * FUNCTION
 *  l4c_eq_keypad_detect_rind
 * DESCRIPTION
 *  This is l4c_eq_keypad_detect_rind function of L4C module.
 *  handler the indication to RMMI if +CMER is turn on.
 * PARAMETERS
 *  drv_get_key_func        [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_eq_keypad_detect_rind(kal_bool(*drv_get_key_func) (kbd_data *))
{
#ifndef __MMI_FMI__
    kal_uint16 string_length;
    kal_uint8 buffer[MAX_UART_LENGTH];
    kal_uint8 press;
    kal_bool result;
    kal_uint8 key;
    DCL_HANDLE handle;
    DCL_CTRL_DATA_T data;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    //kal_brief_trace(TRACE_FUNC, FUNC_L4C_EQ_KEYPAD_DETECT_RIND);

    if ((rmmi_ptr->report_mode.cmer_keyp == 2) || 
       ((rmmi_ptr->report_mode.cmer_keyp == 1) && ((*drv_get_key_func) != (l4c_kbd_getkeydata)))) //cmer_revise
    {
        handle = DclSKBD_Open(DCL_KBD, 0);
        if (DclSKBD_Control(handle, KBD_CMD_GET_KEY_DATA, (DCL_CTRL_DATA_T*)&data) == STATUS_OK)
        {
            if (data.rKBDCtrGetData.Keyevent == DCL_kbd_onekey_press)
            {
                press = 1;
            }
            else if (data.rKBDCtrGetData.Keyevent == DCL_kbd_onekey_release)
            {
                press = 0;
            }
            else
            {
                press = data.rKBDCtrGetData.Keyevent;
            }

            result = convert_keypad_code(data.rKBDCtrGetData.Keydata[0], &key);

            if (result == KAL_FALSE)
            {
                return;
            }

            rmmi_ptr->arg_list[0] = (void*)&key;
            rmmi_ptr->arg_list[1] = (void*)&press;
            string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CKEV: %c, %d", rmmi_ptr->arg_list, 2);

            //cmer_revise
            rmmi_write_unsolicitedResultCode(
                (kal_uint8*) buffer,
                string_length,
                KAL_TRUE,
                rmmi_ptr->report_mode.cmer_mode,
                (void*)&rmmi_ptr->CNMI_ResultCodeBuffer);
        }
    }
#endif /* __MMI_FMI__ */ 
    return;
}


#if !defined(__MMI_FMI__) && defined(__GEMINI__)
/*****************************************************************************
 * FUNCTION
 *  l4c_eq_pwnon_dual_sim_rind
 * DESCRIPTION
 *  To send +EDSIM: 0 URC to DTE when SIM2 is ready to be brought up
 *  Same usage as MSG_ID_MMI_EQ_PWNON_DUAL_SIM_IND
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_eq_pwnon_dual_sim_rind(void)
{
    kal_uint8 buffer[MAX_UART_LENGTH];
    kal_uint8 string_length;
    //kal_sprintf((kal_char*) buffer, "+EDSIM: 0");
    kal_sprintf((kal_char*) buffer, "+EPOK: 0");   
    string_length = (kal_uint8)strlen((char*)buffer);
    rmmi_write_to_uart(buffer, string_length, KAL_TRUE);
}

/*****************************************************************************
 * FUNCTION
 *  l4c_nw_rac_activated_rind
 * DESCRIPTION
 *  To send +EDSIM: 1 URC to DTE
 *  Same usage as MSG_ID_MMI_NW_RAC_ACTIVATED_IND
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_nw_rac_activated_rind(void)
{
    kal_uint8 buffer[MAX_UART_LENGTH];
    kal_uint8 string_length;
    kal_sprintf((kal_char*) buffer, "+EPOK: 1");
    string_length = (kal_uint8)strlen((char*)buffer);
    rmmi_write_to_uart(buffer, string_length, KAL_TRUE);
}

/*****************************************************************************
 * FUNCTION
 *  l4c_nw_search_normal_finish_rind
 * DESCRIPTION
 *  To send +EDSIM: 2 URC to DTE
 *  Same usage as MSG_ID_MMI_NW_SEARCH_NORMAL_FINISH_IND
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_nw_search_normal_finish_rind(void)
{
    kal_uint8 buffer[MAX_UART_LENGTH];
    kal_uint8 string_length;
//    kal_sprintf((kal_char*) buffer, "+EDSIM: 2");
    kal_sprintf((kal_char*) buffer, "+EPOK: 2");  
    string_length = (kal_uint8)strlen((char*)buffer);
    rmmi_write_to_uart(buffer, string_length, KAL_TRUE);
}

#endif /* !defined(__MMI_FMI__) && defined(__GEMINI__) */

/*****************************************************************************
 * FUNCTION
 *  l4c_eq_battery_status_rind
 * DESCRIPTION
 *  This is l4c_eq_battery_status_rind function of L4C module.
 *  hand the indication to RMMI with baterry stats
 * PARAMETERS
 *  battery_status      [IN]        
 *  battery_voltage     [IN]        
 *  file_id(?)          [IN]        The index of its record
 *  result(?)           [IN]        The result of record a file
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_eq_battery_status_rind(kal_uint8 battery_status, kal_uint8 battery_voltage)
{
    kal_uint16 string_length;
    kal_uint8 buffer[MAX_UART_LENGTH];
    kal_uint8 cind_value;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

#if defined(__GEMINI__) && defined(__DISABLE_SIM2_AT_SUPPORT__)//mtk01616_100511: prevent SIM2 event to update RMMI context
    if(l4c_current_mod_id == MOD_L4C_2)
        return;		
#endif

    /* if em_enable: +CEMS */
    if (rmmi_ptr->em_enable)
    {
        rmmi_ptr->arg_list[0] = (void*)&battery_status;
        string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+BATS: %d", rmmi_ptr->arg_list, 1);
        rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
    }

    cind_value = l4_custom_battery_cind_value(battery_voltage);

    /* unsolicited result code for +CMER */
    if (cind_value != rmmi_ptr->indicators.battchg)
    {

        //mtk01616_070718
    #ifdef __BT_SUPPORT__
        if (rmmi_ptr->report_mode.cmer_ind > 0)
        {
            /* send unsolicited result code */
            l4c_cc_handfree_rind(RMMI_CIND_BATTCHG, cind_value);
        }
    #endif /* __BT_SUPPORT__ */ 
    #if !defined(__BT_SUPPORT__)
        if (rmmi_ptr->report_mode.cmer_ind > 0) //cmer_revise == 2)
        {
            kal_sprintf((kal_char*) buffer, "+CIEV: 1, %d", cind_value);  // 1: <battchg> in +CIND
            rmmi_write_unsolicitedResultCode(
                (kal_uint8*) buffer,
                (kal_uint16) strlen((char*)buffer),
                KAL_TRUE,
                rmmi_ptr->report_mode.cmer_mode,
                (void*)&rmmi_ptr->CNMI_ResultCodeBuffer);
        }
    #endif /* !defined(__BT_SUPPORT__) */ 

        /* update indicators.battchg & send unsolicited result code */
        rmmi_ptr->indicators.battchg = cind_value;
    }
}


/*****************************************************************************
 * FUNCTION
 *  l4c_eq_alarm_detect_rind
 * DESCRIPTION
 *  This is l4c_eq_alarm_detect_rind of L4C module.
 *  hand the indication to RMMI with Alarm detect indication
 *  send +CALV : <n> to DTE.
 * PARAMETERS
 *  rtc_time        [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_eq_alarm_detect_rind(rtc_format_struct *rtc_time)
{
    /* MMI might has different other kind of alarm , 
       Here AT should send +CALV indication only when RMMI_ONLY  */
#ifndef __MMI_FMI__
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];

    kal_sprintf((kal_char*) buffer, "+CALV: 0");
    rmmi_write_to_uart((kal_uint8*) buffer, (kal_uint16)strlen((char*)buffer), KAL_TRUE);
    return;
#endif /* __MMI_FMI__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  l4c_get_adc_all_channel_rind
 * DESCRIPTION
 *  This is l4c_eq_gpio_detect_rind function of L4C module.
 *  hand the indication to RMMI with GPIO detect indication
 * PARAMETERS
 *  vbat                [IN]        
 *  bat_temp            [IN]        
 *  vaux                [IN]        
 *  charge_current      [IN]        
 *  vcharge             [IN]        
 *  file_id(?)          [IN]        The index of its record
 *  result(?)           [IN]        The result of record a file
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_get_adc_all_channel_rind(
        kal_int32 vbat,
        kal_int32 bat_temp,
        kal_int32 vaux,
        kal_int32 charge_current,
        kal_int32 vcharge)
{
    kal_uint16 string_length;
    kal_uint8 buffer[MAX_UART_LENGTH];
    kal_uint8 temp_string[64];
    double vbat_value;
    double bat_temp_value;
    double vaux_value;
    double charge_current_value;
    double vcharge_value;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    //kal_brief_trace(TRACE_FUNC, FUNC_L4C_SMS_NEW_MSG_INDEX_RIND_ENTRY);
    vbat_value = ((double)vbat) / 1000000.0;
    bat_temp_value = ((double)bat_temp) / 1000.0;
    vaux_value = ((double)vaux) / 1000000.0;
    vcharge_value = ((double)vcharge) / 1000000.0;
    charge_current_value = (double)charge_current;

    if (charge_current & 0x80000000)
    {
        charge_current_value = 0.0;
    }
    else
    {
        charge_current_value = (double)charge_current_value / 1000000.0;
    }

    kal_sprintf(
        (kal_char*) temp_string,
        "%4.2f,%4.2f,%4.2f,%4.2f,%4.2f",
        vbat_value,
        bat_temp_value,
        vaux_value,
        charge_current_value,
        vcharge_value);
    rmmi_ptr->arg_list[0] = (void*)temp_string;
    string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+EADC: %s", rmmi_ptr->arg_list, 1);

    rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
}


/*****************************************************************************
 * FUNCTION
 *  l4c_eq_gpio_detect_rind
 * DESCRIPTION
 *  This is l4c_eq_gpio_detect_rind function of L4C module.
 *  hand the indication to RMMI with GPIO detect indication
 * PARAMETERS
 *  gpio_device     [IN]        
 *  on_off          [IN]        
 *  file_id(?)      [IN]        The index of its record
 *  result(?)       [IN]        The result of record a file
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_eq_gpio_detect_rind(kal_uint8 gpio_device, kal_bool on_off)
{
#if !defined(__SLIM_AT__)
    kal_uint16 string_length;
    kal_uint8 buffer[MAX_UART_LENGTH];
    kal_uint8 device_value;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    /*
     * #define EXT_DEV_NONE                0   // None, if there is no external device 
     * #define EXT_DEV_HANDFREE        1   // Hand-free 
     * #define EXT_DEV_EARPHONE        2   // Earphone 
     * #define EXT_DEV_CARKIT             3   // Car-Kit 
     * #define EXT_DEV_KEY_1               4  // Send Key 
     * #define EXT_DEV_KEY_2               5  // Reserved 
     * #define EXT_DEV_UART                6
     * #define EXT_DEV_CLAM_OPEN     8
     * #define EXT_DEV_CLAM_CLOSE     9
     * #define MAX_EXT_DEVICE_NUM   10
     */

    //kal_brief_trace(TRACE_FUNC, FUNC_L4C_SMS_NEW_MSG_INDEX_RIND_ENTRY);
    switch (gpio_device)
    {
        case EXT_DEV_NONE:
            device_value = 0;
            break;
        case EXT_DEV_HANDFREE:
            device_value = 1;
            break;
        case EXT_DEV_EARPHONE:
            device_value = 2;
            break;
        case EXT_DEV_CARKIT:
            device_value = 3;
            break;
        case EXT_DEV_KEY_1:
            device_value = 4;
            break;
        case EXT_DEV_KEY_2:
            device_value = 5;
            break;
        case EXT_DEV_UART:
            device_value = 6;
            break;
        case EXT_DEV_CLAM_OPEN:
            device_value = 8;
            break;
        case EXT_DEV_CLAM_CLOSE:
            device_value = 9;
            break;
        default:
            device_value = 10;
            break;

    }
    rmmi_ptr->arg_list[0] = (void*)&device_value;
    rmmi_ptr->arg_list[1] = (void*)&on_off;
    string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+GPIOS: %d,%d", rmmi_ptr->arg_list, 2);

    rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
#endif	
}


#ifdef __SAT__
#ifdef __RSAT__
/*****************************************************************************
 * FUNCTION
 *  l4c_sat_stkpci_rind
 * DESCRIPTION
 *  This is l4c_sat_stkpci_rind function of L4C module.
 *  construct +STKPCI unsolicited result code for RMMI
 *  mtk00924 050308 add for Remote SAT
 * PARAMETERS
 *  temp_pci_type           [IN]        
 *  temp_pro_cmd_ptr        [?]         
 *  length                  [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
static const char HexTable[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };

void l4c_sat_stkpci_rind(rsat_config_enum temp_pci_type, kal_uint8 *temp_pro_cmd_ptr, kal_uint8 length)
{
    kal_uint16 string_length;
    kal_uint8 buffer[256*2+14]; //the maximum proactive_cmd length*2 plus the +STK... and eof
    kal_uint8 buf[3]; //for storing CR LF
    kal_uint16 remain_length; //the remaining length to write to UART

    //vito kal_uint8 pro_cmd[256];
    kal_uint8 pci_type;
    kal_uint8 *ptr;     //vito
    kal_uint8 *ptrCmd;
    kal_uint32 pi;
    kal_uint16 cmd_length = length; /* length ==0 means 256 bytes of proactive command data */
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    if (rmmi_ptr->report_mode.einfo & (INFO_REPORT_MASK << RMMI_STKPCI_BIT))
    {
        //       check_sms_pdu_string (length,  /*use sms_pdu_string function tansfer value to hex string*/
        //                                           temp_pro_cmd_ptr, 
        //                                                    pro_cmd);

        /* MAUI_02868445 mtk01616_110212: No need to distinguish this type now */
        if (temp_pci_type == RSAT_BY_SIM /* || temp_pci_type == RSAT_BY_L4C */ )
        {
            pci_type = 1;   /* handled by ME */
        }

        if (temp_pci_type == RSAT_BY_TE)
        {
            pci_type = 0;   /* handled by TE */
        }

        rmmi_ptr->arg_list[0] = (void*)&pci_type;
        //vito   RMMI_PTR->arg_list[1] = (void *)&pro_cmd;

        string_length = rmmi_fast_string_print(buffer,
                                               //                                                   (kal_uint8 *)"+STKPCI: %d,\"%s\"",  
                                               (kal_uint8*) "+STKPCI: %d,\"", rmmi_ptr->arg_list, 1);
        //vito                                                   2);

        ptr = buffer + string_length;
        ptrCmd = temp_pro_cmd_ptr;

        /* mtk00732 length == 0 means 256 bytes of proactive command data */
        if (0 == length)
        {
            cmd_length = 256;
        }

        for (pi = 0; pi < cmd_length; pi++)
        {
            *ptr = HexTable[*ptrCmd >> 4];
            ptr++;
            *ptr = HexTable[*ptrCmd & 0xF];
            ptr++;
            ptrCmd++;
        }

        *ptr++ = '\"';
        *ptr = '\0';

        string_length += (kal_uint32) cmd_length *2 + 1;

        /* debug information */
        /*
         * kal_brief_trace(TRACE_GROUP_3, PCI_TYPE,pci_type);
         * kal_brief_trace(TRACE_GROUP_3, PRO_CMD, pro_cmd[0],pro_cmd[1],pro_cmd[2],pro_cmd[3],pro_cmd[4],pro_cmd[5],pro_cmd[6],pro_cmd[7],pro_cmd[8],pro_cmd[9],
         * pro_cmd[10],pro_cmd[11],pro_cmd[12],pro_cmd[13],pro_cmd[14],pro_cmd[15],pro_cmd[16],pro_cmd[17],pro_cmd[18],pro_cmd[19],
         * pro_cmd[20],pro_cmd[21],pro_cmd[22],pro_cmd[23],pro_cmd[24],pro_cmd[25],pro_cmd[26],pro_cmd[27],pro_cmd[28],pro_cmd[29], 
         * pro_cmd[30],pro_cmd[31],pro_cmd[32],pro_cmd[33],pro_cmd[34],pro_cmd[35],pro_cmd[36],pro_cmd[37],pro_cmd[38],pro_cmd[39],
         * pro_cmd[40],pro_cmd[41],pro_cmd[42],pro_cmd[43],pro_cmd[44],pro_cmd[45],pro_cmd[46],pro_cmd[47],pro_cmd[48],pro_cmd[49],
         * pro_cmd[50],pro_cmd[51],pro_cmd[52],pro_cmd[53],pro_cmd[54],pro_cmd[55],pro_cmd[56],pro_cmd[57],pro_cmd[58],pro_cmd[59]);
         */
        remain_length = string_length;
        ptr = buffer;
        kal_sprintf((char*)buf, "%c%c", rmmi_ptr->s_reg.s3, rmmi_ptr->s_reg.s4);

        if (rmmi_ptr->rsp_mode.format != RMMI_NUM_PARTIAL_HEAD_TAIL)
        {        
            rmmi_write_to_uart((kal_uint8*) buf, 2, KAL_FALSE);//write CR LF in begining
        }
        
        //separately write to UART to prevent overwrite MAX_DATA_QUEUE_LENGTH
        while (remain_length > (MAX_DATA_QUEUE_LENGTH/2))
        {
            rmmi_write_to_uart((kal_uint8*) ptr, (MAX_DATA_QUEUE_LENGTH/2), KAL_FALSE);
            ptr += (MAX_DATA_QUEUE_LENGTH/2);
            remain_length -= (MAX_DATA_QUEUE_LENGTH/2);
        }
        
        rmmi_write_to_uart((kal_uint8*) ptr, remain_length, KAL_FALSE);
        rmmi_write_to_uart((kal_uint8*) buf, 2, KAL_FALSE); //write CR LF end
    }

    return;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_sat_no_other_cmd_rind
 * DESCRIPTION
 *  This is l4c_sat_no_other_cmd_rind function of L4C module.
 *  construct +STKPCI unsolicited result code for RMMI
 *  mtk00924 050308 add for Remote SAT
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_sat_no_other_cmd_rind(void)
{
    kal_uint8 string_length;
    kal_uint8 const *rsp_str = NULL;    /* response string and initialization */
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    if (rmmi_ptr->report_mode.einfo & (INFO_REPORT_MASK << RMMI_STKPCI_BIT))
    {
        rsp_str = (kal_uint8 const*)"+STKPCI: 2";   /* prepare the response string *///vito change = to :
        string_length = (kal_uint8)strlen((char*)rsp_str);     /* type casting */

        rmmi_write_to_uart((kal_uint8*) rsp_str, string_length, KAL_TRUE);
    }
    return;
}


/*****************************************************************************
 * FUNCTION
 *  l4c_sat_stktrind_rind
 * DESCRIPTION
 *  This is l4c_sat_stkpci_rind function of L4C module.
 *  construct +STKRIND unsolicited result code for RMMI
 *  mtk00924 050308 add for Remote SAT
 * PARAMETERS
 *  result                          [IN]        
 *  size_of_additional_info         [IN]        
 *  temp_additional_info_ptr        [?]         
 * RETURNS
 *  void
 *****************************************************************************/
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

#endif /* __RSAT__ */ 
#endif /* __SAT__ */ 
/*****************************************************************************
 * FUNCTION
 *  l4c_sat_run_at_command_rind
 * DESCRIPTION
 *  
 * PARAMETERS
 *  local_ptr       [?]     
 *  peer_ptr        [?]     
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_sat_run_at_command_rind(sat_run_at_command_ind_struct *local_ptr, sat_run_at_command_ind_peer_struct *peer_ptr)      //mtk00714 add for benson SAT
{
#ifdef __SAT__
#ifdef __SATCB__
    sat_run_at_command_ind_struct *msg_ptr;

    //sat_run_at_command_ind_peer_struct *peer_buff = NULL;
    sat_run_at_command_res_struct *param;
    rmmi_string_struct temp_struct;
    kal_uint8 length;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    l4c_context_struct *l4c_ptr = L4C_PTR;
    
#if defined(__GEMINI__) && defined(__DISABLE_SIM2_AT_SUPPORT__)//mtk01616_100511: prevent SIM2 event to update RMMI context
    if(l4c_current_mod_id == MOD_L4C_2)
        return;		
#endif

    msg_ptr = (sat_run_at_command_ind_struct*) local_ptr;
    param = (sat_run_at_command_res_struct*) construct_local_para(
                                                (kal_uint16) sizeof(sat_run_at_command_res_struct),
                                                TD_RESET);
    kal_mem_cpy(param->cmd_detail, msg_ptr->cmd_detail, 5);	// modified by mtk02514_081216

    /* only allow SAT at command when there's no current at command action */
    if ((rmmi_ptr->IsSATcommand == KAL_TRUE)
        //||(L4C_PTR->cc_sub_state[RMMI_SRC] == L4C_CMD_FORWARDED_FOR_ACTION_STATE))
        || (l4c_ptr->cc_current_action[RMMI_SRC] != L4C_NO_ACTION))
    {
        param->res = SAT_ME_CURRENTLY_UNABLE_TO_PROCESS_CMD;    //res
        l4c_sat_run_at_command_res(param);
    }
    else
    {
        rmmi_ptr->SAT_rsp_ptr = (sat_run_at_command_res_struct*) param;
        rmmi_ptr->IsSATcommand = KAL_TRUE;
        rmmi_ptr->IsSATresponse = KAL_TRUE;

        length = peer_ptr->no_at_command;
        temp_struct.index = 0;
        ASSERT((kal_uint16) length + 2 < 2048);
        temp_struct.string_ptr = get_ctrl_buffer((kal_uint16) (length + 2));
        kal_mem_cpy(temp_struct.string_ptr, peer_ptr->at_command, length);
        temp_struct.string_ptr[length] = rmmi_ptr->s_reg.s3;
        temp_struct.string_ptr[length + 1] = RMMI_END_OF_STRING_CHAR;
        temp_struct.src_id = RMMI_SAT;
        rmmi_cmd_processor(&temp_struct, length+1);
        free_ctrl_buffer(temp_struct.string_ptr);
    }
#endif /*__SATCB__*/
#endif /* __SAT__ */ 
}

#if defined(__CTM_SUPPORT__) && defined(__CTM_AT_CMD_SUPPORT__)
/*****************************************************************************
 * FUNCTION
 *  l4c_ctm_connected_rind
 * DESCRIPTION
 *  This is l4c_ctm_connected_rind function of L4C module.
 *  Indicate the far-end CTM detected
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_ctm_connected_rind()
{
    kal_uint8 string_length;
    kal_uint8 const *rsp_str = NULL;

    rsp_str = (kal_uint8 const*)"+CTMI";
    string_length = strlen((char*)rsp_str);

    kal_brief_trace(TRACE_GROUP_1, CTMI);

    rmmi_write_to_uart((kal_uint8*) rsp_str, string_length, KAL_TRUE);
    return;

}


/*****************************************************************************
 * FUNCTION
 *  l4c_ctm_recv_text_rind
 * DESCRIPTION
 *  This is l4c_ctm_recv_text_rind function of L4C module.
 *  format the character received to TE
 * PARAMETERS
 *  num_of_char     [IN]        
 *  text            [?]         
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_ctm_recv_text_rind(kal_uint16 num_of_char, kal_wchar *text)
{

    kal_uint16 string_length;
    kal_uint8 buffer[MAX_UART_LENGTH];
    kal_uint8 ascii_string[MAX_UART_LENGTH];
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    rmmi_ptr->arg_list[0] = (void*)&rmmi_ptr->s_reg.s3;
    rmmi_ptr->arg_list[1] = (void*)&rmmi_ptr->s_reg.s4;

    //rmmi_byte_order_reverse((kal_uint8 *)text, (num_of_char)*2);
    ucs2_to_ascii(text, ascii_string);

    rmmi_ptr->arg_list[2] = (void*)ascii_string;

    string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CTMR:%c%c%s", rmmi_ptr->arg_list, 3);

    kal_sys_trace((kal_char*) buffer);  /* for print string, can't take off */

    rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
    //#endif
}


/*****************************************************************************
 * FUNCTION
 *  l4c_ctm_tty_plug_rind
 * DESCRIPTION
 *  This is l4c_ctm_tty_plug_rind function of L4C module.
 *  Indicate TTY device plug in or out
 * PARAMETERS
 *  is_plug_in      [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_ctm_tty_plug_rind(kal_bool is_plug_in)
{
    kal_uint16 string_length;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    rmmi_ptr->arg_list[0] = (void*)&is_plug_in;
    string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+TTYI: %d", rmmi_ptr->arg_list, 1);

    kal_brief_trace(TRACE_GROUP_1, TIYI, is_plug_in);

    rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
    return;

}


/*****************************************************************************
 * FUNCTION
 *  l4c_ctm_default_changed_rind
 * DESCRIPTION
 *  This is l4c_ctm_default_changed_rind function of L4C module.
 *  Indicate the default CTM setting is changed by LMMI
 * PARAMETERS
 *  is_turn_on          [IN]        
 *  ctm_interface       [IN]        
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_ctm_default_changed_rind(kal_bool is_turn_on, kal_uint8 ctm_interface)
{
    kal_uint16 string_length;
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    rmmi_ptr->arg_list[0] = (void*)&is_turn_on;
    rmmi_ptr->arg_list[1] = (void*)&ctm_interface;

#if defined(__GEMINI__) && defined(__DISABLE_SIM2_AT_SUPPORT__)//mtk01616_100511: prevent SIM2 event to update RMMI context
    if(l4c_current_mod_id == MOD_L4C_2)
        return;		
#endif

    rmmi_ptr->is_ctm_turn_on = is_turn_on;

    string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+CTMS: %d, %d", rmmi_ptr->arg_list, 2);

    kal_brief_trace(TRACE_GROUP_1, CTMS, is_turn_on, ctm_interface);

    rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);
    return;

}

#endif /* __CTM_SUPPORT__ */ 

#if !defined(__MMI_FMI__)
/*****************************************************************************
 * FUNCTION
 *  l4c_file_change_rind
 * DESCRIPTION
 *  
 * PARAMETERS
 *  is_full_change      [IN]        
 *  num_of_file         [IN]        
 *  file_list           [?]         
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_file_change_rind(kal_bool is_full_change, kal_uint8 num_of_file, kal_uint16 *file_list)
{
#if !defined(__SLIM_AT__)
    kal_uint16 string_length;
    kal_uint8 buffer[MAX_UART_LENGTH];
    kal_uint8 i = 0;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    kal_mem_set(buffer, 0x00, MAX_UART_LENGTH);

    if (is_full_change)
    {
    	if (rmmi_ptr->report_mode.eind & (INFO_REPORT_MASK << RMMI_EIND_PLMN_CHANGED_BIT))
        {
            kal_sprintf((kal_char*) buffer, "+EIND: 4");
            string_length = (kal_uint16)strlen((char*)buffer);
            rmmi_write_to_uart(buffer, string_length, KAL_TRUE);
        }
		
    	if (rmmi_ptr->report_mode.eind & (INFO_REPORT_MASK << RMMI_EIND_EONS_CHANGED_BIT))
        {            
            kal_mem_set(buffer, 0x00, MAX_UART_LENGTH);
        	kal_sprintf((kal_char*) buffer, "+EIND: 8");
            string_length = (kal_uint16)strlen((char*)buffer);
            rmmi_write_to_uart(buffer, string_length, KAL_TRUE);
        }
			
    }
    else
    {
        kal_bool is_plmn_file_change, is_eons_file_change;

        is_plmn_file_change = KAL_FALSE;
        is_eons_file_change = KAL_FALSE;

        for (i = 0; i < num_of_file; i++)
        {
            if ((file_list[i] == FILE_PLMNSEL_IDX || file_list[i] == FILE_PLMNWACT_IDX ||
                 file_list[i] == FILE_OPLMNWACT_IDX || file_list[i] == FILE_HPLMNACT_IDX) &&
                is_plmn_file_change == KAL_FALSE)
            {
                if (rmmi_ptr->report_mode.eind & (INFO_REPORT_MASK << RMMI_EIND_PLMN_CHANGED_BIT))
                {
                    is_plmn_file_change = KAL_TRUE;
                    kal_sprintf((kal_char*) buffer, "+EIND: 4");
                    string_length = (kal_uint16)strlen((char*)buffer);
                    rmmi_write_to_uart(buffer, string_length, KAL_TRUE);
                }
            }
            else if ((file_list[i] == FILE_PNN_IDX || file_list[i] == FILE_OPL_IDX) && is_eons_file_change == KAL_FALSE)
            {
                if (rmmi_ptr->report_mode.eind & (INFO_REPORT_MASK << RMMI_EIND_EONS_CHANGED_BIT))
                {            
                    is_eons_file_change = KAL_TRUE;
                    kal_sprintf((kal_char*) buffer, "+EIND: 8");
                    string_length = (kal_uint16)strlen((char*)buffer);
                    rmmi_write_to_uart(buffer, string_length, KAL_TRUE);
                }
            }
        }
    }

#endif /* !defined(__SLIM_AT__) */ 
}

/*****************************************************************************
 * FUNCTION
 *  l4c_sim_status_update_rind
 * DESCRIPTION
 *  To send +ESIMS URC to report SIM1/2 inserted status
 *  Similar to MSG_ID_MMI_SMU_SIM_STATUS_UPDATE_IND
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_sim_status_update_rind(kal_bool is_sim_inserted, kal_uint8 passwd_required)  
{
    kal_uint8 buffer[MAX_UART_LENGTH];
    kal_uint8 string_length;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    kal_uint8 temp_src = rmmi_ptr->current_src;    

    rmmi_ptr->current_src = RMMI_UNSOLICITED;

    if (rmmi_ptr->report_mode.esims > 0)
    {
        kal_sprintf((kal_char*) buffer, "+ESIMS: %d,%d", (kal_uint8)is_sim_inserted, passwd_required);
        string_length = (kal_uint8)strlen((char*)buffer);
        rmmi_write_to_uart(buffer, string_length, KAL_TRUE);
    }

    rmmi_ptr->current_src = temp_src;
}

/*****************************************************************************
 * FUNCTION
 *  l4c_sim_usim_type_rind
 * DESCRIPTION
 *  To send +ESIMS URC to indicate the SIM card is USIM or SIM
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_sim_usim_type_rind(kal_bool is_usim)  
{
    kal_uint8 buffer[MAX_UART_LENGTH];
    kal_uint8 string_length;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    if (rmmi_ptr->report_mode.eusim > 0)
    {
        kal_sprintf((kal_char*) buffer, "+EUSIM: %d", (kal_uint8)is_usim);
        string_length = (kal_uint8)strlen((char*)buffer);
        rmmi_write_to_uart(buffer, string_length, KAL_TRUE);
    }
}

/*****************************************************************************
 * FUNCTION
 *  l4c_sim_cipher_rind
 * DESCRIPTION
 *  To send +ECIPH URC to indicate cihper indication
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_sim_cipher_rind(kal_bool sim_cipher_ind, kal_bool mm_connection, kal_uint8 cs_cipher_on, kal_uint8 ps_cipher_on)
{
    kal_uint8 buffer[MAX_UART_LENGTH];
    kal_uint8 string_length;
    kal_uint8 temp_src = RMMI_PTR->current_src;

    RMMI_PTR->current_src = RMMI_UNSOLICITED;

    if (RMMI_PTR->report_mode.einfo & (INFO_REPORT_MASK << RMMI_ECIPH_BIT))
    {
        kal_sprintf((kal_char*) buffer, "+ECIPH: %d,%d,%d,%d", (kal_uint8)sim_cipher_ind, (kal_uint8)mm_connection, cs_cipher_on, ps_cipher_on);
        string_length = (kal_uint8)strlen((char*)buffer);
        rmmi_write_to_uart(buffer, string_length, KAL_TRUE);
    }
    RMMI_PTR->current_src = temp_src;
}

#ifdef __NBR_CELL_INFO__
void l4c_nbr_cell_info_rind(kal_uint8 rat,kal_bool is_nbr_info_valid,  kal_uint8 *cell_info, kal_uint16 length)
{
		
    kal_uint16 string_length;
    kal_uint8 buffer[512];
    kal_uint8 *str;
    kal_uint16 i,j;	
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    if (16 + length*2 > 512)
    {
	//kal_prompt_trace(MOD_L4C,"Cell info size too large!");
	return;
    }

    str = (kal_uint8*)get_ctrl_buffer(512);
	   
    j=0;
    for (i=0; i<length; i++)
    {
	kal_sprintf((char*)str +j, "%02X", cell_info[i]); // M=2
	j += 2;	
    }
    str[j] = '\0';

    rmmi_ptr->arg_list[0] = (void*)&is_nbr_info_valid;
    rmmi_ptr->arg_list[1] = (void*)&rat;	
    rmmi_ptr->arg_list[2] = (void*)str;	        

    string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "+ECELLINFO: %d,%d,%s", rmmi_ptr->arg_list, 3);	
    rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_TRUE);	

    free_ctrl_buffer(str);
    //kal_prompt_trace(MOD_L4C,"cell_info_rind size:%d, %d, %d",string_length, length*2, 512);
}
#endif

#if defined(__MODEM_EM_MODE__) || defined(__SLIM_MODEM_EM_MODE__)
void l4c_em_status_rind(kal_uint8 type, kal_uint8 *nw_info, kal_uint16 length)
{
    kal_uint16 string_length;
    kal_uint16 output_len;
    kal_uint16 finish_len = 0;
    kal_uint8 buffer[MAX_DATA_QUEUE_LENGTH];
    kal_uint8 *str; 
    kal_uint16 i,j;	
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;

    str = (kal_uint8*)get_ctrl_buffer(MAX_DATA_QUEUE_LENGTH);
      
    rmmi_ptr->arg_list[0] = (void*)&rmmi_ptr->s_reg.s3;	 
    rmmi_ptr->arg_list[1] = (void*)&rmmi_ptr->s_reg.s4;
    rmmi_ptr->arg_list[2] = (void*)&type;
    string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "%c%c+ENWINFO: %d,", rmmi_ptr->arg_list, 3);	
    rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_FALSE);
    
    while(length > 0)
    {	
        if ((1+length*2)> MAX_DATA_QUEUE_LENGTH)
        {
        	//kal_prompt_trace(MOD_L4C,"NW info size too large!");
        	//return;
        	output_len = (MAX_DATA_QUEUE_LENGTH/2) - 1;
        }
        else
        {
            output_len = length;
        }
        
        //j=0;
        for (i=0, j=0; i<output_len; i++)
        {
        	kal_sprintf((char*)str +j, "%02X", nw_info[i+finish_len]);
        	j += 2 ;	
        }
        str[j] = '\0'; 
        rmmi_ptr->arg_list[0] = (void*)str;	  	
    
        string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "%s", rmmi_ptr->arg_list, 1);		
        rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_FALSE);	
        finish_len += output_len;
        length -= output_len;	   
    }
    free_ctrl_buffer(str);
    
    rmmi_ptr->arg_list[0] = (void*)&rmmi_ptr->s_reg.s3;	 
    rmmi_ptr->arg_list[1] = (void*)&rmmi_ptr->s_reg.s4;
    string_length = rmmi_fast_string_print(buffer, (kal_uint8*) "%c%c", rmmi_ptr->arg_list, 2);
    rmmi_write_to_uart((kal_uint8*) buffer, string_length, KAL_FALSE);
    //kal_prompt_trace(MOD_L4C,"nw_info_rind size: type:%d, %d, %d",type,length*2 ,MAX_DATA_QUEUE_LENGTH);
}
#endif /* __MODEM_EM_MODE__ */
#endif /* __MMI_FMI__ */

#ifdef __ACMT_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  l4c_at_acmt_rind
 * DESCRIPTION
 *  report +ACMT URC
 *
 * PARAMETERS
 *  type    [IN]
 *  cause   [IN]
 *
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_at_acmt_rind(protocol_error_type_enum type, kal_uint32 cause)
{
    kal_uint8 buffer[RMMI_SHORT_RSP_LEN];
    kal_uint8 string_length;
    kal_uint8 temp_src = RMMI_PTR->current_src;

    if (RMMI_PTR->eacmt_mode == 1)
    {
        RMMI_PTR->current_src = RMMI_UNSOLICITED;
        kal_sprintf((kal_char*) buffer, "+EACMT: %d, %d", type, cause);
        string_length = strlen((char*)buffer);
        rmmi_write_to_uart(buffer, string_length, KAL_TRUE);
        RMMI_PTR->current_src = temp_src;
    }
}
#endif


#if defined(__GEMINI__)
void l4c_nw_mmrr_service_status_rind(kal_uint8 service_status)
{
    kal_uint8 buffer[MAX_UART_LENGTH];
    kal_uint8 string_length;
    kal_uint8 temp_src = RMMI_PTR->current_src;    

    RMMI_PTR->current_src = RMMI_UNSOLICITED;

    if (RMMI_PTR->report_mode.einfo & (INFO_REPORT_MASK << RMMI_EMMRRS_BIT)) 
    {
        kal_sprintf((kal_char*) buffer, "+EMMRRS: %d", service_status);
        string_length = (kal_uint8)strlen((char*)buffer);
        rmmi_write_to_uart(buffer, string_length, KAL_TRUE);
    }

    RMMI_PTR->current_src = temp_src;
    return;
}
#endif


#if defined(__REPORT_AVAILABLE_PLMN__)
/*****************************************************************************
 * FUNCTION
 *  l4c_nw_plmn_list_rind
 * DESCRIPTION
 *  This function is used to report +ECOPS URC
 * PARAMETERS
 *  list_size   [IN]
 *  list        [IN]         
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_nw_plmn_list_rind(kal_uint8 list_size, l4c_rat_plmn_info_struct *list)
{
    kal_uint8 i;
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    kal_uint8 temp_src = rmmi_ptr->current_src;

    if (rmmi_ptr->ecops_mode == 1)
    {
        rmmi_ptr->current_src = RMMI_UNSOLICITED;
        rmmi_header_rrsp("+ECOPS:");
        rmmi_int_space_rrsp(list_size);
        
        for (i=0; i<(list_size-1); i++)
        {
            rmmi_string_comma_rrsp((kal_char*)(list[i].plmn_id));
        }
        rmmi_tail_string_comma_rrsp((kal_char*)(list[i].plmn_id));
        rmmi_ptr->current_src = temp_src;
    }
}
#endif /* defined(__REPORT_AVAILABLE_PLMN__) */


#if defined(__2STAGE_NW_SELECTION__)
/*****************************************************************************
 * FUNCTION
 *  l4c_nw_modem_suspend_rind
 * DESCRIPTION
 *  This function is used to report +EMSR URC
 * PARAMETERS
 *  session_id   [IN]     
 * RETURNS
 *  void
 *****************************************************************************/
void l4c_nw_modem_suspend_rind(kal_uint8 session_id)
{
    rmmi_context_struct *rmmi_ptr = RMMI_PTR;
    kal_uint8 temp_src = rmmi_ptr->current_src;

    if (rmmi_ptr->emsr_mode == 1)
    {
        rmmi_ptr->current_src = RMMI_UNSOLICITED;
        rmmi_header_rrsp("+EMSR:");
        rmmi_tail_int_space_rrsp(session_id);
        rmmi_ptr->current_src = temp_src;
    }
}
#endif /* defined(__2STAGE_NW_SELECTION__) */


#ifdef __CNAP_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  l4c_cc_call_cnap_ind
 * DESCRIPTION
 *  To send +ECNAP URC to indicate calling name
 *  +ecnap:<call id>,<name>,<dsc>
 * PARAMETERS
 *  
 * RETURNS
 *  
 *****************************************************************************/
void l4c_cc_call_ecnap_rind(kal_uint8 call_id, kal_uint8 *name, kal_uint8 name_dcs, kal_uint8 name_length)
{
    kal_uint8 buffer[MAX_UART_LENGTH];
    kal_uint8 string_length;
    kal_uint8 temp_src = RMMI_PTR->current_src;
    kal_uint8 hex_buf[85]; /* refer to l4_name_struct.name */
    kal_uint8 hex_idx = 0;
    kal_uint8 name_idx = 0;

    kal_uint8 hexchars[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
    
    if(name_length > 42 || name_length == 0)
        return;

    RMMI_PTR->current_src = RMMI_UNSOLICITED;
    
    for(;name_idx < name_length;name_idx++)
    {
        hex_buf[hex_idx] = hexchars[(name[name_idx]>>4) & 0x0F];
        hex_idx++;

        hex_buf[hex_idx] = hexchars[name[name_idx] & 0x0F];
        hex_idx++;
    }

    hex_buf[hex_idx] = '\0';

    /* +ecnap:<call id>,<name>,<dsc> */ 
    kal_sprintf((kal_char*) buffer, "+ECNAP: %d,\"%s\",%d", call_id, hex_buf, name_dcs);
    string_length = strlen((char*)buffer);
    rmmi_write_to_uart(buffer, string_length, KAL_TRUE);
    
    RMMI_PTR->current_src = temp_src;
}

#endif


