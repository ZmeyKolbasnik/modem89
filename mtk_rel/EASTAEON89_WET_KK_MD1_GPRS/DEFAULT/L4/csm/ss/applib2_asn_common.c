/*******************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2007
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/****************************************************************************
 *
 * COMPONENT:   ASN
 * MODULE:      ASN_COMMON
 * DESCRIPTION: Autogenerated by MTK ASN.1 Compiler
 *
 ****************************************************************************/
/**
 * @file asn_common.c
 *
 * ASN.1 Common functions
 *
 * @ingroup asn_common
 */

#ifdef __AGPS_CONTROL_PLANE__

#include "applib2_mtkasn_global.h"
#include "kal_general_types.h"
#include "setjmp.h"
#include "kal_public_api.h"
#include "applib2_asn_common.h"
#include "applib2_asn_memory.h"


U16 applib2_GetUperLengthDeterminant( applib2_AsnContext *pContext )
{
   U16 length = 0;
   if( ! applib2_getShortBits( pContext, 1 ) )
   {
      /* 7 bit length */
      length = applib2_getShortBits( pContext, 7 );
   }
   else if( !applib2_getShortBits( pContext, 1 ) )
   {
      /* 14 bit length */
      length = applib2_getShortBits( pContext, 14 );
   }
   else
   {
      /* Unsupported length format */
      applib2_UA1_ERROR( 1 );
   }

   return length;
}

void applib2_PutUperLengthDeterminant( applib2_AsnContext *pContext, U16 length )
{
   if( length < 128 )
   {
      /* 8 bit length determinant */
      applib2_putShortBits( pContext, 8, length );
   }
   else if( length < 16384 )
   {
      /* 16 bit length determinant */
      applib2_putShortBits( pContext, 16, length | 0x8000 );
   }
   else
   {
      /* Unsupported length */
      applib2_UA1_ERROR( 2 );
   }
}

void applib2_AsnFreeDecoded( void *pType, applib2_PAsnMemFreeCallBack pFreeFunc)
{
   applib2_AsnDecodeFree( ( applib2_AllocRecord *)pType - 1, pFreeFunc);
}

void applib2_AsnFreeEncoded( U8 *pEncoded, applib2_PAsnMemFreeCallBack pFreeFunc)
{
   applib2_AsnEncodeFree( pEncoded, pFreeFunc);
}

void applib2_AsnRootDecodeAlloc( applib2_AsnContext *pContext, void **ppType, int size )
{
   if( !(*ppType) )
   {
      size += sizeof( applib2_AllocRecord );
      applib2_asnMemAlloc(pContext, (void**) &pContext->decodeAlloc, size );
	  pContext->decodeAlloc->ppEnd = &(pContext->decodeAlloc->pMemBlock[0]) + sizeof( pContext->decodeAlloc->pMemBlock ) / sizeof( pContext->decodeAlloc->pMemBlock[0] );
	  pContext->decodeAlloc->ppNext = &(pContext->decodeAlloc->pMemBlock[0]);
      *ppType = pContext->decodeAlloc + 1;
   }
}

void applib2_AsnDecodeAlloc( applib2_AsnContext *pContext, void **ppMem, int size )
{
   if( !pContext->decodeAlloc )
   {
      /* Attempt to allocate memory when decoding to a user supplied buffer */
      applib2_UA1_ERROR( 3 );
   }

   if( pContext->decodeAlloc->ppNext >= pContext->decodeAlloc->ppEnd )
   {
      /* Limit of runtime allocated decode memory blocks reached */
	    //printf("Limit of runtime allocated decode memory blocks reached");
	    applib2_UA1_ERROR( 4 );
   }
   applib2_asnMemAlloc(pContext, ppMem, size );
   *pContext->decodeAlloc->ppNext++ = *ppMem;
}

void applib2_AsnDecodeFree( applib2_AllocRecord *decodeAlloc, applib2_PAsnMemFreeCallBack pFreeFunc)
{
  void **ppFree;
  if( decodeAlloc )
  {
    for( ppFree = decodeAlloc->pMemBlock; ppFree < decodeAlloc->ppNext; ppFree++ )
    {
      if (pFreeFunc == NULL)
      {
        applib2_asnMemFree( ppFree );
      }
      else
      {
        pFreeFunc( ppFree );
      }
    }

    if (pFreeFunc == NULL)
    {
        applib2_asnMemFree((void**)&decodeAlloc);
    }
    else
    {
        pFreeFunc((void**)&decodeAlloc);
    }
  }
}

void applib2_AsnEncodeAlloc( applib2_AsnContext *pContext, void **ppMem, U32 *pEncodedLength )
{
   U32 size;

   if (NULL == ppMem)
   {
      // Encode length test
      pContext->pEncoded = NULL;
   }
   else
   {
      if( !(*ppMem) )
      {
         size = 1024;
         applib2_asnMemAlloc(pContext, (void**)&pContext->encodeAlloc, size );
         *ppMem = pContext->encodeAlloc;
      }
      NOT_USED( pEncodedLength );
   }
}

void applib2_AsnEncodeFree( void *pFree, applib2_PAsnMemFreeCallBack pFreeFunc)
{
   if( pFree )
   {
   	 if (pFreeFunc == NULL)
   	 {
   	   applib2_asnMemFree( &pFree );
   	 }
   	 else
   	 {
   	 	 pFreeFunc( &pFree );
   	 }
   }
}

void applib2_AsnError( applib2_AsnContext *pContext, U32 errorCode )
{
   pContext->result = errorCode;
   longjmp( pContext->env, 1 );
}

extern S32	applib2_GetAlphabetIndex(applib2_ASN_OneByteAlphabet *pAlphabet, char *pChar)
{
	U32		uIndex, left, right;
	left = 0;
	right = pAlphabet->valueLen - 1;

	while(left <= right)
    {
        uIndex = (left + right) / 2;
        if(*(pAlphabet->value+uIndex) == *pChar)
		{
            return uIndex;
		}
        else if(*(pAlphabet->value+uIndex) > *pChar)
		{
			right = uIndex - 1; 
		}
        else
		{
            left = uIndex + 1;
		}
	}
	return -1;
}

extern U32 applib2_get_number_octet_length(U32  Data)
{
	if (Data <= 0xFF) {
		return 1;
	}
	if (Data > 0xFF &&
		Data <= 0xFFFF) {
		return 2;
	}
	if (Data > 0xFFFF &&
		Data <= 0xFFFFFF) {
		return 3;
	}
	else if (Data > 0xFFFFFF &&
			Data <= 0xFFFFFFFF) {
		return 4;
	}
	else{
		return 0;
	}
}

extern Bool applib2_OIDCompare(applib2_OID  oidA, U32 lenght, U32 *pValue)
{
	if (oidA.valueLen != lenght)
	{
		return FALSE;
	}
	if (0 == applib2_asnMemCmp(oidA.value, pValue, lenght * sizeof(U32)))
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

static	struct {
	U8 *pByte;
}applib2_SkipedEncodeByte;

extern  void  applib2_SkipEncodeByte(applib2_AsnContext *pContext)
{
	applib2_SkipedEncodeByte.pByte = pContext->pEncoded;
	pContext->pEncoded += 1;
}

extern EncodeBeginPoint applib2_BeginTestEncodeLen(applib2_AsnContext *pContext)
{
	return (EncodeBeginPoint) pContext->pEncoded;
}

extern  U32 applib2_EndTestEncodeLen(applib2_AsnContext *pContext, EncodeBeginPoint	BeginPoint)
{
	S32	len;
	ASSERT(BeginPoint != 0);

	len = (U32)pContext->pEncoded - (U32)BeginPoint;
	len = len > 0 ? len : -len ;
	return len;
}

extern U32 applib2_testGetShortBits( applib2_AsnContext *pContext, U32 numBits)
{
	U32		result;
	applib2_AsnContext TempContext = *pContext;
	result = applib2_getShortBits(&TempContext, numBits);

	return result;
}

extern  void applib2_PutShortSkipedEncodeByte(applib2_AsnContext *pContext,  U32 uByte, U32 Data, U32 uAfterSize)
{
	applib2_AsnContext	tempContext;

	if (uAfterSize != 0)
	{
		ASSERT(1 >= uByte);
	}

	if (1 < uByte)
	{
		applib2_asnMemMove(applib2_SkipedEncodeByte.pByte+uByte, applib2_SkipedEncodeByte.pByte + 1, uAfterSize);
	}

	tempContext = *pContext;
	pContext->pEncoded = applib2_SkipedEncodeByte.pByte;
	applib2_putShortBits(pContext, uByte * 8, Data);

	*pContext = tempContext;
}


#define MAX_BITS_FOR_SHORT (24)
#define BIT_MASK_ARRAY_LENGTH (33)

static const U32 lsbMask[BIT_MASK_ARRAY_LENGTH]=
{
0x00000000,
0x00000001, 0x00000003, 0x00000007, 0x0000000f,
0x0000001f, 0x0000003f, 0x0000007f, 0x000000ff,
0x000001ff, 0x000003ff, 0x000007ff, 0x00000fff,
0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff,
0x0001ffff, 0x0003ffff, 0x0007ffff, 0x000fffff,
0x001fffff, 0x003fffff, 0x007fffff, 0x00ffffff,
0x01ffffff, 0x03ffffff, 0x07ffffff, 0x0fffffff,
0x1fffffff, 0x3fffffff, 0x7fffffff, 0xffffffff
};

extern void applib2_initFifo( applib2_AsnContext *pContext, U8 *buffer, U32 bufferLength )
{
   pContext->pEncoded = buffer;
   pContext->pEncodedEnd = buffer + bufferLength;
   pContext->shiftRegister = pContext->shiftRegisterLength = 0;
   pContext->result = 0;
}

extern void applib2_flushFifo( applib2_AsnContext *pContext )
{
   if( pContext->shiftRegisterLength > 0 )
   {
      if (NULL == pContext->pEncoded)
      {
         pContext->shiftRegister++;
	  }
      else
      {
         *pContext->pEncoded++ = (U8)(pContext->shiftRegister >> 24);
	  }
   }
}

extern U32 applib2_getShortBits( applib2_AsnContext *pContext, U32 numBits )
{
   U32 retVal;
   ASSERT( numBits <= MAX_BITS_FOR_SHORT );

   while ( numBits > pContext->shiftRegisterLength )
   {
      if( pContext->pEncoded >= pContext->pEncodedEnd )
      {
         applib2_UA1_ERROR( 5 );
      }

      pContext->shiftRegister |= *pContext->pEncoded++ << (24 - pContext->shiftRegisterLength);
      pContext->shiftRegisterLength += 8;
   }

   retVal = pContext->shiftRegister >> (32 - numBits);
   pContext->shiftRegister <<= numBits;
   pContext->shiftRegisterLength -= numBits;

   return( retVal );
}

extern U32 applib2_getBits( applib2_AsnContext *pContext, U32 numBits )
{
   U32 retVal;
   ASSERT( numBits <= 32 );
   if ( numBits <= MAX_BITS_FOR_SHORT )
   {
      retVal = (U32)applib2_getShortBits( pContext, numBits );
   }
   else
   {
      retVal = (U32) applib2_getShortBits( pContext, MAX_BITS_FOR_SHORT );
      numBits -= MAX_BITS_FOR_SHORT;
      /* ASN.1 is big endian so first n bits go at top of word */
      retVal <<= numBits;
      retVal |= (U32)applib2_getShortBits( pContext, numBits );
   }
   return( retVal );
}

extern void applib2_getLongBits( applib2_AsnContext *pContext, U32 numBits, U8 *outputBuffer )
{
   while ( numBits >= 8 )
   {
      if( pContext->pEncoded >= pContext->pEncodedEnd )
      {
         applib2_UA1_ERROR( 6 );
      }
      pContext->shiftRegister |= *pContext->pEncoded++ << (24 - pContext->shiftRegisterLength);
      *outputBuffer++ = (U8)(pContext->shiftRegister >> 24);
      pContext->shiftRegister <<= 8;
      numBits-= 8;
   }

   if ( numBits )
   {
      *outputBuffer = (U8)(applib2_getShortBits( pContext, numBits ) << (8 - numBits));
   }
}

extern void applib2_putShortBits( applib2_AsnContext *pContext, U32 numBits, U32 data )
{
   ASSERT( numBits <= MAX_BITS_FOR_SHORT );
   ASSERT( 0 == (data & ~lsbMask[numBits]) );

   if (NULL != pContext->pEncoded)
   {
      pContext->shiftRegister |= data << (32 - pContext->shiftRegisterLength - numBits);
   }

   pContext->shiftRegisterLength += numBits;

   while ( pContext->shiftRegisterLength >= 8 )
   {
	  if (NULL == pContext->pEncoded)
      {
         pContext->shiftRegister++;
      }
      else
      {
         if (pContext->pEncoded >= pContext->pEncodedEnd)
         {
             applib2_UA1_ERROR(15);
         }

         *pContext->pEncoded++ = (U8)(pContext->shiftRegister >> 24);
         pContext->shiftRegister <<= 8;
      }

      pContext->shiftRegisterLength -= 8;
   }
}

extern void applib2_putBits( applib2_AsnContext *pContext, U32 numBits, U32 data )
{
   ASSERT( numBits <= 32 );
   if( numBits > MAX_BITS_FOR_SHORT )
   {
      /* Insert top 24 bits */
      applib2_putShortBits( pContext, MAX_BITS_FOR_SHORT, data >> (numBits - MAX_BITS_FOR_SHORT) );
      /* reduce amount to fit, and then mask off bits inserted */
      numBits -= MAX_BITS_FOR_SHORT;
      data &= lsbMask[numBits];
   }
   applib2_putShortBits( pContext, numBits, data );
}

extern void applib2_putLongBits( applib2_AsnContext *pContext, U32 numBits, U8 *data )
{
   while ( numBits >= 8 )
   {
	  if (NULL == pContext->pEncoded)
	  {
		  pContext->shiftRegister++;
	  }
	  else
      {
          if (pContext->pEncoded >= pContext->pEncodedEnd)
          {
              applib2_UA1_ERROR(15);
          }

          pContext->shiftRegister |= *data++ << ( 24 - pContext->shiftRegisterLength );
          *pContext->pEncoded++ = (U8)(pContext->shiftRegister >> 24);
          pContext->shiftRegister <<= 8;
      }

      numBits -= 8;
   }

   if ( numBits )
   {
      applib2_putShortBits( pContext, numBits, *data >> (8 - numBits) );
   }
}

void applib2_AsnRootDecodeAlloc2( applib2_AsnContext *pContext, void **ppType, int size, const char *file, unsigned long line)
{
   if( !(*ppType) )
   {
      size += sizeof( applib2_AllocRecord );
      applib2_asnMemAlloc2(pContext, (void**)&pContext->decodeAlloc, size, file, line);
      pContext->decodeAlloc->ppEnd = &(pContext->decodeAlloc->pMemBlock[0]) + sizeof( pContext->decodeAlloc->pMemBlock ) / sizeof( pContext->decodeAlloc->pMemBlock[0] );
      pContext->decodeAlloc->ppNext = &(pContext->decodeAlloc->pMemBlock[0]);
      *ppType = pContext->decodeAlloc + 1;
   }
}

void applib2_AsnDecodeAlloc2( applib2_AsnContext *pContext, void **ppMem, int size, const char *file, int line)
{
   if( !pContext->decodeAlloc )
   {
      /* Attempt to allocate memory when decoding to a user supplied buffer */
      applib2_UA1_ERROR( 3 );
   }
   if( pContext->decodeAlloc->ppNext >= pContext->decodeAlloc->ppEnd )
   {
      /* Limit of runtime allocated decode memory blocks reached */
      applib2_UA1_ERROR( 4 );
   }

   applib2_asnMemAlloc2(pContext, ppMem, size, file, line);
   *pContext->decodeAlloc->ppNext++ = *ppMem;
}

void applib2_AsnEncodeAlloc2( applib2_AsnContext *pContext, U8 **ppEncoded, U32 *pEncodedLength, const char *file, int line)
{
   U32 size;
   if( !(*ppEncoded) )
   {
      size = 1024;
      applib2_asnMemAlloc2(pContext, (void**)&pContext->encodeAlloc, size, file, line);
      *ppEncoded = pContext->encodeAlloc;
   }
   NOT_USED( pEncodedLength );
}


#endif //__AGPS_CONTROL_PLANE__