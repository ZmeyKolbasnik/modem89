/*******************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2007
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/
/****************************************************************************
 *
 *               Assignment : MTK ASN.1 Compiler
 *               CONFIDENTIAL
 *               Copyright (C) 2008 MTK Ltd. All rights reserved.
 *
 *****************************************************************************/
 /****************************************************************************
 *
 * COMPONENT:   TIME EFFICIENT -- BER	
 * MODULE:      ss_asn
 * DESCRIPTION: Autogenerated by MTK ASN.1 Compiler
 *
 ****************************************************************************/

/**
 * @file ss_asn_encode.c
 *
 */



#ifdef __AGPS_CONTROL_PLANE__

#include "applib2_asn_memory.h"
#include "applib2_asn_common.h"
#include "applib2_asn_ber_common.h"
#include "applib2_mtkasn_global.h"
#include "kal_general_types.h"
#include "string.h"
#include "setjmp.h"
#include "ss_asn.h"




/* OCTET STRING BearerServiceCode Ber encoder */
static void AsnEncode_SS2_BearerServiceCode( SS2_BearerServiceCode *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING Ext-BearerServiceCode Ber encoder */
static void AsnEncode_SS2_Ext_BearerServiceCode( SS2_Ext_BearerServiceCode *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING TBCD-STRING Ber encoder */
static void AsnEncode_SS2_TBCD_STRING( SS2_TBCD_STRING *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING AddressString Ber encoder */
static void AsnEncode_SS2_AddressString( SS2_AddressString *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* DEFINED ISDN-AddressString Ber encoder */
static void AsnEncode_SS2_ISDN_AddressString( SS2_ISDN_AddressString *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   AsnEncode_SS2_AddressString(pType, pContext, tag);
}

/* DEFINED FTN-AddressString Ber encoder */
static void AsnEncode_SS2_FTN_AddressString( SS2_FTN_AddressString *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   AsnEncode_SS2_AddressString(pType, pContext, tag);
}

/* OCTET STRING ISDN-SubaddressString Ber encoder */
static void AsnEncode_SS2_ISDN_SubaddressString( SS2_ISDN_SubaddressString *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING SignalInfo Ber encoder */
static void AsnEncode_SS2_SignalInfo( SS2_SignalInfo *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* ENUMERATED ProtocolId Ber encoder */
static void AsnEncode_SS2_ProtocolId( SS2_ProtocolId *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* ENUMERATED Ext-ProtocolId Ber encoder */
static void AsnEncode_SS2_Ext_ProtocolId( SS2_Ext_ProtocolId *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* OCTET STRING LongSignalInfo Ber encoder */
static void AsnEncode_SS2_LongSignalInfo( SS2_LongSignalInfo *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* ENUMERATED AccessNetworkProtocolId Ber encoder */
static void AsnEncode_SS2_AccessNetworkProtocolId( SS2_AccessNetworkProtocolId *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* OCTET STRING AlertingPattern Ber encoder */
static void AsnEncode_SS2_AlertingPattern( SS2_AlertingPattern *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* DEFINED IMSI Ber encoder */
static void AsnEncode_SS2_IMSI( SS2_IMSI *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   AsnEncode_SS2_TBCD_STRING(pType, pContext, tag);
}

/* DEFINED ASCI-CallReference Ber encoder */
static void AsnEncode_SS2_ASCI_CallReference( SS2_ASCI_CallReference *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   AsnEncode_SS2_TBCD_STRING(pType, pContext, tag);
}

/* OCTET STRING TMSI Ber encoder */
static void AsnEncode_SS2_TMSI( SS2_TMSI *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* CHOICE SubscriberId Ber encoder */
extern U32 AsnEncode_SS2_SubscriberId( SS2_SubscriberId *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   
   {
      switch( pType->selection )
      {
         case SS2_SubscriberId_imsi_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 0;
            AsnEncode_SS2_IMSI(&pType->choice.imsi, pContext, tag);
         }
         break;
         
         case SS2_SubscriberId_tmsi_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 1;
            AsnEncode_SS2_TMSI(&pType->choice.tmsi, pContext, tag);
         }
         break;
         
         default:
           /* Constraint Violation */
            applib2_UA1_ERROR( 100 );
         break;
      }
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* DEFINED IMEI Ber encoder */
static void AsnEncode_SS2_IMEI( SS2_IMEI *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   AsnEncode_SS2_TBCD_STRING(pType, pContext, tag);
}

/* DEFINED HLR-Id Ber encoder */
static void AsnEncode_SS2_HLR_Id( SS2_HLR_Id *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   AsnEncode_SS2_IMSI(pType, pContext, tag);
}

/* SEQUENCE OF HLR-List Ber encoder */
static void AsnEncode_SS2_HLR_List( SS2_HLR_List *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_HLR_Id((SS2_HLR_Id *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* OCTET STRING LMSI Ber encoder */
static void AsnEncode_SS2_LMSI( SS2_LMSI *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING GlobalCellId Ber encoder */
static void AsnEncode_SS2_GlobalCellId( SS2_GlobalCellId *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* ENUMERATED NetworkResource Ber encoder */
static void AsnEncode_SS2_NetworkResource( SS2_NetworkResource *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* ENUMERATED AdditionalNetworkResource Ber encoder */
static void AsnEncode_SS2_AdditionalNetworkResource( SS2_AdditionalNetworkResource *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* OCTET STRING NAEA-CIC Ber encoder */
static void AsnEncode_SS2_NAEA_CIC( SS2_NAEA_CIC *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* CHOICE SubscriberIdentity Ber encoder */
static void AsnEncode_SS2_SubscriberIdentity( SS2_SubscriberIdentity *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      applib2_BEGIN_PRE_ENCODE
      
      switch( pType->selection )
      {
         case SS2_SubscriberIdentity_imsi_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 0;
            AsnEncode_SS2_IMSI(&pType->choice.imsi, pContext, tag);
         }
         break;
         
         case SS2_SubscriberIdentity_msisdn_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 1;
            AsnEncode_SS2_ISDN_AddressString(&pType->choice.msisdn, pContext, tag);
         }
         break;
         
         default:
           /* Constraint Violation */
            applib2_UA1_ERROR( 101 );
         break;
      }
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      if(seq_tlv.t.mode == AUTOMATIC )
      {
         if(seq_tlv.t.cl ==ContextSpecific )
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == IMPLICIT)
      {
         if(seq_tlv.t.is_tagged)
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == EXPLICIT || seq_tlv.t.mode ==EMPTY)
      {
         if(seq_tlv.t.is_tagged)
         {
            applib2_BEGIN_PRE_ENCODE
            put_tlv(pContext, &seq_tlv);
            applib2_asnMemFree((void **)&pTemp);
            applib2_BER_END_PRE_ENCODE
            seq_tlv.l.is_defined = TRUE;
            seq_tlv.l.length = ulen;
            seq_tlv.v = (U8 *)pTemp;
            put_tlv(pContext, &seq_tlv);
         }
         else
         {
            put_tlv(pContext, &seq_tlv);
         }
      }
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* ENUMERATED LCSClientInternalID Ber encoder */
static void AsnEncode_SS2_LCSClientInternalID( SS2_LCSClientInternalID *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* INTEGER LCSServiceTypeID Ber encoder */
static void AsnEncode_SS2_LCSServiceTypeID( U8 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_unsigned_integer(pContext, (U32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_unsigned_integer(pContext, (U32)*pType, tag);
   }
}

/* OCTET STRING CellGlobalIdOrServiceAreaIdFixedLength Ber encoder */
static void AsnEncode_SS2_CellGlobalIdOrServiceAreaIdFixedLength( SS2_CellGlobalIdOrServiceAreaIdFixedLength *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING LAIFixedLength Ber encoder */
static void AsnEncode_SS2_LAIFixedLength( SS2_LAIFixedLength *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* INTEGER EMLPP-Priority Ber encoder */
static void AsnEncode_SS2_EMLPP_Priority( U8 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_unsigned_integer(pContext, (U32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_unsigned_integer(pContext, (U32)*pType, tag);
   }
}

/* INTEGER MaxMC-Bearers Ber encoder */
static void AsnEncode_SS2_MaxMC_Bearers( U8 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_unsigned_integer(pContext, (U32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_unsigned_integer(pContext, (U32)*pType, tag);
   }
}

/* INTEGER MC-Bearers Ber encoder */
static void AsnEncode_SS2_MC_Bearers( U8 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_unsigned_integer(pContext, (U32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_unsigned_integer(pContext, (U32)*pType, tag);
   }
}

/* OCTET STRING Ext-SS-Status Ber encoder */
static void AsnEncode_SS2_Ext_SS_Status( SS2_Ext_SS_Status *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* INTEGER AgeOfLocationInformation Ber encoder */
static void AsnEncode_SS2_AgeOfLocationInformation( U16 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_unsigned_integer(pContext, (U32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_unsigned_integer(pContext, (U32)*pType, tag);
   }
}

/* ENUMERATED RoamingNotAllowedCause Ber encoder */
static void AsnEncode_SS2_RoamingNotAllowedCause( SS2_RoamingNotAllowedCause *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* ENUMERATED CallBarringCause Ber encoder */
static void AsnEncode_SS2_CallBarringCause( SS2_CallBarringCause *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* ENUMERATED CUG-RejectCause Ber encoder */
static void AsnEncode_SS2_CUG_RejectCause( SS2_CUG_RejectCause *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* ENUMERATED PW-RegistrationFailureCause Ber encoder */
extern U32 AsnEncode_SS2_PW_RegistrationFailureCause( SS2_PW_RegistrationFailureCause *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;
U32 encoded = 0;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   switch( *pType )
   {
   case SS2_PW_RegistrationFailureCause_undetermined:
      encoded = 0;
      break;
   case SS2_PW_RegistrationFailureCause_invalidFormat:
      encoded = 1;
      break;
   case SS2_PW_RegistrationFailureCause_newPasswordsMismatch:
      encoded = 2;
      break;
   default:
      /* Constraint Violation */
      applib2_UA1_ERROR( 102 );
      ((void)encoded);
      break;
   }

   {
      BER_TAG   tag;
      tag.is_primitive = TRUE;
      tag.cl=Universal;
      tag.tag=10;
      ber_put_enum(pContext, (U32)*pType, tag);
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* ENUMERATED SM-EnumeratedDeliveryFailureCause Ber encoder */
static void AsnEncode_SS2_SM_EnumeratedDeliveryFailureCause( SS2_SM_EnumeratedDeliveryFailureCause *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* INTEGER AbsentSubscriberDiagnosticSM Ber encoder */
static void AsnEncode_SS2_AbsentSubscriberDiagnosticSM( U8 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_unsigned_integer(pContext, (U32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_unsigned_integer(pContext, (U32)*pType, tag);
   }
}

/* ENUMERATED UnknownSubscriberDiagnostic Ber encoder */
static void AsnEncode_SS2_UnknownSubscriberDiagnostic( SS2_UnknownSubscriberDiagnostic *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* ENUMERATED AbsentSubscriberReason Ber encoder */
static void AsnEncode_SS2_AbsentSubscriberReason( SS2_AbsentSubscriberReason *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* SEQUENCE ShortTermDenialParam Ber encoder */
extern U32 AsnEncode_SS2_ShortTermDenialParam( SS2_ShortTermDenialParam *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
   NOT_USED(pType);

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE LongTermDenialParam Ber encoder */
extern U32 AsnEncode_SS2_LongTermDenialParam( SS2_LongTermDenialParam *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
   NOT_USED(pType);

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* ENUMERATED UnauthorizedLCSClient-Diagnostic Ber encoder */
static void AsnEncode_SS2_UnauthorizedLCSClient_Diagnostic( SS2_UnauthorizedLCSClient_Diagnostic *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* ENUMERATED PositionMethodFailure-Diagnostic Ber encoder */
static void AsnEncode_SS2_PositionMethodFailure_Diagnostic( SS2_PositionMethodFailure_Diagnostic *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* SEQUENCE PrivateExtension Ber encoder */
static void AsnEncode_SS2_PrivateExtension( SS2_PrivateExtension *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
   NOT_USED(pType);
}

/* SEQUENCE PCS-Extensions Ber encoder */
static void AsnEncode_SS2_PCS_Extensions( SS2_PCS_Extensions *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
   NOT_USED(pType);
}

/* SEQUENCE SLR-Arg-PCS-Extensions Ber encoder */
static void AsnEncode_SS2_SLR_Arg_PCS_Extensions( SS2_SLR_Arg_PCS_Extensions *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_SLR_Arg_PCS_Extensions_na_ESRK_Request_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* ENUMERATED LocationEstimateType Ber encoder */
static void AsnEncode_SS2_LocationEstimateType( SS2_LocationEstimateType *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* BIT STRING DeferredLocationEventType Ber encoder */
static void AsnEncode_SS2_DeferredLocationEventType( SS2_DeferredLocationEventType *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_bit_string(pContext, pType->stringData, (U16)pType->numBits, tag);
}

/* ENUMERATED LCSClientType Ber encoder */
static void AsnEncode_SS2_LCSClientType( SS2_LCSClientType *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* ENUMERATED LCS-FormatIndicator Ber encoder */
static void AsnEncode_SS2_LCS_FormatIndicator( SS2_LCS_FormatIndicator *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* OCTET STRING LCS-Priority Ber encoder */
static void AsnEncode_SS2_LCS_Priority( SS2_LCS_Priority *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING Horizontal-Accuracy Ber encoder */
static void AsnEncode_SS2_Horizontal_Accuracy( SS2_Horizontal_Accuracy *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING Vertical-Accuracy Ber encoder */
static void AsnEncode_SS2_Vertical_Accuracy( SS2_Vertical_Accuracy *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* ENUMERATED ResponseTimeCategory Ber encoder */
static void AsnEncode_SS2_ResponseTimeCategory( SS2_ResponseTimeCategory *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* BIT STRING SupportedGADShapes Ber encoder */
static void AsnEncode_SS2_SupportedGADShapes( SS2_SupportedGADShapes *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_bit_string(pContext, pType->stringData, (U16)pType->numBits, tag);
}

/* OCTET STRING LCS-ReferenceNumber Ber encoder */
static void AsnEncode_SS2_LCS_ReferenceNumber( SS2_LCS_ReferenceNumber *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* ENUMERATED PrivacyCheckRelatedAction Ber encoder */
static void AsnEncode_SS2_PrivacyCheckRelatedAction( SS2_PrivacyCheckRelatedAction *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* ENUMERATED AreaType Ber encoder */
static void AsnEncode_SS2_AreaType( SS2_AreaType *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* OCTET STRING AreaIdentification Ber encoder */
static void AsnEncode_SS2_AreaIdentification( SS2_AreaIdentification *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* ENUMERATED OccurrenceInfo Ber encoder */
static void AsnEncode_SS2_OccurrenceInfo( SS2_OccurrenceInfo *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* INTEGER IntervalTime Ber encoder */
static void AsnEncode_SS2_IntervalTime( U16 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_unsigned_integer(pContext, (U32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_unsigned_integer(pContext, (U32)*pType, tag);
   }
}

/* ENUMERATED AccuracyFulfilmentIndicator Ber encoder */
static void AsnEncode_SS2_AccuracyFulfilmentIndicator( SS2_AccuracyFulfilmentIndicator *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* OCTET STRING Ext-GeographicalInformation Ber encoder */
static void AsnEncode_SS2_Ext_GeographicalInformation( SS2_Ext_GeographicalInformation *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING PositioningDataInformation Ber encoder */
static void AsnEncode_SS2_PositioningDataInformation( SS2_PositioningDataInformation *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING UtranPositioningDataInfo Ber encoder */
static void AsnEncode_SS2_UtranPositioningDataInfo( SS2_UtranPositioningDataInfo *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING Add-GeographicalInformation Ber encoder */
static void AsnEncode_SS2_Add_GeographicalInformation( SS2_Add_GeographicalInformation *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* ENUMERATED LCS-Event Ber encoder */
static void AsnEncode_SS2_LCS_Event( SS2_LCS_Event *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* ENUMERATED TerminationCause Ber encoder */
static void AsnEncode_SS2_TerminationCause( SS2_TerminationCause *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* OCTET STRING AgeIndicator Ber encoder */
static void AsnEncode_SS2_AgeIndicator( SS2_AgeIndicator *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* ENUMERATED IST-SupportIndicator Ber encoder */
static void AsnEncode_SS2_IST_SupportIndicator( SS2_IST_SupportIndicator *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* BIT STRING SupportedLCS-CapabilitySets Ber encoder */
static void AsnEncode_SS2_SupportedLCS_CapabilitySets( SS2_SupportedLCS_CapabilitySets *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_bit_string(pContext, pType->stringData, (U16)pType->numBits, tag);
}

/* SEQUENCE ADD-Info Ber encoder */
static void AsnEncode_SS2_ADD_Info( SS2_ADD_Info *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IMEI(&pType->imeisv, pContext, tag);
      }
      
      if( pType->validity & SS2_ADD_Info_skipSubscriberDataUpdate_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* ENUMERATED CancellationType Ber encoder */
static void AsnEncode_SS2_CancellationType( SS2_CancellationType *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* INTEGER HopCounter Ber encoder */
static void AsnEncode_SS2_HopCounter( U8 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_unsigned_integer(pContext, (U32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_unsigned_integer(pContext, (U32)*pType, tag);
   }
}

/* OCTET STRING RAND Ber encoder */
static void AsnEncode_SS2_RAND( SS2_RAND *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING SRES Ber encoder */
static void AsnEncode_SS2_SRES( SS2_SRES *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING Kc Ber encoder */
static void AsnEncode_SS2_Kc( SS2_Kc *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING XRES Ber encoder */
static void AsnEncode_SS2_XRES( SS2_XRES *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING CK Ber encoder */
static void AsnEncode_SS2_CK( SS2_CK *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING IK Ber encoder */
static void AsnEncode_SS2_IK( SS2_IK *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING AUTN Ber encoder */
static void AsnEncode_SS2_AUTN( SS2_AUTN *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING AUTS Ber encoder */
static void AsnEncode_SS2_AUTS( SS2_AUTS *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING Cksn Ber encoder */
static void AsnEncode_SS2_Cksn( SS2_Cksn *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING KSI Ber encoder */
static void AsnEncode_SS2_KSI( SS2_KSI *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* ENUMERATED AccessType Ber encoder */
static void AsnEncode_SS2_AccessType( SS2_AccessType *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* ENUMERATED FailureCause Ber encoder */
static void AsnEncode_SS2_FailureCause( SS2_FailureCause *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* OCTET STRING GSN-Address Ber encoder */
static void AsnEncode_SS2_GSN_Address( SS2_GSN_Address *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING AllowedGSM-Algorithms Ber encoder */
static void AsnEncode_SS2_AllowedGSM_Algorithms( SS2_AllowedGSM_Algorithms *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING PermittedIntegrityProtectionAlgorithms Ber encoder */
static void AsnEncode_SS2_PermittedIntegrityProtectionAlgorithms( SS2_PermittedIntegrityProtectionAlgorithms *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING PermittedEncryptionAlgorithms Ber encoder */
static void AsnEncode_SS2_PermittedEncryptionAlgorithms( SS2_PermittedEncryptionAlgorithms *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* ENUMERATED KeyStatus Ber encoder */
static void AsnEncode_SS2_KeyStatus( SS2_KeyStatus *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* OCTET STRING BSSMAP-ServiceHandover Ber encoder */
static void AsnEncode_SS2_BSSMAP_ServiceHandover( SS2_BSSMAP_ServiceHandover *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING RANAP-ServiceHandover Ber encoder */
static void AsnEncode_SS2_RANAP_ServiceHandover( SS2_RANAP_ServiceHandover *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING ChosenIntegrityProtectionAlgorithm Ber encoder */
static void AsnEncode_SS2_ChosenIntegrityProtectionAlgorithm( SS2_ChosenIntegrityProtectionAlgorithm *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING ChosenEncryptionAlgorithm Ber encoder */
static void AsnEncode_SS2_ChosenEncryptionAlgorithm( SS2_ChosenEncryptionAlgorithm *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING ChosenChannelInfo Ber encoder */
static void AsnEncode_SS2_ChosenChannelInfo( SS2_ChosenChannelInfo *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING ChosenSpeechVersion Ber encoder */
static void AsnEncode_SS2_ChosenSpeechVersion( SS2_ChosenSpeechVersion *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING Codec Ber encoder */
static void AsnEncode_SS2_Codec( SS2_Codec *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING GERAN-Classmark Ber encoder */
static void AsnEncode_SS2_GERAN_Classmark( SS2_GERAN_Classmark *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING SelectedGSM-Algorithm Ber encoder */
static void AsnEncode_SS2_SelectedGSM_Algorithm( SS2_SelectedGSM_Algorithm *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING RNCId Ber encoder */
static void AsnEncode_SS2_RNCId( SS2_RNCId *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* INTEGER MulticallBearerInfo Ber encoder */
static void AsnEncode_SS2_MulticallBearerInfo( U8 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_unsigned_integer(pContext, (U32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_unsigned_integer(pContext, (U32)*pType, tag);
   }
}

/* INTEGER RAB-Id Ber encoder */
static void AsnEncode_SS2_RAB_Id( U8 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_unsigned_integer(pContext, (U32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_unsigned_integer(pContext, (U32)*pType, tag);
   }
}

/* OCTET STRING RadioResourceInformation Ber encoder */
static void AsnEncode_SS2_RadioResourceInformation( SS2_RadioResourceInformation *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING IntegrityProtectionInformation Ber encoder */
static void AsnEncode_SS2_IntegrityProtectionInformation( SS2_IntegrityProtectionInformation *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING EncryptionInformation Ber encoder */
static void AsnEncode_SS2_EncryptionInformation( SS2_EncryptionInformation *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING PLMN-Id Ber encoder */
static void AsnEncode_SS2_PLMN_Id( SS2_PLMN_Id *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* INTEGER NumberOfRequestedVectors Ber encoder */
static void AsnEncode_SS2_NumberOfRequestedVectors( U8 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_unsigned_integer(pContext, (U32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_unsigned_integer(pContext, (U32)*pType, tag);
   }
}

/* SEQUENCE Re-synchronisationInfo Ber encoder */
static void AsnEncode_SS2_Re_synchronisationInfo( SS2_Re_synchronisationInfo *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RAND(&pType->rand, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AUTS(&pType->auts, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* ENUMERATED RequestingNodeType Ber encoder */
static void AsnEncode_SS2_RequestingNodeType( SS2_RequestingNodeType *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* BIT STRING RequestedEquipmentInfo Ber encoder */
static void AsnEncode_SS2_RequestedEquipmentInfo( SS2_RequestedEquipmentInfo *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_bit_string(pContext, pType->stringData, (U16)pType->numBits, tag);
}

/* BIT STRING UESBI-IuA Ber encoder */
static void AsnEncode_SS2_UESBI_IuA( SS2_UESBI_IuA *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_bit_string(pContext, pType->stringData, (U16)pType->numBits, tag);
}

/* BIT STRING UESBI-IuB Ber encoder */
static void AsnEncode_SS2_UESBI_IuB( SS2_UESBI_IuB *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_bit_string(pContext, pType->stringData, (U16)pType->numBits, tag);
}

/* ENUMERATED EquipmentStatus Ber encoder */
static void AsnEncode_SS2_EquipmentStatus( SS2_EquipmentStatus *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* BIT STRING AccessRestrictionData Ber encoder */
static void AsnEncode_SS2_AccessRestrictionData( SS2_AccessRestrictionData *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_bit_string(pContext, pType->stringData, (U16)pType->numBits, tag);
}

/* OCTET STRING CS-AllocationRetentionPriority Ber encoder */
static void AsnEncode_SS2_CS_AllocationRetentionPriority( SS2_CS_AllocationRetentionPriority *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* INTEGER IST-AlertTimerValue Ber encoder */
static void AsnEncode_SS2_IST_AlertTimerValue( U8 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_unsigned_integer(pContext, (U32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_unsigned_integer(pContext, (U32)*pType, tag);
   }
}

/* SEQUENCE OF GMLC-List Ber encoder */
static void AsnEncode_SS2_GMLC_List( SS2_GMLC_List *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString((SS2_ISDN_AddressString *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* ENUMERATED NetworkAccessMode Ber encoder */
static void AsnEncode_SS2_NetworkAccessMode( SS2_NetworkAccessMode *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* INTEGER ContextId Ber encoder */
static void AsnEncode_SS2_ContextId( U8 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_unsigned_integer(pContext, (U32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_unsigned_integer(pContext, (U32)*pType, tag);
   }
}

/* ENUMERATED DefaultGPRS-Handling Ber encoder */
static void AsnEncode_SS2_DefaultGPRS_Handling( SS2_DefaultGPRS_Handling *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* ENUMERATED GPRS-TriggerDetectionPoint Ber encoder */
static void AsnEncode_SS2_GPRS_TriggerDetectionPoint( SS2_GPRS_TriggerDetectionPoint *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* OCTET STRING APN Ber encoder */
static void AsnEncode_SS2_APN( SS2_APN *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING PDP-Type Ber encoder */
static void AsnEncode_SS2_PDP_Type( SS2_PDP_Type *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING PDP-Address Ber encoder */
static void AsnEncode_SS2_PDP_Address( SS2_PDP_Address *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING QoS-Subscribed Ber encoder */
static void AsnEncode_SS2_QoS_Subscribed( SS2_QoS_Subscribed *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING Ext-QoS-Subscribed Ber encoder */
static void AsnEncode_SS2_Ext_QoS_Subscribed( SS2_Ext_QoS_Subscribed *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING Ext2-QoS-Subscribed Ber encoder */
static void AsnEncode_SS2_Ext2_QoS_Subscribed( SS2_Ext2_QoS_Subscribed *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING ChargingCharacteristics Ber encoder */
static void AsnEncode_SS2_ChargingCharacteristics( SS2_ChargingCharacteristics *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* ENUMERATED LSAOnlyAccessIndicator Ber encoder */
static void AsnEncode_SS2_LSAOnlyAccessIndicator( SS2_LSAOnlyAccessIndicator *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* OCTET STRING LSAIdentity Ber encoder */
static void AsnEncode_SS2_LSAIdentity( SS2_LSAIdentity *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING LSAAttributes Ber encoder */
static void AsnEncode_SS2_LSAAttributes( SS2_LSAAttributes *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING Category Ber encoder */
static void AsnEncode_SS2_Category( SS2_Category *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* ENUMERATED SubscriberStatus Ber encoder */
static void AsnEncode_SS2_SubscriberStatus( SS2_SubscriberStatus *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* SEQUENCE OF BearerServiceList Ber encoder */
static void AsnEncode_SS2_BearerServiceList( SS2_BearerServiceList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_BearerServiceCode((SS2_Ext_BearerServiceCode *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* BIT STRING ODB-GeneralData Ber encoder */
static void AsnEncode_SS2_ODB_GeneralData( SS2_ODB_GeneralData *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_bit_string(pContext, pType->stringData, (U16)pType->numBits, tag);
}

/* BIT STRING ODB-HPLMN-Data Ber encoder */
static void AsnEncode_SS2_ODB_HPLMN_Data( SS2_ODB_HPLMN_Data *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_bit_string(pContext, pType->stringData, (U16)pType->numBits, tag);
}

/* OCTET STRING Ext-ForwOptions Ber encoder */
static void AsnEncode_SS2_Ext_ForwOptions( SS2_Ext_ForwOptions *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* INTEGER Ext-NoRepCondTime Ber encoder */
static void AsnEncode_SS2_Ext_NoRepCondTime( U8 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_unsigned_integer(pContext, (U32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_unsigned_integer(pContext, (U32)*pType, tag);
   }
}

/* INTEGER CUG-Index Ber encoder */
static void AsnEncode_SS2_CUG_Index( U16 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_unsigned_integer(pContext, (U32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_unsigned_integer(pContext, (U32)*pType, tag);
   }
}

/* OCTET STRING CUG-Interlock Ber encoder */
static void AsnEncode_SS2_CUG_Interlock( SS2_CUG_Interlock *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* ENUMERATED IntraCUG-Options Ber encoder */
static void AsnEncode_SS2_IntraCUG_Options( SS2_IntraCUG_Options *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* OCTET STRING InterCUG-Restrictions Ber encoder */
static void AsnEncode_SS2_InterCUG_Restrictions( SS2_InterCUG_Restrictions *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* SEQUENCE OF PLMNClientList Ber encoder */
static void AsnEncode_SS2_PLMNClientList( SS2_PLMNClientList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 10;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCSClientInternalID((SS2_LCSClientInternalID *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* ENUMERATED GMLC-Restriction Ber encoder */
static void AsnEncode_SS2_GMLC_Restriction( SS2_GMLC_Restriction *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* ENUMERATED NotificationToMSUser Ber encoder */
static void AsnEncode_SS2_NotificationToMSUser( SS2_NotificationToMSUser *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* OCTET STRING ZoneCode Ber encoder */
static void AsnEncode_SS2_ZoneCode( SS2_ZoneCode *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* ENUMERATED RegionalSubscriptionResponse Ber encoder */
static void AsnEncode_SS2_RegionalSubscriptionResponse( SS2_RegionalSubscriptionResponse *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* BIT STRING SpecificCSI-Withdraw Ber encoder */
static void AsnEncode_SS2_SpecificCSI_Withdraw( SS2_SpecificCSI_Withdraw *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_bit_string(pContext, pType->stringData, (U16)pType->numBits, tag);
}

/* SEQUENCE OF ContextIdList Ber encoder */
static void AsnEncode_SS2_ContextIdList( SS2_ContextIdList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ContextId( (SS2_ContextId *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE OF LSAIdentityList Ber encoder */
static void AsnEncode_SS2_LSAIdentityList( SS2_LSAIdentityList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LSAIdentity((SS2_LSAIdentity *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* ENUMERATED MT-SMS-TPDU-Type Ber encoder */
static void AsnEncode_SS2_MT_SMS_TPDU_Type( SS2_MT_SMS_TPDU_Type *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* INTEGER ServiceKey Ber encoder */
static void AsnEncode_SS2_ServiceKey( U32 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_unsigned_integer(pContext, (U32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_unsigned_integer(pContext, (U32)*pType, tag);
   }
}

/* ENUMERATED O-BcsmTriggerDetectionPoint Ber encoder */
static void AsnEncode_SS2_O_BcsmTriggerDetectionPoint( SS2_O_BcsmTriggerDetectionPoint *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* SEQUENCE OF DestinationNumberList Ber encoder */
static void AsnEncode_SS2_DestinationNumberList( SS2_DestinationNumberList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString((SS2_ISDN_AddressString *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* INTEGER DestinationNumberLengthList-seqOf Ber encoder */
static void AsnEncode_SS2_DestinationNumberLengthList_seqOf( U8 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_unsigned_integer(pContext, (U32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_unsigned_integer(pContext, (U32)*pType, tag);
   }
}

/* SEQUENCE OF DestinationNumberLengthList Ber encoder */
static void AsnEncode_SS2_DestinationNumberLengthList( SS2_DestinationNumberLengthList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_DestinationNumberLengthList_seqOf( (U8 *)(&pType->element[i]), pContext, tag );
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* ENUMERATED CallTypeCriteria Ber encoder */
static void AsnEncode_SS2_CallTypeCriteria( SS2_CallTypeCriteria *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* ENUMERATED MatchType Ber encoder */
static void AsnEncode_SS2_MatchType( SS2_MatchType *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* OCTET STRING CauseValue Ber encoder */
static void AsnEncode_SS2_CauseValue( SS2_CauseValue *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* ENUMERATED DefaultCallHandling Ber encoder */
static void AsnEncode_SS2_DefaultCallHandling( SS2_DefaultCallHandling *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* INTEGER CamelCapabilityHandling Ber encoder */
static void AsnEncode_SS2_CamelCapabilityHandling( U8 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_unsigned_integer(pContext, (U32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_unsigned_integer(pContext, (U32)*pType, tag);
   }
}

/* BIT STRING SupportedCamelPhases Ber encoder */
static void AsnEncode_SS2_SupportedCamelPhases( SS2_SupportedCamelPhases *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_bit_string(pContext, pType->stringData, (U16)pType->numBits, tag);
}

/* BIT STRING OfferedCamel4CSIs Ber encoder */
static void AsnEncode_SS2_OfferedCamel4CSIs( SS2_OfferedCamel4CSIs *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_bit_string(pContext, pType->stringData, (U16)pType->numBits, tag);
}

/* BIT STRING OfferedCamel4Functionalities Ber encoder */
static void AsnEncode_SS2_OfferedCamel4Functionalities( SS2_OfferedCamel4Functionalities *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_bit_string(pContext, pType->stringData, (U16)pType->numBits, tag);
}

/* ENUMERATED SMS-TriggerDetectionPoint Ber encoder */
static void AsnEncode_SS2_SMS_TriggerDetectionPoint( SS2_SMS_TriggerDetectionPoint *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* ENUMERATED DefaultSMS-Handling Ber encoder */
static void AsnEncode_SS2_DefaultSMS_Handling( SS2_DefaultSMS_Handling *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* OCTET STRING MM-Code Ber encoder */
static void AsnEncode_SS2_MM_Code( SS2_MM_Code *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* ENUMERATED T-BcsmTriggerDetectionPoint Ber encoder */
static void AsnEncode_SS2_T_BcsmTriggerDetectionPoint( SS2_T_BcsmTriggerDetectionPoint *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* SEQUENCE ResetArg Ber encoder */
extern U32 AsnEncode_SS2_ResetArg( SS2_ResetArg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->hlr_Number, pContext, tag);
      }
      
      if( pType->validity & SS2_ResetArg_hlr_List_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_HLR_List(&pType->hlr_List, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* DEFINED GroupId Ber encoder */
static void AsnEncode_SS2_GroupId( SS2_GroupId *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   AsnEncode_SS2_TBCD_STRING(pType, pContext, tag);
}

/* DEFINED RouteingNumber Ber encoder */
static void AsnEncode_SS2_RouteingNumber( SS2_RouteingNumber *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   AsnEncode_SS2_TBCD_STRING(pType, pContext, tag);
}

/* ENUMERATED NumberPortabilityStatus Ber encoder */
static void AsnEncode_SS2_NumberPortabilityStatus( SS2_NumberPortabilityStatus *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* OCTET STRING MS-Classmark2 Ber encoder */
static void AsnEncode_SS2_MS_Classmark2( SS2_MS_Classmark2 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING MSNetworkCapability Ber encoder */
static void AsnEncode_SS2_MSNetworkCapability( SS2_MSNetworkCapability *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING MSRadioAccessCapability Ber encoder */
static void AsnEncode_SS2_MSRadioAccessCapability( SS2_MSRadioAccessCapability *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* ENUMERATED DomainType Ber encoder */
static void AsnEncode_SS2_DomainType( SS2_DomainType *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* OCTET STRING RAIdentity Ber encoder */
static void AsnEncode_SS2_RAIdentity( SS2_RAIdentity *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING GeographicalInformation Ber encoder */
static void AsnEncode_SS2_GeographicalInformation( SS2_GeographicalInformation *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING GeodeticInformation Ber encoder */
static void AsnEncode_SS2_GeodeticInformation( SS2_GeodeticInformation *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING LocationNumber Ber encoder */
static void AsnEncode_SS2_LocationNumber( SS2_LocationNumber *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* INTEGER NSAPI Ber encoder */
static void AsnEncode_SS2_NSAPI( U8 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_unsigned_integer(pContext, (U32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_unsigned_integer(pContext, (U32)*pType, tag);
   }
}

/* OCTET STRING TransactionId Ber encoder */
static void AsnEncode_SS2_TransactionId( SS2_TransactionId *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING TEID Ber encoder */
static void AsnEncode_SS2_TEID( SS2_TEID *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING GPRSChargingID Ber encoder */
static void AsnEncode_SS2_GPRSChargingID( SS2_GPRSChargingID *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* ENUMERATED NotReachableReason Ber encoder */
static void AsnEncode_SS2_NotReachableReason( SS2_NotReachableReason *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* ENUMERATED RequestedCAMEL-SubscriptionInfo Ber encoder */
static void AsnEncode_SS2_RequestedCAMEL_SubscriptionInfo( SS2_RequestedCAMEL_SubscriptionInfo *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* ENUMERATED AdditionalRequestedCAMEL-SubscriptionInfo Ber encoder */
static void AsnEncode_SS2_AdditionalRequestedCAMEL_SubscriptionInfo( SS2_AdditionalRequestedCAMEL_SubscriptionInfo *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* INTEGER WrongPasswordAttemptsCounter Ber encoder */
static void AsnEncode_SS2_WrongPasswordAttemptsCounter( U8 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_unsigned_integer(pContext, (U32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_unsigned_integer(pContext, (U32)*pType, tag);
   }
}

/* ENUMERATED ModificationInstruction Ber encoder */
static void AsnEncode_SS2_ModificationInstruction( SS2_ModificationInstruction *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* OCTET STRING TraceReference Ber encoder */
static void AsnEncode_SS2_TraceReference( SS2_TraceReference *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING TraceReference2 Ber encoder */
static void AsnEncode_SS2_TraceReference2( SS2_TraceReference2 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING TraceRecordingSessionReference Ber encoder */
static void AsnEncode_SS2_TraceRecordingSessionReference( SS2_TraceRecordingSessionReference *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* INTEGER TraceType Ber encoder */
static void AsnEncode_SS2_TraceType( U8 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_unsigned_integer(pContext, (U32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_unsigned_integer(pContext, (U32)*pType, tag);
   }
}

/* ENUMERATED TraceDepth Ber encoder */
static void AsnEncode_SS2_TraceDepth( SS2_TraceDepth *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* BIT STRING TraceNE-TypeList Ber encoder */
static void AsnEncode_SS2_TraceNE_TypeList( SS2_TraceNE_TypeList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_bit_string(pContext, pType->stringData, (U16)pType->numBits, tag);
}

/* BIT STRING MSC-S-InterfaceList Ber encoder */
static void AsnEncode_SS2_MSC_S_InterfaceList( SS2_MSC_S_InterfaceList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_bit_string(pContext, pType->stringData, (U16)pType->numBits, tag);
}

/* BIT STRING MGW-InterfaceList Ber encoder */
static void AsnEncode_SS2_MGW_InterfaceList( SS2_MGW_InterfaceList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_bit_string(pContext, pType->stringData, (U16)pType->numBits, tag);
}

/* BIT STRING SGSN-InterfaceList Ber encoder */
static void AsnEncode_SS2_SGSN_InterfaceList( SS2_SGSN_InterfaceList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_bit_string(pContext, pType->stringData, (U16)pType->numBits, tag);
}

/* BIT STRING GGSN-InterfaceList Ber encoder */
static void AsnEncode_SS2_GGSN_InterfaceList( SS2_GGSN_InterfaceList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_bit_string(pContext, pType->stringData, (U16)pType->numBits, tag);
}

/* BIT STRING RNC-InterfaceList Ber encoder */
static void AsnEncode_SS2_RNC_InterfaceList( SS2_RNC_InterfaceList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_bit_string(pContext, pType->stringData, (U16)pType->numBits, tag);
}

/* BIT STRING BMSC-InterfaceList Ber encoder */
static void AsnEncode_SS2_BMSC_InterfaceList( SS2_BMSC_InterfaceList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_bit_string(pContext, pType->stringData, (U16)pType->numBits, tag);
}

/* BIT STRING MSC-S-EventList Ber encoder */
static void AsnEncode_SS2_MSC_S_EventList( SS2_MSC_S_EventList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_bit_string(pContext, pType->stringData, (U16)pType->numBits, tag);
}

/* BIT STRING MGW-EventList Ber encoder */
static void AsnEncode_SS2_MGW_EventList( SS2_MGW_EventList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_bit_string(pContext, pType->stringData, (U16)pType->numBits, tag);
}

/* BIT STRING SGSN-EventList Ber encoder */
static void AsnEncode_SS2_SGSN_EventList( SS2_SGSN_EventList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_bit_string(pContext, pType->stringData, (U16)pType->numBits, tag);
}

/* BIT STRING GGSN-EventList Ber encoder */
static void AsnEncode_SS2_GGSN_EventList( SS2_GGSN_EventList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_bit_string(pContext, pType->stringData, (U16)pType->numBits, tag);
}

/* BIT STRING BMSC-EventList Ber encoder */
static void AsnEncode_SS2_BMSC_EventList( SS2_BMSC_EventList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_bit_string(pContext, pType->stringData, (U16)pType->numBits, tag);
}

/* SEQUENCE TracePropagationList Ber encoder */
static void AsnEncode_SS2_TracePropagationList( SS2_TracePropagationList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_TracePropagationList_traceReference_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_TraceReference(&pType->traceReference, pContext, tag);
      }
      
      if( pType->validity & SS2_TracePropagationList_traceType_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_TraceType( &pType->traceType, pContext, tag);
      }
      
      if( pType->validity & SS2_TracePropagationList_traceReference2_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_TraceReference2(&pType->traceReference2, pContext, tag);
      }
      
      if( pType->validity & SS2_TracePropagationList_traceRecordingSessionReference_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_TraceRecordingSessionReference(&pType->traceRecordingSessionReference, pContext, tag);
      }
      
      if( pType->validity & SS2_TracePropagationList_rnc_TraceDepth_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_TraceDepth(&pType->rnc_TraceDepth, pContext, tag);
      }
      
      if( pType->validity & SS2_TracePropagationList_rnc_InterfaceList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RNC_InterfaceList(&pType->rnc_InterfaceList, pContext, tag);
      }
      
      if( pType->validity & SS2_TracePropagationList_msc_s_TraceDepth_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_TraceDepth(&pType->msc_s_TraceDepth, pContext, tag);
      }
      
      if( pType->validity & SS2_TracePropagationList_msc_s_InterfaceList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 7;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_MSC_S_InterfaceList(&pType->msc_s_InterfaceList, pContext, tag);
      }
      
      if( pType->validity & SS2_TracePropagationList_msc_s_EventList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 8;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_MSC_S_EventList(&pType->msc_s_EventList, pContext, tag);
      }
      
      if( pType->validity & SS2_TracePropagationList_mgw_TraceDepth_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 9;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_TraceDepth(&pType->mgw_TraceDepth, pContext, tag);
      }
      
      if( pType->validity & SS2_TracePropagationList_mgw_InterfaceList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 10;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_MGW_InterfaceList(&pType->mgw_InterfaceList, pContext, tag);
      }
      
      if( pType->validity & SS2_TracePropagationList_mgw_EventList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 11;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_MGW_EventList(&pType->mgw_EventList, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* INTEGER SM-RP-MTI Ber encoder */
static void AsnEncode_SS2_SM_RP_MTI( U8 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_unsigned_integer(pContext, (U32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_unsigned_integer(pContext, (U32)*pType, tag);
   }
}

/* OCTET STRING SM-RP-SMEA Ber encoder */
static void AsnEncode_SS2_SM_RP_SMEA( SS2_SM_RP_SMEA *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* CHOICE Additional-Number Ber encoder */
static void AsnEncode_SS2_Additional_Number( SS2_Additional_Number *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      applib2_BEGIN_PRE_ENCODE
      
      switch( pType->selection )
      {
         case SS2_Additional_Number_msc_Number_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 0;
            AsnEncode_SS2_ISDN_AddressString(&pType->choice.msc_Number, pContext, tag);
         }
         break;
         
         case SS2_Additional_Number_sgsn_Number_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 1;
            AsnEncode_SS2_ISDN_AddressString(&pType->choice.sgsn_Number, pContext, tag);
         }
         break;
         
         default:
           /* Constraint Violation */
            applib2_UA1_ERROR( 103 );
         break;
      }
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      if(seq_tlv.t.mode == AUTOMATIC )
      {
         if(seq_tlv.t.cl ==ContextSpecific )
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == IMPLICIT)
      {
         if(seq_tlv.t.is_tagged)
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == EXPLICIT || seq_tlv.t.mode ==EMPTY)
      {
         if(seq_tlv.t.is_tagged)
         {
            applib2_BEGIN_PRE_ENCODE
            put_tlv(pContext, &seq_tlv);
            applib2_asnMemFree((void **)&pTemp);
            applib2_BER_END_PRE_ENCODE
            seq_tlv.l.is_defined = TRUE;
            seq_tlv.l.length = ulen;
            seq_tlv.v = (U8 *)pTemp;
            put_tlv(pContext, &seq_tlv);
         }
         else
         {
            put_tlv(pContext, &seq_tlv);
         }
      }
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* CHOICE SM-RP-DA Ber encoder */
static void AsnEncode_SS2_SM_RP_DA( SS2_SM_RP_DA *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      applib2_BEGIN_PRE_ENCODE
      
      switch( pType->selection )
      {
         case SS2_SM_RP_DA_imsi_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 0;
            AsnEncode_SS2_IMSI(&pType->choice.imsi, pContext, tag);
         }
         break;
         
         case SS2_SM_RP_DA_lmsi_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 1;
            AsnEncode_SS2_LMSI(&pType->choice.lmsi, pContext, tag);
         }
         break;
         
         case SS2_SM_RP_DA_serviceCentreAddressDA_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 4;
            AsnEncode_SS2_AddressString(&pType->choice.serviceCentreAddressDA, pContext, tag);
         }
         break;
         
         case SS2_SM_RP_DA_noSM_RP_DA_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 5;
            /*encode for NULL type */
            tag.is_primitive=TRUE;
            {
                 BER_TLV	null_tlv;
                 null_tlv.t=tag;
                 null_tlv.l.is_defined=TRUE;
                 null_tlv.l.length =0;
                 put_tlv(pContext, &null_tlv);
            }
         }
         break;
         
         default:
           /* Constraint Violation */
            applib2_UA1_ERROR( 104 );
         break;
      }
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      if(seq_tlv.t.mode == AUTOMATIC )
      {
         if(seq_tlv.t.cl ==ContextSpecific )
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == IMPLICIT)
      {
         if(seq_tlv.t.is_tagged)
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == EXPLICIT || seq_tlv.t.mode ==EMPTY)
      {
         if(seq_tlv.t.is_tagged)
         {
            applib2_BEGIN_PRE_ENCODE
            put_tlv(pContext, &seq_tlv);
            applib2_asnMemFree((void **)&pTemp);
            applib2_BER_END_PRE_ENCODE
            seq_tlv.l.is_defined = TRUE;
            seq_tlv.l.length = ulen;
            seq_tlv.v = (U8 *)pTemp;
            put_tlv(pContext, &seq_tlv);
         }
         else
         {
            put_tlv(pContext, &seq_tlv);
         }
      }
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* CHOICE SM-RP-OA Ber encoder */
static void AsnEncode_SS2_SM_RP_OA( SS2_SM_RP_OA *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      applib2_BEGIN_PRE_ENCODE
      
      switch( pType->selection )
      {
         case SS2_SM_RP_OA_msisdn_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 2;
            AsnEncode_SS2_ISDN_AddressString(&pType->choice.msisdn, pContext, tag);
         }
         break;
         
         case SS2_SM_RP_OA_serviceCentreAddressOA_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 4;
            AsnEncode_SS2_AddressString(&pType->choice.serviceCentreAddressOA, pContext, tag);
         }
         break;
         
         case SS2_SM_RP_OA_noSM_RP_OA_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 5;
            /*encode for NULL type */
            tag.is_primitive=TRUE;
            {
                 BER_TLV	null_tlv;
                 null_tlv.t=tag;
                 null_tlv.l.is_defined=TRUE;
                 null_tlv.l.length =0;
                 put_tlv(pContext, &null_tlv);
            }
         }
         break;
         
         default:
           /* Constraint Violation */
            applib2_UA1_ERROR( 105 );
         break;
      }
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      if(seq_tlv.t.mode == AUTOMATIC )
      {
         if(seq_tlv.t.cl ==ContextSpecific )
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == IMPLICIT)
      {
         if(seq_tlv.t.is_tagged)
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == EXPLICIT || seq_tlv.t.mode ==EMPTY)
      {
         if(seq_tlv.t.is_tagged)
         {
            applib2_BEGIN_PRE_ENCODE
            put_tlv(pContext, &seq_tlv);
            applib2_asnMemFree((void **)&pTemp);
            applib2_BER_END_PRE_ENCODE
            seq_tlv.l.is_defined = TRUE;
            seq_tlv.l.length = ulen;
            seq_tlv.v = (U8 *)pTemp;
            put_tlv(pContext, &seq_tlv);
         }
         else
         {
            put_tlv(pContext, &seq_tlv);
         }
      }
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* ENUMERATED SM-DeliveryOutcome Ber encoder */
static void AsnEncode_SS2_SM_DeliveryOutcome( SS2_SM_DeliveryOutcome *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* SEQUENCE AlertServiceCentreArg Ber encoder */
extern U32 AsnEncode_SS2_AlertServiceCentreArg( SS2_AlertServiceCentreArg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->msisdn, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AddressString(&pType->serviceCentreAddress, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* BIT STRING MW-Status Ber encoder */
static void AsnEncode_SS2_MW_Status( SS2_MW_Status *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_bit_string(pContext, pType->stringData, (U16)pType->numBits, tag);
}

/* ENUMERATED AlertReason Ber encoder */
static void AsnEncode_SS2_AlertReason( SS2_AlertReason *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* OCTET STRING SS-Code Ber encoder */
static void AsnEncode_SS2_SS_Code( SS2_SS_Code *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* INTEGER NoReplyConditionTime Ber encoder */
static void AsnEncode_SS2_NoReplyConditionTime( U8 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_unsigned_integer(pContext, (U32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_unsigned_integer(pContext, (U32)*pType, tag);
   }
}

/* OCTET STRING SS-Status Ber encoder */
static void AsnEncode_SS2_SS_Status( SS2_SS_Status *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING ForwardingOptions Ber encoder */
static void AsnEncode_SS2_ForwardingOptions( SS2_ForwardingOptions *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* ENUMERATED CliRestrictionOption Ber encoder */
static void AsnEncode_SS2_CliRestrictionOption( SS2_CliRestrictionOption *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* ENUMERATED OverrideCategory Ber encoder */
static void AsnEncode_SS2_OverrideCategory( SS2_OverrideCategory *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* INTEGER CCBS-Index Ber encoder */
static void AsnEncode_SS2_CCBS_Index( U8 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_unsigned_integer(pContext, (U32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_unsigned_integer(pContext, (U32)*pType, tag);
   }
}

/* OCTET STRING USSD-DataCodingScheme Ber encoder */
static void AsnEncode_SS2_USSD_DataCodingScheme( SS2_USSD_DataCodingScheme *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING USSD-String Ber encoder */
static void AsnEncode_SS2_USSD_String( SS2_USSD_String *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* NUMERIC STRING Password Ber encoder */
static void AsnEncode_SS2_Password( SS2_Password *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_string(pContext, (U8 *)(pType->value), pType->valueLen, tag);
}

/* ENUMERATED GuidanceInfo Ber encoder */
extern U32 AsnEncode_SS2_GuidanceInfo( SS2_GuidanceInfo *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;
U32 encoded = 0;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   switch( *pType )
   {
   case SS2_GuidanceInfo_enterPW:
      encoded = 0;
      break;
   case SS2_GuidanceInfo_enterNewPW:
      encoded = 1;
      break;
   case SS2_GuidanceInfo_enterNewPW_Again:
      encoded = 2;
      break;
   default:
      /* Constraint Violation */
      applib2_UA1_ERROR( 106 );
      ((void)encoded);
      break;
   }

   {
      BER_TAG   tag;
      tag.is_primitive = TRUE;
      tag.cl=Universal;
      tag.tag=10;
      ber_put_enum(pContext, (U32)*pType, tag);
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE OF SS-List Ber encoder */
static void AsnEncode_SS2_SS_List( SS2_SS_List *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_Code((SS2_SS_Code *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* ENUMERATED CCBS-RequestState Ber encoder */
static void AsnEncode_SS2_CCBS_RequestState( SS2_CCBS_RequestState *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* SEQUENCE OF SS-EventSpecification Ber encoder */
static void AsnEncode_SS2_SS_EventSpecification( SS2_SS_EventSpecification *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AddressString((SS2_AddressString *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* BIT STRING ServiceIndicator Ber encoder */
static void AsnEncode_SS2_ServiceIndicator( SS2_ServiceIndicator *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_bit_string(pContext, pType->stringData, (U16)pType->numBits, tag);
}

/* SEQUENCE EraseCC-EntryArg Ber encoder */
extern U32 AsnEncode_SS2_EraseCC_EntryArg( SS2_EraseCC_EntryArg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_Code(&pType->ss_Code, pContext, tag);
      }
      
      if( pType->validity & SS2_EraseCC_EntryArg_ccbs_Index_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CCBS_Index( &pType->ccbs_Index, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE EraseCC-EntryRes Ber encoder */
extern U32 AsnEncode_SS2_EraseCC_EntryRes( SS2_EraseCC_EntryRes *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_Code(&pType->ss_Code, pContext, tag);
      }
      
      if( pType->validity & SS2_EraseCC_EntryRes_ss_Status_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_Status(&pType->ss_Status, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* OCTET STRING TeleserviceCode Ber encoder */
static void AsnEncode_SS2_TeleserviceCode( SS2_TeleserviceCode *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING Ext-TeleserviceCode Ber encoder */
static void AsnEncode_SS2_Ext_TeleserviceCode( SS2_Ext_TeleserviceCode *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* INTEGER GeneralProblem Ber encoder */
static void AsnEncode_SS2_GeneralProblem( S32 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_signed_integer(pContext, (S32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_signed_integer(pContext, (S32)*pType, tag);
   }
}

/* INTEGER InvokeProblem Ber encoder */
static void AsnEncode_SS2_InvokeProblem( S32 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_signed_integer(pContext, (S32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_signed_integer(pContext, (S32)*pType, tag);
   }
}

/* INTEGER ReturnResultProblem Ber encoder */
static void AsnEncode_SS2_ReturnResultProblem( S32 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_signed_integer(pContext, (S32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_signed_integer(pContext, (S32)*pType, tag);
   }
}

/* INTEGER ReturnErrorProblem Ber encoder */
static void AsnEncode_SS2_ReturnErrorProblem( S32 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_signed_integer(pContext, (S32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_signed_integer(pContext, (S32)*pType, tag);
   }
}

/* INTEGER RejectProblem Ber encoder */
extern U32 AsnEncode_SS2_RejectProblem( SS2_RejectProblem *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TAG tag;
      tag.cl = Universal;
      tag.tag = 2;
      ber_put_signed_integer(pContext, (S32)*pType, tag);
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* INTEGER InvokeId-present Ber encoder */
static void AsnEncode_SS2_InvokeId_present( S32 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_signed_integer(pContext, (S32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_signed_integer(pContext, (S32)*pType, tag);
   }
}

/* INTEGER Code-local Ber encoder */
static void AsnEncode_SS2_Code_local( S32 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_signed_integer(pContext, (S32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_signed_integer(pContext, (S32)*pType, tag);
   }
}

/* CHOICE Code Ber encoder */
extern U32 AsnEncode_SS2_Code( SS2_Code *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   
   {
      switch( pType->selection )
      {
         case SS2_Code_local_selected:
         {
            BER_TAG   tag;
            tag.cl = Universal;
            tag.tag = 2;
            AsnEncode_SS2_Code_local( &pType->choice.local, pContext, tag );
         }
         break;
         
         case SS2_Code_global_selected:
         {
            BER_TAG   tag;
            tag.cl = Universal;
            tag.tag = 6;
            ber_put_oid(pContext, &pType->choice.global, tag);
         }
         break;
         
         default:
           /* Constraint Violation */
            applib2_UA1_ERROR( 107 );
         break;
      }
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* INTEGER Priority Ber encoder */
extern U32 AsnEncode_SS2_Priority( SS2_Priority *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TAG tag;
      tag.cl = Universal;
      tag.tag = 2;
      ber_put_unsigned_integer(pContext, (U32)*pType, tag);
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* IA5 STRING SS-UserData Ber encoder */
extern U32 AsnEncode_SS2_SS_UserData( SS2_SS_UserData *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TAG tag;
      tag.cl = Universal;
      tag.tag = 22;
      tag.is_primitive = TRUE;
      ber_put_string(pContext, (U8 *)(pType->value), pType->valueLen, tag);
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* ENUMERATED Multicall-Indicator Ber encoder */
extern U32 AsnEncode_SS2_Multicall_Indicator( SS2_Multicall_Indicator *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;
U32 encoded = 0;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   switch( *pType )
   {
   case SS2_Multicall_Indicator_nbr_SNexceeded:
      encoded = 0;
      break;
   case SS2_Multicall_Indicator_nbr_Userexceeded:
      encoded = 1;
      break;
   default:
      /* Constraint Violation */
      applib2_UA1_ERROR( 108 );
      ((void)encoded);
      break;
   }

   {
      BER_TAG   tag;
      tag.is_primitive = TRUE;
      tag.cl=Universal;
      tag.tag=10;
      ber_put_enum(pContext, (U32)*pType, tag);
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* OCTET STRING SS-Notification Ber encoder */
extern U32 AsnEncode_SS2_SS_Notification( SS2_SS_Notification *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TAG tag;
      tag.cl = Universal;
      tag.tag = 4;
      tag.is_primitive = TRUE;
      ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* INTEGER E1 Ber encoder */
static void AsnEncode_SS2_E1( U16 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_unsigned_integer(pContext, (U32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_unsigned_integer(pContext, (U32)*pType, tag);
   }
}

/* INTEGER E2 Ber encoder */
static void AsnEncode_SS2_E2( U16 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_unsigned_integer(pContext, (U32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_unsigned_integer(pContext, (U32)*pType, tag);
   }
}

/* INTEGER E3 Ber encoder */
static void AsnEncode_SS2_E3( U16 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_unsigned_integer(pContext, (U32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_unsigned_integer(pContext, (U32)*pType, tag);
   }
}

/* INTEGER E4 Ber encoder */
static void AsnEncode_SS2_E4( U16 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_unsigned_integer(pContext, (U32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_unsigned_integer(pContext, (U32)*pType, tag);
   }
}

/* INTEGER E5 Ber encoder */
static void AsnEncode_SS2_E5( U16 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_unsigned_integer(pContext, (U32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_unsigned_integer(pContext, (U32)*pType, tag);
   }
}

/* INTEGER E6 Ber encoder */
static void AsnEncode_SS2_E6( U16 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_unsigned_integer(pContext, (U32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_unsigned_integer(pContext, (U32)*pType, tag);
   }
}

/* INTEGER E7 Ber encoder */
static void AsnEncode_SS2_E7( U16 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_unsigned_integer(pContext, (U32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_unsigned_integer(pContext, (U32)*pType, tag);
   }
}

/* ENUMERATED CallOnHold-Indicator Ber encoder */
extern U32 AsnEncode_SS2_CallOnHold_Indicator( SS2_CallOnHold_Indicator *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;
U32 encoded = 0;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   switch( *pType )
   {
   case SS2_CallOnHold_Indicator_callRetrieved:
      encoded = 0;
      break;
   case SS2_CallOnHold_Indicator_callOnHold:
      encoded = 1;
      break;
   default:
      /* Constraint Violation */
      applib2_UA1_ERROR( 109 );
      ((void)encoded);
      break;
   }

   {
      BER_TAG   tag;
      tag.is_primitive = TRUE;
      tag.cl=Universal;
      tag.tag=10;
      ber_put_enum(pContext, (U32)*pType, tag);
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE ForwardCUG-InfoArg Ber encoder */
extern U32 AsnEncode_SS2_ForwardCUG_InfoArg( SS2_ForwardCUG_InfoArg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_ForwardCUG_InfoArg_cug_Index_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CUG_Index( &pType->cug_Index, pContext, tag);
      }
      
      if( pType->validity & SS2_ForwardCUG_InfoArg_suppressPrefCUG_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_ForwardCUG_InfoArg_suppressOA_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* ENUMERATED ECT-CallState Ber encoder */
static void AsnEncode_SS2_ECT_CallState( SS2_ECT_CallState *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* INTEGER NameSet-lengthInCharacters Ber encoder */
static void AsnEncode_SS2_NameSet_lengthInCharacters( S32 *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   BER_TLV	seq_tlv;
   U32   ulen;
   U8*   pTemp=(U8 *)0;
   seq_tlv.t = tag;
   if(tag.mode==EXPLICIT && tag.is_tagged)
   {
      applib2_BEGIN_PRE_ENCODE
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = EXPLICIT;
         ber_put_signed_integer(pContext, (S32)*pType, tag);
      }
      applib2_BER_END_PRE_ENCODE
   
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv); 
      applib2_asnMemFree((void **)&pTemp);
   }
   else
   {
      ber_put_signed_integer(pContext, (S32)*pType, tag);
   }
}

/* SEQUENCE NameSet Ber encoder */
static void AsnEncode_SS2_NameSet( SS2_NameSet *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_USSD_DataCodingScheme(&pType->dataCodingScheme, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_NameSet_lengthInCharacters( &pType->lengthInCharacters, pContext, tag );
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_USSD_String(&pType->nameString, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE RemotePartyNumber Ber encoder */
static void AsnEncode_SS2_RemotePartyNumber( SS2_RemotePartyNumber *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->partyNumber, pContext, tag);
      }
      
      if( pType->validity & SS2_RemotePartyNumber_partyNumberSubaddress_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_SubaddressString(&pType->partyNumberSubaddress, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE AccessRegisterCCEntryArg Ber encoder */
extern U32 AsnEncode_SS2_AccessRegisterCCEntryArg( SS2_AccessRegisterCCEntryArg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
   NOT_USED(pType);

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE CallDeflectionArg Ber encoder */
extern U32 AsnEncode_SS2_CallDeflectionArg( SS2_CallDeflectionArg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AddressString(&pType->deflectedToNumber, pContext, tag);
      }
      
      if( pType->validity & SS2_CallDeflectionArg_deflectedToSubaddress_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_SubaddressString(&pType->deflectedToSubaddress, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* ENUMERATED UUS-Service Ber encoder */
static void AsnEncode_SS2_UUS_Service( SS2_UUS_Service *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* ENUMERATED VerificationResponse Ber encoder */
static void AsnEncode_SS2_VerificationResponse( SS2_VerificationResponse *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* ENUMERATED MOLR-Type Ber encoder */
static void AsnEncode_SS2_MOLR_Type( SS2_MOLR_Type *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* ENUMERATED LocationMethod Ber encoder */
static void AsnEncode_SS2_LocationMethod( SS2_LocationMethod *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   tag.is_primitive = TRUE;
   ber_put_enum(pContext, (U32)*pType, tag);
}

/* OCTET STRING GPSAssistanceData Ber encoder */
static void AsnEncode_SS2_GPSAssistanceData( SS2_GPSAssistanceData *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* OCTET STRING DecipheringKeys Ber encoder */
static void AsnEncode_SS2_DecipheringKeys( SS2_DecipheringKeys *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   ber_put_octet_string(pContext, pType->stringData, pType->numOctets, tag);
}

/* SEQUENCE LCS-AreaEventReportArg Ber encoder */
extern U32 AsnEncode_SS2_LCS_AreaEventReportArg( SS2_LCS_AreaEventReportArg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCS_ReferenceNumber(&pType->referenceNumber, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GSN_Address(&pType->h_gmlc_address, pContext, tag);
      }
      
      if( pType->validity & SS2_LCS_AreaEventReportArg_r_gmlc_address_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GSN_Address(&pType->r_gmlc_address, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE LCS-AreaEventCancellationArg Ber encoder */
extern U32 AsnEncode_SS2_LCS_AreaEventCancellationArg( SS2_LCS_AreaEventCancellationArg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCS_ReferenceNumber(&pType->referenceNumber, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GSN_Address(&pType->h_gmlc_address, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE IMSI-WithLMSI Ber encoder */
static void AsnEncode_SS2_IMSI_WithLMSI( SS2_IMSI_WithLMSI *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IMSI(&pType->imsi, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LMSI(&pType->lmsi, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* CHOICE CellGlobalIdOrServiceAreaIdOrLAI Ber encoder */
static void AsnEncode_SS2_CellGlobalIdOrServiceAreaIdOrLAI( SS2_CellGlobalIdOrServiceAreaIdOrLAI *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      applib2_BEGIN_PRE_ENCODE
      
      switch( pType->selection )
      {
         case SS2_CellGlobalIdOrServiceAreaIdOrLAI_cellGlobalIdOrServiceAreaIdFixedLength_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 0;
            AsnEncode_SS2_CellGlobalIdOrServiceAreaIdFixedLength(&pType->choice.cellGlobalIdOrServiceAreaIdFixedLength, pContext, tag);
         }
         break;
         
         case SS2_CellGlobalIdOrServiceAreaIdOrLAI_laiFixedLength_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 1;
            AsnEncode_SS2_LAIFixedLength(&pType->choice.laiFixedLength, pContext, tag);
         }
         break;
         
         default:
           /* Constraint Violation */
            applib2_UA1_ERROR( 110 );
         break;
      }
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      if(seq_tlv.t.mode == AUTOMATIC )
      {
         if(seq_tlv.t.cl ==ContextSpecific )
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == IMPLICIT)
      {
         if(seq_tlv.t.is_tagged)
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == EXPLICIT || seq_tlv.t.mode ==EMPTY)
      {
         if(seq_tlv.t.is_tagged)
         {
            applib2_BEGIN_PRE_ENCODE
            put_tlv(pContext, &seq_tlv);
            applib2_asnMemFree((void **)&pTemp);
            applib2_BER_END_PRE_ENCODE
            seq_tlv.l.is_defined = TRUE;
            seq_tlv.l.length = ulen;
            seq_tlv.v = (U8 *)pTemp;
            put_tlv(pContext, &seq_tlv);
         }
         else
         {
            put_tlv(pContext, &seq_tlv);
         }
      }
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* CHOICE BasicServiceCode Ber encoder */
static void AsnEncode_SS2_BasicServiceCode( SS2_BasicServiceCode *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      applib2_BEGIN_PRE_ENCODE
      
      switch( pType->selection )
      {
         case SS2_BasicServiceCode_bearerService_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 2;
            AsnEncode_SS2_BearerServiceCode(&pType->choice.bearerService, pContext, tag);
         }
         break;
         
         case SS2_BasicServiceCode_teleservice_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 3;
            AsnEncode_SS2_TeleserviceCode(&pType->choice.teleservice, pContext, tag);
         }
         break;
         
         default:
           /* Constraint Violation */
            applib2_UA1_ERROR( 111 );
         break;
      }
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      if(seq_tlv.t.mode == AUTOMATIC )
      {
         if(seq_tlv.t.cl ==ContextSpecific )
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == IMPLICIT)
      {
         if(seq_tlv.t.is_tagged)
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == EXPLICIT || seq_tlv.t.mode ==EMPTY)
      {
         if(seq_tlv.t.is_tagged)
         {
            applib2_BEGIN_PRE_ENCODE
            put_tlv(pContext, &seq_tlv);
            applib2_asnMemFree((void **)&pTemp);
            applib2_BER_END_PRE_ENCODE
            seq_tlv.l.is_defined = TRUE;
            seq_tlv.l.length = ulen;
            seq_tlv.v = (U8 *)pTemp;
            put_tlv(pContext, &seq_tlv);
         }
         else
         {
            put_tlv(pContext, &seq_tlv);
         }
      }
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* CHOICE Ext-BasicServiceCode Ber encoder */
static void AsnEncode_SS2_Ext_BasicServiceCode( SS2_Ext_BasicServiceCode *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      applib2_BEGIN_PRE_ENCODE
      
      switch( pType->selection )
      {
         case SS2_Ext_BasicServiceCode_ext_BearerService_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 2;
            AsnEncode_SS2_Ext_BearerServiceCode(&pType->choice.ext_BearerService, pContext, tag);
         }
         break;
         
         case SS2_Ext_BasicServiceCode_ext_Teleservice_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 3;
            AsnEncode_SS2_Ext_TeleserviceCode(&pType->choice.ext_Teleservice, pContext, tag);
         }
         break;
         
         default:
           /* Constraint Violation */
            applib2_UA1_ERROR( 112 );
         break;
      }
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      if(seq_tlv.t.mode == AUTOMATIC )
      {
         if(seq_tlv.t.cl ==ContextSpecific )
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == IMPLICIT)
      {
         if(seq_tlv.t.is_tagged)
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == EXPLICIT || seq_tlv.t.mode ==EMPTY)
      {
         if(seq_tlv.t.is_tagged)
         {
            applib2_BEGIN_PRE_ENCODE
            put_tlv(pContext, &seq_tlv);
            applib2_asnMemFree((void **)&pTemp);
            applib2_BER_END_PRE_ENCODE
            seq_tlv.l.is_defined = TRUE;
            seq_tlv.l.length = ulen;
            seq_tlv.v = (U8 *)pTemp;
            put_tlv(pContext, &seq_tlv);
         }
         else
         {
            put_tlv(pContext, &seq_tlv);
         }
      }
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE SS-IncompatibilityCause Ber encoder */
extern U32 AsnEncode_SS2_SS_IncompatibilityCause( SS2_SS_IncompatibilityCause *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_SS_IncompatibilityCause_ss_Code_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_Code(&pType->ss_Code, pContext, tag);
      }
      
      if( pType->validity & SS2_SS_IncompatibilityCause_basicService_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 0;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_BasicServiceCode(&pType->basicService, pContext, tag);
      }
      
      if( pType->validity & SS2_SS_IncompatibilityCause_ss_Status_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_Status(&pType->ss_Status, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE OF PrivateExtensionList Ber encoder */
static void AsnEncode_SS2_PrivateExtensionList( SS2_PrivateExtensionList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_PrivateExtension((SS2_PrivateExtension *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE LocationType Ber encoder */
static void AsnEncode_SS2_LocationType( SS2_LocationType *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LocationEstimateType(&pType->locationEstimateType, pContext, tag);
      }
      
      if( pType->validity & SS2_LocationType_deferredLocationEventType_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_DeferredLocationEventType(&pType->deferredLocationEventType, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* DEFINED NameString Ber encoder */
static void AsnEncode_SS2_NameString( SS2_NameString *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   AsnEncode_SS2_USSD_String(pType, pContext, tag);
}

/* DEFINED RequestorIDString Ber encoder */
static void AsnEncode_SS2_RequestorIDString( SS2_RequestorIDString *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   AsnEncode_SS2_USSD_String(pType, pContext, tag);
}

/* SEQUENCE ResponseTime Ber encoder */
static void AsnEncode_SS2_ResponseTime( SS2_ResponseTime *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 10;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ResponseTimeCategory(&pType->responseTimeCategory, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* DEFINED LCSCodewordString Ber encoder */
static void AsnEncode_SS2_LCSCodewordString( SS2_LCSCodewordString *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   AsnEncode_SS2_USSD_String(pType, pContext, tag);
}

/* SEQUENCE LCS-PrivacyCheck Ber encoder */
static void AsnEncode_SS2_LCS_PrivacyCheck( SS2_LCS_PrivacyCheck *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_PrivacyCheckRelatedAction(&pType->callSessionUnrelated, pContext, tag);
      }
      
      if( pType->validity & SS2_LCS_PrivacyCheck_callSessionRelated_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_PrivacyCheckRelatedAction(&pType->callSessionRelated, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE Area Ber encoder */
static void AsnEncode_SS2_Area( SS2_Area *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AreaType(&pType->areaType, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AreaIdentification(&pType->areaIdentification, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* CHOICE SuperChargerInfo Ber encoder */
static void AsnEncode_SS2_SuperChargerInfo( SS2_SuperChargerInfo *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      applib2_BEGIN_PRE_ENCODE
      
      switch( pType->selection )
      {
         case SS2_SuperChargerInfo_sendSubscriberData_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 0;
            /*encode for NULL type */
            tag.is_primitive=TRUE;
            {
                 BER_TLV	null_tlv;
                 null_tlv.t=tag;
                 null_tlv.l.is_defined=TRUE;
                 null_tlv.l.length =0;
                 put_tlv(pContext, &null_tlv);
            }
         }
         break;
         
         case SS2_SuperChargerInfo_subscriberDataStored_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 1;
            AsnEncode_SS2_AgeIndicator(&pType->choice.subscriberDataStored, pContext, tag);
         }
         break;
         
         default:
           /* Constraint Violation */
            applib2_UA1_ERROR( 113 );
         break;
      }
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      if(seq_tlv.t.mode == AUTOMATIC )
      {
         if(seq_tlv.t.cl ==ContextSpecific )
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == IMPLICIT)
      {
         if(seq_tlv.t.is_tagged)
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == EXPLICIT || seq_tlv.t.mode ==EMPTY)
      {
         if(seq_tlv.t.is_tagged)
         {
            applib2_BEGIN_PRE_ENCODE
            put_tlv(pContext, &seq_tlv);
            applib2_asnMemFree((void **)&pTemp);
            applib2_BER_END_PRE_ENCODE
            seq_tlv.l.is_defined = TRUE;
            seq_tlv.l.length = ulen;
            seq_tlv.v = (U8 *)pTemp;
            put_tlv(pContext, &seq_tlv);
         }
         else
         {
            put_tlv(pContext, &seq_tlv);
         }
      }
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE AuthenticationTriplet Ber encoder */
static void AsnEncode_SS2_AuthenticationTriplet( SS2_AuthenticationTriplet *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RAND(&pType->rand, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SRES(&pType->sres, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Kc(&pType->kc, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE AuthenticationQuintuplet Ber encoder */
static void AsnEncode_SS2_AuthenticationQuintuplet( SS2_AuthenticationQuintuplet *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RAND(&pType->rand, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_XRES(&pType->xres, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CK(&pType->ck, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IK(&pType->ik, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AUTN(&pType->autn, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE GSM-SecurityContextData Ber encoder */
static void AsnEncode_SS2_GSM_SecurityContextData( SS2_GSM_SecurityContextData *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Kc(&pType->kc, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Cksn(&pType->cksn, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE UMTS-SecurityContextData Ber encoder */
static void AsnEncode_SS2_UMTS_SecurityContextData( SS2_UMTS_SecurityContextData *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CK(&pType->ck, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IK(&pType->ik, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_KSI(&pType->ksi, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE BSSMAP-ServiceHandoverInfo Ber encoder */
static void AsnEncode_SS2_BSSMAP_ServiceHandoverInfo( SS2_BSSMAP_ServiceHandoverInfo *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_BSSMAP_ServiceHandover(&pType->bssmap_ServiceHandover, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RAB_Id( &pType->rab_Id, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE RadioResource Ber encoder */
static void AsnEncode_SS2_RadioResource( SS2_RadioResource *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RadioResourceInformation(&pType->radioResourceInformation, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RAB_Id( &pType->rab_Id, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE ChosenRadioResourceInformation Ber encoder */
static void AsnEncode_SS2_ChosenRadioResourceInformation( SS2_ChosenRadioResourceInformation *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_ChosenRadioResourceInformation_chosenChannelInfo_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ChosenChannelInfo(&pType->chosenChannelInfo, pContext, tag);
      }
      
      if( pType->validity & SS2_ChosenRadioResourceInformation_chosenSpeechVersion_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ChosenSpeechVersion(&pType->chosenSpeechVersion, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE RelocationNumber Ber encoder */
static void AsnEncode_SS2_RelocationNumber( SS2_RelocationNumber *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->handoverNumber, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RAB_Id( &pType->rab_Id, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE UESBI-Iu Ber encoder */
static void AsnEncode_SS2_UESBI_Iu( SS2_UESBI_Iu *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_UESBI_Iu_uesbi_IuA_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_UESBI_IuA(&pType->uesbi_IuA, pContext, tag);
      }
      
      if( pType->validity & SS2_UESBI_Iu_uesbi_IuB_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_UESBI_IuB(&pType->uesbi_IuB, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE OF TeleserviceList Ber encoder */
static void AsnEncode_SS2_TeleserviceList( SS2_TeleserviceList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_TeleserviceCode((SS2_Ext_TeleserviceCode *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE OF Ext-BasicServiceGroupList Ber encoder */
static void AsnEncode_SS2_Ext_BasicServiceGroupList( SS2_Ext_BasicServiceGroupList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 0;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_BasicServiceCode((SS2_Ext_BasicServiceCode *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE OF ZoneCodeList Ber encoder */
static void AsnEncode_SS2_ZoneCodeList( SS2_ZoneCodeList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ZoneCode((SS2_ZoneCode *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* CHOICE GPRSSubscriptionDataWithdraw Ber encoder */
static void AsnEncode_SS2_GPRSSubscriptionDataWithdraw( SS2_GPRSSubscriptionDataWithdraw *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      applib2_BEGIN_PRE_ENCODE
      
      switch( pType->selection )
      {
         case SS2_GPRSSubscriptionDataWithdraw_allGPRSData_selected:
         {
            BER_TAG   tag;
            tag.cl = Universal;
            tag.tag = 5;
            /*encode for NULL type */
            tag.is_primitive=TRUE;
            {
                 BER_TLV	null_tlv;
                 null_tlv.t=tag;
                 null_tlv.l.is_defined=TRUE;
                 null_tlv.l.length =0;
                 put_tlv(pContext, &null_tlv);
            }
         }
         break;
         
         case SS2_GPRSSubscriptionDataWithdraw_contextIdList_selected:
         {
            BER_TAG   tag;
            tag.cl = Universal;
            tag.tag = 16;
            AsnEncode_SS2_ContextIdList(&pType->choice.contextIdList, pContext, tag);
         }
         break;
         
         default:
           /* Constraint Violation */
            applib2_UA1_ERROR( 114 );
         break;
      }
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      if(seq_tlv.t.mode == AUTOMATIC )
      {
         if(seq_tlv.t.cl ==ContextSpecific )
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == IMPLICIT)
      {
         if(seq_tlv.t.is_tagged)
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == EXPLICIT || seq_tlv.t.mode ==EMPTY)
      {
         if(seq_tlv.t.is_tagged)
         {
            put_tlv(pContext, &seq_tlv);
         }
         else
         {
            applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* CHOICE LSAInformationWithdraw Ber encoder */
static void AsnEncode_SS2_LSAInformationWithdraw( SS2_LSAInformationWithdraw *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      applib2_BEGIN_PRE_ENCODE
      
      switch( pType->selection )
      {
         case SS2_LSAInformationWithdraw_allLSAData_selected:
         {
            BER_TAG   tag;
            tag.cl = Universal;
            tag.tag = 5;
            /*encode for NULL type */
            tag.is_primitive=TRUE;
            {
                 BER_TLV	null_tlv;
                 null_tlv.t=tag;
                 null_tlv.l.is_defined=TRUE;
                 null_tlv.l.length =0;
                 put_tlv(pContext, &null_tlv);
            }
         }
         break;
         
         case SS2_LSAInformationWithdraw_lsaIdentityList_selected:
         {
            BER_TAG   tag;
            tag.cl = Universal;
            tag.tag = 16;
            AsnEncode_SS2_LSAIdentityList(&pType->choice.lsaIdentityList, pContext, tag);
         }
         break;
         
         default:
           /* Constraint Violation */
            applib2_UA1_ERROR( 115 );
         break;
      }
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      if(seq_tlv.t.mode == AUTOMATIC )
      {
         if(seq_tlv.t.cl ==ContextSpecific )
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == IMPLICIT)
      {
         if(seq_tlv.t.is_tagged)
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == EXPLICIT || seq_tlv.t.mode ==EMPTY)
      {
         if(seq_tlv.t.is_tagged)
         {
            put_tlv(pContext, &seq_tlv);
         }
         else
         {
            applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE OF BasicServiceList Ber encoder */
static void AsnEncode_SS2_BasicServiceList( SS2_BasicServiceList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 0;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_BasicServiceCode((SS2_Ext_BasicServiceCode *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE OF TPDU-TypeCriterion Ber encoder */
static void AsnEncode_SS2_TPDU_TypeCriterion( SS2_TPDU_TypeCriterion *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 10;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_MT_SMS_TPDU_Type((SS2_MT_SMS_TPDU_Type *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE OF SS-EventList Ber encoder */
static void AsnEncode_SS2_SS_EventList( SS2_SS_EventList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_Code((SS2_SS_Code *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE DestinationNumberCriteria Ber encoder */
static void AsnEncode_SS2_DestinationNumberCriteria( SS2_DestinationNumberCriteria *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_MatchType(&pType->matchType, pContext, tag);
      }
      
      if( pType->validity & SS2_DestinationNumberCriteria_destinationNumberList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_DestinationNumberList(&pType->destinationNumberList, pContext, tag);
      }
      
      if( pType->validity & SS2_DestinationNumberCriteria_destinationNumberLengthList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_DestinationNumberLengthList(&pType->destinationNumberLengthList, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE OF BasicServiceCriteria Ber encoder */
static void AsnEncode_SS2_BasicServiceCriteria( SS2_BasicServiceCriteria *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 0;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_BasicServiceCode((SS2_Ext_BasicServiceCode *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE OF O-CauseValueCriteria Ber encoder */
static void AsnEncode_SS2_O_CauseValueCriteria( SS2_O_CauseValueCriteria *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CauseValue((SS2_CauseValue *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE OF T-CauseValueCriteria Ber encoder */
static void AsnEncode_SS2_T_CauseValueCriteria( SS2_T_CauseValueCriteria *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CauseValue((SS2_CauseValue *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE OF MobilityTriggers Ber encoder */
static void AsnEncode_SS2_MobilityTriggers( SS2_MobilityTriggers *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_MM_Code((SS2_MM_Code *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE GPRSMSClass Ber encoder */
static void AsnEncode_SS2_GPRSMSClass( SS2_GPRSMSClass *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_MSNetworkCapability(&pType->mSNetworkCapability, pContext, tag);
      }
      
      if( pType->validity & SS2_GPRSMSClass_mSRadioAccessCapability_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_MSRadioAccessCapability(&pType->mSRadioAccessCapability, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* CHOICE SubscriberState Ber encoder */
static void AsnEncode_SS2_SubscriberState( SS2_SubscriberState *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      applib2_BEGIN_PRE_ENCODE
      
      switch( pType->selection )
      {
         case SS2_SubscriberState_assumedIdle_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 0;
            /*encode for NULL type */
            tag.is_primitive=TRUE;
            {
                 BER_TLV	null_tlv;
                 null_tlv.t=tag;
                 null_tlv.l.is_defined=TRUE;
                 null_tlv.l.length =0;
                 put_tlv(pContext, &null_tlv);
            }
         }
         break;
         
         case SS2_SubscriberState_camelBusy_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 1;
            /*encode for NULL type */
            tag.is_primitive=TRUE;
            {
                 BER_TLV	null_tlv;
                 null_tlv.t=tag;
                 null_tlv.l.is_defined=TRUE;
                 null_tlv.l.length =0;
                 put_tlv(pContext, &null_tlv);
            }
         }
         break;
         
         case SS2_SubscriberState_netDetNotReachable_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 3;
            AsnEncode_SS2_NotReachableReason(&pType->choice.netDetNotReachable, pContext, tag);
         }
         break;
         
         case SS2_SubscriberState_notProvidedFromVLR_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 2;
            /*encode for NULL type */
            tag.is_primitive=TRUE;
            {
                 BER_TLV	null_tlv;
                 null_tlv.t=tag;
                 null_tlv.l.is_defined=TRUE;
                 null_tlv.l.length =0;
                 put_tlv(pContext, &null_tlv);
            }
         }
         break;
         
         default:
           /* Constraint Violation */
            applib2_UA1_ERROR( 116 );
         break;
      }
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      if(seq_tlv.t.mode == AUTOMATIC )
      {
         if(seq_tlv.t.cl ==ContextSpecific )
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == IMPLICIT)
      {
         if(seq_tlv.t.is_tagged)
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == EXPLICIT || seq_tlv.t.mode ==EMPTY)
      {
         if(seq_tlv.t.is_tagged)
         {
            applib2_BEGIN_PRE_ENCODE
            put_tlv(pContext, &seq_tlv);
            applib2_asnMemFree((void **)&pTemp);
            applib2_BER_END_PRE_ENCODE
            seq_tlv.l.is_defined = TRUE;
            seq_tlv.l.length = ulen;
            seq_tlv.v = (U8 *)pTemp;
            put_tlv(pContext, &seq_tlv);
         }
         else
         {
            put_tlv(pContext, &seq_tlv);
         }
      }
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE TraceDepthList Ber encoder */
static void AsnEncode_SS2_TraceDepthList( SS2_TraceDepthList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_TraceDepthList_msc_s_TraceDepth_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_TraceDepth(&pType->msc_s_TraceDepth, pContext, tag);
      }
      
      if( pType->validity & SS2_TraceDepthList_mgw_TraceDepth_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_TraceDepth(&pType->mgw_TraceDepth, pContext, tag);
      }
      
      if( pType->validity & SS2_TraceDepthList_sgsn_TraceDepth_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_TraceDepth(&pType->sgsn_TraceDepth, pContext, tag);
      }
      
      if( pType->validity & SS2_TraceDepthList_ggsn_TraceDepth_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_TraceDepth(&pType->ggsn_TraceDepth, pContext, tag);
      }
      
      if( pType->validity & SS2_TraceDepthList_rnc_TraceDepth_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_TraceDepth(&pType->rnc_TraceDepth, pContext, tag);
      }
      
      if( pType->validity & SS2_TraceDepthList_bmsc_TraceDepth_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_TraceDepth(&pType->bmsc_TraceDepth, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE TraceInterfaceList Ber encoder */
static void AsnEncode_SS2_TraceInterfaceList( SS2_TraceInterfaceList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_TraceInterfaceList_msc_s_List_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_MSC_S_InterfaceList(&pType->msc_s_List, pContext, tag);
      }
      
      if( pType->validity & SS2_TraceInterfaceList_mgw_List_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_MGW_InterfaceList(&pType->mgw_List, pContext, tag);
      }
      
      if( pType->validity & SS2_TraceInterfaceList_sgsn_List_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SGSN_InterfaceList(&pType->sgsn_List, pContext, tag);
      }
      
      if( pType->validity & SS2_TraceInterfaceList_ggsn_List_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GGSN_InterfaceList(&pType->ggsn_List, pContext, tag);
      }
      
      if( pType->validity & SS2_TraceInterfaceList_rnc_List_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RNC_InterfaceList(&pType->rnc_List, pContext, tag);
      }
      
      if( pType->validity & SS2_TraceInterfaceList_bmsc_List_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_BMSC_InterfaceList(&pType->bmsc_List, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE TraceEventList Ber encoder */
static void AsnEncode_SS2_TraceEventList( SS2_TraceEventList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_TraceEventList_msc_s_List_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_MSC_S_EventList(&pType->msc_s_List, pContext, tag);
      }
      
      if( pType->validity & SS2_TraceEventList_mgw_List_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_MGW_EventList(&pType->mgw_List, pContext, tag);
      }
      
      if( pType->validity & SS2_TraceEventList_sgsn_List_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SGSN_EventList(&pType->sgsn_List, pContext, tag);
      }
      
      if( pType->validity & SS2_TraceEventList_ggsn_List_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GGSN_EventList(&pType->ggsn_List, pContext, tag);
      }
      
      if( pType->validity & SS2_TraceEventList_bmsc_List_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_BMSC_EventList(&pType->bmsc_List, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE RegisterSS-Arg Ber encoder */
extern U32 AsnEncode_SS2_RegisterSS_Arg( SS2_RegisterSS_Arg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_Code(&pType->ss_Code, pContext, tag);
      }
      
      if( pType->validity & SS2_RegisterSS_Arg_basicService_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 0;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_BasicServiceCode(&pType->basicService, pContext, tag);
      }
      
      if( pType->validity & SS2_RegisterSS_Arg_forwardedToNumber_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AddressString(&pType->forwardedToNumber, pContext, tag);
      }
      
      if( pType->validity & SS2_RegisterSS_Arg_forwardedToSubaddress_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_SubaddressString(&pType->forwardedToSubaddress, pContext, tag);
      }
      
      if( pType->validity & SS2_RegisterSS_Arg_noReplyConditionTime_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_NoReplyConditionTime( &pType->noReplyConditionTime, pContext, tag);
      }
      
      if( pType->validity & SS2_RegisterSS_Arg_defaultPriority_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 7;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_EMLPP_Priority( &pType->defaultPriority, pContext, tag);
      }
      
      if( pType->validity & SS2_RegisterSS_Arg_nbrUser_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 8;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_MC_Bearers( &pType->nbrUser, pContext, tag);
      }
      
      if( pType->validity & SS2_RegisterSS_Arg_longFTN_Supported_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 9;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE ForwardingFeature Ber encoder */
static void AsnEncode_SS2_ForwardingFeature( SS2_ForwardingFeature *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_ForwardingFeature_basicService_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 0;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_BasicServiceCode(&pType->basicService, pContext, tag);
      }
      
      if( pType->validity & SS2_ForwardingFeature_ss_Status_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_Status(&pType->ss_Status, pContext, tag);
      }
      
      if( pType->validity & SS2_ForwardingFeature_forwardedToNumber_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->forwardedToNumber, pContext, tag);
      }
      
      if( pType->validity & SS2_ForwardingFeature_forwardedToSubaddress_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 8;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_SubaddressString(&pType->forwardedToSubaddress, pContext, tag);
      }
      
      if( pType->validity & SS2_ForwardingFeature_forwardingOptions_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ForwardingOptions(&pType->forwardingOptions, pContext, tag);
      }
      
      if( pType->validity & SS2_ForwardingFeature_noReplyConditionTime_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 7;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_NoReplyConditionTime( &pType->noReplyConditionTime, pContext, tag);
      }
      
      if( pType->validity & SS2_ForwardingFeature_longForwardedToNumber_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 9;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_FTN_AddressString(&pType->longForwardedToNumber, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE CallBarringFeature Ber encoder */
static void AsnEncode_SS2_CallBarringFeature( SS2_CallBarringFeature *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_CallBarringFeature_basicService_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 0;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_BasicServiceCode(&pType->basicService, pContext, tag);
      }
      
      if( pType->validity & SS2_CallBarringFeature_ss_Status_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_Status(&pType->ss_Status, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* CHOICE SS-SubscriptionOption Ber encoder */
static void AsnEncode_SS2_SS_SubscriptionOption( SS2_SS_SubscriptionOption *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      applib2_BEGIN_PRE_ENCODE
      
      switch( pType->selection )
      {
         case SS2_SS_SubscriptionOption_cliRestrictionOption_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 2;
            AsnEncode_SS2_CliRestrictionOption(&pType->choice.cliRestrictionOption, pContext, tag);
         }
         break;
         
         case SS2_SS_SubscriptionOption_overrideCategory_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 1;
            AsnEncode_SS2_OverrideCategory(&pType->choice.overrideCategory, pContext, tag);
         }
         break;
         
         default:
           /* Constraint Violation */
            applib2_UA1_ERROR( 117 );
         break;
      }
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      if(seq_tlv.t.mode == AUTOMATIC )
      {
         if(seq_tlv.t.cl ==ContextSpecific )
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == IMPLICIT)
      {
         if(seq_tlv.t.is_tagged)
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == EXPLICIT || seq_tlv.t.mode ==EMPTY)
      {
         if(seq_tlv.t.is_tagged)
         {
            applib2_BEGIN_PRE_ENCODE
            put_tlv(pContext, &seq_tlv);
            applib2_asnMemFree((void **)&pTemp);
            applib2_BER_END_PRE_ENCODE
            seq_tlv.l.is_defined = TRUE;
            seq_tlv.l.length = ulen;
            seq_tlv.v = (U8 *)pTemp;
            put_tlv(pContext, &seq_tlv);
         }
         else
         {
            put_tlv(pContext, &seq_tlv);
         }
      }
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE SS-ForBS-Code Ber encoder */
static void AsnEncode_SS2_SS_ForBS_Code( SS2_SS_ForBS_Code *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_Code(&pType->ss_Code, pContext, tag);
      }
      
      if( pType->validity & SS2_SS_ForBS_Code_basicService_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 0;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_BasicServiceCode(&pType->basicService, pContext, tag);
      }
      
      if( pType->validity & SS2_SS_ForBS_Code_longFTN_Supported_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE CCBS-Feature Ber encoder */
static void AsnEncode_SS2_CCBS_Feature( SS2_CCBS_Feature *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_CCBS_Feature_ccbs_Index_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CCBS_Index( &pType->ccbs_Index, pContext, tag);
      }
      
      if( pType->validity & SS2_CCBS_Feature_b_subscriberNumber_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->b_subscriberNumber, pContext, tag);
      }
      
      if( pType->validity & SS2_CCBS_Feature_b_subscriberSubaddress_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_SubaddressString(&pType->b_subscriberSubaddress, pContext, tag);
      }
      
      if( pType->validity & SS2_CCBS_Feature_basicServiceGroup_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_BasicServiceCode(&pType->basicServiceGroup, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE USSD-Arg Ber encoder */
extern U32 AsnEncode_SS2_USSD_Arg( SS2_USSD_Arg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_USSD_DataCodingScheme(&pType->ussd_DataCodingScheme, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_USSD_String(&pType->ussd_String, pContext, tag);
      }
      
      if( pType->validity & SS2_USSD_Arg_alertingPattern_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AlertingPattern(&pType->alertingPattern, pContext, tag);
      }
      
      if( pType->validity & SS2_USSD_Arg_msisdn_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->msisdn, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE USSD-Res Ber encoder */
extern U32 AsnEncode_SS2_USSD_Res( SS2_USSD_Res *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_USSD_DataCodingScheme(&pType->ussd_DataCodingScheme, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_USSD_String(&pType->ussd_String, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE OF BasicServiceGroupList Ber encoder */
static void AsnEncode_SS2_BasicServiceGroupList( SS2_BasicServiceGroupList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 0;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_BasicServiceCode((SS2_BasicServiceCode *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE RegisterCC-EntryRes Ber encoder */
extern U32 AsnEncode_SS2_RegisterCC_EntryRes( SS2_RegisterCC_EntryRes *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_RegisterCC_EntryRes_ccbs_Feature_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CCBS_Feature(&pType->ccbs_Feature, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* CHOICE InvokeId Ber encoder */
static void AsnEncode_SS2_InvokeId( SS2_InvokeId *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      applib2_BEGIN_PRE_ENCODE
      
      switch( pType->selection )
      {
         case SS2_InvokeId_present_selected:
         {
            BER_TAG   tag;
            tag.cl = Universal;
            tag.tag = 2;
            AsnEncode_SS2_InvokeId_present( &pType->choice.present, pContext, tag);
         }
         break;
         
         case SS2_InvokeId_absent_selected:
         {
            BER_TAG   tag;
            tag.cl = Universal;
            tag.tag = 5;
            /*encode for NULL type */
            tag.is_primitive=TRUE;
            {
                 BER_TLV	null_tlv;
                 null_tlv.t=tag;
                 null_tlv.l.is_defined=TRUE;
                 null_tlv.l.length =0;
                 put_tlv(pContext, &null_tlv);
            }
         }
         break;
         
         default:
           /* Constraint Violation */
            applib2_UA1_ERROR( 118 );
         break;
      }
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      if(seq_tlv.t.mode == AUTOMATIC )
      {
         if(seq_tlv.t.cl ==ContextSpecific )
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == IMPLICIT)
      {
         if(seq_tlv.t.is_tagged)
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == EXPLICIT || seq_tlv.t.mode ==EMPTY)
      {
         if(seq_tlv.t.is_tagged)
         {
            put_tlv(pContext, &seq_tlv);
         }
         else
         {
            applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* DEFINED NoInvokeId Ber encoder */
extern U32 AsnEncode_SS2_NoInvokeId( SS2_NoInvokeId *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TAG   tag;
      
      tag.cl = Universal;
      tag.tag = 0;
      
      AsnEncode_SS2_InvokeId(pType, pContext, tag);
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE ChargingInformation Ber encoder */
static void AsnEncode_SS2_ChargingInformation( SS2_ChargingInformation *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_ChargingInformation_e1_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_E1( &pType->e1, pContext, tag);
      }
      
      if( pType->validity & SS2_ChargingInformation_e2_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_E2( &pType->e2, pContext, tag);
      }
      
      if( pType->validity & SS2_ChargingInformation_e3_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_E3( &pType->e3, pContext, tag);
      }
      
      if( pType->validity & SS2_ChargingInformation_e4_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_E4( &pType->e4, pContext, tag);
      }
      
      if( pType->validity & SS2_ChargingInformation_e5_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_E5( &pType->e5, pContext, tag);
      }
      
      if( pType->validity & SS2_ChargingInformation_e6_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_E6( &pType->e6, pContext, tag);
      }
      
      if( pType->validity & SS2_ChargingInformation_e7_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 7;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_E7( &pType->e7, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* CHOICE Name Ber encoder */
static void AsnEncode_SS2_Name( SS2_Name *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      applib2_BEGIN_PRE_ENCODE
      
      switch( pType->selection )
      {
         case SS2_Name_namePresentationAllowed_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 0;
            AsnEncode_SS2_NameSet(&pType->choice.namePresentationAllowed, pContext, tag);
         }
         break;
         
         case SS2_Name_presentationRestricted_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 1;
            /*encode for NULL type */
            tag.is_primitive=TRUE;
            {
                 BER_TLV	null_tlv;
                 null_tlv.t=tag;
                 null_tlv.l.is_defined=TRUE;
                 null_tlv.l.length =0;
                 put_tlv(pContext, &null_tlv);
            }
         }
         break;
         
         case SS2_Name_nameUnavailable_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 2;
            /*encode for NULL type */
            tag.is_primitive=TRUE;
            {
                 BER_TLV	null_tlv;
                 null_tlv.t=tag;
                 null_tlv.l.is_defined=TRUE;
                 null_tlv.l.length =0;
                 put_tlv(pContext, &null_tlv);
            }
         }
         break;
         
         case SS2_Name_namePresentationRestricted_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 3;
            AsnEncode_SS2_NameSet(&pType->choice.namePresentationRestricted, pContext, tag);
         }
         break;
         
         default:
           /* Constraint Violation */
            applib2_UA1_ERROR( 119 );
         break;
      }
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      if(seq_tlv.t.mode == AUTOMATIC )
      {
         if(seq_tlv.t.cl ==ContextSpecific )
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == IMPLICIT)
      {
         if(seq_tlv.t.is_tagged)
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == EXPLICIT || seq_tlv.t.mode ==EMPTY)
      {
         if(seq_tlv.t.is_tagged)
         {
            applib2_BEGIN_PRE_ENCODE
            put_tlv(pContext, &seq_tlv);
            applib2_asnMemFree((void **)&pTemp);
            applib2_BER_END_PRE_ENCODE
            seq_tlv.l.is_defined = TRUE;
            seq_tlv.l.length = ulen;
            seq_tlv.v = (U8 *)pTemp;
            put_tlv(pContext, &seq_tlv);
         }
         else
         {
            put_tlv(pContext, &seq_tlv);
         }
      }
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* CHOICE RDN Ber encoder */
static void AsnEncode_SS2_RDN( SS2_RDN *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      applib2_BEGIN_PRE_ENCODE
      
      switch( pType->selection )
      {
         case SS2_RDN_presentationAllowedAddress_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 0;
            AsnEncode_SS2_RemotePartyNumber(&pType->choice.presentationAllowedAddress, pContext, tag);
         }
         break;
         
         case SS2_RDN_presentationRestricted_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 1;
            /*encode for NULL type */
            tag.is_primitive=TRUE;
            {
                 BER_TLV	null_tlv;
                 null_tlv.t=tag;
                 null_tlv.l.is_defined=TRUE;
                 null_tlv.l.length =0;
                 put_tlv(pContext, &null_tlv);
            }
         }
         break;
         
         case SS2_RDN_numberNotAvailableDueToInterworking_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 2;
            /*encode for NULL type */
            tag.is_primitive=TRUE;
            {
                 BER_TLV	null_tlv;
                 null_tlv.t=tag;
                 null_tlv.l.is_defined=TRUE;
                 null_tlv.l.length =0;
                 put_tlv(pContext, &null_tlv);
            }
         }
         break;
         
         case SS2_RDN_presentationRestrictedAddress_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 3;
            AsnEncode_SS2_RemotePartyNumber(&pType->choice.presentationRestrictedAddress, pContext, tag);
         }
         break;
         
         default:
           /* Constraint Violation */
            applib2_UA1_ERROR( 120 );
         break;
      }
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      if(seq_tlv.t.mode == AUTOMATIC )
      {
         if(seq_tlv.t.cl ==ContextSpecific )
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == IMPLICIT)
      {
         if(seq_tlv.t.is_tagged)
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == EXPLICIT || seq_tlv.t.mode ==EMPTY)
      {
         if(seq_tlv.t.is_tagged)
         {
            applib2_BEGIN_PRE_ENCODE
            put_tlv(pContext, &seq_tlv);
            applib2_asnMemFree((void **)&pTemp);
            applib2_BER_END_PRE_ENCODE
            seq_tlv.l.is_defined = TRUE;
            seq_tlv.l.length = ulen;
            seq_tlv.v = (U8 *)pTemp;
            put_tlv(pContext, &seq_tlv);
         }
         else
         {
            put_tlv(pContext, &seq_tlv);
         }
      }
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE UserUserServiceArg Ber encoder */
extern U32 AsnEncode_SS2_UserUserServiceArg( SS2_UserUserServiceArg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_UUS_Service(&pType->uUS_Service, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         ber_put_boolean(pContext, (AsnBool *)(&pType->uUS_Required), tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE LocationNotificationRes Ber encoder */
extern U32 AsnEncode_SS2_LocationNotificationRes( SS2_LocationNotificationRes *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_LocationNotificationRes_verificationResponse_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_VerificationResponse(&pType->verificationResponse, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE LCS-MOLRRes Ber encoder */
extern U32 AsnEncode_SS2_LCS_MOLRRes( SS2_LCS_MOLRRes *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_LCS_MOLRRes_locationEstimate_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_GeographicalInformation(&pType->locationEstimate, pContext, tag);
      }
      
      if( pType->validity & SS2_LCS_MOLRRes_decipheringKeys_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_DecipheringKeys(&pType->decipheringKeys, pContext, tag);
      }
      
      if( pType->validity & SS2_LCS_MOLRRes_add_LocationEstimate_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Add_GeographicalInformation(&pType->add_LocationEstimate, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* CHOICE Identity Ber encoder */
static void AsnEncode_SS2_Identity( SS2_Identity *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      applib2_BEGIN_PRE_ENCODE
      
      switch( pType->selection )
      {
         case SS2_Identity_imsi_selected:
         {
            BER_TAG   tag;
            tag.cl = Universal;
            tag.tag = 4;
            AsnEncode_SS2_IMSI(&pType->choice.imsi, pContext, tag);
         }
         break;
         
         case SS2_Identity_imsi_WithLMSI_selected:
         {
            BER_TAG   tag;
            tag.cl = Universal;
            tag.tag = 16;
            AsnEncode_SS2_IMSI_WithLMSI(&pType->choice.imsi_WithLMSI, pContext, tag);
         }
         break;
         
         default:
           /* Constraint Violation */
            applib2_UA1_ERROR( 121 );
         break;
      }
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      if(seq_tlv.t.mode == AUTOMATIC )
      {
         if(seq_tlv.t.cl ==ContextSpecific )
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == IMPLICIT)
      {
         if(seq_tlv.t.is_tagged)
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == EXPLICIT || seq_tlv.t.mode ==EMPTY)
      {
         if(seq_tlv.t.is_tagged)
         {
            put_tlv(pContext, &seq_tlv);
         }
         else
         {
            applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE ExtensionContainer Ber encoder */
static void AsnEncode_SS2_ExtensionContainer( SS2_ExtensionContainer *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_ExtensionContainer_privateExtensionList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_PrivateExtensionList(&pType->privateExtensionList, pContext, tag);
      }
      
      if( pType->validity & SS2_ExtensionContainer_pcs_Extensions_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_PCS_Extensions(&pType->pcs_Extensions, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE SLR-ArgExtensionContainer Ber encoder */
static void AsnEncode_SS2_SLR_ArgExtensionContainer( SS2_SLR_ArgExtensionContainer *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_SLR_ArgExtensionContainer_privateExtensionList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_PrivateExtensionList(&pType->privateExtensionList, pContext, tag);
      }
      
      if( pType->validity & SS2_SLR_ArgExtensionContainer_slr_Arg_PCS_Extensions_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SLR_Arg_PCS_Extensions(&pType->slr_Arg_PCS_Extensions, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE RoutingInfoForLCS-Arg Ber encoder */
extern U32 AsnEncode_SS2_RoutingInfoForLCS_Arg( SS2_RoutingInfoForLCS_Arg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->mlcNumber, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SubscriberIdentity(&pType->targetMS, pContext, tag);
      }
      
      if( pType->validity & SS2_RoutingInfoForLCS_Arg_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE LCSLocationInfo Ber encoder */
static void AsnEncode_SS2_LCSLocationInfo( SS2_LCSLocationInfo *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->networkNode_Number, pContext, tag);
      }
      
      if( pType->validity & SS2_LCSLocationInfo_lmsi_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LMSI(&pType->lmsi, pContext, tag);
      }
      
      if( pType->validity & SS2_LCSLocationInfo_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_LCSLocationInfo_gprsNodeIndicator_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_LCSLocationInfo_additional_Number_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Additional_Number(&pType->additional_Number, pContext, tag);
      }
      
      if( pType->validity & SS2_LCSLocationInfo_supportedLCS_CapabilitySets_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SupportedLCS_CapabilitySets(&pType->supportedLCS_CapabilitySets, pContext, tag);
      }
      
      if( pType->validity & SS2_LCSLocationInfo_additional_LCS_CapabilitySets_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SupportedLCS_CapabilitySets(&pType->additional_LCS_CapabilitySets, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE LCSClientName Ber encoder */
static void AsnEncode_SS2_LCSClientName( SS2_LCSClientName *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_USSD_DataCodingScheme(&pType->dataCodingScheme, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_NameString(&pType->nameString, pContext, tag);
      }
      
      if( pType->validity & SS2_LCSClientName_lcs_FormatIndicator_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCS_FormatIndicator(&pType->lcs_FormatIndicator, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE LCSRequestorID Ber encoder */
static void AsnEncode_SS2_LCSRequestorID( SS2_LCSRequestorID *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_USSD_DataCodingScheme(&pType->dataCodingScheme, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RequestorIDString(&pType->requestorIDString, pContext, tag);
      }
      
      if( pType->validity & SS2_LCSRequestorID_lcs_FormatIndicator_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCS_FormatIndicator(&pType->lcs_FormatIndicator, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE LCS-QoS Ber encoder */
static void AsnEncode_SS2_LCS_QoS( SS2_LCS_QoS *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_LCS_QoS_horizontal_accuracy_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Horizontal_Accuracy(&pType->horizontal_accuracy, pContext, tag);
      }
      
      if( pType->validity & SS2_LCS_QoS_verticalCoordinateRequest_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_LCS_QoS_vertical_accuracy_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Vertical_Accuracy(&pType->vertical_accuracy, pContext, tag);
      }
      
      if( pType->validity & SS2_LCS_QoS_responseTime_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ResponseTime(&pType->responseTime, pContext, tag);
      }
      
      if( pType->validity & SS2_LCS_QoS_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE LCSCodeword Ber encoder */
static void AsnEncode_SS2_LCSCodeword( SS2_LCSCodeword *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_USSD_DataCodingScheme(&pType->dataCodingScheme, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCSCodewordString(&pType->lcsCodewordString, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE OF AreaList Ber encoder */
static void AsnEncode_SS2_AreaList( SS2_AreaList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Area((SS2_Area *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE ProvideSubscriberLocation-Res Ber encoder */
extern U32 AsnEncode_SS2_ProvideSubscriberLocation_Res( SS2_ProvideSubscriberLocation_Res *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_GeographicalInformation(&pType->locationEstimate, pContext, tag);
      }
      
      if( pType->validity & SS2_ProvideSubscriberLocation_Res_ageOfLocationEstimate_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AgeOfLocationInformation( &pType->ageOfLocationEstimate, pContext, tag);
      }
      
      if( pType->validity & SS2_ProvideSubscriberLocation_Res_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_ProvideSubscriberLocation_Res_add_LocationEstimate_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Add_GeographicalInformation(&pType->add_LocationEstimate, pContext, tag);
      }
      
      if( pType->validity & SS2_ProvideSubscriberLocation_Res_deferredmt_lrResponseIndicator_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_ProvideSubscriberLocation_Res_geranPositioningData_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_PositioningDataInformation(&pType->geranPositioningData, pContext, tag);
      }
      
      if( pType->validity & SS2_ProvideSubscriberLocation_Res_utranPositioningData_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_UtranPositioningDataInfo(&pType->utranPositioningData, pContext, tag);
      }
      
      if( pType->validity & SS2_ProvideSubscriberLocation_Res_cellIdOrSai_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CellGlobalIdOrServiceAreaIdOrLAI(&pType->cellIdOrSai, pContext, tag);
      }
      
      if( pType->validity & SS2_ProvideSubscriberLocation_Res_sai_Present_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 7;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_ProvideSubscriberLocation_Res_accuracyFulfilmentIndicator_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 8;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AccuracyFulfilmentIndicator(&pType->accuracyFulfilmentIndicator, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE Deferredmt-lrData Ber encoder */
static void AsnEncode_SS2_Deferredmt_lrData( SS2_Deferredmt_lrData *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 3;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_DeferredLocationEventType(&pType->deferredLocationEventType, pContext, tag);
      }
      
      if( pType->validity & SS2_Deferredmt_lrData_terminationCause_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_TerminationCause(&pType->terminationCause, pContext, tag);
      }
      
      if( pType->validity & SS2_Deferredmt_lrData_lcsLocationInfo_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCSLocationInfo(&pType->lcsLocationInfo, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE SubscriberLocationReport-Res Ber encoder */
extern U32 AsnEncode_SS2_SubscriberLocationReport_Res( SS2_SubscriberLocationReport_Res *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_SubscriberLocationReport_Res_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_SubscriberLocationReport_Res_na_ESRK_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->na_ESRK, pContext, tag);
      }
      
      if( pType->validity & SS2_SubscriberLocationReport_Res_na_ESRD_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->na_ESRD, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE VLR-Capability Ber encoder */
static void AsnEncode_SS2_VLR_Capability( SS2_VLR_Capability *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_VLR_Capability_supportedCamelPhases_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SupportedCamelPhases(&pType->supportedCamelPhases, pContext, tag);
      }
      
      if( pType->validity & SS2_VLR_Capability_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_VLR_Capability_solsaSupportIndicator_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_VLR_Capability_istSupportIndicator_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IST_SupportIndicator(&pType->istSupportIndicator, pContext, tag);
      }
      
      if( pType->validity & SS2_VLR_Capability_superChargerSupportedInServingNetworkEntity_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SuperChargerInfo(&pType->superChargerSupportedInServingNetworkEntity, pContext, tag);
      }
      
      if( pType->validity & SS2_VLR_Capability_longFTN_Supported_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_VLR_Capability_supportedLCS_CapabilitySets_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SupportedLCS_CapabilitySets(&pType->supportedLCS_CapabilitySets, pContext, tag);
      }
      
      if( pType->validity & SS2_VLR_Capability_offeredCamel4CSIs_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_OfferedCamel4CSIs(&pType->offeredCamel4CSIs, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE UpdateLocationRes Ber encoder */
extern U32 AsnEncode_SS2_UpdateLocationRes( SS2_UpdateLocationRes *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->hlr_Number, pContext, tag);
      }
      
      if( pType->validity & SS2_UpdateLocationRes_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_UpdateLocationRes_add_Capability_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 5;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE CancelLocationArg Ber encoder */
extern U32 AsnEncode_SS2_CancelLocationArg( SS2_CancelLocationArg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = ContextSpecific;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 3;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 0;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Identity(&pType->identity, pContext, tag);
      }
      
      if( pType->validity & SS2_CancelLocationArg_cancellationType_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 10;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CancellationType(&pType->cancellationType, pContext, tag);
      }
      
      if( pType->validity & SS2_CancelLocationArg_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE CancelLocationRes Ber encoder */
extern U32 AsnEncode_SS2_CancelLocationRes( SS2_CancelLocationRes *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_CancelLocationRes_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE PurgeMS-Arg Ber encoder */
extern U32 AsnEncode_SS2_PurgeMS_Arg( SS2_PurgeMS_Arg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = ContextSpecific;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 3;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IMSI(&pType->imsi, pContext, tag);
      }
      
      if( pType->validity & SS2_PurgeMS_Arg_vlr_Number_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->vlr_Number, pContext, tag);
      }
      
      if( pType->validity & SS2_PurgeMS_Arg_sgsn_Number_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->sgsn_Number, pContext, tag);
      }
      
      if( pType->validity & SS2_PurgeMS_Arg_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE PurgeMS-Res Ber encoder */
extern U32 AsnEncode_SS2_PurgeMS_Res( SS2_PurgeMS_Res *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_PurgeMS_Res_freezeTMSI_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_PurgeMS_Res_freezeP_TMSI_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_PurgeMS_Res_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE SendIdentificationArg Ber encoder */
extern U32 AsnEncode_SS2_SendIdentificationArg( SS2_SendIdentificationArg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_TMSI(&pType->tmsi, pContext, tag);
      }
      
      if( pType->validity & SS2_SendIdentificationArg_numberOfRequestedVectors_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_NumberOfRequestedVectors( &pType->numberOfRequestedVectors, pContext, tag);
      }
      
      if( pType->validity & SS2_SendIdentificationArg_segmentationProhibited_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 5;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_SendIdentificationArg_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_SendIdentificationArg_msc_Number_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->msc_Number, pContext, tag);
      }
      
      if( pType->validity & SS2_SendIdentificationArg_previous_LAI_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LAIFixedLength(&pType->previous_LAI, pContext, tag);
      }
      
      if( pType->validity & SS2_SendIdentificationArg_hopCounter_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_HopCounter( &pType->hopCounter, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE OF TripletList Ber encoder */
static void AsnEncode_SS2_TripletList( SS2_TripletList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AuthenticationTriplet((SS2_AuthenticationTriplet *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE OF QuintupletList Ber encoder */
static void AsnEncode_SS2_QuintupletList( SS2_QuintupletList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AuthenticationQuintuplet((SS2_AuthenticationQuintuplet *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* CHOICE CurrentSecurityContext Ber encoder */
static void AsnEncode_SS2_CurrentSecurityContext( SS2_CurrentSecurityContext *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      applib2_BEGIN_PRE_ENCODE
      
      switch( pType->selection )
      {
         case SS2_CurrentSecurityContext_gsm_SecurityContextData_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 0;
            AsnEncode_SS2_GSM_SecurityContextData(&pType->choice.gsm_SecurityContextData, pContext, tag);
         }
         break;
         
         case SS2_CurrentSecurityContext_umts_SecurityContextData_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 1;
            AsnEncode_SS2_UMTS_SecurityContextData(&pType->choice.umts_SecurityContextData, pContext, tag);
         }
         break;
         
         default:
           /* Constraint Violation */
            applib2_UA1_ERROR( 122 );
         break;
      }
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      if(seq_tlv.t.mode == AUTOMATIC )
      {
         if(seq_tlv.t.cl ==ContextSpecific )
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == IMPLICIT)
      {
         if(seq_tlv.t.is_tagged)
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == EXPLICIT || seq_tlv.t.mode ==EMPTY)
      {
         if(seq_tlv.t.is_tagged)
         {
            applib2_BEGIN_PRE_ENCODE
            put_tlv(pContext, &seq_tlv);
            applib2_asnMemFree((void **)&pTemp);
            applib2_BER_END_PRE_ENCODE
            seq_tlv.l.is_defined = TRUE;
            seq_tlv.l.length = ulen;
            seq_tlv.v = (U8 *)pTemp;
            put_tlv(pContext, &seq_tlv);
         }
         else
         {
            put_tlv(pContext, &seq_tlv);
         }
      }
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE AuthenticationFailureReportArg Ber encoder */
extern U32 AsnEncode_SS2_AuthenticationFailureReportArg( SS2_AuthenticationFailureReportArg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IMSI(&pType->imsi, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 10;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_FailureCause(&pType->failureCause, pContext, tag);
      }
      
      if( pType->validity & SS2_AuthenticationFailureReportArg_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_AuthenticationFailureReportArg_re_attempt_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 1;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         ber_put_boolean(pContext, (AsnBool *)(&pType->re_attempt), tag);
      }
      
      if( pType->validity & SS2_AuthenticationFailureReportArg_accessType_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 10;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AccessType(&pType->accessType, pContext, tag);
      }
      
      if( pType->validity & SS2_AuthenticationFailureReportArg_rand_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RAND(&pType->rand, pContext, tag);
      }
      
      if( pType->validity & SS2_AuthenticationFailureReportArg_vlr_Number_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->vlr_Number, pContext, tag);
      }
      
      if( pType->validity & SS2_AuthenticationFailureReportArg_sgsn_Number_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->sgsn_Number, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE AuthenticationFailureReportRes Ber encoder */
extern U32 AsnEncode_SS2_AuthenticationFailureReportRes( SS2_AuthenticationFailureReportRes *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_AuthenticationFailureReportRes_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE SGSN-Capability Ber encoder */
static void AsnEncode_SS2_SGSN_Capability( SS2_SGSN_Capability *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_SGSN_Capability_solsaSupportIndicator_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 5;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_SGSN_Capability_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_SGSN_Capability_superChargerSupportedInServingNetworkEntity_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SuperChargerInfo(&pType->superChargerSupportedInServingNetworkEntity, pContext, tag);
      }
      
      if( pType->validity & SS2_SGSN_Capability_gprsEnhancementsSupportIndicator_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_SGSN_Capability_supportedCamelPhases_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SupportedCamelPhases(&pType->supportedCamelPhases, pContext, tag);
      }
      
      if( pType->validity & SS2_SGSN_Capability_supportedLCS_CapabilitySets_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SupportedLCS_CapabilitySets(&pType->supportedLCS_CapabilitySets, pContext, tag);
      }
      
      if( pType->validity & SS2_SGSN_Capability_offeredCamel4CSIs_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_OfferedCamel4CSIs(&pType->offeredCamel4CSIs, pContext, tag);
      }
      
      if( pType->validity & SS2_SGSN_Capability_smsCallBarringSupportIndicator_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 7;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE UpdateGprsLocationRes Ber encoder */
extern U32 AsnEncode_SS2_UpdateGprsLocationRes( SS2_UpdateGprsLocationRes *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->hlr_Number, pContext, tag);
      }
      
      if( pType->validity & SS2_UpdateGprsLocationRes_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_UpdateGprsLocationRes_add_Capability_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 5;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE AllowedUMTS-Algorithms Ber encoder */
static void AsnEncode_SS2_AllowedUMTS_Algorithms( SS2_AllowedUMTS_Algorithms *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_AllowedUMTS_Algorithms_integrityProtectionAlgorithms_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_PermittedIntegrityProtectionAlgorithms(&pType->integrityProtectionAlgorithms, pContext, tag);
      }
      
      if( pType->validity & SS2_AllowedUMTS_Algorithms_encryptionAlgorithms_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_PermittedEncryptionAlgorithms(&pType->encryptionAlgorithms, pContext, tag);
      }
      
      if( pType->validity & SS2_AllowedUMTS_Algorithms_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE OF BSSMAP-ServiceHandoverList Ber encoder */
static void AsnEncode_SS2_BSSMAP_ServiceHandoverList( SS2_BSSMAP_ServiceHandoverList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_BSSMAP_ServiceHandoverInfo((SS2_BSSMAP_ServiceHandoverInfo *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE OF RadioResourceList Ber encoder */
static void AsnEncode_SS2_RadioResourceList( SS2_RadioResourceList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RadioResource((SS2_RadioResource *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE SelectedUMTS-Algorithms Ber encoder */
static void AsnEncode_SS2_SelectedUMTS_Algorithms( SS2_SelectedUMTS_Algorithms *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_SelectedUMTS_Algorithms_integrityProtectionAlgorithm_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ChosenIntegrityProtectionAlgorithm(&pType->integrityProtectionAlgorithm, pContext, tag);
      }
      
      if( pType->validity & SS2_SelectedUMTS_Algorithms_encryptionAlgorithm_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ChosenEncryptionAlgorithm(&pType->encryptionAlgorithm, pContext, tag);
      }
      
      if( pType->validity & SS2_SelectedUMTS_Algorithms_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE CodecList Ber encoder */
static void AsnEncode_SS2_CodecList( SS2_CodecList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Codec(&pType->codec1, pContext, tag);
      }
      
      if( pType->validity & SS2_CodecList_codec2_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Codec(&pType->codec2, pContext, tag);
      }
      
      if( pType->validity & SS2_CodecList_codec3_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Codec(&pType->codec3, pContext, tag);
      }
      
      if( pType->validity & SS2_CodecList_codec4_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Codec(&pType->codec4, pContext, tag);
      }
      
      if( pType->validity & SS2_CodecList_codec5_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Codec(&pType->codec5, pContext, tag);
      }
      
      if( pType->validity & SS2_CodecList_codec6_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Codec(&pType->codec6, pContext, tag);
      }
      
      if( pType->validity & SS2_CodecList_codec7_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 7;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Codec(&pType->codec7, pContext, tag);
      }
      
      if( pType->validity & SS2_CodecList_codec8_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 8;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Codec(&pType->codec8, pContext, tag);
      }
      
      if( pType->validity & SS2_CodecList_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 9;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE SendEndSignal-Res Ber encoder */
extern U32 AsnEncode_SS2_SendEndSignal_Res( SS2_SendEndSignal_Res *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_SendEndSignal_Res_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE OF RelocationNumberList Ber encoder */
static void AsnEncode_SS2_RelocationNumberList( SS2_RelocationNumberList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RelocationNumber((SS2_RelocationNumber *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE SendAuthenticationInfoArg Ber encoder */
extern U32 AsnEncode_SS2_SendAuthenticationInfoArg( SS2_SendAuthenticationInfoArg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IMSI(&pType->imsi, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_NumberOfRequestedVectors( &pType->numberOfRequestedVectors, pContext, tag);
      }
      
      if( pType->validity & SS2_SendAuthenticationInfoArg_segmentationProhibited_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 5;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_SendAuthenticationInfoArg_immediateResponsePreferred_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_SendAuthenticationInfoArg_re_synchronisationInfo_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Re_synchronisationInfo(&pType->re_synchronisationInfo, pContext, tag);
      }
      
      if( pType->validity & SS2_SendAuthenticationInfoArg_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_SendAuthenticationInfoArg_requestingNodeType_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RequestingNodeType(&pType->requestingNodeType, pContext, tag);
      }
      
      if( pType->validity & SS2_SendAuthenticationInfoArg_requestingPLMN_Id_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_PLMN_Id(&pType->requestingPLMN_Id, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE CheckIMEI-Arg Ber encoder */
extern U32 AsnEncode_SS2_CheckIMEI_Arg( SS2_CheckIMEI_Arg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IMEI(&pType->imei, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 3;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RequestedEquipmentInfo(&pType->requestedEquipmentInfo, pContext, tag);
      }
      
      if( pType->validity & SS2_CheckIMEI_Arg_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE CheckIMEI-Res Ber encoder */
extern U32 AsnEncode_SS2_CheckIMEI_Res( SS2_CheckIMEI_Res *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_CheckIMEI_Res_equipmentStatus_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 10;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_EquipmentStatus(&pType->equipmentStatus, pContext, tag);
      }
      
      if( pType->validity & SS2_CheckIMEI_Res_bmuef_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_UESBI_Iu(&pType->bmuef, pContext, tag);
      }
      
      if( pType->validity & SS2_CheckIMEI_Res_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE PDP-Context Ber encoder */
static void AsnEncode_SS2_PDP_Context( SS2_PDP_Context *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ContextId( &pType->pdp_ContextId, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 16;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_PDP_Type(&pType->pdp_Type, pContext, tag);
      }
      
      if( pType->validity & SS2_PDP_Context_pdp_Address_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 17;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_PDP_Address(&pType->pdp_Address, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 18;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_QoS_Subscribed(&pType->qos_Subscribed, pContext, tag);
      }
      
      if( pType->validity & SS2_PDP_Context_vplmnAddressAllowed_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 19;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 20;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_APN(&pType->apn, pContext, tag);
      }
      
      if( pType->validity & SS2_PDP_Context_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 21;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_PDP_Context_ext_QoS_Subscribed_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_QoS_Subscribed(&pType->ext_QoS_Subscribed, pContext, tag);
      }
      
      if( pType->validity & SS2_PDP_Context_pdp_ChargingCharacteristics_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ChargingCharacteristics(&pType->pdp_ChargingCharacteristics, pContext, tag);
      }
      
      if( pType->validity & SS2_PDP_Context_ext2_QoS_Subscribed_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext2_QoS_Subscribed(&pType->ext2_QoS_Subscribed, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE GPRS-CamelTDPData Ber encoder */
static void AsnEncode_SS2_GPRS_CamelTDPData( SS2_GPRS_CamelTDPData *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GPRS_TriggerDetectionPoint(&pType->gprs_TriggerDetectionPoint, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ServiceKey( &pType->serviceKey, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->gsmSCF_Address, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_DefaultGPRS_Handling(&pType->defaultSessionHandling, pContext, tag);
      }
      
      if( pType->validity & SS2_GPRS_CamelTDPData_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE LSAData Ber encoder */
static void AsnEncode_SS2_LSAData( SS2_LSAData *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LSAIdentity(&pType->lsaIdentity, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LSAAttributes(&pType->lsaAttributes, pContext, tag);
      }
      
      if( pType->validity & SS2_LSAData_lsaActiveModeIndicator_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_LSAData_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE ODB-Data Ber encoder */
static void AsnEncode_SS2_ODB_Data( SS2_ODB_Data *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 3;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ODB_GeneralData(&pType->odb_GeneralData, pContext, tag);
      }
      
      if( pType->validity & SS2_ODB_Data_odb_HPLMN_Data_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 3;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ODB_HPLMN_Data(&pType->odb_HPLMN_Data, pContext, tag);
      }
      
      if( pType->validity & SS2_ODB_Data_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE Ext-ForwFeature Ber encoder */
static void AsnEncode_SS2_Ext_ForwFeature( SS2_Ext_ForwFeature *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_Ext_ForwFeature_basicService_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 0;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_BasicServiceCode(&pType->basicService, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_SS_Status(&pType->ss_Status, pContext, tag);
      }
      
      if( pType->validity & SS2_Ext_ForwFeature_forwardedToNumber_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->forwardedToNumber, pContext, tag);
      }
      
      if( pType->validity & SS2_Ext_ForwFeature_forwardedToSubaddress_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 8;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_SubaddressString(&pType->forwardedToSubaddress, pContext, tag);
      }
      
      if( pType->validity & SS2_Ext_ForwFeature_forwardingOptions_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_ForwOptions(&pType->forwardingOptions, pContext, tag);
      }
      
      if( pType->validity & SS2_Ext_ForwFeature_noReplyConditionTime_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 7;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_NoRepCondTime( &pType->noReplyConditionTime, pContext, tag);
      }
      
      if( pType->validity & SS2_Ext_ForwFeature_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 9;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_Ext_ForwFeature_longForwardedToNumber_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 10;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_FTN_AddressString(&pType->longForwardedToNumber, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE Ext-CallBarringFeature Ber encoder */
static void AsnEncode_SS2_Ext_CallBarringFeature( SS2_Ext_CallBarringFeature *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_Ext_CallBarringFeature_basicService_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 0;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_BasicServiceCode(&pType->basicService, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_SS_Status(&pType->ss_Status, pContext, tag);
      }
      
      if( pType->validity & SS2_Ext_CallBarringFeature_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE CUG-Subscription Ber encoder */
static void AsnEncode_SS2_CUG_Subscription( SS2_CUG_Subscription *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CUG_Index( &pType->cug_Index, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CUG_Interlock(&pType->cug_Interlock, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 10;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IntraCUG_Options(&pType->intraCUG_Options, pContext, tag);
      }
      
      if( pType->validity & SS2_CUG_Subscription_basicServiceGroupList_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_BasicServiceGroupList(&pType->basicServiceGroupList, pContext, tag);
      }
      
      if( pType->validity & SS2_CUG_Subscription_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE CUG-Feature Ber encoder */
static void AsnEncode_SS2_CUG_Feature( SS2_CUG_Feature *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_CUG_Feature_basicService_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 0;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_BasicServiceCode(&pType->basicService, pContext, tag);
      }
      
      if( pType->validity & SS2_CUG_Feature_preferentialCUG_Indicator_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CUG_Index( &pType->preferentialCUG_Indicator, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_InterCUG_Restrictions(&pType->interCUG_Restrictions, pContext, tag);
      }
      
      if( pType->validity & SS2_CUG_Feature_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE Ext-SS-Data Ber encoder */
static void AsnEncode_SS2_Ext_SS_Data( SS2_Ext_SS_Data *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_Code(&pType->ss_Code, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_SS_Status(&pType->ss_Status, pContext, tag);
      }
      
      if( pType->validity & SS2_Ext_SS_Data_ss_SubscriptionOption_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 0;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_SubscriptionOption(&pType->ss_SubscriptionOption, pContext, tag);
      }
      
      if( pType->validity & SS2_Ext_SS_Data_basicServiceGroupList_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_BasicServiceGroupList(&pType->basicServiceGroupList, pContext, tag);
      }
      
      if( pType->validity & SS2_Ext_SS_Data_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE ServiceType Ber encoder */
static void AsnEncode_SS2_ServiceType( SS2_ServiceType *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCSServiceTypeID( &pType->serviceTypeIdentity, pContext, tag);
      }
      
      if( pType->validity & SS2_ServiceType_gmlc_Restriction_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GMLC_Restriction(&pType->gmlc_Restriction, pContext, tag);
      }
      
      if( pType->validity & SS2_ServiceType_notificationToMSUser_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_NotificationToMSUser(&pType->notificationToMSUser, pContext, tag);
      }
      
      if( pType->validity & SS2_ServiceType_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE MOLR-Class Ber encoder */
static void AsnEncode_SS2_MOLR_Class( SS2_MOLR_Class *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_Code(&pType->ss_Code, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_SS_Status(&pType->ss_Status, pContext, tag);
      }
      
      if( pType->validity & SS2_MOLR_Class_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE InsertSubscriberDataRes Ber encoder */
extern U32 AsnEncode_SS2_InsertSubscriberDataRes( SS2_InsertSubscriberDataRes *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_InsertSubscriberDataRes_teleserviceList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_TeleserviceList(&pType->teleserviceList, pContext, tag);
      }
      
      if( pType->validity & SS2_InsertSubscriberDataRes_bearerServiceList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_BearerServiceList(&pType->bearerServiceList, pContext, tag);
      }
      
      if( pType->validity & SS2_InsertSubscriberDataRes_ss_List_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_List(&pType->ss_List, pContext, tag);
      }
      
      if( pType->validity & SS2_InsertSubscriberDataRes_odb_GeneralData_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ODB_GeneralData(&pType->odb_GeneralData, pContext, tag);
      }
      
      if( pType->validity & SS2_InsertSubscriberDataRes_regionalSubscriptionResponse_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RegionalSubscriptionResponse(&pType->regionalSubscriptionResponse, pContext, tag);
      }
      
      if( pType->validity & SS2_InsertSubscriberDataRes_supportedCamelPhases_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SupportedCamelPhases(&pType->supportedCamelPhases, pContext, tag);
      }
      
      if( pType->validity & SS2_InsertSubscriberDataRes_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 7;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_InsertSubscriberDataRes_offeredCamel4CSIs_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 8;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_OfferedCamel4CSIs(&pType->offeredCamel4CSIs, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE DeleteSubscriberDataArg Ber encoder */
extern U32 AsnEncode_SS2_DeleteSubscriberDataArg( SS2_DeleteSubscriberDataArg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IMSI(&pType->imsi, pContext, tag);
      }
      
      if( pType->validity & SS2_DeleteSubscriberDataArg_basicServiceList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_BasicServiceList(&pType->basicServiceList, pContext, tag);
      }
      
      if( pType->validity & SS2_DeleteSubscriberDataArg_ss_List_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_List(&pType->ss_List, pContext, tag);
      }
      
      if( pType->validity & SS2_DeleteSubscriberDataArg_roamingRestrictionDueToUnsupportedFeature_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_DeleteSubscriberDataArg_regionalSubscriptionIdentifier_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ZoneCode(&pType->regionalSubscriptionIdentifier, pContext, tag);
      }
      
      if( pType->validity & SS2_DeleteSubscriberDataArg_vbsGroupIndication_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 7;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_DeleteSubscriberDataArg_vgcsGroupIndication_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 8;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_DeleteSubscriberDataArg_camelSubscriptionInfoWithdraw_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 9;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_DeleteSubscriberDataArg_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_DeleteSubscriberDataArg_gprsSubscriptionDataWithdraw_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 10;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GPRSSubscriptionDataWithdraw(&pType->gprsSubscriptionDataWithdraw, pContext, tag);
      }
      
      if( pType->validity & SS2_DeleteSubscriberDataArg_roamingRestrictedInSgsnDueToUnsuppportedFeature_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 11;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_DeleteSubscriberDataArg_lsaInformationWithdraw_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 12;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LSAInformationWithdraw(&pType->lsaInformationWithdraw, pContext, tag);
      }
      
      if( pType->validity & SS2_DeleteSubscriberDataArg_gmlc_ListWithdraw_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 13;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_DeleteSubscriberDataArg_istInformationWithdraw_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 14;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_DeleteSubscriberDataArg_specificCSI_Withdraw_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 15;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SpecificCSI_Withdraw(&pType->specificCSI_Withdraw, pContext, tag);
      }
      
      if( pType->validity & SS2_DeleteSubscriberDataArg_chargingCharacteristicsWithdraw_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 16;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE DeleteSubscriberDataRes Ber encoder */
extern U32 AsnEncode_SS2_DeleteSubscriberDataRes( SS2_DeleteSubscriberDataRes *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_DeleteSubscriberDataRes_regionalSubscriptionResponse_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RegionalSubscriptionResponse(&pType->regionalSubscriptionResponse, pContext, tag);
      }
      
      if( pType->validity & SS2_DeleteSubscriberDataRes_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE MT-smsCAMELTDP-Criteria Ber encoder */
static void AsnEncode_SS2_MT_smsCAMELTDP_Criteria( SS2_MT_smsCAMELTDP_Criteria *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 10;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SMS_TriggerDetectionPoint(&pType->sms_TriggerDetectionPoint, pContext, tag);
      }
      
      if( pType->validity & SS2_MT_smsCAMELTDP_Criteria_tpdu_TypeCriterion_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_TPDU_TypeCriterion(&pType->tpdu_TypeCriterion, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE DP-AnalysedInfoCriterium Ber encoder */
static void AsnEncode_SS2_DP_AnalysedInfoCriterium( SS2_DP_AnalysedInfoCriterium *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->dialledNumber, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ServiceKey( &pType->serviceKey, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->gsmSCF_Address, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 10;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_DefaultCallHandling(&pType->defaultCallHandling, pContext, tag);
      }
      
      if( pType->validity & SS2_DP_AnalysedInfoCriterium_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE SS-CamelData Ber encoder */
static void AsnEncode_SS2_SS_CamelData( SS2_SS_CamelData *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_EventList(&pType->ss_EventList, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->gsmSCF_Address, pContext, tag);
      }
      
      if( pType->validity & SS2_SS_CamelData_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE O-BcsmCamelTDPData Ber encoder */
static void AsnEncode_SS2_O_BcsmCamelTDPData( SS2_O_BcsmCamelTDPData *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 10;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_O_BcsmTriggerDetectionPoint(&pType->o_BcsmTriggerDetectionPoint, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ServiceKey( &pType->serviceKey, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->gsmSCF_Address, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_DefaultCallHandling(&pType->defaultCallHandling, pContext, tag);
      }
      
      if( pType->validity & SS2_O_BcsmCamelTDPData_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE O-BcsmCamelTDP-Criteria Ber encoder */
static void AsnEncode_SS2_O_BcsmCamelTDP_Criteria( SS2_O_BcsmCamelTDP_Criteria *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 10;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_O_BcsmTriggerDetectionPoint(&pType->o_BcsmTriggerDetectionPoint, pContext, tag);
      }
      
      if( pType->validity & SS2_O_BcsmCamelTDP_Criteria_destinationNumberCriteria_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_DestinationNumberCriteria(&pType->destinationNumberCriteria, pContext, tag);
      }
      
      if( pType->validity & SS2_O_BcsmCamelTDP_Criteria_basicServiceCriteria_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_BasicServiceCriteria(&pType->basicServiceCriteria, pContext, tag);
      }
      
      if( pType->validity & SS2_O_BcsmCamelTDP_Criteria_callTypeCriteria_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CallTypeCriteria(&pType->callTypeCriteria, pContext, tag);
      }
      
      if( pType->validity & SS2_O_BcsmCamelTDP_Criteria_o_CauseValueCriteria_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_O_CauseValueCriteria(&pType->o_CauseValueCriteria, pContext, tag);
      }
      
      if( pType->validity & SS2_O_BcsmCamelTDP_Criteria_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE T-BCSM-CAMEL-TDP-Criteria Ber encoder */
static void AsnEncode_SS2_T_BCSM_CAMEL_TDP_Criteria( SS2_T_BCSM_CAMEL_TDP_Criteria *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 10;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_T_BcsmTriggerDetectionPoint(&pType->t_BCSM_TriggerDetectionPoint, pContext, tag);
      }
      
      if( pType->validity & SS2_T_BCSM_CAMEL_TDP_Criteria_basicServiceCriteria_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_BasicServiceCriteria(&pType->basicServiceCriteria, pContext, tag);
      }
      
      if( pType->validity & SS2_T_BCSM_CAMEL_TDP_Criteria_t_CauseValueCriteria_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_T_CauseValueCriteria(&pType->t_CauseValueCriteria, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE SMS-CAMEL-TDP-Data Ber encoder */
static void AsnEncode_SS2_SMS_CAMEL_TDP_Data( SS2_SMS_CAMEL_TDP_Data *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SMS_TriggerDetectionPoint(&pType->sms_TriggerDetectionPoint, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ServiceKey( &pType->serviceKey, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->gsmSCF_Address, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_DefaultSMS_Handling(&pType->defaultSMS_Handling, pContext, tag);
      }
      
      if( pType->validity & SS2_SMS_CAMEL_TDP_Data_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE M-CSI Ber encoder */
static void AsnEncode_SS2_M_CSI( SS2_M_CSI *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_MobilityTriggers(&pType->mobilityTriggers, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ServiceKey( &pType->serviceKey, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->gsmSCF_Address, pContext, tag);
      }
      
      if( pType->validity & SS2_M_CSI_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_M_CSI_notificationToCSE_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_M_CSI_csi_Active_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE MG-CSI Ber encoder */
static void AsnEncode_SS2_MG_CSI( SS2_MG_CSI *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_MobilityTriggers(&pType->mobilityTriggers, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ServiceKey( &pType->serviceKey, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->gsmSCF_Address, pContext, tag);
      }
      
      if( pType->validity & SS2_MG_CSI_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_MG_CSI_notificationToCSE_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_MG_CSI_csi_Active_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE T-BcsmCamelTDPData Ber encoder */
static void AsnEncode_SS2_T_BcsmCamelTDPData( SS2_T_BcsmCamelTDPData *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 10;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_T_BcsmTriggerDetectionPoint(&pType->t_BcsmTriggerDetectionPoint, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ServiceKey( &pType->serviceKey, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->gsmSCF_Address, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_DefaultCallHandling(&pType->defaultCallHandling, pContext, tag);
      }
      
      if( pType->validity & SS2_T_BcsmCamelTDPData_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE SendRoutingInfoForGprsArg Ber encoder */
extern U32 AsnEncode_SS2_SendRoutingInfoForGprsArg( SS2_SendRoutingInfoForGprsArg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IMSI(&pType->imsi, pContext, tag);
      }
      
      if( pType->validity & SS2_SendRoutingInfoForGprsArg_ggsn_Address_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GSN_Address(&pType->ggsn_Address, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->ggsn_Number, pContext, tag);
      }
      
      if( pType->validity & SS2_SendRoutingInfoForGprsArg_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE SendRoutingInfoForGprsRes Ber encoder */
extern U32 AsnEncode_SS2_SendRoutingInfoForGprsRes( SS2_SendRoutingInfoForGprsRes *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GSN_Address(&pType->sgsn_Address, pContext, tag);
      }
      
      if( pType->validity & SS2_SendRoutingInfoForGprsRes_ggsn_Address_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GSN_Address(&pType->ggsn_Address, pContext, tag);
      }
      
      if( pType->validity & SS2_SendRoutingInfoForGprsRes_mobileNotReachableReason_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AbsentSubscriberDiagnosticSM( &pType->mobileNotReachableReason, pContext, tag);
      }
      
      if( pType->validity & SS2_SendRoutingInfoForGprsRes_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE FailureReportArg Ber encoder */
extern U32 AsnEncode_SS2_FailureReportArg( SS2_FailureReportArg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IMSI(&pType->imsi, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->ggsn_Number, pContext, tag);
      }
      
      if( pType->validity & SS2_FailureReportArg_ggsn_Address_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GSN_Address(&pType->ggsn_Address, pContext, tag);
      }
      
      if( pType->validity & SS2_FailureReportArg_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE FailureReportRes Ber encoder */
extern U32 AsnEncode_SS2_FailureReportRes( SS2_FailureReportRes *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_FailureReportRes_ggsn_Address_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GSN_Address(&pType->ggsn_Address, pContext, tag);
      }
      
      if( pType->validity & SS2_FailureReportRes_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE NoteMsPresentForGprsArg Ber encoder */
extern U32 AsnEncode_SS2_NoteMsPresentForGprsArg( SS2_NoteMsPresentForGprsArg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IMSI(&pType->imsi, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GSN_Address(&pType->sgsn_Address, pContext, tag);
      }
      
      if( pType->validity & SS2_NoteMsPresentForGprsArg_ggsn_Address_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GSN_Address(&pType->ggsn_Address, pContext, tag);
      }
      
      if( pType->validity & SS2_NoteMsPresentForGprsArg_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE NoteMsPresentForGprsRes Ber encoder */
extern U32 AsnEncode_SS2_NoteMsPresentForGprsRes( SS2_NoteMsPresentForGprsRes *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_NoteMsPresentForGprsRes_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE RestoreDataArg Ber encoder */
extern U32 AsnEncode_SS2_RestoreDataArg( SS2_RestoreDataArg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IMSI(&pType->imsi, pContext, tag);
      }
      
      if( pType->validity & SS2_RestoreDataArg_lmsi_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LMSI(&pType->lmsi, pContext, tag);
      }
      
      if( pType->validity & SS2_RestoreDataArg_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_RestoreDataArg_vlr_Capability_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_VLR_Capability(&pType->vlr_Capability, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE RestoreDataRes Ber encoder */
extern U32 AsnEncode_SS2_RestoreDataRes( SS2_RestoreDataRes *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->hlr_Number, pContext, tag);
      }
      
      if( pType->validity & SS2_RestoreDataRes_msNotReachable_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 5;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_RestoreDataRes_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE VoiceGroupCallData Ber encoder */
static void AsnEncode_SS2_VoiceGroupCallData( SS2_VoiceGroupCallData *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GroupId(&pType->groupId, pContext, tag);
      }
      
      if( pType->validity & SS2_VoiceGroupCallData_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE VoiceBroadcastData Ber encoder */
static void AsnEncode_SS2_VoiceBroadcastData( SS2_VoiceBroadcastData *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GroupId(&pType->groupid, pContext, tag);
      }
      
      if( pType->validity & SS2_VoiceBroadcastData_broadcastInitEntitlement_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 5;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_VoiceBroadcastData_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE MNPInfoRes Ber encoder */
static void AsnEncode_SS2_MNPInfoRes( SS2_MNPInfoRes *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_MNPInfoRes_routeingNumber_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RouteingNumber(&pType->routeingNumber, pContext, tag);
      }
      
      if( pType->validity & SS2_MNPInfoRes_imsi_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IMSI(&pType->imsi, pContext, tag);
      }
      
      if( pType->validity & SS2_MNPInfoRes_msisdn_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->msisdn, pContext, tag);
      }
      
      if( pType->validity & SS2_MNPInfoRes_numberPortabilityStatus_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_NumberPortabilityStatus(&pType->numberPortabilityStatus, pContext, tag);
      }
      
      if( pType->validity & SS2_MNPInfoRes_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE RequestedInfo Ber encoder */
static void AsnEncode_SS2_RequestedInfo( SS2_RequestedInfo *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_RequestedInfo_locationInformation_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_RequestedInfo_subscriberState_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_RequestedInfo_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_RequestedInfo_currentLocation_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_RequestedInfo_requestedDomain_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_DomainType(&pType->requestedDomain, pContext, tag);
      }
      
      if( pType->validity & SS2_RequestedInfo_imei_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_RequestedInfo_ms_classmark_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_RequestedInfo_mnpRequestedInfo_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 7;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE LocationInformation Ber encoder */
static void AsnEncode_SS2_LocationInformation( SS2_LocationInformation *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_LocationInformation_ageOfLocationInformation_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AgeOfLocationInformation( &pType->ageOfLocationInformation, pContext, tag);
      }
      
      if( pType->validity & SS2_LocationInformation_geographicalInformation_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GeographicalInformation(&pType->geographicalInformation, pContext, tag);
      }
      
      if( pType->validity & SS2_LocationInformation_vlr_number_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->vlr_number, pContext, tag);
      }
      
      if( pType->validity & SS2_LocationInformation_locationNumber_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LocationNumber(&pType->locationNumber, pContext, tag);
      }
      
      if( pType->validity & SS2_LocationInformation_cellGlobalIdOrServiceAreaIdOrLAI_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CellGlobalIdOrServiceAreaIdOrLAI(&pType->cellGlobalIdOrServiceAreaIdOrLAI, pContext, tag);
      }
      
      if( pType->validity & SS2_LocationInformation_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_LocationInformation_selectedLSA_Id_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LSAIdentity(&pType->selectedLSA_Id, pContext, tag);
      }
      
      if( pType->validity & SS2_LocationInformation_msc_Number_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->msc_Number, pContext, tag);
      }
      
      if( pType->validity & SS2_LocationInformation_geodeticInformation_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 7;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GeodeticInformation(&pType->geodeticInformation, pContext, tag);
      }
      
      if( pType->validity & SS2_LocationInformation_currentLocationRetrieved_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 8;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_LocationInformation_sai_Present_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 9;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE LocationInformationGPRS Ber encoder */
static void AsnEncode_SS2_LocationInformationGPRS( SS2_LocationInformationGPRS *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_LocationInformationGPRS_cellGlobalIdOrServiceAreaIdOrLAI_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CellGlobalIdOrServiceAreaIdOrLAI(&pType->cellGlobalIdOrServiceAreaIdOrLAI, pContext, tag);
      }
      
      if( pType->validity & SS2_LocationInformationGPRS_routeingAreaIdentity_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RAIdentity(&pType->routeingAreaIdentity, pContext, tag);
      }
      
      if( pType->validity & SS2_LocationInformationGPRS_geographicalInformation_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GeographicalInformation(&pType->geographicalInformation, pContext, tag);
      }
      
      if( pType->validity & SS2_LocationInformationGPRS_sgsn_Number_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->sgsn_Number, pContext, tag);
      }
      
      if( pType->validity & SS2_LocationInformationGPRS_selectedLSAIdentity_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LSAIdentity(&pType->selectedLSAIdentity, pContext, tag);
      }
      
      if( pType->validity & SS2_LocationInformationGPRS_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_LocationInformationGPRS_sai_Present_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_LocationInformationGPRS_geodeticInformation_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 7;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GeodeticInformation(&pType->geodeticInformation, pContext, tag);
      }
      
      if( pType->validity & SS2_LocationInformationGPRS_currentLocationRetrieved_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 8;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_LocationInformationGPRS_ageOfLocationInformation_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 9;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AgeOfLocationInformation( &pType->ageOfLocationInformation, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE PDP-ContextInfo Ber encoder */
static void AsnEncode_SS2_PDP_ContextInfo( SS2_PDP_ContextInfo *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ContextId( &pType->pdp_ContextIdentifier, pContext, tag);
      }
      
      if( pType->validity & SS2_PDP_ContextInfo_pdp_ContextActive_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_PDP_Type(&pType->pdp_Type, pContext, tag);
      }
      
      if( pType->validity & SS2_PDP_ContextInfo_pdp_Address_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_PDP_Address(&pType->pdp_Address, pContext, tag);
      }
      
      if( pType->validity & SS2_PDP_ContextInfo_apn_Subscribed_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_APN(&pType->apn_Subscribed, pContext, tag);
      }
      
      if( pType->validity & SS2_PDP_ContextInfo_apn_InUse_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_APN(&pType->apn_InUse, pContext, tag);
      }
      
      if( pType->validity & SS2_PDP_ContextInfo_nsapi_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_NSAPI( &pType->nsapi, pContext, tag);
      }
      
      if( pType->validity & SS2_PDP_ContextInfo_transactionId_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 7;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_TransactionId(&pType->transactionId, pContext, tag);
      }
      
      if( pType->validity & SS2_PDP_ContextInfo_teid_ForGnAndGp_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 8;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_TEID(&pType->teid_ForGnAndGp, pContext, tag);
      }
      
      if( pType->validity & SS2_PDP_ContextInfo_teid_ForIu_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 9;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_TEID(&pType->teid_ForIu, pContext, tag);
      }
      
      if( pType->validity & SS2_PDP_ContextInfo_ggsn_Address_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 10;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GSN_Address(&pType->ggsn_Address, pContext, tag);
      }
      
      if( pType->validity & SS2_PDP_ContextInfo_qos_Subscribed_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 11;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_QoS_Subscribed(&pType->qos_Subscribed, pContext, tag);
      }
      
      if( pType->validity & SS2_PDP_ContextInfo_qos_Requested_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 12;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_QoS_Subscribed(&pType->qos_Requested, pContext, tag);
      }
      
      if( pType->validity & SS2_PDP_ContextInfo_qos_Negotiated_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 13;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_QoS_Subscribed(&pType->qos_Negotiated, pContext, tag);
      }
      
      if( pType->validity & SS2_PDP_ContextInfo_chargingId_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 14;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GPRSChargingID(&pType->chargingId, pContext, tag);
      }
      
      if( pType->validity & SS2_PDP_ContextInfo_chargingCharacteristics_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 15;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ChargingCharacteristics(&pType->chargingCharacteristics, pContext, tag);
      }
      
      if( pType->validity & SS2_PDP_ContextInfo_rnc_Address_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 16;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GSN_Address(&pType->rnc_Address, pContext, tag);
      }
      
      if( pType->validity & SS2_PDP_ContextInfo_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 17;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_PDP_ContextInfo_qos2_Subscribed_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 18;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext2_QoS_Subscribed(&pType->qos2_Subscribed, pContext, tag);
      }
      
      if( pType->validity & SS2_PDP_ContextInfo_qos2_Requested_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 19;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext2_QoS_Subscribed(&pType->qos2_Requested, pContext, tag);
      }
      
      if( pType->validity & SS2_PDP_ContextInfo_qos2_Negotiated_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 20;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext2_QoS_Subscribed(&pType->qos2_Negotiated, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE AnyTimeInterrogationArg Ber encoder */
extern U32 AsnEncode_SS2_AnyTimeInterrogationArg( SS2_AnyTimeInterrogationArg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SubscriberIdentity(&pType->subscriberIdentity, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RequestedInfo(&pType->requestedInfo, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->gsmSCF_Address, pContext, tag);
      }
      
      if( pType->validity & SS2_AnyTimeInterrogationArg_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE RequestedSubscriptionInfo Ber encoder */
static void AsnEncode_SS2_RequestedSubscriptionInfo( SS2_RequestedSubscriptionInfo *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_RequestedSubscriptionInfo_requestedSS_Info_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_ForBS_Code(&pType->requestedSS_Info, pContext, tag);
      }
      
      if( pType->validity & SS2_RequestedSubscriptionInfo_odb_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_RequestedSubscriptionInfo_requestedCAMEL_SubscriptionInfo_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RequestedCAMEL_SubscriptionInfo(&pType->requestedCAMEL_SubscriptionInfo, pContext, tag);
      }
      
      if( pType->validity & SS2_RequestedSubscriptionInfo_supportedVLR_CAMEL_Phases_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_RequestedSubscriptionInfo_supportedSGSN_CAMEL_Phases_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_RequestedSubscriptionInfo_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_RequestedSubscriptionInfo_additionalRequestedCAMEL_SubscriptionInfo_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 7;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AdditionalRequestedCAMEL_SubscriptionInfo(&pType->additionalRequestedCAMEL_SubscriptionInfo, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE ODB-Info Ber encoder */
static void AsnEncode_SS2_ODB_Info( SS2_ODB_Info *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ODB_Data(&pType->odb_Data, pContext, tag);
      }
      
      if( pType->validity & SS2_ODB_Info_notificationToCSE_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 5;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_ODB_Info_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE ModificationRequestFor-CF-Info Ber encoder */
static void AsnEncode_SS2_ModificationRequestFor_CF_Info( SS2_ModificationRequestFor_CF_Info *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_Code(&pType->ss_Code, pContext, tag);
      }
      
      if( pType->validity & SS2_ModificationRequestFor_CF_Info_basicService_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_BasicServiceCode(&pType->basicService, pContext, tag);
      }
      
      if( pType->validity & SS2_ModificationRequestFor_CF_Info_ss_Status_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_SS_Status(&pType->ss_Status, pContext, tag);
      }
      
      if( pType->validity & SS2_ModificationRequestFor_CF_Info_forwardedToNumber_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AddressString(&pType->forwardedToNumber, pContext, tag);
      }
      
      if( pType->validity & SS2_ModificationRequestFor_CF_Info_forwardedToSubaddress_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_SubaddressString(&pType->forwardedToSubaddress, pContext, tag);
      }
      
      if( pType->validity & SS2_ModificationRequestFor_CF_Info_noReplyConditionTime_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_NoRepCondTime( &pType->noReplyConditionTime, pContext, tag);
      }
      
      if( pType->validity & SS2_ModificationRequestFor_CF_Info_modifyNotificationToCSE_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ModificationInstruction(&pType->modifyNotificationToCSE, pContext, tag);
      }
      
      if( pType->validity & SS2_ModificationRequestFor_CF_Info_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 7;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE ModificationRequestFor-CB-Info Ber encoder */
static void AsnEncode_SS2_ModificationRequestFor_CB_Info( SS2_ModificationRequestFor_CB_Info *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_Code(&pType->ss_Code, pContext, tag);
      }
      
      if( pType->validity & SS2_ModificationRequestFor_CB_Info_basicService_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_BasicServiceCode(&pType->basicService, pContext, tag);
      }
      
      if( pType->validity & SS2_ModificationRequestFor_CB_Info_ss_Status_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_SS_Status(&pType->ss_Status, pContext, tag);
      }
      
      if( pType->validity & SS2_ModificationRequestFor_CB_Info_password_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Password(&pType->password, pContext, tag);
      }
      
      if( pType->validity & SS2_ModificationRequestFor_CB_Info_wrongPasswordAttemptsCounter_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_WrongPasswordAttemptsCounter( &pType->wrongPasswordAttemptsCounter, pContext, tag);
      }
      
      if( pType->validity & SS2_ModificationRequestFor_CB_Info_modifyNotificationToCSE_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ModificationInstruction(&pType->modifyNotificationToCSE, pContext, tag);
      }
      
      if( pType->validity & SS2_ModificationRequestFor_CB_Info_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE ModificationRequestFor-ODB-data Ber encoder */
static void AsnEncode_SS2_ModificationRequestFor_ODB_data( SS2_ModificationRequestFor_ODB_data *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_ModificationRequestFor_ODB_data_odb_data_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ODB_Data(&pType->odb_data, pContext, tag);
      }
      
      if( pType->validity & SS2_ModificationRequestFor_ODB_data_modifyNotificationToCSE_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ModificationInstruction(&pType->modifyNotificationToCSE, pContext, tag);
      }
      
      if( pType->validity & SS2_ModificationRequestFor_ODB_data_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE ModificationRequestFor-CSI Ber encoder */
static void AsnEncode_SS2_ModificationRequestFor_CSI( SS2_ModificationRequestFor_CSI *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RequestedCAMEL_SubscriptionInfo(&pType->requestedCamel_SubscriptionInfo, pContext, tag);
      }
      
      if( pType->validity & SS2_ModificationRequestFor_CSI_modifyNotificationToCSE_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ModificationInstruction(&pType->modifyNotificationToCSE, pContext, tag);
      }
      
      if( pType->validity & SS2_ModificationRequestFor_CSI_modifyCSI_State_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ModificationInstruction(&pType->modifyCSI_State, pContext, tag);
      }
      
      if( pType->validity & SS2_ModificationRequestFor_CSI_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_ModificationRequestFor_CSI_additionalRequestedCAMEL_SubscriptionInfo_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AdditionalRequestedCAMEL_SubscriptionInfo(&pType->additionalRequestedCAMEL_SubscriptionInfo, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE NoteSubscriberDataModifiedRes Ber encoder */
extern U32 AsnEncode_SS2_NoteSubscriberDataModifiedRes( SS2_NoteSubscriberDataModifiedRes *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_NoteSubscriberDataModifiedRes_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE NoteMM-EventArg Ber encoder */
extern U32 AsnEncode_SS2_NoteMM_EventArg( SS2_NoteMM_EventArg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ServiceKey( &pType->serviceKey, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_MM_Code(&pType->eventMet, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IMSI(&pType->imsi, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->msisdn, pContext, tag);
      }
      
      if( pType->validity & SS2_NoteMM_EventArg_locationInformation_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LocationInformation(&pType->locationInformation, pContext, tag);
      }
      
      if( pType->validity & SS2_NoteMM_EventArg_supportedCAMELPhases_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SupportedCamelPhases(&pType->supportedCAMELPhases, pContext, tag);
      }
      
      if( pType->validity & SS2_NoteMM_EventArg_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_NoteMM_EventArg_locationInformationGPRS_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 7;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LocationInformationGPRS(&pType->locationInformationGPRS, pContext, tag);
      }
      
      if( pType->validity & SS2_NoteMM_EventArg_offeredCamel4Functionalities_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 8;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_OfferedCamel4Functionalities(&pType->offeredCamel4Functionalities, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE NoteMM-EventRes Ber encoder */
extern U32 AsnEncode_SS2_NoteMM_EventRes( SS2_NoteMM_EventRes *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_NoteMM_EventRes_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE ActivateTraceModeArg Ber encoder */
extern U32 AsnEncode_SS2_ActivateTraceModeArg( SS2_ActivateTraceModeArg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_ActivateTraceModeArg_imsi_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IMSI(&pType->imsi, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_TraceReference(&pType->traceReference, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_TraceType( &pType->traceType, pContext, tag);
      }
      
      if( pType->validity & SS2_ActivateTraceModeArg_omc_Id_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AddressString(&pType->omc_Id, pContext, tag);
      }
      
      if( pType->validity & SS2_ActivateTraceModeArg_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_ActivateTraceModeArg_traceReference2_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_TraceReference2(&pType->traceReference2, pContext, tag);
      }
      
      if( pType->validity & SS2_ActivateTraceModeArg_traceDepthList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_TraceDepthList(&pType->traceDepthList, pContext, tag);
      }
      
      if( pType->validity & SS2_ActivateTraceModeArg_traceNE_TypeList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 7;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_TraceNE_TypeList(&pType->traceNE_TypeList, pContext, tag);
      }
      
      if( pType->validity & SS2_ActivateTraceModeArg_traceInterfaceList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 8;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_TraceInterfaceList(&pType->traceInterfaceList, pContext, tag);
      }
      
      if( pType->validity & SS2_ActivateTraceModeArg_traceEventList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 9;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_TraceEventList(&pType->traceEventList, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE ActivateTraceModeRes Ber encoder */
extern U32 AsnEncode_SS2_ActivateTraceModeRes( SS2_ActivateTraceModeRes *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_ActivateTraceModeRes_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_ActivateTraceModeRes_traceSupportIndicator_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE DeactivateTraceModeArg Ber encoder */
extern U32 AsnEncode_SS2_DeactivateTraceModeArg( SS2_DeactivateTraceModeArg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_DeactivateTraceModeArg_imsi_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IMSI(&pType->imsi, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_TraceReference(&pType->traceReference, pContext, tag);
      }
      
      if( pType->validity & SS2_DeactivateTraceModeArg_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_DeactivateTraceModeArg_traceReference2_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_TraceReference2(&pType->traceReference2, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE DeactivateTraceModeRes Ber encoder */
extern U32 AsnEncode_SS2_DeactivateTraceModeRes( SS2_DeactivateTraceModeRes *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_DeactivateTraceModeRes_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE RoutingInfoForSM-Arg Ber encoder */
extern U32 AsnEncode_SS2_RoutingInfoForSM_Arg( SS2_RoutingInfoForSM_Arg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->msisdn, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         ber_put_boolean(pContext, (AsnBool *)(&pType->sm_RP_PRI), tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AddressString(&pType->serviceCentreAddress, pContext, tag);
      }
      
      if( pType->validity & SS2_RoutingInfoForSM_Arg_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_RoutingInfoForSM_Arg_gprsSupportIndicator_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 7;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_RoutingInfoForSM_Arg_sm_RP_MTI_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 8;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SM_RP_MTI( &pType->sm_RP_MTI, pContext, tag);
      }
      
      if( pType->validity & SS2_RoutingInfoForSM_Arg_sm_RP_SMEA_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 9;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SM_RP_SMEA(&pType->sm_RP_SMEA, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE LocationInfoWithLMSI Ber encoder */
static void AsnEncode_SS2_LocationInfoWithLMSI( SS2_LocationInfoWithLMSI *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->networkNode_Number, pContext, tag);
      }
      
      if( pType->validity & SS2_LocationInfoWithLMSI_lmsi_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LMSI(&pType->lmsi, pContext, tag);
      }
      
      if( pType->validity & SS2_LocationInfoWithLMSI_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_LocationInfoWithLMSI_gprsNodeIndicator_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_LocationInfoWithLMSI_additional_Number_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Additional_Number(&pType->additional_Number, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE MO-ForwardSM-Arg Ber encoder */
extern U32 AsnEncode_SS2_MO_ForwardSM_Arg( SS2_MO_ForwardSM_Arg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 0;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SM_RP_DA(&pType->sm_RP_DA, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 0;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SM_RP_OA(&pType->sm_RP_OA, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SignalInfo(&pType->sm_RP_UI, pContext, tag);
      }
      
      if( pType->validity & SS2_MO_ForwardSM_Arg_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_MO_ForwardSM_Arg_imsi_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IMSI(&pType->imsi, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE MO-ForwardSM-Res Ber encoder */
extern U32 AsnEncode_SS2_MO_ForwardSM_Res( SS2_MO_ForwardSM_Res *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_MO_ForwardSM_Res_sm_RP_UI_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SignalInfo(&pType->sm_RP_UI, pContext, tag);
      }
      
      if( pType->validity & SS2_MO_ForwardSM_Res_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE MT-ForwardSM-Arg Ber encoder */
extern U32 AsnEncode_SS2_MT_ForwardSM_Arg( SS2_MT_ForwardSM_Arg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 0;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SM_RP_DA(&pType->sm_RP_DA, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 0;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SM_RP_OA(&pType->sm_RP_OA, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SignalInfo(&pType->sm_RP_UI, pContext, tag);
      }
      
      if( pType->validity & SS2_MT_ForwardSM_Arg_moreMessagesToSend_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 5;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_MT_ForwardSM_Arg_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE MT-ForwardSM-Res Ber encoder */
extern U32 AsnEncode_SS2_MT_ForwardSM_Res( SS2_MT_ForwardSM_Res *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_MT_ForwardSM_Res_sm_RP_UI_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SignalInfo(&pType->sm_RP_UI, pContext, tag);
      }
      
      if( pType->validity & SS2_MT_ForwardSM_Res_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE ReportSM-DeliveryStatusArg Ber encoder */
extern U32 AsnEncode_SS2_ReportSM_DeliveryStatusArg( SS2_ReportSM_DeliveryStatusArg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->msisdn, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AddressString(&pType->serviceCentreAddress, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 10;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SM_DeliveryOutcome(&pType->sm_DeliveryOutcome, pContext, tag);
      }
      
      if( pType->validity & SS2_ReportSM_DeliveryStatusArg_absentSubscriberDiagnosticSM_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AbsentSubscriberDiagnosticSM( &pType->absentSubscriberDiagnosticSM, pContext, tag);
      }
      
      if( pType->validity & SS2_ReportSM_DeliveryStatusArg_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_ReportSM_DeliveryStatusArg_gprsSupportIndicator_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_ReportSM_DeliveryStatusArg_deliveryOutcomeIndicator_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_ReportSM_DeliveryStatusArg_additionalSM_DeliveryOutcome_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SM_DeliveryOutcome(&pType->additionalSM_DeliveryOutcome, pContext, tag);
      }
      
      if( pType->validity & SS2_ReportSM_DeliveryStatusArg_additionalAbsentSubscriberDiagnosticSM_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AbsentSubscriberDiagnosticSM( &pType->additionalAbsentSubscriberDiagnosticSM, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE ReportSM-DeliveryStatusRes Ber encoder */
extern U32 AsnEncode_SS2_ReportSM_DeliveryStatusRes( SS2_ReportSM_DeliveryStatusRes *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_ReportSM_DeliveryStatusRes_storedMSISDN_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->storedMSISDN, pContext, tag);
      }
      
      if( pType->validity & SS2_ReportSM_DeliveryStatusRes_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE InformServiceCentreArg Ber encoder */
extern U32 AsnEncode_SS2_InformServiceCentreArg( SS2_InformServiceCentreArg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_InformServiceCentreArg_storedMSISDN_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->storedMSISDN, pContext, tag);
      }
      
      if( pType->validity & SS2_InformServiceCentreArg_mw_Status_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 3;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_MW_Status(&pType->mw_Status, pContext, tag);
      }
      
      if( pType->validity & SS2_InformServiceCentreArg_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_InformServiceCentreArg_absentSubscriberDiagnosticSM_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AbsentSubscriberDiagnosticSM( &pType->absentSubscriberDiagnosticSM, pContext, tag);
      }
      
      if( pType->validity & SS2_InformServiceCentreArg_additionalAbsentSubscriberDiagnosticSM_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AbsentSubscriberDiagnosticSM( &pType->additionalAbsentSubscriberDiagnosticSM, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE ReadyForSM-Arg Ber encoder */
extern U32 AsnEncode_SS2_ReadyForSM_Arg( SS2_ReadyForSM_Arg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IMSI(&pType->imsi, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 10;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AlertReason(&pType->alertReason, pContext, tag);
      }
      
      if( pType->validity & SS2_ReadyForSM_Arg_alertReasonIndicator_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 5;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_ReadyForSM_Arg_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE ReadyForSM-Res Ber encoder */
extern U32 AsnEncode_SS2_ReadyForSM_Res( SS2_ReadyForSM_Res *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_ReadyForSM_Res_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE OF ForwardingFeatureList Ber encoder */
static void AsnEncode_SS2_ForwardingFeatureList( SS2_ForwardingFeatureList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ForwardingFeature((SS2_ForwardingFeature *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE OF CallBarringFeatureList Ber encoder */
static void AsnEncode_SS2_CallBarringFeatureList( SS2_CallBarringFeatureList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CallBarringFeature((SS2_CallBarringFeature *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE SS-Data Ber encoder */
static void AsnEncode_SS2_SS_Data( SS2_SS_Data *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_SS_Data_ss_Code_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_Code(&pType->ss_Code, pContext, tag);
      }
      
      if( pType->validity & SS2_SS_Data_ss_Status_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_Status(&pType->ss_Status, pContext, tag);
      }
      
      if( pType->validity & SS2_SS_Data_ss_SubscriptionOption_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 0;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_SubscriptionOption(&pType->ss_SubscriptionOption, pContext, tag);
      }
      
      if( pType->validity & SS2_SS_Data_basicServiceGroupList_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_BasicServiceGroupList(&pType->basicServiceGroupList, pContext, tag);
      }
      
      if( pType->validity & SS2_SS_Data_defaultPriority_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_EMLPP_Priority( &pType->defaultPriority, pContext, tag);
      }
      
      if( pType->validity & SS2_SS_Data_nbrUser_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_MC_Bearers( &pType->nbrUser, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE OF CCBS-FeatureList Ber encoder */
static void AsnEncode_SS2_CCBS_FeatureList( SS2_CCBS_FeatureList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CCBS_Feature((SS2_CCBS_Feature *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE SS-InvocationNotificationArg Ber encoder */
extern U32 AsnEncode_SS2_SS_InvocationNotificationArg( SS2_SS_InvocationNotificationArg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IMSI(&pType->imsi, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->msisdn, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_Code(&pType->ss_Event, pContext, tag);
      }
      
      if( pType->validity & SS2_SS_InvocationNotificationArg_ss_EventSpecification_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_EventSpecification(&pType->ss_EventSpecification, pContext, tag);
      }
      
      if( pType->validity & SS2_SS_InvocationNotificationArg_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_SS_InvocationNotificationArg_b_subscriberNumber_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->b_subscriberNumber, pContext, tag);
      }
      
      if( pType->validity & SS2_SS_InvocationNotificationArg_ccbs_RequestState_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CCBS_RequestState(&pType->ccbs_RequestState, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE SS-InvocationNotificationRes Ber encoder */
extern U32 AsnEncode_SS2_SS_InvocationNotificationRes( SS2_SS_InvocationNotificationRes *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_SS_InvocationNotificationRes_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* CHOICE Reject-problem Ber encoder */
static void AsnEncode_SS2_Reject_problem( SS2_Reject_problem *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      applib2_BEGIN_PRE_ENCODE
      
      switch( pType->selection )
      {
         case SS2_Reject_problem_general_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 0;
            AsnEncode_SS2_GeneralProblem( &pType->choice.general, pContext, tag);
         }
         break;
         
         case SS2_Reject_problem_invoke_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 1;
            AsnEncode_SS2_InvokeProblem( &pType->choice.invoke, pContext, tag);
         }
         break;
         
         case SS2_Reject_problem_returnResult_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 2;
            AsnEncode_SS2_ReturnResultProblem( &pType->choice.returnResult, pContext, tag);
         }
         break;
         
         case SS2_Reject_problem_returnError_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 3;
            AsnEncode_SS2_ReturnErrorProblem( &pType->choice.returnError, pContext, tag);
         }
         break;
         
         default:
           /* Constraint Violation */
            applib2_UA1_ERROR( 123 );
         break;
      }
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      if(seq_tlv.t.mode == AUTOMATIC )
      {
         if(seq_tlv.t.cl ==ContextSpecific )
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == IMPLICIT)
      {
         if(seq_tlv.t.is_tagged)
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == EXPLICIT || seq_tlv.t.mode ==EMPTY)
      {
         if(seq_tlv.t.is_tagged)
         {
            applib2_BEGIN_PRE_ENCODE
            put_tlv(pContext, &seq_tlv);
            applib2_asnMemFree((void **)&pTemp);
            applib2_BER_END_PRE_ENCODE
            seq_tlv.l.is_defined = TRUE;
            seq_tlv.l.length = ulen;
            seq_tlv.v = (U8 *)pTemp;
            put_tlv(pContext, &seq_tlv);
         }
         else
         {
            put_tlv(pContext, &seq_tlv);
         }
      }
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE Reject Ber encoder */
extern U32 AsnEncode_SS2_Reject( SS2_Reject *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 0;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_InvokeId(&pType->invokeId, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 0;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Reject_problem( &pType->problem, pContext, tag );
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE ForwardChargeAdviceArg Ber encoder */
extern U32 AsnEncode_SS2_ForwardChargeAdviceArg( SS2_ForwardChargeAdviceArg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_Code(&pType->ss_Code, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ChargingInformation(&pType->chargingInformation, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE ECT-Indicator Ber encoder */
extern U32 AsnEncode_SS2_ECT_Indicator( SS2_ECT_Indicator *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ECT_CallState(&pType->ect_CallState, pContext, tag);
      }
      
      if( pType->validity & SS2_ECT_Indicator_rdn_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RDN(&pType->rdn, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE NameIndicator Ber encoder */
extern U32 AsnEncode_SS2_NameIndicator( SS2_NameIndicator *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_NameIndicator_callingName_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Name(&pType->callingName, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE ExternalSignalInfo Ber encoder */
static void AsnEncode_SS2_ExternalSignalInfo( SS2_ExternalSignalInfo *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 10;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ProtocolId(&pType->protocolId, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SignalInfo(&pType->signalInfo, pContext, tag);
      }
      
      if( pType->validity & SS2_ExternalSignalInfo_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE Ext-ExternalSignalInfo Ber encoder */
extern U32 AsnEncode_SS2_Ext_ExternalSignalInfo( SS2_Ext_ExternalSignalInfo *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 10;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_ProtocolId(&pType->ext_ProtocolId, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SignalInfo(&pType->signalInfo, pContext, tag);
      }
      
      if( pType->validity & SS2_Ext_ExternalSignalInfo_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE AccessNetworkSignalInfo Ber encoder */
static void AsnEncode_SS2_AccessNetworkSignalInfo( SS2_AccessNetworkSignalInfo *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 10;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AccessNetworkProtocolId(&pType->accessNetworkProtocolId, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LongSignalInfo(&pType->signalInfo, pContext, tag);
      }
      
      if( pType->validity & SS2_AccessNetworkSignalInfo_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE NAEA-PreferredCI Ber encoder */
static void AsnEncode_SS2_NAEA_PreferredCI( SS2_NAEA_PreferredCI *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_NAEA_CIC(&pType->naea_PreferredCIC, pContext, tag);
      }
      
      if( pType->validity & SS2_NAEA_PreferredCI_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE LCSClientExternalID Ber encoder */
static void AsnEncode_SS2_LCSClientExternalID( SS2_LCSClientExternalID *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_LCSClientExternalID_externalAddress_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->externalAddress, pContext, tag);
      }
      
      if( pType->validity & SS2_LCSClientExternalID_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE EMLPP-Info Ber encoder */
static void AsnEncode_SS2_EMLPP_Info( SS2_EMLPP_Info *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_EMLPP_Priority( &pType->maximumentitledPriority, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_EMLPP_Priority( &pType->defaultPriority, pContext, tag);
      }
      
      if( pType->validity & SS2_EMLPP_Info_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE MC-SS-Info Ber encoder */
static void AsnEncode_SS2_MC_SS_Info( SS2_MC_SS_Info *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_Code(&pType->ss_Code, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_SS_Status(&pType->ss_Status, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_MaxMC_Bearers( &pType->nbrSB, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_MC_Bearers( &pType->nbrUser, pContext, tag);
      }
      
      if( pType->validity & SS2_MC_SS_Info_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE RoamingNotAllowedParam Ber encoder */
extern U32 AsnEncode_SS2_RoamingNotAllowedParam( SS2_RoamingNotAllowedParam *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 10;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RoamingNotAllowedCause(&pType->roamingNotAllowedCause, pContext, tag);
      }
      
      if( pType->validity & SS2_RoamingNotAllowedParam_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE ExtensibleCallBarredParam Ber encoder */
static void AsnEncode_SS2_ExtensibleCallBarredParam( SS2_ExtensibleCallBarredParam *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_ExtensibleCallBarredParam_callBarringCause_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 10;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CallBarringCause(&pType->callBarringCause, pContext, tag);
      }
      
      if( pType->validity & SS2_ExtensibleCallBarredParam_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_ExtensibleCallBarredParam_unauthorisedMessageOriginator_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE CUG-RejectParam Ber encoder */
extern U32 AsnEncode_SS2_CUG_RejectParam( SS2_CUG_RejectParam *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_CUG_RejectParam_cug_RejectCause_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 10;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CUG_RejectCause(&pType->cug_RejectCause, pContext, tag);
      }
      
      if( pType->validity & SS2_CUG_RejectParam_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE SM-DeliveryFailureCause Ber encoder */
extern U32 AsnEncode_SS2_SM_DeliveryFailureCause( SS2_SM_DeliveryFailureCause *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 10;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SM_EnumeratedDeliveryFailureCause(&pType->sm_EnumeratedDeliveryFailureCause, pContext, tag);
      }
      
      if( pType->validity & SS2_SM_DeliveryFailureCause_diagnosticInfo_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SignalInfo(&pType->diagnosticInfo, pContext, tag);
      }
      
      if( pType->validity & SS2_SM_DeliveryFailureCause_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE AbsentSubscriberSM-Param Ber encoder */
extern U32 AsnEncode_SS2_AbsentSubscriberSM_Param( SS2_AbsentSubscriberSM_Param *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_AbsentSubscriberSM_Param_absentSubscriberDiagnosticSM_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AbsentSubscriberDiagnosticSM( &pType->absentSubscriberDiagnosticSM, pContext, tag);
      }
      
      if( pType->validity & SS2_AbsentSubscriberSM_Param_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_AbsentSubscriberSM_Param_additionalAbsentSubscriberDiagnosticSM_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AbsentSubscriberDiagnosticSM( &pType->additionalAbsentSubscriberDiagnosticSM, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE ExtensibleSystemFailureParam Ber encoder */
static void AsnEncode_SS2_ExtensibleSystemFailureParam( SS2_ExtensibleSystemFailureParam *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_ExtensibleSystemFailureParam_networkResource_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 10;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_NetworkResource(&pType->networkResource, pContext, tag);
      }
      
      if( pType->validity & SS2_ExtensibleSystemFailureParam_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_ExtensibleSystemFailureParam_additionalNetworkResource_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AdditionalNetworkResource(&pType->additionalNetworkResource, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE DataMissingParam Ber encoder */
extern U32 AsnEncode_SS2_DataMissingParam( SS2_DataMissingParam *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_DataMissingParam_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE UnexpectedDataParam Ber encoder */
extern U32 AsnEncode_SS2_UnexpectedDataParam( SS2_UnexpectedDataParam *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_UnexpectedDataParam_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE FacilityNotSupParam Ber encoder */
extern U32 AsnEncode_SS2_FacilityNotSupParam( SS2_FacilityNotSupParam *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_FacilityNotSupParam_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_FacilityNotSupParam_shapeOfLocationEstimateNotSupported_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_FacilityNotSupParam_neededLcsCapabilityNotSupportedInServingNode_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE OR-NotAllowedParam Ber encoder */
extern U32 AsnEncode_SS2_OR_NotAllowedParam( SS2_OR_NotAllowedParam *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_OR_NotAllowedParam_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE UnknownSubscriberParam Ber encoder */
extern U32 AsnEncode_SS2_UnknownSubscriberParam( SS2_UnknownSubscriberParam *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_UnknownSubscriberParam_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_UnknownSubscriberParam_unknownSubscriberDiagnostic_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 10;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_UnknownSubscriberDiagnostic(&pType->unknownSubscriberDiagnostic, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE NumberChangedParam Ber encoder */
extern U32 AsnEncode_SS2_NumberChangedParam( SS2_NumberChangedParam *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_NumberChangedParam_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE UnidentifiedSubParam Ber encoder */
extern U32 AsnEncode_SS2_UnidentifiedSubParam( SS2_UnidentifiedSubParam *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_UnidentifiedSubParam_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE IllegalSubscriberParam Ber encoder */
extern U32 AsnEncode_SS2_IllegalSubscriberParam( SS2_IllegalSubscriberParam *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_IllegalSubscriberParam_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE IllegalEquipmentParam Ber encoder */
extern U32 AsnEncode_SS2_IllegalEquipmentParam( SS2_IllegalEquipmentParam *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_IllegalEquipmentParam_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE BearerServNotProvParam Ber encoder */
extern U32 AsnEncode_SS2_BearerServNotProvParam( SS2_BearerServNotProvParam *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_BearerServNotProvParam_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE TeleservNotProvParam Ber encoder */
extern U32 AsnEncode_SS2_TeleservNotProvParam( SS2_TeleservNotProvParam *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_TeleservNotProvParam_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE TracingBufferFullParam Ber encoder */
extern U32 AsnEncode_SS2_TracingBufferFullParam( SS2_TracingBufferFullParam *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_TracingBufferFullParam_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE NoRoamingNbParam Ber encoder */
extern U32 AsnEncode_SS2_NoRoamingNbParam( SS2_NoRoamingNbParam *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_NoRoamingNbParam_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE AbsentSubscriberParam Ber encoder */
extern U32 AsnEncode_SS2_AbsentSubscriberParam( SS2_AbsentSubscriberParam *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_AbsentSubscriberParam_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_AbsentSubscriberParam_absentSubscriberReason_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AbsentSubscriberReason(&pType->absentSubscriberReason, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE BusySubscriberParam Ber encoder */
extern U32 AsnEncode_SS2_BusySubscriberParam( SS2_BusySubscriberParam *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_BusySubscriberParam_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_BusySubscriberParam_ccbs_Possible_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_BusySubscriberParam_ccbs_Busy_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE NoSubscriberReplyParam Ber encoder */
extern U32 AsnEncode_SS2_NoSubscriberReplyParam( SS2_NoSubscriberReplyParam *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_NoSubscriberReplyParam_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE ForwardingViolationParam Ber encoder */
extern U32 AsnEncode_SS2_ForwardingViolationParam( SS2_ForwardingViolationParam *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_ForwardingViolationParam_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE ForwardingFailedParam Ber encoder */
extern U32 AsnEncode_SS2_ForwardingFailedParam( SS2_ForwardingFailedParam *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_ForwardingFailedParam_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE ATI-NotAllowedParam Ber encoder */
extern U32 AsnEncode_SS2_ATI_NotAllowedParam( SS2_ATI_NotAllowedParam *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_ATI_NotAllowedParam_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE ATSI-NotAllowedParam Ber encoder */
extern U32 AsnEncode_SS2_ATSI_NotAllowedParam( SS2_ATSI_NotAllowedParam *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_ATSI_NotAllowedParam_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE ATM-NotAllowedParam Ber encoder */
extern U32 AsnEncode_SS2_ATM_NotAllowedParam( SS2_ATM_NotAllowedParam *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_ATM_NotAllowedParam_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE IllegalSS-OperationParam Ber encoder */
extern U32 AsnEncode_SS2_IllegalSS_OperationParam( SS2_IllegalSS_OperationParam *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_IllegalSS_OperationParam_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE SS-NotAvailableParam Ber encoder */
extern U32 AsnEncode_SS2_SS_NotAvailableParam( SS2_SS_NotAvailableParam *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_SS_NotAvailableParam_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE SS-SubscriptionViolationParam Ber encoder */
extern U32 AsnEncode_SS2_SS_SubscriptionViolationParam( SS2_SS_SubscriptionViolationParam *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_SS_SubscriptionViolationParam_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE InformationNotAvailableParam Ber encoder */
extern U32 AsnEncode_SS2_InformationNotAvailableParam( SS2_InformationNotAvailableParam *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_InformationNotAvailableParam_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE SubBusyForMT-SMS-Param Ber encoder */
extern U32 AsnEncode_SS2_SubBusyForMT_SMS_Param( SS2_SubBusyForMT_SMS_Param *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_SubBusyForMT_SMS_Param_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_SubBusyForMT_SMS_Param_gprsConnectionSuspended_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 5;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE MessageWaitListFullParam Ber encoder */
extern U32 AsnEncode_SS2_MessageWaitListFullParam( SS2_MessageWaitListFullParam *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_MessageWaitListFullParam_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE ResourceLimitationParam Ber encoder */
extern U32 AsnEncode_SS2_ResourceLimitationParam( SS2_ResourceLimitationParam *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_ResourceLimitationParam_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE NoGroupCallNbParam Ber encoder */
extern U32 AsnEncode_SS2_NoGroupCallNbParam( SS2_NoGroupCallNbParam *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_NoGroupCallNbParam_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE IncompatibleTerminalParam Ber encoder */
extern U32 AsnEncode_SS2_IncompatibleTerminalParam( SS2_IncompatibleTerminalParam *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_IncompatibleTerminalParam_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE UnauthorizedRequestingNetwork-Param Ber encoder */
extern U32 AsnEncode_SS2_UnauthorizedRequestingNetwork_Param( SS2_UnauthorizedRequestingNetwork_Param *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_UnauthorizedRequestingNetwork_Param_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE UnauthorizedLCSClient-Param Ber encoder */
extern U32 AsnEncode_SS2_UnauthorizedLCSClient_Param( SS2_UnauthorizedLCSClient_Param *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_UnauthorizedLCSClient_Param_unauthorizedLCSClient_Diagnostic_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_UnauthorizedLCSClient_Diagnostic(&pType->unauthorizedLCSClient_Diagnostic, pContext, tag);
      }
      
      if( pType->validity & SS2_UnauthorizedLCSClient_Param_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE PositionMethodFailure-Param Ber encoder */
extern U32 AsnEncode_SS2_PositionMethodFailure_Param( SS2_PositionMethodFailure_Param *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_PositionMethodFailure_Param_positionMethodFailure_Diagnostic_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_PositionMethodFailure_Diagnostic(&pType->positionMethodFailure_Diagnostic, pContext, tag);
      }
      
      if( pType->validity & SS2_PositionMethodFailure_Param_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE UnknownOrUnreachableLCSClient-Param Ber encoder */
extern U32 AsnEncode_SS2_UnknownOrUnreachableLCSClient_Param( SS2_UnknownOrUnreachableLCSClient_Param *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_UnknownOrUnreachableLCSClient_Param_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE MM-EventNotSupported-Param Ber encoder */
extern U32 AsnEncode_SS2_MM_EventNotSupported_Param( SS2_MM_EventNotSupported_Param *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_MM_EventNotSupported_Param_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE TargetCellOutsideGCA-Param Ber encoder */
extern U32 AsnEncode_SS2_TargetCellOutsideGCA_Param( SS2_TargetCellOutsideGCA_Param *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_TargetCellOutsideGCA_Param_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE RoutingInfoForLCS-Res Ber encoder */
extern U32 AsnEncode_SS2_RoutingInfoForLCS_Res( SS2_RoutingInfoForLCS_Res *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SubscriberIdentity(&pType->targetMS, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCSLocationInfo(&pType->lcsLocationInfo, pContext, tag);
      }
      
      if( pType->validity & SS2_RoutingInfoForLCS_Res_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_RoutingInfoForLCS_Res_v_gmlc_Address_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GSN_Address(&pType->v_gmlc_Address, pContext, tag);
      }
      
      if( pType->validity & SS2_RoutingInfoForLCS_Res_h_gmlc_Address_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GSN_Address(&pType->h_gmlc_Address, pContext, tag);
      }
      
      if( pType->validity & SS2_RoutingInfoForLCS_Res_ppr_Address_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GSN_Address(&pType->ppr_Address, pContext, tag);
      }
      
      if( pType->validity & SS2_RoutingInfoForLCS_Res_additional_v_gmlc_Address_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GSN_Address(&pType->additional_v_gmlc_Address, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE LCS-ClientID Ber encoder */
static void AsnEncode_SS2_LCS_ClientID( SS2_LCS_ClientID *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCSClientType(&pType->lcsClientType, pContext, tag);
      }
      
      if( pType->validity & SS2_LCS_ClientID_lcsClientExternalID_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCSClientExternalID(&pType->lcsClientExternalID, pContext, tag);
      }
      
      if( pType->validity & SS2_LCS_ClientID_lcsClientDialedByMS_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AddressString(&pType->lcsClientDialedByMS, pContext, tag);
      }
      
      if( pType->validity & SS2_LCS_ClientID_lcsClientInternalID_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCSClientInternalID(&pType->lcsClientInternalID, pContext, tag);
      }
      
      if( pType->validity & SS2_LCS_ClientID_lcsClientName_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCSClientName(&pType->lcsClientName, pContext, tag);
      }
      
      if( pType->validity & SS2_LCS_ClientID_lcsAPN_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_APN(&pType->lcsAPN, pContext, tag);
      }
      
      if( pType->validity & SS2_LCS_ClientID_lcsRequestorID_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCSRequestorID(&pType->lcsRequestorID, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE AreaDefinition Ber encoder */
static void AsnEncode_SS2_AreaDefinition( SS2_AreaDefinition *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AreaList(&pType->areaList, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE SubscriberLocationReport-Arg Ber encoder */
extern U32 AsnEncode_SS2_SubscriberLocationReport_Arg( SS2_SubscriberLocationReport_Arg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 10;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCS_Event(&pType->lcs_Event, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCS_ClientID(&pType->lcs_ClientID, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCSLocationInfo(&pType->lcsLocationInfo, pContext, tag);
      }
      
      if( pType->validity & SS2_SubscriberLocationReport_Arg_msisdn_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->msisdn, pContext, tag);
      }
      
      if( pType->validity & SS2_SubscriberLocationReport_Arg_imsi_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IMSI(&pType->imsi, pContext, tag);
      }
      
      if( pType->validity & SS2_SubscriberLocationReport_Arg_imei_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IMEI(&pType->imei, pContext, tag);
      }
      
      if( pType->validity & SS2_SubscriberLocationReport_Arg_na_ESRD_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->na_ESRD, pContext, tag);
      }
      
      if( pType->validity & SS2_SubscriberLocationReport_Arg_na_ESRK_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->na_ESRK, pContext, tag);
      }
      
      if( pType->validity & SS2_SubscriberLocationReport_Arg_locationEstimate_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_GeographicalInformation(&pType->locationEstimate, pContext, tag);
      }
      
      if( pType->validity & SS2_SubscriberLocationReport_Arg_ageOfLocationEstimate_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AgeOfLocationInformation( &pType->ageOfLocationEstimate, pContext, tag);
      }
      
      if( pType->validity & SS2_SubscriberLocationReport_Arg_slr_ArgExtensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 7;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SLR_ArgExtensionContainer(&pType->slr_ArgExtensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_SubscriberLocationReport_Arg_add_LocationEstimate_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 8;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Add_GeographicalInformation(&pType->add_LocationEstimate, pContext, tag);
      }
      
      if( pType->validity & SS2_SubscriberLocationReport_Arg_deferredmt_lrData_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 9;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Deferredmt_lrData(&pType->deferredmt_lrData, pContext, tag);
      }
      
      if( pType->validity & SS2_SubscriberLocationReport_Arg_lcs_ReferenceNumber_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 10;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCS_ReferenceNumber(&pType->lcs_ReferenceNumber, pContext, tag);
      }
      
      if( pType->validity & SS2_SubscriberLocationReport_Arg_geranPositioningData_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 11;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_PositioningDataInformation(&pType->geranPositioningData, pContext, tag);
      }
      
      if( pType->validity & SS2_SubscriberLocationReport_Arg_utranPositioningData_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 12;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_UtranPositioningDataInfo(&pType->utranPositioningData, pContext, tag);
      }
      
      if( pType->validity & SS2_SubscriberLocationReport_Arg_cellIdOrSai_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 13;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CellGlobalIdOrServiceAreaIdOrLAI(&pType->cellIdOrSai, pContext, tag);
      }
      
      if( pType->validity & SS2_SubscriberLocationReport_Arg_h_gmlc_Address_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 14;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GSN_Address(&pType->h_gmlc_Address, pContext, tag);
      }
      
      if( pType->validity & SS2_SubscriberLocationReport_Arg_lcsServiceTypeID_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 15;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCSServiceTypeID( &pType->lcsServiceTypeID, pContext, tag);
      }
      
      if( pType->validity & SS2_SubscriberLocationReport_Arg_sai_Present_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 17;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_SubscriberLocationReport_Arg_pseudonymIndicator_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 18;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_SubscriberLocationReport_Arg_accuracyFulfilmentIndicator_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 19;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AccuracyFulfilmentIndicator(&pType->accuracyFulfilmentIndicator, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE UpdateLocationArg Ber encoder */
extern U32 AsnEncode_SS2_UpdateLocationArg( SS2_UpdateLocationArg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IMSI(&pType->imsi, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->msc_Number, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->vlr_Number, pContext, tag);
      }
      
      if( pType->validity & SS2_UpdateLocationArg_lmsi_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 10;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LMSI(&pType->lmsi, pContext, tag);
      }
      
      if( pType->validity & SS2_UpdateLocationArg_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_UpdateLocationArg_vlr_Capability_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_VLR_Capability(&pType->vlr_Capability, pContext, tag);
      }
      
      if( pType->validity & SS2_UpdateLocationArg_informPreviousNetworkEntity_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 11;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_UpdateLocationArg_cs_LCS_NotSupportedByUE_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 12;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_UpdateLocationArg_v_gmlc_Address_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GSN_Address(&pType->v_gmlc_Address, pContext, tag);
      }
      
      if( pType->validity & SS2_UpdateLocationArg_add_info_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 13;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ADD_Info(&pType->add_info, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* CHOICE AuthenticationSetList Ber encoder */
static void AsnEncode_SS2_AuthenticationSetList( SS2_AuthenticationSetList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      applib2_BEGIN_PRE_ENCODE
      
      switch( pType->selection )
      {
         case SS2_AuthenticationSetList_tripletList_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 0;
            AsnEncode_SS2_TripletList(&pType->choice.tripletList, pContext, tag);
         }
         break;
         
         case SS2_AuthenticationSetList_quintupletList_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 1;
            AsnEncode_SS2_QuintupletList(&pType->choice.quintupletList, pContext, tag);
         }
         break;
         
         default:
           /* Constraint Violation */
            applib2_UA1_ERROR( 124 );
         break;
      }
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      if(seq_tlv.t.mode == AUTOMATIC )
      {
         if(seq_tlv.t.cl ==ContextSpecific )
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == IMPLICIT)
      {
         if(seq_tlv.t.is_tagged)
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == EXPLICIT || seq_tlv.t.mode ==EMPTY)
      {
         if(seq_tlv.t.is_tagged)
         {
            applib2_BEGIN_PRE_ENCODE
            put_tlv(pContext, &seq_tlv);
            applib2_asnMemFree((void **)&pTemp);
            applib2_BER_END_PRE_ENCODE
            seq_tlv.l.is_defined = TRUE;
            seq_tlv.l.length = ulen;
            seq_tlv.v = (U8 *)pTemp;
            put_tlv(pContext, &seq_tlv);
         }
         else
         {
            put_tlv(pContext, &seq_tlv);
         }
      }
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE UpdateGprsLocationArg Ber encoder */
extern U32 AsnEncode_SS2_UpdateGprsLocationArg( SS2_UpdateGprsLocationArg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IMSI(&pType->imsi, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->sgsn_Number, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GSN_Address(&pType->sgsn_Address, pContext, tag);
      }
      
      if( pType->validity & SS2_UpdateGprsLocationArg_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_UpdateGprsLocationArg_sgsn_Capability_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SGSN_Capability(&pType->sgsn_Capability, pContext, tag);
      }
      
      if( pType->validity & SS2_UpdateGprsLocationArg_informPreviousNetworkEntity_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_UpdateGprsLocationArg_ps_LCS_NotSupportedByUE_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_UpdateGprsLocationArg_v_gmlc_Address_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GSN_Address(&pType->v_gmlc_Address, pContext, tag);
      }
      
      if( pType->validity & SS2_UpdateGprsLocationArg_add_info_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ADD_Info(&pType->add_info, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE PrepareHO-Res Ber encoder */
extern U32 AsnEncode_SS2_PrepareHO_Res( SS2_PrepareHO_Res *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = ContextSpecific;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 3;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_PrepareHO_Res_handoverNumber_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->handoverNumber, pContext, tag);
      }
      
      if( pType->validity & SS2_PrepareHO_Res_relocationNumberList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RelocationNumberList(&pType->relocationNumberList, pContext, tag);
      }
      
      if( pType->validity & SS2_PrepareHO_Res_an_APDU_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AccessNetworkSignalInfo(&pType->an_APDU, pContext, tag);
      }
      
      if( pType->validity & SS2_PrepareHO_Res_multicallBearerInfo_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_MulticallBearerInfo( &pType->multicallBearerInfo, pContext, tag);
      }
      
      if( pType->validity & SS2_PrepareHO_Res_multipleBearerNotSupported_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 5;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_PrepareHO_Res_selectedUMTS_Algorithms_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SelectedUMTS_Algorithms(&pType->selectedUMTS_Algorithms, pContext, tag);
      }
      
      if( pType->validity & SS2_PrepareHO_Res_chosenRadioResourceInformation_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ChosenRadioResourceInformation(&pType->chosenRadioResourceInformation, pContext, tag);
      }
      
      if( pType->validity & SS2_PrepareHO_Res_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_PrepareHO_Res_iuSelectedCodec_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 7;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Codec(&pType->iuSelectedCodec, pContext, tag);
      }
      
      if( pType->validity & SS2_PrepareHO_Res_iuAvailableCodecsList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 8;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CodecList(&pType->iuAvailableCodecsList, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE PrepareSubsequentHO-Arg Ber encoder */
extern U32 AsnEncode_SS2_PrepareSubsequentHO_Arg( SS2_PrepareSubsequentHO_Arg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = ContextSpecific;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 3;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_PrepareSubsequentHO_Arg_targetCellId_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GlobalCellId(&pType->targetCellId, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->targetMSC_Number, pContext, tag);
      }
      
      if( pType->validity & SS2_PrepareSubsequentHO_Arg_targetRNCId_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RNCId(&pType->targetRNCId, pContext, tag);
      }
      
      if( pType->validity & SS2_PrepareSubsequentHO_Arg_an_APDU_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AccessNetworkSignalInfo(&pType->an_APDU, pContext, tag);
      }
      
      if( pType->validity & SS2_PrepareSubsequentHO_Arg_selectedRab_Id_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RAB_Id( &pType->selectedRab_Id, pContext, tag);
      }
      
      if( pType->validity & SS2_PrepareSubsequentHO_Arg_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_PrepareSubsequentHO_Arg_geran_classmark_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GERAN_Classmark(&pType->geran_classmark, pContext, tag);
      }
      
      if( pType->validity & SS2_PrepareSubsequentHO_Arg_rab_ConfigurationIndicator_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 7;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE PrepareSubsequentHO-Res Ber encoder */
extern U32 AsnEncode_SS2_PrepareSubsequentHO_Res( SS2_PrepareSubsequentHO_Res *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = ContextSpecific;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 3;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AccessNetworkSignalInfo(&pType->an_APDU, pContext, tag);
      }
      
      if( pType->validity & SS2_PrepareSubsequentHO_Res_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE ProcessAccessSignalling-Arg Ber encoder */
extern U32 AsnEncode_SS2_ProcessAccessSignalling_Arg( SS2_ProcessAccessSignalling_Arg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = ContextSpecific;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 3;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AccessNetworkSignalInfo(&pType->an_APDU, pContext, tag);
      }
      
      if( pType->validity & SS2_ProcessAccessSignalling_Arg_selectedUMTS_Algorithms_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SelectedUMTS_Algorithms(&pType->selectedUMTS_Algorithms, pContext, tag);
      }
      
      if( pType->validity & SS2_ProcessAccessSignalling_Arg_selectedGSM_Algorithm_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SelectedGSM_Algorithm(&pType->selectedGSM_Algorithm, pContext, tag);
      }
      
      if( pType->validity & SS2_ProcessAccessSignalling_Arg_chosenRadioResourceInformation_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ChosenRadioResourceInformation(&pType->chosenRadioResourceInformation, pContext, tag);
      }
      
      if( pType->validity & SS2_ProcessAccessSignalling_Arg_selectedRab_Id_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RAB_Id( &pType->selectedRab_Id, pContext, tag);
      }
      
      if( pType->validity & SS2_ProcessAccessSignalling_Arg_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_ProcessAccessSignalling_Arg_iUSelectedCodec_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Codec(&pType->iUSelectedCodec, pContext, tag);
      }
      
      if( pType->validity & SS2_ProcessAccessSignalling_Arg_iuAvailableCodecsList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CodecList(&pType->iuAvailableCodecsList, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE SupportedCodecsList Ber encoder */
static void AsnEncode_SS2_SupportedCodecsList( SS2_SupportedCodecsList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_SupportedCodecsList_utranCodecList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CodecList(&pType->utranCodecList, pContext, tag);
      }
      
      if( pType->validity & SS2_SupportedCodecsList_geranCodecList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CodecList(&pType->geranCodecList, pContext, tag);
      }
      
      if( pType->validity & SS2_SupportedCodecsList_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE SendEndSignal-Arg Ber encoder */
extern U32 AsnEncode_SS2_SendEndSignal_Arg( SS2_SendEndSignal_Arg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = ContextSpecific;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 3;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AccessNetworkSignalInfo(&pType->an_APDU, pContext, tag);
      }
      
      if( pType->validity & SS2_SendEndSignal_Arg_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE SendAuthenticationInfoRes Ber encoder */
extern U32 AsnEncode_SS2_SendAuthenticationInfoRes( SS2_SendAuthenticationInfoRes *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = ContextSpecific;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 3;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_SendAuthenticationInfoRes_authenticationSetList_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 0;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AuthenticationSetList(&pType->authenticationSetList, pContext, tag);
      }
      
      if( pType->validity & SS2_SendAuthenticationInfoRes_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE OF GPRSDataList Ber encoder */
static void AsnEncode_SS2_GPRSDataList( SS2_GPRSDataList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_PDP_Context((SS2_PDP_Context *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE GPRSSubscriptionData Ber encoder */
static void AsnEncode_SS2_GPRSSubscriptionData( SS2_GPRSSubscriptionData *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_GPRSSubscriptionData_completeDataListIncluded_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 5;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GPRSDataList(&pType->gprsDataList, pContext, tag);
      }
      
      if( pType->validity & SS2_GPRSSubscriptionData_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE OF GPRS-CamelTDPDataList Ber encoder */
static void AsnEncode_SS2_GPRS_CamelTDPDataList( SS2_GPRS_CamelTDPDataList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GPRS_CamelTDPData((SS2_GPRS_CamelTDPData *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE OF LSADataList Ber encoder */
static void AsnEncode_SS2_LSADataList( SS2_LSADataList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LSAData((SS2_LSAData *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE LSAInformation Ber encoder */
static void AsnEncode_SS2_LSAInformation( SS2_LSAInformation *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_LSAInformation_completeDataListIncluded_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 5;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_LSAInformation_lsaOnlyAccessIndicator_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LSAOnlyAccessIndicator(&pType->lsaOnlyAccessIndicator, pContext, tag);
      }
      
      if( pType->validity & SS2_LSAInformation_lsaDataList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LSADataList(&pType->lsaDataList, pContext, tag);
      }
      
      if( pType->validity & SS2_LSAInformation_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE OF Ext-ForwFeatureList Ber encoder */
static void AsnEncode_SS2_Ext_ForwFeatureList( SS2_Ext_ForwFeatureList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_ForwFeature((SS2_Ext_ForwFeature *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE OF Ext-CallBarFeatureList Ber encoder */
static void AsnEncode_SS2_Ext_CallBarFeatureList( SS2_Ext_CallBarFeatureList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_CallBarringFeature((SS2_Ext_CallBarringFeature *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE OF CUG-SubscriptionList Ber encoder */
static void AsnEncode_SS2_CUG_SubscriptionList( SS2_CUG_SubscriptionList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CUG_Subscription((SS2_CUG_Subscription *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE OF CUG-FeatureList Ber encoder */
static void AsnEncode_SS2_CUG_FeatureList( SS2_CUG_FeatureList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CUG_Feature((SS2_CUG_Feature *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE ExternalClient Ber encoder */
static void AsnEncode_SS2_ExternalClient( SS2_ExternalClient *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCSClientExternalID(&pType->clientIdentity, pContext, tag);
      }
      
      if( pType->validity & SS2_ExternalClient_gmlc_Restriction_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GMLC_Restriction(&pType->gmlc_Restriction, pContext, tag);
      }
      
      if( pType->validity & SS2_ExternalClient_notificationToMSUser_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_NotificationToMSUser(&pType->notificationToMSUser, pContext, tag);
      }
      
      if( pType->validity & SS2_ExternalClient_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE OF ServiceTypeList Ber encoder */
static void AsnEncode_SS2_ServiceTypeList( SS2_ServiceTypeList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ServiceType((SS2_ServiceType *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE OF MOLR-List Ber encoder */
static void AsnEncode_SS2_MOLR_List( SS2_MOLR_List *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_MOLR_Class((SS2_MOLR_Class *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE OF MT-smsCAMELTDP-CriteriaList Ber encoder */
static void AsnEncode_SS2_MT_smsCAMELTDP_CriteriaList( SS2_MT_smsCAMELTDP_CriteriaList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_MT_smsCAMELTDP_Criteria((SS2_MT_smsCAMELTDP_Criteria *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE OF DP-AnalysedInfoCriteriaList Ber encoder */
static void AsnEncode_SS2_DP_AnalysedInfoCriteriaList( SS2_DP_AnalysedInfoCriteriaList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_DP_AnalysedInfoCriterium((SS2_DP_AnalysedInfoCriterium *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE SS-CSI Ber encoder */
static void AsnEncode_SS2_SS_CSI( SS2_SS_CSI *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_CamelData(&pType->ss_CamelData, pContext, tag);
      }
      
      if( pType->validity & SS2_SS_CSI_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_SS_CSI_notificationToCSE_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_SS_CSI_csi_Active_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE OF O-BcsmCamelTDPDataList Ber encoder */
static void AsnEncode_SS2_O_BcsmCamelTDPDataList( SS2_O_BcsmCamelTDPDataList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_O_BcsmCamelTDPData((SS2_O_BcsmCamelTDPData *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE OF O-BcsmCamelTDPCriteriaList Ber encoder */
static void AsnEncode_SS2_O_BcsmCamelTDPCriteriaList( SS2_O_BcsmCamelTDPCriteriaList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_O_BcsmCamelTDP_Criteria((SS2_O_BcsmCamelTDP_Criteria *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE OF T-BCSM-CAMEL-TDP-CriteriaList Ber encoder */
static void AsnEncode_SS2_T_BCSM_CAMEL_TDP_CriteriaList( SS2_T_BCSM_CAMEL_TDP_CriteriaList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_T_BCSM_CAMEL_TDP_Criteria((SS2_T_BCSM_CAMEL_TDP_Criteria *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE OF SMS-CAMEL-TDP-DataList Ber encoder */
static void AsnEncode_SS2_SMS_CAMEL_TDP_DataList( SS2_SMS_CAMEL_TDP_DataList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SMS_CAMEL_TDP_Data((SS2_SMS_CAMEL_TDP_Data *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE OF T-BcsmCamelTDPDataList Ber encoder */
static void AsnEncode_SS2_T_BcsmCamelTDPDataList( SS2_T_BcsmCamelTDPDataList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_T_BcsmCamelTDPData((SS2_T_BcsmCamelTDPData *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE OF VBSDataList Ber encoder */
static void AsnEncode_SS2_VBSDataList( SS2_VBSDataList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_VoiceBroadcastData((SS2_VoiceBroadcastData *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE OF VGCSDataList Ber encoder */
static void AsnEncode_SS2_VGCSDataList( SS2_VGCSDataList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_VoiceGroupCallData((SS2_VoiceGroupCallData *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE ProvideSubscriberInfoArg Ber encoder */
extern U32 AsnEncode_SS2_ProvideSubscriberInfoArg( SS2_ProvideSubscriberInfoArg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IMSI(&pType->imsi, pContext, tag);
      }
      
      if( pType->validity & SS2_ProvideSubscriberInfoArg_lmsi_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LMSI(&pType->lmsi, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RequestedInfo(&pType->requestedInfo, pContext, tag);
      }
      
      if( pType->validity & SS2_ProvideSubscriberInfoArg_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE OF PDP-ContextInfoList Ber encoder */
static void AsnEncode_SS2_PDP_ContextInfoList( SS2_PDP_ContextInfoList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_PDP_ContextInfo((SS2_PDP_ContextInfo *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE AnyTimeSubscriptionInterrogationArg Ber encoder */
extern U32 AsnEncode_SS2_AnyTimeSubscriptionInterrogationArg( SS2_AnyTimeSubscriptionInterrogationArg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SubscriberIdentity(&pType->subscriberIdentity, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RequestedSubscriptionInfo(&pType->requestedSubscriptionInfo, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->gsmSCF_Address, pContext, tag);
      }
      
      if( pType->validity & SS2_AnyTimeSubscriptionInterrogationArg_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_AnyTimeSubscriptionInterrogationArg_longFTN_Supported_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE CallForwardingData Ber encoder */
static void AsnEncode_SS2_CallForwardingData( SS2_CallForwardingData *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_ForwFeatureList(&pType->forwardingFeatureList, pContext, tag);
      }
      
      if( pType->validity & SS2_CallForwardingData_notificationToCSE_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 5;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_CallForwardingData_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE CallBarringData Ber encoder */
static void AsnEncode_SS2_CallBarringData( SS2_CallBarringData *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_CallBarFeatureList(&pType->callBarringFeatureList, pContext, tag);
      }
      
      if( pType->validity & SS2_CallBarringData_password_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 18;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Password(&pType->password, pContext, tag);
      }
      
      if( pType->validity & SS2_CallBarringData_wrongPasswordAttemptsCounter_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 2;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_WrongPasswordAttemptsCounter( &pType->wrongPasswordAttemptsCounter, pContext, tag);
      }
      
      if( pType->validity & SS2_CallBarringData_notificationToCSE_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 5;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_CallBarringData_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE AnyTimeModificationArg Ber encoder */
extern U32 AsnEncode_SS2_AnyTimeModificationArg( SS2_AnyTimeModificationArg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SubscriberIdentity(&pType->subscriberIdentity, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->gsmSCF_Address, pContext, tag);
      }
      
      if( pType->validity & SS2_AnyTimeModificationArg_modificationRequestFor_CF_Info_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ModificationRequestFor_CF_Info(&pType->modificationRequestFor_CF_Info, pContext, tag);
      }
      
      if( pType->validity & SS2_AnyTimeModificationArg_modificationRequestFor_CB_Info_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ModificationRequestFor_CB_Info(&pType->modificationRequestFor_CB_Info, pContext, tag);
      }
      
      if( pType->validity & SS2_AnyTimeModificationArg_modificationRequestFor_CSI_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ModificationRequestFor_CSI(&pType->modificationRequestFor_CSI, pContext, tag);
      }
      
      if( pType->validity & SS2_AnyTimeModificationArg_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_AnyTimeModificationArg_longFTN_Supported_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_AnyTimeModificationArg_modificationRequestFor_ODB_data_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 7;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ModificationRequestFor_ODB_data(&pType->modificationRequestFor_ODB_data, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE Ext-ForwardingInfoFor-CSE Ber encoder */
static void AsnEncode_SS2_Ext_ForwardingInfoFor_CSE( SS2_Ext_ForwardingInfoFor_CSE *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_Code(&pType->ss_Code, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_ForwFeatureList(&pType->forwardingFeatureList, pContext, tag);
      }
      
      if( pType->validity & SS2_Ext_ForwardingInfoFor_CSE_notificationToCSE_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_Ext_ForwardingInfoFor_CSE_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE Ext-CallBarringInfoFor-CSE Ber encoder */
static void AsnEncode_SS2_Ext_CallBarringInfoFor_CSE( SS2_Ext_CallBarringInfoFor_CSE *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_Code(&pType->ss_Code, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_CallBarFeatureList(&pType->callBarringFeatureList, pContext, tag);
      }
      
      if( pType->validity & SS2_Ext_CallBarringInfoFor_CSE_password_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Password(&pType->password, pContext, tag);
      }
      
      if( pType->validity & SS2_Ext_CallBarringInfoFor_CSE_wrongPasswordAttemptsCounter_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_WrongPasswordAttemptsCounter( &pType->wrongPasswordAttemptsCounter, pContext, tag);
      }
      
      if( pType->validity & SS2_Ext_CallBarringInfoFor_CSE_notificationToCSE_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_Ext_CallBarringInfoFor_CSE_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE RoutingInfoForSM-Res Ber encoder */
extern U32 AsnEncode_SS2_RoutingInfoForSM_Res( SS2_RoutingInfoForSM_Res *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IMSI(&pType->imsi, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LocationInfoWithLMSI(&pType->locationInfoWithLMSI, pContext, tag);
      }
      
      if( pType->validity & SS2_RoutingInfoForSM_Res_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE ForwardingInfo Ber encoder */
static void AsnEncode_SS2_ForwardingInfo( SS2_ForwardingInfo *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_ForwardingInfo_ss_Code_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_Code(&pType->ss_Code, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ForwardingFeatureList(&pType->forwardingFeatureList, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE CallBarringInfo Ber encoder */
static void AsnEncode_SS2_CallBarringInfo( SS2_CallBarringInfo *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_CallBarringInfo_ss_Code_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_Code(&pType->ss_Code, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CallBarringFeatureList(&pType->callBarringFeatureList, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE GenericServiceInfo Ber encoder */
static void AsnEncode_SS2_GenericServiceInfo( SS2_GenericServiceInfo *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_Status(&pType->ss_Status, pContext, tag);
      }
      
      if( pType->validity & SS2_GenericServiceInfo_cliRestrictionOption_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 10;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CliRestrictionOption(&pType->cliRestrictionOption, pContext, tag);
      }
      
      if( pType->validity & SS2_GenericServiceInfo_maximumEntitledPriority_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_EMLPP_Priority( &pType->maximumEntitledPriority, pContext, tag);
      }
      
      if( pType->validity & SS2_GenericServiceInfo_defaultPriority_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_EMLPP_Priority( &pType->defaultPriority, pContext, tag);
      }
      
      if( pType->validity & SS2_GenericServiceInfo_ccbs_FeatureList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CCBS_FeatureList(&pType->ccbs_FeatureList, pContext, tag);
      }
      
      if( pType->validity & SS2_GenericServiceInfo_nbrSB_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_MaxMC_Bearers( &pType->nbrSB, pContext, tag);
      }
      
      if( pType->validity & SS2_GenericServiceInfo_nbrUser_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_MC_Bearers( &pType->nbrUser, pContext, tag);
      }
      
      if( pType->validity & SS2_GenericServiceInfo_nbrSN_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_MC_Bearers( &pType->nbrSN, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* CHOICE InterrogateSS-Res Ber encoder */
extern U32 AsnEncode_SS2_InterrogateSS_Res( SS2_InterrogateSS_Res *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   
   {
      switch( pType->selection )
      {
         case SS2_InterrogateSS_Res_ss_Status_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 0;
            AsnEncode_SS2_SS_Status(&pType->choice.ss_Status, pContext, tag);
         }
         break;
         
         case SS2_InterrogateSS_Res_basicServiceGroupList_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 2;
            AsnEncode_SS2_BasicServiceGroupList(&pType->choice.basicServiceGroupList, pContext, tag);
         }
         break;
         
         case SS2_InterrogateSS_Res_forwardingFeatureList_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 3;
            AsnEncode_SS2_ForwardingFeatureList(&pType->choice.forwardingFeatureList, pContext, tag);
         }
         break;
         
         case SS2_InterrogateSS_Res_genericServiceInfo_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 4;
            AsnEncode_SS2_GenericServiceInfo(&pType->choice.genericServiceInfo, pContext, tag);
         }
         break;
         
         default:
           /* Constraint Violation */
            applib2_UA1_ERROR( 125 );
         break;
      }
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE CCBS-Data Ber encoder */
static void AsnEncode_SS2_CCBS_Data( SS2_CCBS_Data *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CCBS_Feature(&pType->ccbs_Feature, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->translatedB_Number, pContext, tag);
      }
      
      if( pType->validity & SS2_CCBS_Data_serviceIndicator_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ServiceIndicator(&pType->serviceIndicator, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExternalSignalInfo(&pType->callInfo, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExternalSignalInfo(&pType->networkSignalInfo, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE LocationNotificationArg Ber encoder */
extern U32 AsnEncode_SS2_LocationNotificationArg( SS2_LocationNotificationArg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_NotificationToMSUser(&pType->notificationType, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LocationType(&pType->locationType, pContext, tag);
      }
      
      if( pType->validity & SS2_LocationNotificationArg_lcsClientExternalID_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCSClientExternalID(&pType->lcsClientExternalID, pContext, tag);
      }
      
      if( pType->validity & SS2_LocationNotificationArg_lcsClientName_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCSClientName(&pType->lcsClientName, pContext, tag);
      }
      
      if( pType->validity & SS2_LocationNotificationArg_lcsRequestorID_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCSRequestorID(&pType->lcsRequestorID, pContext, tag);
      }
      
      if( pType->validity & SS2_LocationNotificationArg_lcsCodeword_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCSCodeword(&pType->lcsCodeword, pContext, tag);
      }
      
      if( pType->validity & SS2_LocationNotificationArg_lcsServiceTypeID_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCSServiceTypeID( &pType->lcsServiceTypeID, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE LCS-MOLRArg Ber encoder */
extern U32 AsnEncode_SS2_LCS_MOLRArg( SS2_LCS_MOLRArg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_MOLR_Type(&pType->molr_Type, pContext, tag);
      }
      
      if( pType->validity & SS2_LCS_MOLRArg_locationMethod_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LocationMethod(&pType->locationMethod, pContext, tag);
      }
      
      if( pType->validity & SS2_LCS_MOLRArg_lcs_QoS_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCS_QoS(&pType->lcs_QoS, pContext, tag);
      }
      
      if( pType->validity & SS2_LCS_MOLRArg_lcsClientExternalID_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCSClientExternalID(&pType->lcsClientExternalID, pContext, tag);
      }
      
      if( pType->validity & SS2_LCS_MOLRArg_mlc_Number_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->mlc_Number, pContext, tag);
      }
      
      if( pType->validity & SS2_LCS_MOLRArg_gpsAssistanceData_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GPSAssistanceData(&pType->gpsAssistanceData, pContext, tag);
      }
      
      if( pType->validity & SS2_LCS_MOLRArg_supportedGADShapes_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SupportedGADShapes(&pType->supportedGADShapes, pContext, tag);
      }
      
      if( pType->validity & SS2_LCS_MOLRArg_lcsServiceTypeID_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 7;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCSServiceTypeID( &pType->lcsServiceTypeID, pContext, tag);
      }
      
      if( pType->validity & SS2_LCS_MOLRArg_ageOfLocationInfo_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 8;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AgeOfLocationInformation( &pType->ageOfLocationInfo, pContext, tag);
      }
      
      if( pType->validity & SS2_LCS_MOLRArg_locationType_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 9;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LocationType(&pType->locationType, pContext, tag);
      }
      
      if( pType->validity & SS2_LCS_MOLRArg_pseudonymIndicator_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 10;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* CHOICE CallBarredParam Ber encoder */
extern U32 AsnEncode_SS2_CallBarredParam( SS2_CallBarredParam *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   
   {
      switch( pType->selection )
      {
         case SS2_CallBarredParam_callBarringCause_selected:
         {
            BER_TAG   tag;
            tag.cl = Universal;
            tag.tag = 10;
            AsnEncode_SS2_CallBarringCause(&pType->choice.callBarringCause, pContext, tag);
         }
         break;
         
         case SS2_CallBarredParam_extensibleCallBarredParam_selected:
         {
            BER_TAG   tag;
            tag.cl = Universal;
            tag.tag = 16;
            AsnEncode_SS2_ExtensibleCallBarredParam(&pType->choice.extensibleCallBarredParam, pContext, tag);
         }
         break;
         
         default:
           /* Constraint Violation */
            applib2_UA1_ERROR( 126 );
         break;
      }
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* CHOICE SystemFailureParam Ber encoder */
extern U32 AsnEncode_SS2_SystemFailureParam( SS2_SystemFailureParam *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   
   {
      switch( pType->selection )
      {
         case SS2_SystemFailureParam_networkResource_selected:
         {
            BER_TAG   tag;
            tag.cl = Universal;
            tag.tag = 10;
            AsnEncode_SS2_NetworkResource(&pType->choice.networkResource, pContext, tag);
         }
         break;
         
         case SS2_SystemFailureParam_extensibleSystemFailureParam_selected:
         {
            BER_TAG   tag;
            tag.cl = Universal;
            tag.tag = 16;
            AsnEncode_SS2_ExtensibleSystemFailureParam(&pType->choice.extensibleSystemFailureParam, pContext, tag);
         }
         break;
         
         default:
           /* Constraint Violation */
            applib2_UA1_ERROR( 127 );
         break;
      }
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE AreaEventInfo Ber encoder */
static void AsnEncode_SS2_AreaEventInfo( SS2_AreaEventInfo *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AreaDefinition(&pType->areaDefinition, pContext, tag);
      }
      
      if( pType->validity & SS2_AreaEventInfo_occurrenceInfo_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_OccurrenceInfo(&pType->occurrenceInfo, pContext, tag);
      }
      
      if( pType->validity & SS2_AreaEventInfo_intervalTime_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IntervalTime( &pType->intervalTime, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE SendIdentificationRes Ber encoder */
extern U32 AsnEncode_SS2_SendIdentificationRes( SS2_SendIdentificationRes *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = ContextSpecific;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 3;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_SendIdentificationRes_imsi_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IMSI(&pType->imsi, pContext, tag);
      }
      
      if( pType->validity & SS2_SendIdentificationRes_authenticationSetList_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 0;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AuthenticationSetList(&pType->authenticationSetList, pContext, tag);
      }
      
      if( pType->validity & SS2_SendIdentificationRes_currentSecurityContext_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CurrentSecurityContext(&pType->currentSecurityContext, pContext, tag);
      }
      
      if( pType->validity & SS2_SendIdentificationRes_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE ForwardAccessSignalling-Arg Ber encoder */
extern U32 AsnEncode_SS2_ForwardAccessSignalling_Arg( SS2_ForwardAccessSignalling_Arg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = ContextSpecific;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 3;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AccessNetworkSignalInfo(&pType->an_APDU, pContext, tag);
      }
      
      if( pType->validity & SS2_ForwardAccessSignalling_Arg_integrityProtectionInfo_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IntegrityProtectionInformation(&pType->integrityProtectionInfo, pContext, tag);
      }
      
      if( pType->validity & SS2_ForwardAccessSignalling_Arg_encryptionInfo_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_EncryptionInformation(&pType->encryptionInfo, pContext, tag);
      }
      
      if( pType->validity & SS2_ForwardAccessSignalling_Arg_keyStatus_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_KeyStatus(&pType->keyStatus, pContext, tag);
      }
      
      if( pType->validity & SS2_ForwardAccessSignalling_Arg_allowedGSM_Algorithms_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AllowedGSM_Algorithms(&pType->allowedGSM_Algorithms, pContext, tag);
      }
      
      if( pType->validity & SS2_ForwardAccessSignalling_Arg_allowedUMTS_Algorithms_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AllowedUMTS_Algorithms(&pType->allowedUMTS_Algorithms, pContext, tag);
      }
      
      if( pType->validity & SS2_ForwardAccessSignalling_Arg_radioResourceInformation_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RadioResourceInformation(&pType->radioResourceInformation, pContext, tag);
      }
      
      if( pType->validity & SS2_ForwardAccessSignalling_Arg_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_ForwardAccessSignalling_Arg_radioResourceList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 7;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RadioResourceList(&pType->radioResourceList, pContext, tag);
      }
      
      if( pType->validity & SS2_ForwardAccessSignalling_Arg_bssmap_ServiceHandover_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 9;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_BSSMAP_ServiceHandover(&pType->bssmap_ServiceHandover, pContext, tag);
      }
      
      if( pType->validity & SS2_ForwardAccessSignalling_Arg_ranap_ServiceHandover_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 8;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RANAP_ServiceHandover(&pType->ranap_ServiceHandover, pContext, tag);
      }
      
      if( pType->validity & SS2_ForwardAccessSignalling_Arg_bssmap_ServiceHandoverList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 10;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_BSSMAP_ServiceHandoverList(&pType->bssmap_ServiceHandoverList, pContext, tag);
      }
      
      if( pType->validity & SS2_ForwardAccessSignalling_Arg_currentlyUsedCodec_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 11;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Codec(&pType->currentlyUsedCodec, pContext, tag);
      }
      
      if( pType->validity & SS2_ForwardAccessSignalling_Arg_iuSupportedCodecsList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 12;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SupportedCodecsList(&pType->iuSupportedCodecsList, pContext, tag);
      }
      
      if( pType->validity & SS2_ForwardAccessSignalling_Arg_rab_ConfigurationIndicator_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 13;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_ForwardAccessSignalling_Arg_iuSelectedCodec_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 14;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Codec(&pType->iuSelectedCodec, pContext, tag);
      }
      
      if( pType->validity & SS2_ForwardAccessSignalling_Arg_alternativeChannelType_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 15;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RadioResourceInformation(&pType->alternativeChannelType, pContext, tag);
      }
      
      if( pType->validity & SS2_ForwardAccessSignalling_Arg_tracePropagationList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 17;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_TracePropagationList(&pType->tracePropagationList, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE PrepareHO-Arg Ber encoder */
extern U32 AsnEncode_SS2_PrepareHO_Arg( SS2_PrepareHO_Arg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = ContextSpecific;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 3;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_PrepareHO_Arg_targetCellId_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GlobalCellId(&pType->targetCellId, pContext, tag);
      }
      
      if( pType->validity & SS2_PrepareHO_Arg_ho_NumberNotRequired_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 5;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_PrepareHO_Arg_targetRNCId_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RNCId(&pType->targetRNCId, pContext, tag);
      }
      
      if( pType->validity & SS2_PrepareHO_Arg_an_APDU_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AccessNetworkSignalInfo(&pType->an_APDU, pContext, tag);
      }
      
      if( pType->validity & SS2_PrepareHO_Arg_multipleBearerRequested_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_PrepareHO_Arg_imsi_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IMSI(&pType->imsi, pContext, tag);
      }
      
      if( pType->validity & SS2_PrepareHO_Arg_integrityProtectionInfo_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IntegrityProtectionInformation(&pType->integrityProtectionInfo, pContext, tag);
      }
      
      if( pType->validity & SS2_PrepareHO_Arg_encryptionInfo_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_EncryptionInformation(&pType->encryptionInfo, pContext, tag);
      }
      
      if( pType->validity & SS2_PrepareHO_Arg_radioResourceInformation_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 7;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RadioResourceInformation(&pType->radioResourceInformation, pContext, tag);
      }
      
      if( pType->validity & SS2_PrepareHO_Arg_allowedGSM_Algorithms_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 9;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AllowedGSM_Algorithms(&pType->allowedGSM_Algorithms, pContext, tag);
      }
      
      if( pType->validity & SS2_PrepareHO_Arg_allowedUMTS_Algorithms_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 10;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AllowedUMTS_Algorithms(&pType->allowedUMTS_Algorithms, pContext, tag);
      }
      
      if( pType->validity & SS2_PrepareHO_Arg_radioResourceList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 11;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RadioResourceList(&pType->radioResourceList, pContext, tag);
      }
      
      if( pType->validity & SS2_PrepareHO_Arg_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 8;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_PrepareHO_Arg_rab_Id_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 12;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RAB_Id( &pType->rab_Id, pContext, tag);
      }
      
      if( pType->validity & SS2_PrepareHO_Arg_bssmap_ServiceHandover_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 13;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_BSSMAP_ServiceHandover(&pType->bssmap_ServiceHandover, pContext, tag);
      }
      
      if( pType->validity & SS2_PrepareHO_Arg_ranap_ServiceHandover_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 14;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RANAP_ServiceHandover(&pType->ranap_ServiceHandover, pContext, tag);
      }
      
      if( pType->validity & SS2_PrepareHO_Arg_bssmap_ServiceHandoverList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 15;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_BSSMAP_ServiceHandoverList(&pType->bssmap_ServiceHandoverList, pContext, tag);
      }
      
      if( pType->validity & SS2_PrepareHO_Arg_asciCallReference_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 20;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ASCI_CallReference(&pType->asciCallReference, pContext, tag);
      }
      
      if( pType->validity & SS2_PrepareHO_Arg_geran_classmark_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 16;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GERAN_Classmark(&pType->geran_classmark, pContext, tag);
      }
      
      if( pType->validity & SS2_PrepareHO_Arg_iuCurrentlyUsedCodec_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 17;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Codec(&pType->iuCurrentlyUsedCodec, pContext, tag);
      }
      
      if( pType->validity & SS2_PrepareHO_Arg_iuSupportedCodecsList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 18;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SupportedCodecsList(&pType->iuSupportedCodecsList, pContext, tag);
      }
      
      if( pType->validity & SS2_PrepareHO_Arg_rab_ConfigurationIndicator_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 19;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_PrepareHO_Arg_uesbi_Iu_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 21;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_UESBI_Iu(&pType->uesbi_Iu, pContext, tag);
      }
      
      if( pType->validity & SS2_PrepareHO_Arg_imeisv_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 22;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IMEI(&pType->imeisv, pContext, tag);
      }
      
      if( pType->validity & SS2_PrepareHO_Arg_alternativeChannelType_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 23;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_RadioResourceInformation(&pType->alternativeChannelType, pContext, tag);
      }
      
      if( pType->validity & SS2_PrepareHO_Arg_tracePropagationList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 25;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_TracePropagationList(&pType->tracePropagationList, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE GPRS-CSI Ber encoder */
static void AsnEncode_SS2_GPRS_CSI( SS2_GPRS_CSI *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_GPRS_CSI_gprs_CamelTDPDataList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GPRS_CamelTDPDataList(&pType->gprs_CamelTDPDataList, pContext, tag);
      }
      
      if( pType->validity & SS2_GPRS_CSI_camelCapabilityHandling_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CamelCapabilityHandling( &pType->camelCapabilityHandling, pContext, tag);
      }
      
      if( pType->validity & SS2_GPRS_CSI_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_GPRS_CSI_notificationToCSE_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_GPRS_CSI_csi_Active_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE Ext-ForwInfo Ber encoder */
static void AsnEncode_SS2_Ext_ForwInfo( SS2_Ext_ForwInfo *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_Code(&pType->ss_Code, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_ForwFeatureList(&pType->forwardingFeatureList, pContext, tag);
      }
      
      if( pType->validity & SS2_Ext_ForwInfo_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE Ext-CallBarInfo Ber encoder */
static void AsnEncode_SS2_Ext_CallBarInfo( SS2_Ext_CallBarInfo *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_Code(&pType->ss_Code, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_CallBarFeatureList(&pType->callBarringFeatureList, pContext, tag);
      }
      
      if( pType->validity & SS2_Ext_CallBarInfo_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE CUG-Info Ber encoder */
static void AsnEncode_SS2_CUG_Info( SS2_CUG_Info *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CUG_SubscriptionList(&pType->cug_SubscriptionList, pContext, tag);
      }
      
      if( pType->validity & SS2_CUG_Info_cug_FeatureList_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CUG_FeatureList(&pType->cug_FeatureList, pContext, tag);
      }
      
      if( pType->validity & SS2_CUG_Info_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE OF ExternalClientList Ber encoder */
static void AsnEncode_SS2_ExternalClientList( SS2_ExternalClientList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExternalClient((SS2_ExternalClient *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE OF Ext-ExternalClientList Ber encoder */
static void AsnEncode_SS2_Ext_ExternalClientList( SS2_Ext_ExternalClientList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExternalClient((SS2_ExternalClient *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE D-CSI Ber encoder */
static void AsnEncode_SS2_D_CSI( SS2_D_CSI *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_D_CSI_dp_AnalysedInfoCriteriaList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_DP_AnalysedInfoCriteriaList(&pType->dp_AnalysedInfoCriteriaList, pContext, tag);
      }
      
      if( pType->validity & SS2_D_CSI_camelCapabilityHandling_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CamelCapabilityHandling( &pType->camelCapabilityHandling, pContext, tag);
      }
      
      if( pType->validity & SS2_D_CSI_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_D_CSI_notificationToCSE_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_D_CSI_csi_Active_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE O-CSI Ber encoder */
static void AsnEncode_SS2_O_CSI( SS2_O_CSI *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_O_BcsmCamelTDPDataList(&pType->o_BcsmCamelTDPDataList, pContext, tag);
      }
      
      if( pType->validity & SS2_O_CSI_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_O_CSI_camelCapabilityHandling_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CamelCapabilityHandling( &pType->camelCapabilityHandling, pContext, tag);
      }
      
      if( pType->validity & SS2_O_CSI_notificationToCSE_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_O_CSI_csiActive_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE SMS-CSI Ber encoder */
static void AsnEncode_SS2_SMS_CSI( SS2_SMS_CSI *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_SMS_CSI_sms_CAMEL_TDP_DataList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SMS_CAMEL_TDP_DataList(&pType->sms_CAMEL_TDP_DataList, pContext, tag);
      }
      
      if( pType->validity & SS2_SMS_CSI_camelCapabilityHandling_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CamelCapabilityHandling( &pType->camelCapabilityHandling, pContext, tag);
      }
      
      if( pType->validity & SS2_SMS_CSI_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_SMS_CSI_notificationToCSE_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_SMS_CSI_csi_Active_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE T-CSI Ber encoder */
static void AsnEncode_SS2_T_CSI( SS2_T_CSI *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_T_BcsmCamelTDPDataList(&pType->t_BcsmCamelTDPDataList, pContext, tag);
      }
      
      if( pType->validity & SS2_T_CSI_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_T_CSI_camelCapabilityHandling_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CamelCapabilityHandling( &pType->camelCapabilityHandling, pContext, tag);
      }
      
      if( pType->validity & SS2_T_CSI_notificationToCSE_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_T_CSI_csi_Active_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* CHOICE PS-SubscriberState Ber encoder */
static void AsnEncode_SS2_PS_SubscriberState( SS2_PS_SubscriberState *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      applib2_BEGIN_PRE_ENCODE
      
      switch( pType->selection )
      {
         case SS2_PS_SubscriberState_notProvidedFromSGSN_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 0;
            /*encode for NULL type */
            tag.is_primitive=TRUE;
            {
                 BER_TLV	null_tlv;
                 null_tlv.t=tag;
                 null_tlv.l.is_defined=TRUE;
                 null_tlv.l.length =0;
                 put_tlv(pContext, &null_tlv);
            }
         }
         break;
         
         case SS2_PS_SubscriberState_ps_Detached_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 1;
            /*encode for NULL type */
            tag.is_primitive=TRUE;
            {
                 BER_TLV	null_tlv;
                 null_tlv.t=tag;
                 null_tlv.l.is_defined=TRUE;
                 null_tlv.l.length =0;
                 put_tlv(pContext, &null_tlv);
            }
         }
         break;
         
         case SS2_PS_SubscriberState_ps_AttachedNotReachableForPaging_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 2;
            /*encode for NULL type */
            tag.is_primitive=TRUE;
            {
                 BER_TLV	null_tlv;
                 null_tlv.t=tag;
                 null_tlv.l.is_defined=TRUE;
                 null_tlv.l.length =0;
                 put_tlv(pContext, &null_tlv);
            }
         }
         break;
         
         case SS2_PS_SubscriberState_ps_AttachedReachableForPaging_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 3;
            /*encode for NULL type */
            tag.is_primitive=TRUE;
            {
                 BER_TLV	null_tlv;
                 null_tlv.t=tag;
                 null_tlv.l.is_defined=TRUE;
                 null_tlv.l.length =0;
                 put_tlv(pContext, &null_tlv);
            }
         }
         break;
         
         case SS2_PS_SubscriberState_ps_PDP_ActiveNotReachableForPaging_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 4;
            AsnEncode_SS2_PDP_ContextInfoList(&pType->choice.ps_PDP_ActiveNotReachableForPaging, pContext, tag);
         }
         break;
         
         case SS2_PS_SubscriberState_ps_PDP_ActiveReachableForPaging_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 5;
            AsnEncode_SS2_PDP_ContextInfoList(&pType->choice.ps_PDP_ActiveReachableForPaging, pContext, tag);
         }
         break;
         
         case SS2_PS_SubscriberState_netDetNotReachable_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 6;
            AsnEncode_SS2_NotReachableReason(&pType->choice.netDetNotReachable, pContext, tag);
         }
         break;
         
         default:
           /* Constraint Violation */
            applib2_UA1_ERROR( 128 );
         break;
      }
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      if(seq_tlv.t.mode == AUTOMATIC )
      {
         if(seq_tlv.t.cl ==ContextSpecific )
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == IMPLICIT)
      {
         if(seq_tlv.t.is_tagged)
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == EXPLICIT || seq_tlv.t.mode ==EMPTY)
      {
         if(seq_tlv.t.is_tagged)
         {
            applib2_BEGIN_PRE_ENCODE
            put_tlv(pContext, &seq_tlv);
            applib2_asnMemFree((void **)&pTemp);
            applib2_BER_END_PRE_ENCODE
            seq_tlv.l.is_defined = TRUE;
            seq_tlv.l.length = ulen;
            seq_tlv.v = (U8 *)pTemp;
            put_tlv(pContext, &seq_tlv);
         }
         else
         {
            put_tlv(pContext, &seq_tlv);
         }
      }
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE CAMEL-SubscriptionInfo Ber encoder */
static void AsnEncode_SS2_CAMEL_SubscriptionInfo( SS2_CAMEL_SubscriptionInfo *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_CAMEL_SubscriptionInfo_o_CSI_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_O_CSI(&pType->o_CSI, pContext, tag);
      }
      
      if( pType->validity & SS2_CAMEL_SubscriptionInfo_o_BcsmCamelTDP_CriteriaList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_O_BcsmCamelTDPCriteriaList(&pType->o_BcsmCamelTDP_CriteriaList, pContext, tag);
      }
      
      if( pType->validity & SS2_CAMEL_SubscriptionInfo_d_CSI_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_D_CSI(&pType->d_CSI, pContext, tag);
      }
      
      if( pType->validity & SS2_CAMEL_SubscriptionInfo_t_CSI_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_T_CSI(&pType->t_CSI, pContext, tag);
      }
      
      if( pType->validity & SS2_CAMEL_SubscriptionInfo_t_BCSM_CAMEL_TDP_CriteriaList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_T_BCSM_CAMEL_TDP_CriteriaList(&pType->t_BCSM_CAMEL_TDP_CriteriaList, pContext, tag);
      }
      
      if( pType->validity & SS2_CAMEL_SubscriptionInfo_vt_CSI_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_T_CSI(&pType->vt_CSI, pContext, tag);
      }
      
      if( pType->validity & SS2_CAMEL_SubscriptionInfo_vt_BCSM_CAMEL_TDP_CriteriaList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_T_BCSM_CAMEL_TDP_CriteriaList(&pType->vt_BCSM_CAMEL_TDP_CriteriaList, pContext, tag);
      }
      
      if( pType->validity & SS2_CAMEL_SubscriptionInfo_tif_CSI_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 7;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_CAMEL_SubscriptionInfo_tif_CSI_NotificationToCSE_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 8;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_CAMEL_SubscriptionInfo_gprs_CSI_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 9;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GPRS_CSI(&pType->gprs_CSI, pContext, tag);
      }
      
      if( pType->validity & SS2_CAMEL_SubscriptionInfo_mo_sms_CSI_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 10;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SMS_CSI(&pType->mo_sms_CSI, pContext, tag);
      }
      
      if( pType->validity & SS2_CAMEL_SubscriptionInfo_ss_CSI_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 11;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_CSI(&pType->ss_CSI, pContext, tag);
      }
      
      if( pType->validity & SS2_CAMEL_SubscriptionInfo_m_CSI_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 12;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_M_CSI(&pType->m_CSI, pContext, tag);
      }
      
      if( pType->validity & SS2_CAMEL_SubscriptionInfo_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 13;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_CAMEL_SubscriptionInfo_specificCSIDeletedList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 14;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SpecificCSI_Withdraw(&pType->specificCSIDeletedList, pContext, tag);
      }
      
      if( pType->validity & SS2_CAMEL_SubscriptionInfo_mt_sms_CSI_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 15;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SMS_CSI(&pType->mt_sms_CSI, pContext, tag);
      }
      
      if( pType->validity & SS2_CAMEL_SubscriptionInfo_mt_smsCAMELTDP_CriteriaList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 16;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_MT_smsCAMELTDP_CriteriaList(&pType->mt_smsCAMELTDP_CriteriaList, pContext, tag);
      }
      
      if( pType->validity & SS2_CAMEL_SubscriptionInfo_mg_csi_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 17;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_MG_CSI(&pType->mg_csi, pContext, tag);
      }
      
      if( pType->validity & SS2_CAMEL_SubscriptionInfo_o_IM_CSI_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 18;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_O_CSI(&pType->o_IM_CSI, pContext, tag);
      }
      
      if( pType->validity & SS2_CAMEL_SubscriptionInfo_o_IM_BcsmCamelTDP_CriteriaList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 19;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_O_BcsmCamelTDPCriteriaList(&pType->o_IM_BcsmCamelTDP_CriteriaList, pContext, tag);
      }
      
      if( pType->validity & SS2_CAMEL_SubscriptionInfo_d_IM_CSI_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 20;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_D_CSI(&pType->d_IM_CSI, pContext, tag);
      }
      
      if( pType->validity & SS2_CAMEL_SubscriptionInfo_vt_IM_CSI_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 21;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_T_CSI(&pType->vt_IM_CSI, pContext, tag);
      }
      
      if( pType->validity & SS2_CAMEL_SubscriptionInfo_vt_IM_BCSM_CAMEL_TDP_CriteriaList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 22;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_T_BCSM_CAMEL_TDP_CriteriaList(&pType->vt_IM_BCSM_CAMEL_TDP_CriteriaList, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE NoteSubscriberDataModifiedArg Ber encoder */
extern U32 AsnEncode_SS2_NoteSubscriberDataModifiedArg( SS2_NoteSubscriberDataModifiedArg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IMSI(&pType->imsi, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->msisdn, pContext, tag);
      }
      
      if( pType->validity & SS2_NoteSubscriberDataModifiedArg_forwardingInfoFor_CSE_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_ForwardingInfoFor_CSE(&pType->forwardingInfoFor_CSE, pContext, tag);
      }
      
      if( pType->validity & SS2_NoteSubscriberDataModifiedArg_callBarringInfoFor_CSE_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_CallBarringInfoFor_CSE(&pType->callBarringInfoFor_CSE, pContext, tag);
      }
      
      if( pType->validity & SS2_NoteSubscriberDataModifiedArg_odb_Info_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ODB_Info(&pType->odb_Info, pContext, tag);
      }
      
      if( pType->validity & SS2_NoteSubscriberDataModifiedArg_camel_SubscriptionInfo_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CAMEL_SubscriptionInfo(&pType->camel_SubscriptionInfo, pContext, tag);
      }
      
      if( pType->validity & SS2_NoteSubscriberDataModifiedArg_allInformationSent_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_NoteSubscriberDataModifiedArg_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* CHOICE Ext-SS-InfoFor-CSE Ber encoder */
static void AsnEncode_SS2_Ext_SS_InfoFor_CSE( SS2_Ext_SS_InfoFor_CSE *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      applib2_BEGIN_PRE_ENCODE
      
      switch( pType->selection )
      {
         case SS2_Ext_SS_InfoFor_CSE_forwardingInfoFor_CSE_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 0;
            AsnEncode_SS2_Ext_ForwardingInfoFor_CSE(&pType->choice.forwardingInfoFor_CSE, pContext, tag);
         }
         break;
         
         case SS2_Ext_SS_InfoFor_CSE_callBarringInfoFor_CSE_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 1;
            AsnEncode_SS2_Ext_CallBarringInfoFor_CSE(&pType->choice.callBarringInfoFor_CSE, pContext, tag);
         }
         break;
         
         default:
           /* Constraint Violation */
            applib2_UA1_ERROR( 129 );
         break;
      }
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      if(seq_tlv.t.mode == AUTOMATIC )
      {
         if(seq_tlv.t.cl ==ContextSpecific )
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == IMPLICIT)
      {
         if(seq_tlv.t.is_tagged)
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == EXPLICIT || seq_tlv.t.mode ==EMPTY)
      {
         if(seq_tlv.t.is_tagged)
         {
            applib2_BEGIN_PRE_ENCODE
            put_tlv(pContext, &seq_tlv);
            applib2_asnMemFree((void **)&pTemp);
            applib2_BER_END_PRE_ENCODE
            seq_tlv.l.is_defined = TRUE;
            seq_tlv.l.length = ulen;
            seq_tlv.v = (U8 *)pTemp;
            put_tlv(pContext, &seq_tlv);
         }
         else
         {
            put_tlv(pContext, &seq_tlv);
         }
      }
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* CHOICE SS-Info Ber encoder */
static void AsnEncode_SS2_SS_Info( SS2_SS_Info *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      applib2_BEGIN_PRE_ENCODE
      
      switch( pType->selection )
      {
         case SS2_SS_Info_forwardingInfo_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 0;
            AsnEncode_SS2_ForwardingInfo(&pType->choice.forwardingInfo, pContext, tag);
         }
         break;
         
         case SS2_SS_Info_callBarringInfo_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 1;
            AsnEncode_SS2_CallBarringInfo(&pType->choice.callBarringInfo, pContext, tag);
         }
         break;
         
         case SS2_SS_Info_ss_Data_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 3;
            AsnEncode_SS2_SS_Data(&pType->choice.ss_Data, pContext, tag);
         }
         break;
         
         default:
           /* Constraint Violation */
            applib2_UA1_ERROR( 130 );
         break;
      }
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      if(seq_tlv.t.mode == AUTOMATIC )
      {
         if(seq_tlv.t.cl ==ContextSpecific )
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == IMPLICIT)
      {
         if(seq_tlv.t.is_tagged)
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == EXPLICIT || seq_tlv.t.mode ==EMPTY)
      {
         if(seq_tlv.t.is_tagged)
         {
            applib2_BEGIN_PRE_ENCODE
            put_tlv(pContext, &seq_tlv);
            applib2_asnMemFree((void **)&pTemp);
            applib2_BER_END_PRE_ENCODE
            seq_tlv.l.is_defined = TRUE;
            seq_tlv.l.length = ulen;
            seq_tlv.v = (U8 *)pTemp;
            put_tlv(pContext, &seq_tlv);
         }
         else
         {
            put_tlv(pContext, &seq_tlv);
         }
      }
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE OF SS-InfoList Ber encoder */
extern U32 AsnEncode_SS2_SS_InfoList( SS2_SS_InfoList *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;
unsigned int i;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32	    ulen;
      U8*   pTemp=(U8 *)0;

      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 0;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_Info((SS2_SS_Info *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE RegisterCC-EntryArg Ber encoder */
extern U32 AsnEncode_SS2_RegisterCC_EntryArg( SS2_RegisterCC_EntryArg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_Code(&pType->ss_Code, pContext, tag);
      }
      
      if( pType->validity & SS2_RegisterCC_EntryArg_ccbs_Data_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CCBS_Data(&pType->ccbs_Data, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE LCS-AreaEventRequestArg Ber encoder */
extern U32 AsnEncode_SS2_LCS_AreaEventRequestArg( SS2_LCS_AreaEventRequestArg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCS_ReferenceNumber(&pType->referenceNumber, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GSN_Address(&pType->h_gmlc_address, pContext, tag);
      }
      
      if( pType->validity & SS2_LCS_AreaEventRequestArg_r_gmlc_address_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GSN_Address(&pType->r_gmlc_address, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_DeferredLocationEventType(&pType->deferredLocationEventType, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AreaEventInfo(&pType->areaEventInfo, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE ProvideSubscriberLocation-Arg Ber encoder */
extern U32 AsnEncode_SS2_ProvideSubscriberLocation_Arg( SS2_ProvideSubscriberLocation_Arg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LocationType(&pType->locationType, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->mlc_Number, pContext, tag);
      }
      
      if( pType->validity & SS2_ProvideSubscriberLocation_Arg_lcs_ClientID_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCS_ClientID(&pType->lcs_ClientID, pContext, tag);
      }
      
      if( pType->validity & SS2_ProvideSubscriberLocation_Arg_privacyOverride_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_ProvideSubscriberLocation_Arg_imsi_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IMSI(&pType->imsi, pContext, tag);
      }
      
      if( pType->validity & SS2_ProvideSubscriberLocation_Arg_msisdn_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->msisdn, pContext, tag);
      }
      
      if( pType->validity & SS2_ProvideSubscriberLocation_Arg_lmsi_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LMSI(&pType->lmsi, pContext, tag);
      }
      
      if( pType->validity & SS2_ProvideSubscriberLocation_Arg_imei_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IMEI(&pType->imei, pContext, tag);
      }
      
      if( pType->validity & SS2_ProvideSubscriberLocation_Arg_lcs_Priority_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCS_Priority(&pType->lcs_Priority, pContext, tag);
      }
      
      if( pType->validity & SS2_ProvideSubscriberLocation_Arg_lcs_QoS_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 7;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCS_QoS(&pType->lcs_QoS, pContext, tag);
      }
      
      if( pType->validity & SS2_ProvideSubscriberLocation_Arg_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 8;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_ProvideSubscriberLocation_Arg_supportedGADShapes_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 9;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SupportedGADShapes(&pType->supportedGADShapes, pContext, tag);
      }
      
      if( pType->validity & SS2_ProvideSubscriberLocation_Arg_lcs_ReferenceNumber_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 10;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCS_ReferenceNumber(&pType->lcs_ReferenceNumber, pContext, tag);
      }
      
      if( pType->validity & SS2_ProvideSubscriberLocation_Arg_lcsServiceTypeID_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 11;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCSServiceTypeID( &pType->lcsServiceTypeID, pContext, tag);
      }
      
      if( pType->validity & SS2_ProvideSubscriberLocation_Arg_lcsCodeword_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 12;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCSCodeword(&pType->lcsCodeword, pContext, tag);
      }
      
      if( pType->validity & SS2_ProvideSubscriberLocation_Arg_lcs_PrivacyCheck_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 13;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCS_PrivacyCheck(&pType->lcs_PrivacyCheck, pContext, tag);
      }
      
      if( pType->validity & SS2_ProvideSubscriberLocation_Arg_areaEventInfo_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 14;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AreaEventInfo(&pType->areaEventInfo, pContext, tag);
      }
      
      if( pType->validity & SS2_ProvideSubscriberLocation_Arg_h_gmlc_Address_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 15;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GSN_Address(&pType->h_gmlc_Address, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE SGSN-CAMEL-SubscriptionInfo Ber encoder */
static void AsnEncode_SS2_SGSN_CAMEL_SubscriptionInfo( SS2_SGSN_CAMEL_SubscriptionInfo *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_SGSN_CAMEL_SubscriptionInfo_gprs_CSI_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GPRS_CSI(&pType->gprs_CSI, pContext, tag);
      }
      
      if( pType->validity & SS2_SGSN_CAMEL_SubscriptionInfo_mo_sms_CSI_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SMS_CSI(&pType->mo_sms_CSI, pContext, tag);
      }
      
      if( pType->validity & SS2_SGSN_CAMEL_SubscriptionInfo_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_SGSN_CAMEL_SubscriptionInfo_mt_sms_CSI_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SMS_CSI(&pType->mt_sms_CSI, pContext, tag);
      }
      
      if( pType->validity & SS2_SGSN_CAMEL_SubscriptionInfo_mt_smsCAMELTDP_CriteriaList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_MT_smsCAMELTDP_CriteriaList(&pType->mt_smsCAMELTDP_CriteriaList, pContext, tag);
      }
      
      if( pType->validity & SS2_SGSN_CAMEL_SubscriptionInfo_mg_csi_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_MG_CSI(&pType->mg_csi, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* CHOICE Ext-SS-Info Ber encoder */
static void AsnEncode_SS2_Ext_SS_Info( SS2_Ext_SS_Info *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      applib2_BEGIN_PRE_ENCODE
      
      switch( pType->selection )
      {
         case SS2_Ext_SS_Info_forwardingInfo_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 0;
            AsnEncode_SS2_Ext_ForwInfo(&pType->choice.forwardingInfo, pContext, tag);
         }
         break;
         
         case SS2_Ext_SS_Info_callBarringInfo_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 1;
            AsnEncode_SS2_Ext_CallBarInfo(&pType->choice.callBarringInfo, pContext, tag);
         }
         break;
         
         case SS2_Ext_SS_Info_cug_Info_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 2;
            AsnEncode_SS2_CUG_Info(&pType->choice.cug_Info, pContext, tag);
         }
         break;
         
         case SS2_Ext_SS_Info_ss_Data_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 3;
            AsnEncode_SS2_Ext_SS_Data(&pType->choice.ss_Data, pContext, tag);
         }
         break;
         
         case SS2_Ext_SS_Info_emlpp_Info_selected:
         {
            BER_TAG   tag;
            tag.cl = ContextSpecific;
            tag.tag = 4;
            AsnEncode_SS2_EMLPP_Info(&pType->choice.emlpp_Info, pContext, tag);
         }
         break;
         
         default:
           /* Constraint Violation */
            applib2_UA1_ERROR( 131 );
         break;
      }
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      if(seq_tlv.t.mode == AUTOMATIC )
      {
         if(seq_tlv.t.cl ==ContextSpecific )
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == IMPLICIT)
      {
         if(seq_tlv.t.is_tagged)
         {
             put_tlv(pContext, &seq_tlv);
         }
         else
         {
             applib2_putLongBits(pContext, seq_tlv.l.length*8, seq_tlv.v);
         }
      }
      else if(seq_tlv.t.mode == EXPLICIT || seq_tlv.t.mode ==EMPTY)
      {
         if(seq_tlv.t.is_tagged)
         {
            applib2_BEGIN_PRE_ENCODE
            put_tlv(pContext, &seq_tlv);
            applib2_asnMemFree((void **)&pTemp);
            applib2_BER_END_PRE_ENCODE
            seq_tlv.l.is_defined = TRUE;
            seq_tlv.l.length = ulen;
            seq_tlv.v = (U8 *)pTemp;
            put_tlv(pContext, &seq_tlv);
         }
         else
         {
            put_tlv(pContext, &seq_tlv);
         }
      }
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE LCS-PrivacyClass Ber encoder */
static void AsnEncode_SS2_LCS_PrivacyClass( SS2_LCS_PrivacyClass *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_Code(&pType->ss_Code, pContext, tag);
      }
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 4;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_SS_Status(&pType->ss_Status, pContext, tag);
      }
      
      if( pType->validity & SS2_LCS_PrivacyClass_notificationToMSUser_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_NotificationToMSUser(&pType->notificationToMSUser, pContext, tag);
      }
      
      if( pType->validity & SS2_LCS_PrivacyClass_externalClientList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExternalClientList(&pType->externalClientList, pContext, tag);
      }
      
      if( pType->validity & SS2_LCS_PrivacyClass_plmnClientList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_PLMNClientList(&pType->plmnClientList, pContext, tag);
      }
      
      if( pType->validity & SS2_LCS_PrivacyClass_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_LCS_PrivacyClass_ext_externalClientList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_ExternalClientList(&pType->ext_externalClientList, pContext, tag);
      }
      
      if( pType->validity & SS2_LCS_PrivacyClass_serviceTypeList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ServiceTypeList(&pType->serviceTypeList, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE VlrCamelSubscriptionInfo Ber encoder */
static void AsnEncode_SS2_VlrCamelSubscriptionInfo( SS2_VlrCamelSubscriptionInfo *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_VlrCamelSubscriptionInfo_o_CSI_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_O_CSI(&pType->o_CSI, pContext, tag);
      }
      
      if( pType->validity & SS2_VlrCamelSubscriptionInfo_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_VlrCamelSubscriptionInfo_ss_CSI_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SS_CSI(&pType->ss_CSI, pContext, tag);
      }
      
      if( pType->validity & SS2_VlrCamelSubscriptionInfo_o_BcsmCamelTDP_CriteriaList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_O_BcsmCamelTDPCriteriaList(&pType->o_BcsmCamelTDP_CriteriaList, pContext, tag);
      }
      
      if( pType->validity & SS2_VlrCamelSubscriptionInfo_tif_CSI_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_VlrCamelSubscriptionInfo_m_CSI_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_M_CSI(&pType->m_CSI, pContext, tag);
      }
      
      if( pType->validity & SS2_VlrCamelSubscriptionInfo_mo_sms_CSI_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SMS_CSI(&pType->mo_sms_CSI, pContext, tag);
      }
      
      if( pType->validity & SS2_VlrCamelSubscriptionInfo_vt_CSI_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 7;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_T_CSI(&pType->vt_CSI, pContext, tag);
      }
      
      if( pType->validity & SS2_VlrCamelSubscriptionInfo_t_BCSM_CAMEL_TDP_CriteriaList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 8;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_T_BCSM_CAMEL_TDP_CriteriaList(&pType->t_BCSM_CAMEL_TDP_CriteriaList, pContext, tag);
      }
      
      if( pType->validity & SS2_VlrCamelSubscriptionInfo_d_CSI_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 9;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_D_CSI(&pType->d_CSI, pContext, tag);
      }
      
      if( pType->validity & SS2_VlrCamelSubscriptionInfo_mt_sms_CSI_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 10;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SMS_CSI(&pType->mt_sms_CSI, pContext, tag);
      }
      
      if( pType->validity & SS2_VlrCamelSubscriptionInfo_mt_smsCAMELTDP_CriteriaList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 11;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_MT_smsCAMELTDP_CriteriaList(&pType->mt_smsCAMELTDP_CriteriaList, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE SubscriberInfo Ber encoder */
static void AsnEncode_SS2_SubscriberInfo( SS2_SubscriberInfo *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_SubscriberInfo_locationInformation_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LocationInformation(&pType->locationInformation, pContext, tag);
      }
      
      if( pType->validity & SS2_SubscriberInfo_subscriberState_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SubscriberState(&pType->subscriberState, pContext, tag);
      }
      
      if( pType->validity & SS2_SubscriberInfo_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_SubscriberInfo_locationInformationGPRS_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LocationInformationGPRS(&pType->locationInformationGPRS, pContext, tag);
      }
      
      if( pType->validity & SS2_SubscriberInfo_ps_SubscriberState_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_PS_SubscriberState(&pType->ps_SubscriberState, pContext, tag);
      }
      
      if( pType->validity & SS2_SubscriberInfo_imei_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IMEI(&pType->imei, pContext, tag);
      }
      
      if( pType->validity & SS2_SubscriberInfo_ms_Classmark2_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_MS_Classmark2(&pType->ms_Classmark2, pContext, tag);
      }
      
      if( pType->validity & SS2_SubscriberInfo_gprs_MS_Class_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 7;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GPRSMSClass(&pType->gprs_MS_Class, pContext, tag);
      }
      
      if( pType->validity & SS2_SubscriberInfo_mnpInfoRes_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 8;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_MNPInfoRes(&pType->mnpInfoRes, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE AnyTimeInterrogationRes Ber encoder */
extern U32 AsnEncode_SS2_AnyTimeInterrogationRes( SS2_AnyTimeInterrogationRes *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SubscriberInfo(&pType->subscriberInfo, pContext, tag);
      }
      
      if( pType->validity & SS2_AnyTimeInterrogationRes_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE AnyTimeSubscriptionInterrogationRes Ber encoder */
extern U32 AsnEncode_SS2_AnyTimeSubscriptionInterrogationRes( SS2_AnyTimeSubscriptionInterrogationRes *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_AnyTimeSubscriptionInterrogationRes_callForwardingData_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CallForwardingData(&pType->callForwardingData, pContext, tag);
      }
      
      if( pType->validity & SS2_AnyTimeSubscriptionInterrogationRes_callBarringData_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CallBarringData(&pType->callBarringData, pContext, tag);
      }
      
      if( pType->validity & SS2_AnyTimeSubscriptionInterrogationRes_odb_Info_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ODB_Info(&pType->odb_Info, pContext, tag);
      }
      
      if( pType->validity & SS2_AnyTimeSubscriptionInterrogationRes_camel_SubscriptionInfo_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CAMEL_SubscriptionInfo(&pType->camel_SubscriptionInfo, pContext, tag);
      }
      
      if( pType->validity & SS2_AnyTimeSubscriptionInterrogationRes_supportedVLR_CAMEL_Phases_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 5;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SupportedCamelPhases(&pType->supportedVLR_CAMEL_Phases, pContext, tag);
      }
      
      if( pType->validity & SS2_AnyTimeSubscriptionInterrogationRes_supportedSGSN_CAMEL_Phases_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SupportedCamelPhases(&pType->supportedSGSN_CAMEL_Phases, pContext, tag);
      }
      
      if( pType->validity & SS2_AnyTimeSubscriptionInterrogationRes_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 7;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_AnyTimeSubscriptionInterrogationRes_offeredCamel4CSIsInVLR_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 8;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_OfferedCamel4CSIs(&pType->offeredCamel4CSIsInVLR, pContext, tag);
      }
      
      if( pType->validity & SS2_AnyTimeSubscriptionInterrogationRes_offeredCamel4CSIsInSGSN_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 9;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_OfferedCamel4CSIs(&pType->offeredCamel4CSIsInSGSN, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE AnyTimeModificationRes Ber encoder */
extern U32 AsnEncode_SS2_AnyTimeModificationRes( SS2_AnyTimeModificationRes *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_AnyTimeModificationRes_ss_InfoFor_CSE_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_SS_InfoFor_CSE(&pType->ss_InfoFor_CSE, pContext, tag);
      }
      
      if( pType->validity & SS2_AnyTimeModificationRes_camel_SubscriptionInfo_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CAMEL_SubscriptionInfo(&pType->camel_SubscriptionInfo, pContext, tag);
      }
      
      if( pType->validity & SS2_AnyTimeModificationRes_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_AnyTimeModificationRes_odb_Info_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ODB_Info(&pType->odb_Info, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE OF Ext-SS-InfoList Ber encoder */
static void AsnEncode_SS2_Ext_SS_InfoList( SS2_Ext_SS_InfoList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 0;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_SS_Info((SS2_Ext_SS_Info *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE OF LCS-PrivacyExceptionList Ber encoder */
static void AsnEncode_SS2_LCS_PrivacyExceptionList( SS2_LCS_PrivacyExceptionList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
unsigned int i;
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;

      tag.is_primitive = FALSE;
      seq_tlv.t = tag;

      applib2_BEGIN_PRE_ENCODE

      for( i = 0; i < pType->numElements; i++ )
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCS_PrivacyClass((SS2_LCS_PrivacyClass *)(&pType->element[i]), pContext, tag);
      }

      applib2_BER_END_PRE_ENCODE

      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;

      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   }
}

/* SEQUENCE ProvideSubscriberInfoRes Ber encoder */
extern U32 AsnEncode_SS2_ProvideSubscriberInfoRes( SS2_ProvideSubscriberInfoRes *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SubscriberInfo(&pType->subscriberInfo, pContext, tag);
      }
      
      if( pType->validity & SS2_ProvideSubscriberInfoRes_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = Universal;
         tag.tag = 16;
         tag.is_tagged = FALSE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE LCSInformation Ber encoder */
static void AsnEncode_SS2_LCSInformation( SS2_LCSInformation *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t = tag;
      seq_tlv.t.is_primitive = FALSE;
      
      if (Universal == tag.cl)
         tag.tag = 16;	/* correct value */
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_LCSInformation_gmlc_List_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GMLC_List(&pType->gmlc_List, pContext, tag);
      }
      
      if( pType->validity & SS2_LCSInformation_lcs_PrivacyExceptionList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCS_PrivacyExceptionList(&pType->lcs_PrivacyExceptionList, pContext, tag);
      }
      
      if( pType->validity & SS2_LCSInformation_molr_List_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_MOLR_List(&pType->molr_List, pContext, tag);
      }
      
      if( pType->validity & SS2_LCSInformation_add_lcs_PrivacyExceptionList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCS_PrivacyExceptionList(&pType->add_lcs_PrivacyExceptionList, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }
}

/* SEQUENCE SubscriberData Ber encoder */
extern U32 AsnEncode_SS2_SubscriberData( SS2_SubscriberData *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_SubscriberData_msisdn_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->msisdn, pContext, tag);
      }
      
      if( pType->validity & SS2_SubscriberData_category_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Category(&pType->category, pContext, tag);
      }
      
      if( pType->validity & SS2_SubscriberData_subscriberStatus_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SubscriberStatus(&pType->subscriberStatus, pContext, tag);
      }
      
      if( pType->validity & SS2_SubscriberData_bearerServiceList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_BearerServiceList(&pType->bearerServiceList, pContext, tag);
      }
      
      if( pType->validity & SS2_SubscriberData_teleserviceList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_TeleserviceList(&pType->teleserviceList, pContext, tag);
      }
      
      if( pType->validity & SS2_SubscriberData_provisionedSS_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 7;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_SS_InfoList(&pType->provisionedSS, pContext, tag);
      }
      
      if( pType->validity & SS2_SubscriberData_odb_Data_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 8;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ODB_Data(&pType->odb_Data, pContext, tag);
      }
      
      if( pType->validity & SS2_SubscriberData_roamingRestrictionDueToUnsupportedFeature_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 9;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_SubscriberData_regionalSubscriptionData_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 10;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ZoneCodeList(&pType->regionalSubscriptionData, pContext, tag);
      }
      
      if( pType->validity & SS2_SubscriberData_vbsSubscriptionData_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 11;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_VBSDataList(&pType->vbsSubscriptionData, pContext, tag);
      }
      
      if( pType->validity & SS2_SubscriberData_vgcsSubscriptionData_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 12;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_VGCSDataList(&pType->vgcsSubscriptionData, pContext, tag);
      }
      
      if( pType->validity & SS2_SubscriberData_vlrCamelSubscriptionInfo_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 13;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_VlrCamelSubscriptionInfo(&pType->vlrCamelSubscriptionInfo, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

/* SEQUENCE InsertSubscriberDataArg Ber encoder */
extern U32 AsnEncode_SS2_InsertSubscriberDataArg( SS2_InsertSubscriberDataArg *pType, U8 **ppEncoded, U32 *pEncodedLength, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext encodeAsnContext, *pContext = &encodeAsnContext;

   pContext->encodeAlloc = NULL;

   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   }
   if( setjmp( pContext->env ) )
   {
      /* An encode exception has occurred - free any allocated memory */
      applib2_AsnEncodeFree( pContext->encodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnEncodeAlloc( pContext, (void **)ppEncoded, pEncodedLength );


   if (NULL == ppEncoded)
   {
      //Encode length query
      pContext->pEncoded = NULL;
      pContext->pEncodedEnd = NULL;
      pContext->shiftRegister = pContext->shiftRegisterLength = 0;
      pContext->result = 0;
   }
   else
   {
      applib2_initFifo( pContext, *ppEncoded, 4000 );
   }

   {
      BER_TLV	seq_tlv;
      U32   ulen;
      U8*   pTemp=(U8 *)0;
      
      seq_tlv.t.cl = Universal;
      seq_tlv.t.is_primitive = FALSE;
      seq_tlv.t.tag = 16;
      
      applib2_BEGIN_PRE_ENCODE
      
      if( pType->validity & SS2_InsertSubscriberDataArg_imsi_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 0;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IMSI(&pType->imsi, pContext, tag);
      }
      
      if( pType->validity & SS2_InsertSubscriberDataArg_msisdn_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 1;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ISDN_AddressString(&pType->msisdn, pContext, tag);
      }
      
      if( pType->validity & SS2_InsertSubscriberDataArg_category_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 2;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Category(&pType->category, pContext, tag);
      }
      
      if( pType->validity & SS2_InsertSubscriberDataArg_subscriberStatus_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 3;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SubscriberStatus(&pType->subscriberStatus, pContext, tag);
      }
      
      if( pType->validity & SS2_InsertSubscriberDataArg_bearerServiceList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 4;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_BearerServiceList(&pType->bearerServiceList, pContext, tag);
      }
      
      if( pType->validity & SS2_InsertSubscriberDataArg_teleserviceList_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 6;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_TeleserviceList(&pType->teleserviceList, pContext, tag);
      }
      
      if( pType->validity & SS2_InsertSubscriberDataArg_provisionedSS_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 7;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_Ext_SS_InfoList(&pType->provisionedSS, pContext, tag);
      }
      
      if( pType->validity & SS2_InsertSubscriberDataArg_odb_Data_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 8;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ODB_Data(&pType->odb_Data, pContext, tag);
      }
      
      if( pType->validity & SS2_InsertSubscriberDataArg_roamingRestrictionDueToUnsupportedFeature_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 9;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_InsertSubscriberDataArg_regionalSubscriptionData_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 10;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ZoneCodeList(&pType->regionalSubscriptionData, pContext, tag);
      }
      
      if( pType->validity & SS2_InsertSubscriberDataArg_vbsSubscriptionData_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 11;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_VBSDataList(&pType->vbsSubscriptionData, pContext, tag);
      }
      
      if( pType->validity & SS2_InsertSubscriberDataArg_vgcsSubscriptionData_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 12;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_VGCSDataList(&pType->vgcsSubscriptionData, pContext, tag);
      }
      
      if( pType->validity & SS2_InsertSubscriberDataArg_vlrCamelSubscriptionInfo_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 13;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_VlrCamelSubscriptionInfo(&pType->vlrCamelSubscriptionInfo, pContext, tag);
      }
      
      if( pType->validity & SS2_InsertSubscriberDataArg_extensionContainer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 14;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ExtensionContainer(&pType->extensionContainer, pContext, tag);
      }
      
      if( pType->validity & SS2_InsertSubscriberDataArg_naea_PreferredCI_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 15;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_NAEA_PreferredCI(&pType->naea_PreferredCI, pContext, tag);
      }
      
      if( pType->validity & SS2_InsertSubscriberDataArg_gprsSubscriptionData_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 16;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_GPRSSubscriptionData(&pType->gprsSubscriptionData, pContext, tag);
      }
      
      if( pType->validity & SS2_InsertSubscriberDataArg_roamingRestrictedInSgsnDueToUnsupportedFeature_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 23;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_InsertSubscriberDataArg_networkAccessMode_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 24;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_NetworkAccessMode(&pType->networkAccessMode, pContext, tag);
      }
      
      if( pType->validity & SS2_InsertSubscriberDataArg_lsaInformation_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 25;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LSAInformation(&pType->lsaInformation, pContext, tag);
      }
      
      if( pType->validity & SS2_InsertSubscriberDataArg_lmu_Indicator_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 21;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         

               /* NULL */
         tag.is_primitive=TRUE;
         {
             BER_TLV	null_tlv;
             null_tlv.t=tag;
             null_tlv.l.is_defined=TRUE;
             null_tlv.l.length =0;
             put_tlv(pContext, &null_tlv);
         }
      }
      
      if( pType->validity & SS2_InsertSubscriberDataArg_lcsInformation_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 22;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_LCSInformation(&pType->lcsInformation, pContext, tag);
      }
      
      if( pType->validity & SS2_InsertSubscriberDataArg_istAlertTimer_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 26;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_IST_AlertTimerValue( &pType->istAlertTimer, pContext, tag);
      }
      
      if( pType->validity & SS2_InsertSubscriberDataArg_superChargerSupportedInHLR_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 27;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AgeIndicator(&pType->superChargerSupportedInHLR, pContext, tag);
      }
      
      if( pType->validity & SS2_InsertSubscriberDataArg_mc_SS_Info_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 28;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_MC_SS_Info(&pType->mc_SS_Info, pContext, tag);
      }
      
      if( pType->validity & SS2_InsertSubscriberDataArg_cs_AllocationRetentionPriority_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 29;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_CS_AllocationRetentionPriority(&pType->cs_AllocationRetentionPriority, pContext, tag);
      }
      
      if( pType->validity & SS2_InsertSubscriberDataArg_sgsn_CAMEL_SubscriptionInfo_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 17;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_SGSN_CAMEL_SubscriptionInfo(&pType->sgsn_CAMEL_SubscriptionInfo, pContext, tag);
      }
      
      if( pType->validity & SS2_InsertSubscriberDataArg_chargingCharacteristics_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 18;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_ChargingCharacteristics(&pType->chargingCharacteristics, pContext, tag);
      }
      
      if( pType->validity & SS2_InsertSubscriberDataArg_accessRestrictionData_valid)
      {
         BER_TAG   tag;
         tag.cl = ContextSpecific;
         tag.tag = 19;
         tag.is_tagged = TRUE;
         tag.mode = IMPLICIT ;
         AsnEncode_SS2_AccessRestrictionData(&pType->accessRestrictionData, pContext, tag);
      }
      
      
      applib2_BER_END_PRE_ENCODE
      
      seq_tlv.l.is_defined = TRUE;
      seq_tlv.l.length = ulen;
      seq_tlv.v = (U8 *)pTemp;
      put_tlv(pContext, &seq_tlv);
      applib2_asnMemFree((void **)&pTemp);
   
   }

   applib2_flushFifo( pContext );

   /* Work out the length of the encoding */

   if (NULL == ppEncoded)
   {
      *pEncodedLength = pContext->shiftRegister;
   }
   else
   {
      *pEncodedLength = pContext->pEncoded - *ppEncoded;
   }

   return 0;
}

#endif //__AGPS_CONTROL_PLANE__
