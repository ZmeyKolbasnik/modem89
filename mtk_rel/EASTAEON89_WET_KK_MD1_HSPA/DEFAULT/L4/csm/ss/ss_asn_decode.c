/*******************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2007
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/
/****************************************************************************
 *
 *               Assignment : MTK ASN.1 Compiler
 *               CONFIDENTIAL
 *               Copyright (C) 2008 MTK Ltd. All rights reserved.
 *
 *****************************************************************************/
 /****************************************************************************
 *
 * COMPONENT:   TIME EFFICIENT -- BER	
 * MODULE:      ss_asn
 * DESCRIPTION: Autogenerated by MTK ASN.1 Compiler
 *
 ****************************************************************************/

/**
 * @file ss_asn_decode.c
 *
 */



#ifdef __AGPS_CONTROL_PLANE__

#include "applib2_asn_memory.h"
#include "applib2_asn_common.h"
#include "applib2_asn_ber_common.h"
#include "applib2_mtkasn_global.h"
#include "kal_general_types.h"
#include "string.h"
#include "setjmp.h"
#include "ss_asn.h"




/* OCTET STRING BearerServiceCode Ber decoder */
static void AsnDecode_SS2_BearerServiceCode( SS2_BearerServiceCode *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 1;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING Ext-BearerServiceCode Ber decoder */
static void AsnDecode_SS2_Ext_BearerServiceCode( SS2_Ext_BearerServiceCode *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 5;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING TBCD-STRING Ber decoder */
static void AsnDecode_SS2_TBCD_STRING( SS2_TBCD_STRING *pType, applib2_AsnContext *pContext)
{
   pType->stringData = NULL;
   pType->numOctets  = ber_get_octet_string(pContext, (U8 **)(&pType->stringData), pType->numOctets);
}

/* OCTET STRING AddressString Ber decoder */
static void AsnDecode_SS2_AddressString( SS2_AddressString *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 20;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* DEFINED ISDN-AddressString Ber decoder */
static void AsnDecode_SS2_ISDN_AddressString( SS2_ISDN_AddressString *pType, applib2_AsnContext *pContext)
{
   { 
      BER_TAG tag;
      tag.is_tagged = FALSE;
      ((void)tag); 

      AsnDecode_SS2_AddressString( pType, pContext);
   }
}

/* DEFINED FTN-AddressString Ber decoder */
static void AsnDecode_SS2_FTN_AddressString( SS2_FTN_AddressString *pType, applib2_AsnContext *pContext)
{
   { 
      BER_TAG tag;
      tag.is_tagged = FALSE;
      ((void)tag); 

      AsnDecode_SS2_AddressString( pType, pContext);
   }
}

/* OCTET STRING ISDN-SubaddressString Ber decoder */
static void AsnDecode_SS2_ISDN_SubaddressString( SS2_ISDN_SubaddressString *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 21;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING SignalInfo Ber decoder */
static void AsnDecode_SS2_SignalInfo( SS2_SignalInfo *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 200;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* ENUMERATED ProtocolId Ber decoder */
static void AsnDecode_SS2_ProtocolId( SS2_ProtocolId *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* ENUMERATED Ext-ProtocolId Ber decoder */
static void AsnDecode_SS2_Ext_ProtocolId( SS2_Ext_ProtocolId *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* OCTET STRING LongSignalInfo Ber decoder */
static void AsnDecode_SS2_LongSignalInfo( SS2_LongSignalInfo *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 2560;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* ENUMERATED AccessNetworkProtocolId Ber decoder */
static void AsnDecode_SS2_AccessNetworkProtocolId( SS2_AccessNetworkProtocolId *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* OCTET STRING AlertingPattern Ber decoder */
static void AsnDecode_SS2_AlertingPattern( SS2_AlertingPattern *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 1;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* DEFINED IMSI Ber decoder */
static void AsnDecode_SS2_IMSI( SS2_IMSI *pType, applib2_AsnContext *pContext)
{
   { 
      BER_TAG tag;
      tag.is_tagged = FALSE;
      ((void)tag); 

      AsnDecode_SS2_TBCD_STRING( pType, pContext);
   }
}

/* DEFINED ASCI-CallReference Ber decoder */
static void AsnDecode_SS2_ASCI_CallReference( SS2_ASCI_CallReference *pType, applib2_AsnContext *pContext)
{
   { 
      BER_TAG tag;
      tag.is_tagged = FALSE;
      ((void)tag); 

      AsnDecode_SS2_TBCD_STRING( pType, pContext);
   }
}

/* OCTET STRING TMSI Ber decoder */
static void AsnDecode_SS2_TMSI( SS2_TMSI *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 4;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* CHOICE SubscriberId Ber decoder */
extern U32 AsnDecode_SS2_SubscriberId( SS2_SubscriberId **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_SubscriberId *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_SubscriberId ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   {
      BER_TAG   pdu_tag;
      
      pre_get_t(pContext, &pdu_tag);
      
      if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 0) )
      {
         AsnDecode_SS2_IMSI( &pType->choice.imsi, pContext);
         
         pType->selection = SS2_SubscriberId_imsi_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 1) )
      {
         AsnDecode_SS2_TMSI( &pType->choice.tmsi, pContext);
         
         pType->selection = SS2_SubscriberId_tmsi_selected;
      }
   }
   

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* DEFINED IMEI Ber decoder */
static void AsnDecode_SS2_IMEI( SS2_IMEI *pType, applib2_AsnContext *pContext)
{
   { 
      BER_TAG tag;
      tag.is_tagged = FALSE;
      ((void)tag); 

      AsnDecode_SS2_TBCD_STRING( pType, pContext);
   }
}

/* DEFINED HLR-Id Ber decoder */
static void AsnDecode_SS2_HLR_Id( SS2_HLR_Id *pType, applib2_AsnContext *pContext)
{
   { 
      BER_TAG tag;
      tag.is_tagged = FALSE;
      ((void)tag); 

      AsnDecode_SS2_IMSI( pType, pContext);
   }
}

/* SET OF HLR-List Ber decoder */
static void AsnDecode_SS2_HLR_List( SS2_HLR_List *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_HLR_Id( &pType->element[i], pContext);
   }
}

/* OCTET STRING LMSI Ber decoder */
static void AsnDecode_SS2_LMSI( SS2_LMSI *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 4;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING GlobalCellId Ber decoder */
static void AsnDecode_SS2_GlobalCellId( SS2_GlobalCellId *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 7;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* ENUMERATED NetworkResource Ber decoder */
static void AsnDecode_SS2_NetworkResource( SS2_NetworkResource *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* ENUMERATED AdditionalNetworkResource Ber decoder */
static void AsnDecode_SS2_AdditionalNetworkResource( SS2_AdditionalNetworkResource *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* OCTET STRING NAEA-CIC Ber decoder */
static void AsnDecode_SS2_NAEA_CIC( SS2_NAEA_CIC *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 3;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* CHOICE SubscriberIdentity Ber decoder */
static void AsnDecode_SS2_SubscriberIdentity( SS2_SubscriberIdentity *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV		seq_tlv;
      pre_get_t(pContext, &seq_tlv.t);
      if(ContextSpecific == seq_tlv.t.cl && tag.is_tagged == TRUE)
         get_tl(pContext, &seq_tlv);
   }
   
   {
      BER_TAG   pdu_tag;
      
      pre_get_t(pContext, &pdu_tag);
      
      if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 0) )
      {
         AsnDecode_SS2_IMSI( &pType->choice.imsi, pContext);
         
         pType->selection = SS2_SubscriberIdentity_imsi_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 1) )
      {
         AsnDecode_SS2_ISDN_AddressString( &pType->choice.msisdn, pContext);
         
         pType->selection = SS2_SubscriberIdentity_msisdn_selected;
      }
   }
   
}

/* ENUMERATED LCSClientInternalID Ber decoder */
static void AsnDecode_SS2_LCSClientInternalID( SS2_LCSClientInternalID *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* OCTET STRING CellGlobalIdOrServiceAreaIdFixedLength Ber decoder */
static void AsnDecode_SS2_CellGlobalIdOrServiceAreaIdFixedLength( SS2_CellGlobalIdOrServiceAreaIdFixedLength *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 7;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING LAIFixedLength Ber decoder */
static void AsnDecode_SS2_LAIFixedLength( SS2_LAIFixedLength *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 5;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING Ext-SS-Status Ber decoder */
static void AsnDecode_SS2_Ext_SS_Status( SS2_Ext_SS_Status *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 5;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* ENUMERATED RoamingNotAllowedCause Ber decoder */
static void AsnDecode_SS2_RoamingNotAllowedCause( SS2_RoamingNotAllowedCause *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* ENUMERATED CallBarringCause Ber decoder */
static void AsnDecode_SS2_CallBarringCause( SS2_CallBarringCause *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* ENUMERATED CUG-RejectCause Ber decoder */
static void AsnDecode_SS2_CUG_RejectCause( SS2_CUG_RejectCause *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* ENUMERATED PW-RegistrationFailureCause Ber decoder */
extern U32 AsnDecode_SS2_PW_RegistrationFailureCause( SS2_PW_RegistrationFailureCause **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_PW_RegistrationFailureCause *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_PW_RegistrationFailureCause ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   *pType = ber_get_integer(pContext);

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* ENUMERATED SM-EnumeratedDeliveryFailureCause Ber decoder */
static void AsnDecode_SS2_SM_EnumeratedDeliveryFailureCause( SS2_SM_EnumeratedDeliveryFailureCause *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* ENUMERATED UnknownSubscriberDiagnostic Ber decoder */
static void AsnDecode_SS2_UnknownSubscriberDiagnostic( SS2_UnknownSubscriberDiagnostic *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* ENUMERATED AbsentSubscriberReason Ber decoder */
static void AsnDecode_SS2_AbsentSubscriberReason( SS2_AbsentSubscriberReason *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* SEQUENCE ShortTermDenialParam Ber decoder */
extern U32 AsnDecode_SS2_ShortTermDenialParam( SS2_ShortTermDenialParam **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_ShortTermDenialParam *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_ShortTermDenialParam ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE LongTermDenialParam Ber decoder */
extern U32 AsnDecode_SS2_LongTermDenialParam( SS2_LongTermDenialParam **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_LongTermDenialParam *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_LongTermDenialParam ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* ENUMERATED UnauthorizedLCSClient-Diagnostic Ber decoder */
static void AsnDecode_SS2_UnauthorizedLCSClient_Diagnostic( SS2_UnauthorizedLCSClient_Diagnostic *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* ENUMERATED PositionMethodFailure-Diagnostic Ber decoder */
static void AsnDecode_SS2_PositionMethodFailure_Diagnostic( SS2_PositionMethodFailure_Diagnostic *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* SEQUENCE PrivateExtension Ber decoder */
static void AsnDecode_SS2_PrivateExtension( SS2_PrivateExtension *pType, applib2_AsnContext *pContext)
{
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   }
}

/* SEQUENCE PCS-Extensions Ber decoder */
static void AsnDecode_SS2_PCS_Extensions( SS2_PCS_Extensions *pType, applib2_AsnContext *pContext)
{
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   }
}

/* SEQUENCE SLR-Arg-PCS-Extensions Ber decoder */
static void AsnDecode_SS2_SLR_Arg_PCS_Extensions( SS2_SLR_Arg_PCS_Extensions *pType, applib2_AsnContext *pContext)
{
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_SLR_Arg_PCS_Extensions_na_ESRK_Request_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* ENUMERATED LocationEstimateType Ber decoder */
static void AsnDecode_SS2_LocationEstimateType( SS2_LocationEstimateType *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* BIT STRING DeferredLocationEventType Ber decoder */
static void AsnDecode_SS2_DeferredLocationEventType( SS2_DeferredLocationEventType *pType, applib2_AsnContext *pContext)
{
   pType->numBits = 2;
   pType->numBits = ber_get_bit_string1(pContext, pType->stringData, pType->numBits);
}

/* ENUMERATED LCSClientType Ber decoder */
static void AsnDecode_SS2_LCSClientType( SS2_LCSClientType *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* ENUMERATED LCS-FormatIndicator Ber decoder */
static void AsnDecode_SS2_LCS_FormatIndicator( SS2_LCS_FormatIndicator *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* OCTET STRING LCS-Priority Ber decoder */
static void AsnDecode_SS2_LCS_Priority( SS2_LCS_Priority *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 1;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING Horizontal-Accuracy Ber decoder */
static void AsnDecode_SS2_Horizontal_Accuracy( SS2_Horizontal_Accuracy *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 1;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING Vertical-Accuracy Ber decoder */
static void AsnDecode_SS2_Vertical_Accuracy( SS2_Vertical_Accuracy *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 1;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* ENUMERATED ResponseTimeCategory Ber decoder */
static void AsnDecode_SS2_ResponseTimeCategory( SS2_ResponseTimeCategory *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* BIT STRING SupportedGADShapes Ber decoder */
static void AsnDecode_SS2_SupportedGADShapes( SS2_SupportedGADShapes *pType, applib2_AsnContext *pContext)
{
   pType->numBits = 2;
   pType->numBits = ber_get_bit_string1(pContext, pType->stringData, pType->numBits);
}

/* OCTET STRING LCS-ReferenceNumber Ber decoder */
static void AsnDecode_SS2_LCS_ReferenceNumber( SS2_LCS_ReferenceNumber *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 1;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* ENUMERATED PrivacyCheckRelatedAction Ber decoder */
static void AsnDecode_SS2_PrivacyCheckRelatedAction( SS2_PrivacyCheckRelatedAction *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* ENUMERATED AreaType Ber decoder */
static void AsnDecode_SS2_AreaType( SS2_AreaType *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* OCTET STRING AreaIdentification Ber decoder */
static void AsnDecode_SS2_AreaIdentification( SS2_AreaIdentification *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 7;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* ENUMERATED OccurrenceInfo Ber decoder */
static void AsnDecode_SS2_OccurrenceInfo( SS2_OccurrenceInfo *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* ENUMERATED AccuracyFulfilmentIndicator Ber decoder */
static void AsnDecode_SS2_AccuracyFulfilmentIndicator( SS2_AccuracyFulfilmentIndicator *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* OCTET STRING Ext-GeographicalInformation Ber decoder */
static void AsnDecode_SS2_Ext_GeographicalInformation( SS2_Ext_GeographicalInformation *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 20;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING PositioningDataInformation Ber decoder */
static void AsnDecode_SS2_PositioningDataInformation( SS2_PositioningDataInformation *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 10;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING UtranPositioningDataInfo Ber decoder */
static void AsnDecode_SS2_UtranPositioningDataInfo( SS2_UtranPositioningDataInfo *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 11;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING Add-GeographicalInformation Ber decoder */
static void AsnDecode_SS2_Add_GeographicalInformation( SS2_Add_GeographicalInformation *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 91;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* ENUMERATED LCS-Event Ber decoder */
static void AsnDecode_SS2_LCS_Event( SS2_LCS_Event *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* ENUMERATED TerminationCause Ber decoder */
static void AsnDecode_SS2_TerminationCause( SS2_TerminationCause *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* OCTET STRING AgeIndicator Ber decoder */
static void AsnDecode_SS2_AgeIndicator( SS2_AgeIndicator *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 6;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* ENUMERATED IST-SupportIndicator Ber decoder */
static void AsnDecode_SS2_IST_SupportIndicator( SS2_IST_SupportIndicator *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* BIT STRING SupportedLCS-CapabilitySets Ber decoder */
static void AsnDecode_SS2_SupportedLCS_CapabilitySets( SS2_SupportedLCS_CapabilitySets *pType, applib2_AsnContext *pContext)
{
   pType->numBits = 2;
   pType->numBits = ber_get_bit_string1(pContext, pType->stringData, pType->numBits);
}

/* SEQUENCE ADD-Info Ber decoder */
static void AsnDecode_SS2_ADD_Info( SS2_ADD_Info *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_IMEI( &pType->imeisv, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_ADD_Info_skipSubscriberDataUpdate_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* ENUMERATED CancellationType Ber decoder */
static void AsnDecode_SS2_CancellationType( SS2_CancellationType *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* OCTET STRING RAND Ber decoder */
static void AsnDecode_SS2_RAND( SS2_RAND *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 16;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING SRES Ber decoder */
static void AsnDecode_SS2_SRES( SS2_SRES *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 4;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING Kc Ber decoder */
static void AsnDecode_SS2_Kc( SS2_Kc *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 8;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING XRES Ber decoder */
static void AsnDecode_SS2_XRES( SS2_XRES *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 16;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING CK Ber decoder */
static void AsnDecode_SS2_CK( SS2_CK *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 16;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING IK Ber decoder */
static void AsnDecode_SS2_IK( SS2_IK *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 16;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING AUTN Ber decoder */
static void AsnDecode_SS2_AUTN( SS2_AUTN *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 16;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING AUTS Ber decoder */
static void AsnDecode_SS2_AUTS( SS2_AUTS *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 14;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING Cksn Ber decoder */
static void AsnDecode_SS2_Cksn( SS2_Cksn *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 1;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING KSI Ber decoder */
static void AsnDecode_SS2_KSI( SS2_KSI *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 1;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* ENUMERATED AccessType Ber decoder */
static void AsnDecode_SS2_AccessType( SS2_AccessType *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* ENUMERATED FailureCause Ber decoder */
static void AsnDecode_SS2_FailureCause( SS2_FailureCause *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* OCTET STRING GSN-Address Ber decoder */
static void AsnDecode_SS2_GSN_Address( SS2_GSN_Address *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 17;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING AllowedGSM-Algorithms Ber decoder */
static void AsnDecode_SS2_AllowedGSM_Algorithms( SS2_AllowedGSM_Algorithms *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 1;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING PermittedIntegrityProtectionAlgorithms Ber decoder */
static void AsnDecode_SS2_PermittedIntegrityProtectionAlgorithms( SS2_PermittedIntegrityProtectionAlgorithms *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 9;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING PermittedEncryptionAlgorithms Ber decoder */
static void AsnDecode_SS2_PermittedEncryptionAlgorithms( SS2_PermittedEncryptionAlgorithms *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 9;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* ENUMERATED KeyStatus Ber decoder */
static void AsnDecode_SS2_KeyStatus( SS2_KeyStatus *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* OCTET STRING BSSMAP-ServiceHandover Ber decoder */
static void AsnDecode_SS2_BSSMAP_ServiceHandover( SS2_BSSMAP_ServiceHandover *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 1;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING RANAP-ServiceHandover Ber decoder */
static void AsnDecode_SS2_RANAP_ServiceHandover( SS2_RANAP_ServiceHandover *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 1;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING ChosenIntegrityProtectionAlgorithm Ber decoder */
static void AsnDecode_SS2_ChosenIntegrityProtectionAlgorithm( SS2_ChosenIntegrityProtectionAlgorithm *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 1;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING ChosenEncryptionAlgorithm Ber decoder */
static void AsnDecode_SS2_ChosenEncryptionAlgorithm( SS2_ChosenEncryptionAlgorithm *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 1;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING ChosenChannelInfo Ber decoder */
static void AsnDecode_SS2_ChosenChannelInfo( SS2_ChosenChannelInfo *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 1;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING ChosenSpeechVersion Ber decoder */
static void AsnDecode_SS2_ChosenSpeechVersion( SS2_ChosenSpeechVersion *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 1;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING Codec Ber decoder */
static void AsnDecode_SS2_Codec( SS2_Codec *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 4;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING GERAN-Classmark Ber decoder */
static void AsnDecode_SS2_GERAN_Classmark( SS2_GERAN_Classmark *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 87;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING SelectedGSM-Algorithm Ber decoder */
static void AsnDecode_SS2_SelectedGSM_Algorithm( SS2_SelectedGSM_Algorithm *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 1;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING RNCId Ber decoder */
static void AsnDecode_SS2_RNCId( SS2_RNCId *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 7;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING RadioResourceInformation Ber decoder */
static void AsnDecode_SS2_RadioResourceInformation( SS2_RadioResourceInformation *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 13;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING IntegrityProtectionInformation Ber decoder */
static void AsnDecode_SS2_IntegrityProtectionInformation( SS2_IntegrityProtectionInformation *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 100;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING EncryptionInformation Ber decoder */
static void AsnDecode_SS2_EncryptionInformation( SS2_EncryptionInformation *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 100;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING PLMN-Id Ber decoder */
static void AsnDecode_SS2_PLMN_Id( SS2_PLMN_Id *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 3;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* SEQUENCE Re-synchronisationInfo Ber decoder */
static void AsnDecode_SS2_Re_synchronisationInfo( SS2_Re_synchronisationInfo *pType, applib2_AsnContext *pContext)
{
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_RAND( &pType->rand, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_AUTS( &pType->auts, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* ENUMERATED RequestingNodeType Ber decoder */
static void AsnDecode_SS2_RequestingNodeType( SS2_RequestingNodeType *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* BIT STRING RequestedEquipmentInfo Ber decoder */
static void AsnDecode_SS2_RequestedEquipmentInfo( SS2_RequestedEquipmentInfo *pType, applib2_AsnContext *pContext)
{
   pType->numBits = 1;
   pType->numBits = ber_get_bit_string1(pContext, pType->stringData, pType->numBits);
}

/* BIT STRING UESBI-IuA Ber decoder */
static void AsnDecode_SS2_UESBI_IuA( SS2_UESBI_IuA *pType, applib2_AsnContext *pContext)
{
   pType->numBits = 16;
   pType->numBits = ber_get_bit_string1(pContext, pType->stringData, pType->numBits);
}

/* BIT STRING UESBI-IuB Ber decoder */
static void AsnDecode_SS2_UESBI_IuB( SS2_UESBI_IuB *pType, applib2_AsnContext *pContext)
{
   pType->numBits = 16;
   pType->numBits = ber_get_bit_string1(pContext, pType->stringData, pType->numBits);
}

/* ENUMERATED EquipmentStatus Ber decoder */
static void AsnDecode_SS2_EquipmentStatus( SS2_EquipmentStatus *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* BIT STRING AccessRestrictionData Ber decoder */
static void AsnDecode_SS2_AccessRestrictionData( SS2_AccessRestrictionData *pType, applib2_AsnContext *pContext)
{
   pType->numBits = 1;
   pType->numBits = ber_get_bit_string1(pContext, pType->stringData, pType->numBits);
}

/* OCTET STRING CS-AllocationRetentionPriority Ber decoder */
static void AsnDecode_SS2_CS_AllocationRetentionPriority( SS2_CS_AllocationRetentionPriority *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 1;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* SET OF GMLC-List Ber decoder */
static void AsnDecode_SS2_GMLC_List( SS2_GMLC_List *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_ISDN_AddressString( &pType->element[i], pContext);
   }
}

/* ENUMERATED NetworkAccessMode Ber decoder */
static void AsnDecode_SS2_NetworkAccessMode( SS2_NetworkAccessMode *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* ENUMERATED DefaultGPRS-Handling Ber decoder */
static void AsnDecode_SS2_DefaultGPRS_Handling( SS2_DefaultGPRS_Handling *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* ENUMERATED GPRS-TriggerDetectionPoint Ber decoder */
static void AsnDecode_SS2_GPRS_TriggerDetectionPoint( SS2_GPRS_TriggerDetectionPoint *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* OCTET STRING APN Ber decoder */
static void AsnDecode_SS2_APN( SS2_APN *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 63;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING PDP-Type Ber decoder */
static void AsnDecode_SS2_PDP_Type( SS2_PDP_Type *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 2;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING PDP-Address Ber decoder */
static void AsnDecode_SS2_PDP_Address( SS2_PDP_Address *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 16;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING QoS-Subscribed Ber decoder */
static void AsnDecode_SS2_QoS_Subscribed( SS2_QoS_Subscribed *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 3;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING Ext-QoS-Subscribed Ber decoder */
static void AsnDecode_SS2_Ext_QoS_Subscribed( SS2_Ext_QoS_Subscribed *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 9;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING Ext2-QoS-Subscribed Ber decoder */
static void AsnDecode_SS2_Ext2_QoS_Subscribed( SS2_Ext2_QoS_Subscribed *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 3;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING ChargingCharacteristics Ber decoder */
static void AsnDecode_SS2_ChargingCharacteristics( SS2_ChargingCharacteristics *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 2;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* ENUMERATED LSAOnlyAccessIndicator Ber decoder */
static void AsnDecode_SS2_LSAOnlyAccessIndicator( SS2_LSAOnlyAccessIndicator *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* OCTET STRING LSAIdentity Ber decoder */
static void AsnDecode_SS2_LSAIdentity( SS2_LSAIdentity *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 3;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING LSAAttributes Ber decoder */
static void AsnDecode_SS2_LSAAttributes( SS2_LSAAttributes *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 1;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING Category Ber decoder */
static void AsnDecode_SS2_Category( SS2_Category *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 1;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* ENUMERATED SubscriberStatus Ber decoder */
static void AsnDecode_SS2_SubscriberStatus( SS2_SubscriberStatus *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* SET OF BearerServiceList Ber decoder */
static void AsnDecode_SS2_BearerServiceList( SS2_BearerServiceList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_Ext_BearerServiceCode( &pType->element[i], pContext);
   }
}

/* BIT STRING ODB-GeneralData Ber decoder */
static void AsnDecode_SS2_ODB_GeneralData( SS2_ODB_GeneralData *pType, applib2_AsnContext *pContext)
{
   pType->numBits = 4;
   pType->numBits = ber_get_bit_string1(pContext, pType->stringData, pType->numBits);
}

/* BIT STRING ODB-HPLMN-Data Ber decoder */
static void AsnDecode_SS2_ODB_HPLMN_Data( SS2_ODB_HPLMN_Data *pType, applib2_AsnContext *pContext)
{
   pType->numBits = 4;
   pType->numBits = ber_get_bit_string1(pContext, pType->stringData, pType->numBits);
}

/* OCTET STRING Ext-ForwOptions Ber decoder */
static void AsnDecode_SS2_Ext_ForwOptions( SS2_Ext_ForwOptions *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 5;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING CUG-Interlock Ber decoder */
static void AsnDecode_SS2_CUG_Interlock( SS2_CUG_Interlock *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 4;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* ENUMERATED IntraCUG-Options Ber decoder */
static void AsnDecode_SS2_IntraCUG_Options( SS2_IntraCUG_Options *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* OCTET STRING InterCUG-Restrictions Ber decoder */
static void AsnDecode_SS2_InterCUG_Restrictions( SS2_InterCUG_Restrictions *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 1;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* SET OF PLMNClientList Ber decoder */
static void AsnDecode_SS2_PLMNClientList( SS2_PLMNClientList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_LCSClientInternalID( &pType->element[i], pContext);
   }
}

/* ENUMERATED GMLC-Restriction Ber decoder */
static void AsnDecode_SS2_GMLC_Restriction( SS2_GMLC_Restriction *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* ENUMERATED NotificationToMSUser Ber decoder */
static void AsnDecode_SS2_NotificationToMSUser( SS2_NotificationToMSUser *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* OCTET STRING ZoneCode Ber decoder */
static void AsnDecode_SS2_ZoneCode( SS2_ZoneCode *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 2;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* ENUMERATED RegionalSubscriptionResponse Ber decoder */
static void AsnDecode_SS2_RegionalSubscriptionResponse( SS2_RegionalSubscriptionResponse *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* BIT STRING SpecificCSI-Withdraw Ber decoder */
static void AsnDecode_SS2_SpecificCSI_Withdraw( SS2_SpecificCSI_Withdraw *pType, applib2_AsnContext *pContext)
{
   pType->numBits = 4;
   pType->numBits = ber_get_bit_string1(pContext, pType->stringData, pType->numBits);
}

/* SET OF ContextIdList Ber decoder */
static void AsnDecode_SS2_ContextIdList( SS2_ContextIdList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      pType->element[i] = (U8)ber_get_integer( pContext ); 
   }
}

/* SET OF LSAIdentityList Ber decoder */
static void AsnDecode_SS2_LSAIdentityList( SS2_LSAIdentityList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_LSAIdentity( &pType->element[i], pContext);
   }
}

/* ENUMERATED MT-SMS-TPDU-Type Ber decoder */
static void AsnDecode_SS2_MT_SMS_TPDU_Type( SS2_MT_SMS_TPDU_Type *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* ENUMERATED O-BcsmTriggerDetectionPoint Ber decoder */
static void AsnDecode_SS2_O_BcsmTriggerDetectionPoint( SS2_O_BcsmTriggerDetectionPoint *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* SET OF DestinationNumberList Ber decoder */
static void AsnDecode_SS2_DestinationNumberList( SS2_DestinationNumberList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_ISDN_AddressString( &pType->element[i], pContext);
   }
}

/* SET OF DestinationNumberLengthList Ber decoder */
static void AsnDecode_SS2_DestinationNumberLengthList( SS2_DestinationNumberLengthList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      pType->element[i] = (U8)ber_get_integer( pContext ); 
   }
}

/* ENUMERATED CallTypeCriteria Ber decoder */
static void AsnDecode_SS2_CallTypeCriteria( SS2_CallTypeCriteria *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* ENUMERATED MatchType Ber decoder */
static void AsnDecode_SS2_MatchType( SS2_MatchType *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* OCTET STRING CauseValue Ber decoder */
static void AsnDecode_SS2_CauseValue( SS2_CauseValue *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 1;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* ENUMERATED DefaultCallHandling Ber decoder */
static void AsnDecode_SS2_DefaultCallHandling( SS2_DefaultCallHandling *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* BIT STRING SupportedCamelPhases Ber decoder */
static void AsnDecode_SS2_SupportedCamelPhases( SS2_SupportedCamelPhases *pType, applib2_AsnContext *pContext)
{
   pType->numBits = 2;
   pType->numBits = ber_get_bit_string1(pContext, pType->stringData, pType->numBits);
}

/* BIT STRING OfferedCamel4CSIs Ber decoder */
static void AsnDecode_SS2_OfferedCamel4CSIs( SS2_OfferedCamel4CSIs *pType, applib2_AsnContext *pContext)
{
   pType->numBits = 2;
   pType->numBits = ber_get_bit_string1(pContext, pType->stringData, pType->numBits);
}

/* BIT STRING OfferedCamel4Functionalities Ber decoder */
static void AsnDecode_SS2_OfferedCamel4Functionalities( SS2_OfferedCamel4Functionalities *pType, applib2_AsnContext *pContext)
{
   pType->numBits = 8;
   pType->numBits = ber_get_bit_string1(pContext, pType->stringData, pType->numBits);
}

/* ENUMERATED SMS-TriggerDetectionPoint Ber decoder */
static void AsnDecode_SS2_SMS_TriggerDetectionPoint( SS2_SMS_TriggerDetectionPoint *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* ENUMERATED DefaultSMS-Handling Ber decoder */
static void AsnDecode_SS2_DefaultSMS_Handling( SS2_DefaultSMS_Handling *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* OCTET STRING MM-Code Ber decoder */
static void AsnDecode_SS2_MM_Code( SS2_MM_Code *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 1;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* ENUMERATED T-BcsmTriggerDetectionPoint Ber decoder */
static void AsnDecode_SS2_T_BcsmTriggerDetectionPoint( SS2_T_BcsmTriggerDetectionPoint *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* SEQUENCE ResetArg Ber decoder */
extern U32 AsnDecode_SS2_ResetArg( SS2_ResetArg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_ResetArg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_ResetArg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->hlr_Number, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_HLR_List( &pType->hlr_List, pContext);
            pType->validity |= SS2_ResetArg_hlr_List_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* DEFINED GroupId Ber decoder */
static void AsnDecode_SS2_GroupId( SS2_GroupId *pType, applib2_AsnContext *pContext)
{
   { 
      BER_TAG tag;
      tag.is_tagged = FALSE;
      ((void)tag); 

      AsnDecode_SS2_TBCD_STRING( pType, pContext);
   }
}

/* DEFINED RouteingNumber Ber decoder */
static void AsnDecode_SS2_RouteingNumber( SS2_RouteingNumber *pType, applib2_AsnContext *pContext)
{
   { 
      BER_TAG tag;
      tag.is_tagged = FALSE;
      ((void)tag); 

      AsnDecode_SS2_TBCD_STRING( pType, pContext);
   }
}

/* ENUMERATED NumberPortabilityStatus Ber decoder */
static void AsnDecode_SS2_NumberPortabilityStatus( SS2_NumberPortabilityStatus *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* OCTET STRING MS-Classmark2 Ber decoder */
static void AsnDecode_SS2_MS_Classmark2( SS2_MS_Classmark2 *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 3;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING MSNetworkCapability Ber decoder */
static void AsnDecode_SS2_MSNetworkCapability( SS2_MSNetworkCapability *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 8;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING MSRadioAccessCapability Ber decoder */
static void AsnDecode_SS2_MSRadioAccessCapability( SS2_MSRadioAccessCapability *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 50;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* ENUMERATED DomainType Ber decoder */
static void AsnDecode_SS2_DomainType( SS2_DomainType *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* OCTET STRING RAIdentity Ber decoder */
static void AsnDecode_SS2_RAIdentity( SS2_RAIdentity *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 6;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING GeographicalInformation Ber decoder */
static void AsnDecode_SS2_GeographicalInformation( SS2_GeographicalInformation *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 8;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING GeodeticInformation Ber decoder */
static void AsnDecode_SS2_GeodeticInformation( SS2_GeodeticInformation *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 10;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING LocationNumber Ber decoder */
static void AsnDecode_SS2_LocationNumber( SS2_LocationNumber *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 10;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING TransactionId Ber decoder */
static void AsnDecode_SS2_TransactionId( SS2_TransactionId *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 2;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING TEID Ber decoder */
static void AsnDecode_SS2_TEID( SS2_TEID *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 4;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING GPRSChargingID Ber decoder */
static void AsnDecode_SS2_GPRSChargingID( SS2_GPRSChargingID *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 4;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* ENUMERATED NotReachableReason Ber decoder */
static void AsnDecode_SS2_NotReachableReason( SS2_NotReachableReason *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* ENUMERATED RequestedCAMEL-SubscriptionInfo Ber decoder */
static void AsnDecode_SS2_RequestedCAMEL_SubscriptionInfo( SS2_RequestedCAMEL_SubscriptionInfo *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* ENUMERATED AdditionalRequestedCAMEL-SubscriptionInfo Ber decoder */
static void AsnDecode_SS2_AdditionalRequestedCAMEL_SubscriptionInfo( SS2_AdditionalRequestedCAMEL_SubscriptionInfo *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* ENUMERATED ModificationInstruction Ber decoder */
static void AsnDecode_SS2_ModificationInstruction( SS2_ModificationInstruction *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* OCTET STRING TraceReference Ber decoder */
static void AsnDecode_SS2_TraceReference( SS2_TraceReference *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 2;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING TraceReference2 Ber decoder */
static void AsnDecode_SS2_TraceReference2( SS2_TraceReference2 *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 3;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING TraceRecordingSessionReference Ber decoder */
static void AsnDecode_SS2_TraceRecordingSessionReference( SS2_TraceRecordingSessionReference *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 2;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* ENUMERATED TraceDepth Ber decoder */
static void AsnDecode_SS2_TraceDepth( SS2_TraceDepth *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* BIT STRING TraceNE-TypeList Ber decoder */
static void AsnDecode_SS2_TraceNE_TypeList( SS2_TraceNE_TypeList *pType, applib2_AsnContext *pContext)
{
   pType->numBits = 2;
   pType->numBits = ber_get_bit_string1(pContext, pType->stringData, pType->numBits);
}

/* BIT STRING MSC-S-InterfaceList Ber decoder */
static void AsnDecode_SS2_MSC_S_InterfaceList( SS2_MSC_S_InterfaceList *pType, applib2_AsnContext *pContext)
{
   pType->numBits = 2;
   pType->numBits = ber_get_bit_string1(pContext, pType->stringData, pType->numBits);
}

/* BIT STRING MGW-InterfaceList Ber decoder */
static void AsnDecode_SS2_MGW_InterfaceList( SS2_MGW_InterfaceList *pType, applib2_AsnContext *pContext)
{
   pType->numBits = 1;
   pType->numBits = ber_get_bit_string1(pContext, pType->stringData, pType->numBits);
}

/* BIT STRING SGSN-InterfaceList Ber decoder */
static void AsnDecode_SS2_SGSN_InterfaceList( SS2_SGSN_InterfaceList *pType, applib2_AsnContext *pContext)
{
   pType->numBits = 2;
   pType->numBits = ber_get_bit_string1(pContext, pType->stringData, pType->numBits);
}

/* BIT STRING GGSN-InterfaceList Ber decoder */
static void AsnDecode_SS2_GGSN_InterfaceList( SS2_GGSN_InterfaceList *pType, applib2_AsnContext *pContext)
{
   pType->numBits = 1;
   pType->numBits = ber_get_bit_string1(pContext, pType->stringData, pType->numBits);
}

/* BIT STRING RNC-InterfaceList Ber decoder */
static void AsnDecode_SS2_RNC_InterfaceList( SS2_RNC_InterfaceList *pType, applib2_AsnContext *pContext)
{
   pType->numBits = 1;
   pType->numBits = ber_get_bit_string1(pContext, pType->stringData, pType->numBits);
}

/* BIT STRING BMSC-InterfaceList Ber decoder */
static void AsnDecode_SS2_BMSC_InterfaceList( SS2_BMSC_InterfaceList *pType, applib2_AsnContext *pContext)
{
   pType->numBits = 1;
   pType->numBits = ber_get_bit_string1(pContext, pType->stringData, pType->numBits);
}

/* BIT STRING MSC-S-EventList Ber decoder */
static void AsnDecode_SS2_MSC_S_EventList( SS2_MSC_S_EventList *pType, applib2_AsnContext *pContext)
{
   pType->numBits = 2;
   pType->numBits = ber_get_bit_string1(pContext, pType->stringData, pType->numBits);
}

/* BIT STRING MGW-EventList Ber decoder */
static void AsnDecode_SS2_MGW_EventList( SS2_MGW_EventList *pType, applib2_AsnContext *pContext)
{
   pType->numBits = 1;
   pType->numBits = ber_get_bit_string1(pContext, pType->stringData, pType->numBits);
}

/* BIT STRING SGSN-EventList Ber decoder */
static void AsnDecode_SS2_SGSN_EventList( SS2_SGSN_EventList *pType, applib2_AsnContext *pContext)
{
   pType->numBits = 2;
   pType->numBits = ber_get_bit_string1(pContext, pType->stringData, pType->numBits);
}

/* BIT STRING GGSN-EventList Ber decoder */
static void AsnDecode_SS2_GGSN_EventList( SS2_GGSN_EventList *pType, applib2_AsnContext *pContext)
{
   pType->numBits = 1;
   pType->numBits = ber_get_bit_string1(pContext, pType->stringData, pType->numBits);
}

/* BIT STRING BMSC-EventList Ber decoder */
static void AsnDecode_SS2_BMSC_EventList( SS2_BMSC_EventList *pType, applib2_AsnContext *pContext)
{
   pType->numBits = 1;
   pType->numBits = ber_get_bit_string1(pContext, pType->stringData, pType->numBits);
}

/* SEQUENCE TracePropagationList Ber decoder */
static void AsnDecode_SS2_TracePropagationList( SS2_TracePropagationList *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_TraceReference( &pType->traceReference, pContext);
            pType->validity |= SS2_TracePropagationList_traceReference_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->traceType = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_TracePropagationList_traceType_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_TraceReference2( &pType->traceReference2, pContext);
            pType->validity |= SS2_TracePropagationList_traceReference2_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_TraceRecordingSessionReference( &pType->traceRecordingSessionReference, pContext);
            pType->validity |= SS2_TracePropagationList_traceRecordingSessionReference_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_TraceDepth( &pType->rnc_TraceDepth, pContext);
            pType->validity |= SS2_TracePropagationList_rnc_TraceDepth_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_RNC_InterfaceList( &pType->rnc_InterfaceList, pContext);
            pType->validity |= SS2_TracePropagationList_rnc_InterfaceList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_TraceDepth( &pType->msc_s_TraceDepth, pContext);
            pType->validity |= SS2_TracePropagationList_msc_s_TraceDepth_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 7;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_MSC_S_InterfaceList( &pType->msc_s_InterfaceList, pContext);
            pType->validity |= SS2_TracePropagationList_msc_s_InterfaceList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 8;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_MSC_S_EventList( &pType->msc_s_EventList, pContext);
            pType->validity |= SS2_TracePropagationList_msc_s_EventList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 9;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_TraceDepth( &pType->mgw_TraceDepth, pContext);
            pType->validity |= SS2_TracePropagationList_mgw_TraceDepth_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_MGW_InterfaceList( &pType->mgw_InterfaceList, pContext);
            pType->validity |= SS2_TracePropagationList_mgw_InterfaceList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 11;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_MGW_EventList( &pType->mgw_EventList, pContext);
            pType->validity |= SS2_TracePropagationList_mgw_EventList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* OCTET STRING SM-RP-SMEA Ber decoder */
static void AsnDecode_SS2_SM_RP_SMEA( SS2_SM_RP_SMEA *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 12;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* CHOICE Additional-Number Ber decoder */
static void AsnDecode_SS2_Additional_Number( SS2_Additional_Number *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV		seq_tlv;
      pre_get_t(pContext, &seq_tlv.t);
      if(ContextSpecific == seq_tlv.t.cl && tag.is_tagged == TRUE)
         get_tl(pContext, &seq_tlv);
   }
   
   {
      BER_TAG   pdu_tag;
      
      pre_get_t(pContext, &pdu_tag);
      
      if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 0) )
      {
         AsnDecode_SS2_ISDN_AddressString( &pType->choice.msc_Number, pContext);
         
         pType->selection = SS2_Additional_Number_msc_Number_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 1) )
      {
         AsnDecode_SS2_ISDN_AddressString( &pType->choice.sgsn_Number, pContext);
         
         pType->selection = SS2_Additional_Number_sgsn_Number_selected;
      }
   }
   
}

/* CHOICE SM-RP-DA Ber decoder */
static void AsnDecode_SS2_SM_RP_DA( SS2_SM_RP_DA *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV		seq_tlv;
      pre_get_t(pContext, &seq_tlv.t);
      if(ContextSpecific == seq_tlv.t.cl && tag.is_tagged == TRUE)
         get_tl(pContext, &seq_tlv);
   }
   
   {
      BER_TAG   pdu_tag;
      
      pre_get_t(pContext, &pdu_tag);
      
      if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 0) )
      {
         AsnDecode_SS2_IMSI( &pType->choice.imsi, pContext);
         
         pType->selection = SS2_SM_RP_DA_imsi_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 1) )
      {
         AsnDecode_SS2_LMSI( &pType->choice.lmsi, pContext);
         
         pType->selection = SS2_SM_RP_DA_lmsi_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 4) )
      {
         AsnDecode_SS2_AddressString( &pType->choice.serviceCentreAddressDA, pContext);
         
         pType->selection = SS2_SM_RP_DA_serviceCentreAddressDA_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 5) )
      {
         {
            BER_TLV tlv; 
            get_tl( pContext, &tlv ); 
            /* without value */ 
         }
         
         pType->selection = SS2_SM_RP_DA_noSM_RP_DA_selected;
      }
   }
   
}

/* CHOICE SM-RP-OA Ber decoder */
static void AsnDecode_SS2_SM_RP_OA( SS2_SM_RP_OA *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV		seq_tlv;
      pre_get_t(pContext, &seq_tlv.t);
      if(ContextSpecific == seq_tlv.t.cl && tag.is_tagged == TRUE)
         get_tl(pContext, &seq_tlv);
   }
   
   {
      BER_TAG   pdu_tag;
      
      pre_get_t(pContext, &pdu_tag);
      
      if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 2) )
      {
         AsnDecode_SS2_ISDN_AddressString( &pType->choice.msisdn, pContext);
         
         pType->selection = SS2_SM_RP_OA_msisdn_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 4) )
      {
         AsnDecode_SS2_AddressString( &pType->choice.serviceCentreAddressOA, pContext);
         
         pType->selection = SS2_SM_RP_OA_serviceCentreAddressOA_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 5) )
      {
         {
            BER_TLV tlv; 
            get_tl( pContext, &tlv ); 
            /* without value */ 
         }
         
         pType->selection = SS2_SM_RP_OA_noSM_RP_OA_selected;
      }
   }
   
}

/* ENUMERATED SM-DeliveryOutcome Ber decoder */
static void AsnDecode_SS2_SM_DeliveryOutcome( SS2_SM_DeliveryOutcome *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* SEQUENCE AlertServiceCentreArg Ber decoder */
extern U32 AsnDecode_SS2_AlertServiceCentreArg( SS2_AlertServiceCentreArg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_AlertServiceCentreArg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_AlertServiceCentreArg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->msisdn, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_AddressString( &pType->serviceCentreAddress, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* BIT STRING MW-Status Ber decoder */
static void AsnDecode_SS2_MW_Status( SS2_MW_Status *pType, applib2_AsnContext *pContext)
{
   pType->numBits = 2;
   pType->numBits = ber_get_bit_string1(pContext, pType->stringData, pType->numBits);
}

/* ENUMERATED AlertReason Ber decoder */
static void AsnDecode_SS2_AlertReason( SS2_AlertReason *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* OCTET STRING SS-Code Ber decoder */
static void AsnDecode_SS2_SS_Code( SS2_SS_Code *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 1;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING SS-Status Ber decoder */
static void AsnDecode_SS2_SS_Status( SS2_SS_Status *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 1;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING ForwardingOptions Ber decoder */
static void AsnDecode_SS2_ForwardingOptions( SS2_ForwardingOptions *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 1;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* ENUMERATED CliRestrictionOption Ber decoder */
static void AsnDecode_SS2_CliRestrictionOption( SS2_CliRestrictionOption *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* ENUMERATED OverrideCategory Ber decoder */
static void AsnDecode_SS2_OverrideCategory( SS2_OverrideCategory *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* OCTET STRING USSD-DataCodingScheme Ber decoder */
static void AsnDecode_SS2_USSD_DataCodingScheme( SS2_USSD_DataCodingScheme *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 1;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING USSD-String Ber decoder */
static void AsnDecode_SS2_USSD_String( SS2_USSD_String *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 160;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* NUMERIC STRING Password Ber decoder */
static void AsnDecode_SS2_Password( SS2_Password *pType, applib2_AsnContext *pContext)
{
   ber_get_string(pContext, (U8 **)&pType->value, &pType->valueLen);
}

/* ENUMERATED GuidanceInfo Ber decoder */
extern U32 AsnDecode_SS2_GuidanceInfo( SS2_GuidanceInfo **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_GuidanceInfo *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_GuidanceInfo ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   *pType = ber_get_integer(pContext);

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SET OF SS-List Ber decoder */
static void AsnDecode_SS2_SS_List( SS2_SS_List *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_SS_Code( &pType->element[i], pContext);
   }
}

/* ENUMERATED CCBS-RequestState Ber decoder */
static void AsnDecode_SS2_CCBS_RequestState( SS2_CCBS_RequestState *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* SET OF SS-EventSpecification Ber decoder */
static void AsnDecode_SS2_SS_EventSpecification( SS2_SS_EventSpecification *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_AddressString( &pType->element[i], pContext);
   }
}

/* BIT STRING ServiceIndicator Ber decoder */
static void AsnDecode_SS2_ServiceIndicator( SS2_ServiceIndicator *pType, applib2_AsnContext *pContext)
{
   pType->numBits = 4;
   pType->numBits = ber_get_bit_string1(pContext, pType->stringData, pType->numBits);
}

/* SEQUENCE EraseCC-EntryArg Ber decoder */
extern U32 AsnDecode_SS2_EraseCC_EntryArg( SS2_EraseCC_EntryArg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_EraseCC_EntryArg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_EraseCC_EntryArg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SS_Code( &pType->ss_Code, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->ccbs_Index = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_EraseCC_EntryArg_ccbs_Index_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE EraseCC-EntryRes Ber decoder */
extern U32 AsnDecode_SS2_EraseCC_EntryRes( SS2_EraseCC_EntryRes **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_EraseCC_EntryRes *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_EraseCC_EntryRes ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SS_Code( &pType->ss_Code, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SS_Status( &pType->ss_Status, pContext);
            pType->validity |= SS2_EraseCC_EntryRes_ss_Status_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* OCTET STRING TeleserviceCode Ber decoder */
static void AsnDecode_SS2_TeleserviceCode( SS2_TeleserviceCode *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 1;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING Ext-TeleserviceCode Ber decoder */
static void AsnDecode_SS2_Ext_TeleserviceCode( SS2_Ext_TeleserviceCode *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 5;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* INTEGER RejectProblem Ber decoder */
extern U32 AsnDecode_SS2_RejectProblem( SS2_RejectProblem **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_RejectProblem *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_RejectProblem ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   *pType = (S32)ber_get_integer( pContext ); 

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* CHOICE Code Ber decoder */
extern U32 AsnDecode_SS2_Code( SS2_Code **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_Code *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_Code ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   {
      BER_TAG   pdu_tag;
      
      pre_get_t(pContext, &pdu_tag);
      
      if( (pdu_tag.cl == Universal) && (pdu_tag.tag == 2) )
      {
         pType->choice.local = (S32)ber_get_integer( pContext ); 
         
         pType->selection = SS2_Code_local_selected;
      }
      else if( (pdu_tag.cl == Universal) && (pdu_tag.tag == 6) )
      {
         ber_get_oid(pContext, &pType->choice.global);
         
         pType->selection = SS2_Code_global_selected;
      }
   }
   

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* INTEGER Priority Ber decoder */
extern U32 AsnDecode_SS2_Priority( SS2_Priority **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_Priority *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_Priority ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   *pType = (U32)ber_get_integer( pContext ); 

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* IA5 STRING SS-UserData Ber decoder */
extern U32 AsnDecode_SS2_SS_UserData( SS2_SS_UserData **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_SS_UserData *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_SS_UserData ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   ber_get_string(pContext, (U8 **)&pType->value, &pType->valueLen);

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* ENUMERATED Multicall-Indicator Ber decoder */
extern U32 AsnDecode_SS2_Multicall_Indicator( SS2_Multicall_Indicator **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_Multicall_Indicator *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_Multicall_Indicator ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   *pType = ber_get_integer(pContext);

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* OCTET STRING SS-Notification Ber decoder */
extern U32 AsnDecode_SS2_SS_Notification( SS2_SS_Notification **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_SS_Notification *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_SS_Notification ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   pType->numOctets = 1;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* ENUMERATED CallOnHold-Indicator Ber decoder */
extern U32 AsnDecode_SS2_CallOnHold_Indicator( SS2_CallOnHold_Indicator **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_CallOnHold_Indicator *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_CallOnHold_Indicator ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   *pType = ber_get_integer(pContext);

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE ForwardCUG-InfoArg Ber decoder */
extern U32 AsnDecode_SS2_ForwardCUG_InfoArg( SS2_ForwardCUG_InfoArg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_ForwardCUG_InfoArg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_ForwardCUG_InfoArg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->cug_Index = (U16)ber_get_integer( pContext ); 
            pType->validity |= SS2_ForwardCUG_InfoArg_cug_Index_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_ForwardCUG_InfoArg_suppressPrefCUG_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_ForwardCUG_InfoArg_suppressOA_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* ENUMERATED ECT-CallState Ber decoder */
static void AsnDecode_SS2_ECT_CallState( SS2_ECT_CallState *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* SEQUENCE NameSet Ber decoder */
static void AsnDecode_SS2_NameSet( SS2_NameSet *pType, applib2_AsnContext *pContext)
{
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_USSD_DataCodingScheme( &pType->dataCodingScheme, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->lengthInCharacters = (S32)ber_get_integer( pContext ); 
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_USSD_String( &pType->nameString, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE RemotePartyNumber Ber decoder */
static void AsnDecode_SS2_RemotePartyNumber( SS2_RemotePartyNumber *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->partyNumber, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_SubaddressString( &pType->partyNumberSubaddress, pContext);
            pType->validity |= SS2_RemotePartyNumber_partyNumberSubaddress_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE AccessRegisterCCEntryArg Ber decoder */
extern U32 AsnDecode_SS2_AccessRegisterCCEntryArg( SS2_AccessRegisterCCEntryArg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_AccessRegisterCCEntryArg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_AccessRegisterCCEntryArg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE CallDeflectionArg Ber decoder */
extern U32 AsnDecode_SS2_CallDeflectionArg( SS2_CallDeflectionArg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_CallDeflectionArg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_CallDeflectionArg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_AddressString( &pType->deflectedToNumber, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_SubaddressString( &pType->deflectedToSubaddress, pContext);
            pType->validity |= SS2_CallDeflectionArg_deflectedToSubaddress_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* ENUMERATED UUS-Service Ber decoder */
static void AsnDecode_SS2_UUS_Service( SS2_UUS_Service *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* ENUMERATED VerificationResponse Ber decoder */
static void AsnDecode_SS2_VerificationResponse( SS2_VerificationResponse *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* ENUMERATED MOLR-Type Ber decoder */
static void AsnDecode_SS2_MOLR_Type( SS2_MOLR_Type *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* ENUMERATED LocationMethod Ber decoder */
static void AsnDecode_SS2_LocationMethod( SS2_LocationMethod *pType, applib2_AsnContext *pContext)
{
   *pType = ber_get_integer(pContext);
}

/* OCTET STRING GPSAssistanceData Ber decoder */
static void AsnDecode_SS2_GPSAssistanceData( SS2_GPSAssistanceData *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 38;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* OCTET STRING DecipheringKeys Ber decoder */
static void AsnDecode_SS2_DecipheringKeys( SS2_DecipheringKeys *pType, applib2_AsnContext *pContext)
{
   pType->numOctets = 15;
   pType->numOctets  = ber_get_octet_string1(pContext,  pType->stringData, pType->numOctets);
}

/* SEQUENCE LCS-AreaEventReportArg Ber decoder */
extern U32 AsnDecode_SS2_LCS_AreaEventReportArg( SS2_LCS_AreaEventReportArg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_LCS_AreaEventReportArg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_LCS_AreaEventReportArg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LCS_ReferenceNumber( &pType->referenceNumber, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GSN_Address( &pType->h_gmlc_address, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GSN_Address( &pType->r_gmlc_address, pContext);
            pType->validity |= SS2_LCS_AreaEventReportArg_r_gmlc_address_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE LCS-AreaEventCancellationArg Ber decoder */
extern U32 AsnDecode_SS2_LCS_AreaEventCancellationArg( SS2_LCS_AreaEventCancellationArg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_LCS_AreaEventCancellationArg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_LCS_AreaEventCancellationArg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LCS_ReferenceNumber( &pType->referenceNumber, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GSN_Address( &pType->h_gmlc_address, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE IMSI-WithLMSI Ber decoder */
static void AsnDecode_SS2_IMSI_WithLMSI( SS2_IMSI_WithLMSI *pType, applib2_AsnContext *pContext)
{
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_IMSI( &pType->imsi, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_LMSI( &pType->lmsi, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* CHOICE CellGlobalIdOrServiceAreaIdOrLAI Ber decoder */
static void AsnDecode_SS2_CellGlobalIdOrServiceAreaIdOrLAI( SS2_CellGlobalIdOrServiceAreaIdOrLAI *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV		seq_tlv;
      pre_get_t(pContext, &seq_tlv.t);
      if(ContextSpecific == seq_tlv.t.cl && tag.is_tagged == TRUE)
         get_tl(pContext, &seq_tlv);
   }
   
   {
      BER_TAG   pdu_tag;
      
      pre_get_t(pContext, &pdu_tag);
      
      if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 0) )
      {
         AsnDecode_SS2_CellGlobalIdOrServiceAreaIdFixedLength( &pType->choice.cellGlobalIdOrServiceAreaIdFixedLength, pContext);
         
         pType->selection = SS2_CellGlobalIdOrServiceAreaIdOrLAI_cellGlobalIdOrServiceAreaIdFixedLength_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 1) )
      {
         AsnDecode_SS2_LAIFixedLength( &pType->choice.laiFixedLength, pContext);
         
         pType->selection = SS2_CellGlobalIdOrServiceAreaIdOrLAI_laiFixedLength_selected;
      }
   }
   
}

/* CHOICE BasicServiceCode Ber decoder */
static void AsnDecode_SS2_BasicServiceCode( SS2_BasicServiceCode *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV		seq_tlv;
      pre_get_t(pContext, &seq_tlv.t);
      if(ContextSpecific == seq_tlv.t.cl && tag.is_tagged == TRUE)
         get_tl(pContext, &seq_tlv);
   }
   
   {
      BER_TAG   pdu_tag;
      
      pre_get_t(pContext, &pdu_tag);
      
      if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 2) )
      {
         AsnDecode_SS2_BearerServiceCode( &pType->choice.bearerService, pContext);
         
         pType->selection = SS2_BasicServiceCode_bearerService_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 3) )
      {
         AsnDecode_SS2_TeleserviceCode( &pType->choice.teleservice, pContext);
         
         pType->selection = SS2_BasicServiceCode_teleservice_selected;
      }
   }
   
}

/* CHOICE Ext-BasicServiceCode Ber decoder */
static void AsnDecode_SS2_Ext_BasicServiceCode( SS2_Ext_BasicServiceCode *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV		seq_tlv;
      pre_get_t(pContext, &seq_tlv.t);
      if(ContextSpecific == seq_tlv.t.cl && tag.is_tagged == TRUE)
         get_tl(pContext, &seq_tlv);
   }
   
   {
      BER_TAG   pdu_tag;
      
      pre_get_t(pContext, &pdu_tag);
      
      if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 2) )
      {
         AsnDecode_SS2_Ext_BearerServiceCode( &pType->choice.ext_BearerService, pContext);
         
         pType->selection = SS2_Ext_BasicServiceCode_ext_BearerService_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 3) )
      {
         AsnDecode_SS2_Ext_TeleserviceCode( &pType->choice.ext_Teleservice, pContext);
         
         pType->selection = SS2_Ext_BasicServiceCode_ext_Teleservice_selected;
      }
   }
   
}

/* SEQUENCE SS-IncompatibilityCause Ber decoder */
extern U32 AsnDecode_SS2_SS_IncompatibilityCause( SS2_SS_IncompatibilityCause **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_SS_IncompatibilityCause *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_SS_IncompatibilityCause ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SS_Code( &pType->ss_Code, pContext);
            pType->validity |= SS2_SS_IncompatibilityCause_ss_Code_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 0;
      {
         unsigned int sub_choice_tag_pre_list[]={2,3}, counter=0;
         pre_get_t(pContext, &pdu_tag);
         std_tag.tag=-1;
         for(counter=0;counter<2;counter++)
         {
            if(pdu_tag.tag==sub_choice_tag_pre_list[counter])
            {
               std_tag.tag=0;
               break;
            }
         }
      }
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_BasicServiceCode( &pType->basicService, pContext, tag);
            pType->validity |= SS2_SS_IncompatibilityCause_basicService_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SS_Status( &pType->ss_Status, pContext);
            pType->validity |= SS2_SS_IncompatibilityCause_ss_Status_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SET OF PrivateExtensionList Ber decoder */
static void AsnDecode_SS2_PrivateExtensionList( SS2_PrivateExtensionList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_PrivateExtension( &pType->element[i], pContext);
   }
}

/* SEQUENCE LocationType Ber decoder */
static void AsnDecode_SS2_LocationType( SS2_LocationType *pType, applib2_AsnContext *pContext)
{
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LocationEstimateType( &pType->locationEstimateType, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_DeferredLocationEventType( &pType->deferredLocationEventType, pContext);
            pType->validity |= SS2_LocationType_deferredLocationEventType_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* DEFINED NameString Ber decoder */
static void AsnDecode_SS2_NameString( SS2_NameString *pType, applib2_AsnContext *pContext)
{
   { 
      BER_TAG tag;
      tag.is_tagged = FALSE;
      ((void)tag); 

      AsnDecode_SS2_USSD_String( pType, pContext);
   }
}

/* DEFINED RequestorIDString Ber decoder */
static void AsnDecode_SS2_RequestorIDString( SS2_RequestorIDString *pType, applib2_AsnContext *pContext)
{
   { 
      BER_TAG tag;
      tag.is_tagged = FALSE;
      ((void)tag); 

      AsnDecode_SS2_USSD_String( pType, pContext);
   }
}

/* SEQUENCE ResponseTime Ber decoder */
static void AsnDecode_SS2_ResponseTime( SS2_ResponseTime *pType, applib2_AsnContext *pContext)
{
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ResponseTimeCategory( &pType->responseTimeCategory, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* DEFINED LCSCodewordString Ber decoder */
static void AsnDecode_SS2_LCSCodewordString( SS2_LCSCodewordString *pType, applib2_AsnContext *pContext)
{
   { 
      BER_TAG tag;
      tag.is_tagged = FALSE;
      ((void)tag); 

      AsnDecode_SS2_USSD_String( pType, pContext);
   }
}

/* SEQUENCE LCS-PrivacyCheck Ber decoder */
static void AsnDecode_SS2_LCS_PrivacyCheck( SS2_LCS_PrivacyCheck *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_PrivacyCheckRelatedAction( &pType->callSessionUnrelated, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_PrivacyCheckRelatedAction( &pType->callSessionRelated, pContext);
            pType->validity |= SS2_LCS_PrivacyCheck_callSessionRelated_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE Area Ber decoder */
static void AsnDecode_SS2_Area( SS2_Area *pType, applib2_AsnContext *pContext)
{
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_AreaType( &pType->areaType, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_AreaIdentification( &pType->areaIdentification, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* CHOICE SuperChargerInfo Ber decoder */
static void AsnDecode_SS2_SuperChargerInfo( SS2_SuperChargerInfo *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV		seq_tlv;
      pre_get_t(pContext, &seq_tlv.t);
      if(ContextSpecific == seq_tlv.t.cl && tag.is_tagged == TRUE)
         get_tl(pContext, &seq_tlv);
   }
   
   {
      BER_TAG   pdu_tag;
      
      pre_get_t(pContext, &pdu_tag);
      
      if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 0) )
      {
         {
            BER_TLV tlv; 
            get_tl( pContext, &tlv ); 
            /* without value */ 
         }
         
         pType->selection = SS2_SuperChargerInfo_sendSubscriberData_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 1) )
      {
         AsnDecode_SS2_AgeIndicator( &pType->choice.subscriberDataStored, pContext);
         
         pType->selection = SS2_SuperChargerInfo_subscriberDataStored_selected;
      }
   }
   
}

/* SEQUENCE AuthenticationTriplet Ber decoder */
static void AsnDecode_SS2_AuthenticationTriplet( SS2_AuthenticationTriplet *pType, applib2_AsnContext *pContext)
{
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_RAND( &pType->rand, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_SRES( &pType->sres, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_Kc( &pType->kc, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE AuthenticationQuintuplet Ber decoder */
static void AsnDecode_SS2_AuthenticationQuintuplet( SS2_AuthenticationQuintuplet *pType, applib2_AsnContext *pContext)
{
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_RAND( &pType->rand, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_XRES( &pType->xres, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_CK( &pType->ck, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_IK( &pType->ik, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_AUTN( &pType->autn, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE GSM-SecurityContextData Ber decoder */
static void AsnDecode_SS2_GSM_SecurityContextData( SS2_GSM_SecurityContextData *pType, applib2_AsnContext *pContext)
{
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_Kc( &pType->kc, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_Cksn( &pType->cksn, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE UMTS-SecurityContextData Ber decoder */
static void AsnDecode_SS2_UMTS_SecurityContextData( SS2_UMTS_SecurityContextData *pType, applib2_AsnContext *pContext)
{
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_CK( &pType->ck, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_IK( &pType->ik, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_KSI( &pType->ksi, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE BSSMAP-ServiceHandoverInfo Ber decoder */
static void AsnDecode_SS2_BSSMAP_ServiceHandoverInfo( SS2_BSSMAP_ServiceHandoverInfo *pType, applib2_AsnContext *pContext)
{
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_BSSMAP_ServiceHandover( &pType->bssmap_ServiceHandover, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            pType->rab_Id = (U8)ber_get_integer( pContext ); 
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE RadioResource Ber decoder */
static void AsnDecode_SS2_RadioResource( SS2_RadioResource *pType, applib2_AsnContext *pContext)
{
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_RadioResourceInformation( &pType->radioResourceInformation, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            pType->rab_Id = (U8)ber_get_integer( pContext ); 
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE ChosenRadioResourceInformation Ber decoder */
static void AsnDecode_SS2_ChosenRadioResourceInformation( SS2_ChosenRadioResourceInformation *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ChosenChannelInfo( &pType->chosenChannelInfo, pContext);
            pType->validity |= SS2_ChosenRadioResourceInformation_chosenChannelInfo_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ChosenSpeechVersion( &pType->chosenSpeechVersion, pContext);
            pType->validity |= SS2_ChosenRadioResourceInformation_chosenSpeechVersion_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE RelocationNumber Ber decoder */
static void AsnDecode_SS2_RelocationNumber( SS2_RelocationNumber *pType, applib2_AsnContext *pContext)
{
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->handoverNumber, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            pType->rab_Id = (U8)ber_get_integer( pContext ); 
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE UESBI-Iu Ber decoder */
static void AsnDecode_SS2_UESBI_Iu( SS2_UESBI_Iu *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_UESBI_IuA( &pType->uesbi_IuA, pContext);
            pType->validity |= SS2_UESBI_Iu_uesbi_IuA_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_UESBI_IuB( &pType->uesbi_IuB, pContext);
            pType->validity |= SS2_UESBI_Iu_uesbi_IuB_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SET OF TeleserviceList Ber decoder */
static void AsnDecode_SS2_TeleserviceList( SS2_TeleserviceList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_Ext_TeleserviceCode( &pType->element[i], pContext);
   }
}

/* SET OF Ext-BasicServiceGroupList Ber decoder */
static void AsnDecode_SS2_Ext_BasicServiceGroupList( SS2_Ext_BasicServiceGroupList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_Ext_BasicServiceCode( &pType->element[i], pContext, tag);
   }
}

/* SET OF ZoneCodeList Ber decoder */
static void AsnDecode_SS2_ZoneCodeList( SS2_ZoneCodeList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_ZoneCode( &pType->element[i], pContext);
   }
}

/* CHOICE GPRSSubscriptionDataWithdraw Ber decoder */
static void AsnDecode_SS2_GPRSSubscriptionDataWithdraw( SS2_GPRSSubscriptionDataWithdraw *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV		seq_tlv;
      pre_get_t(pContext, &seq_tlv.t);
      if(ContextSpecific == seq_tlv.t.cl && tag.is_tagged == TRUE)
         get_tl(pContext, &seq_tlv);
   }
   
   {
      BER_TAG   pdu_tag;
      
      pre_get_t(pContext, &pdu_tag);
      
      if( (pdu_tag.cl == Universal) && (pdu_tag.tag == 5) )
      {
         {
            BER_TLV tlv; 
            get_tl( pContext, &tlv ); 
            /* without value */ 
         }
         
         pType->selection = SS2_GPRSSubscriptionDataWithdraw_allGPRSData_selected;
      }
      else if( (pdu_tag.cl == Universal) && (pdu_tag.tag == 16) )
      {
         AsnDecode_SS2_ContextIdList( &pType->choice.contextIdList, pContext);
         
         pType->selection = SS2_GPRSSubscriptionDataWithdraw_contextIdList_selected;
      }
   }
   
}

/* CHOICE LSAInformationWithdraw Ber decoder */
static void AsnDecode_SS2_LSAInformationWithdraw( SS2_LSAInformationWithdraw *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV		seq_tlv;
      pre_get_t(pContext, &seq_tlv.t);
      if(ContextSpecific == seq_tlv.t.cl && tag.is_tagged == TRUE)
         get_tl(pContext, &seq_tlv);
   }
   
   {
      BER_TAG   pdu_tag;
      
      pre_get_t(pContext, &pdu_tag);
      
      if( (pdu_tag.cl == Universal) && (pdu_tag.tag == 5) )
      {
         {
            BER_TLV tlv; 
            get_tl( pContext, &tlv ); 
            /* without value */ 
         }
         
         pType->selection = SS2_LSAInformationWithdraw_allLSAData_selected;
      }
      else if( (pdu_tag.cl == Universal) && (pdu_tag.tag == 16) )
      {
         AsnDecode_SS2_LSAIdentityList( &pType->choice.lsaIdentityList, pContext);
         
         pType->selection = SS2_LSAInformationWithdraw_lsaIdentityList_selected;
      }
   }
   
}

/* SET OF BasicServiceList Ber decoder */
static void AsnDecode_SS2_BasicServiceList( SS2_BasicServiceList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_Ext_BasicServiceCode( &pType->element[i], pContext, tag);
   }
}

/* SET OF TPDU-TypeCriterion Ber decoder */
static void AsnDecode_SS2_TPDU_TypeCriterion( SS2_TPDU_TypeCriterion *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_MT_SMS_TPDU_Type( &pType->element[i], pContext);
   }
}

/* SET OF SS-EventList Ber decoder */
static void AsnDecode_SS2_SS_EventList( SS2_SS_EventList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_SS_Code( &pType->element[i], pContext);
   }
}

/* SEQUENCE DestinationNumberCriteria Ber decoder */
static void AsnDecode_SS2_DestinationNumberCriteria( SS2_DestinationNumberCriteria *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_MatchType( &pType->matchType, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_DestinationNumberList( &pType->destinationNumberList, pContext);
            pType->validity |= SS2_DestinationNumberCriteria_destinationNumberList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_DestinationNumberLengthList( &pType->destinationNumberLengthList, pContext);
            pType->validity |= SS2_DestinationNumberCriteria_destinationNumberLengthList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SET OF BasicServiceCriteria Ber decoder */
static void AsnDecode_SS2_BasicServiceCriteria( SS2_BasicServiceCriteria *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_Ext_BasicServiceCode( &pType->element[i], pContext, tag);
   }
}

/* SET OF O-CauseValueCriteria Ber decoder */
static void AsnDecode_SS2_O_CauseValueCriteria( SS2_O_CauseValueCriteria *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_CauseValue( &pType->element[i], pContext);
   }
}

/* SET OF T-CauseValueCriteria Ber decoder */
static void AsnDecode_SS2_T_CauseValueCriteria( SS2_T_CauseValueCriteria *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_CauseValue( &pType->element[i], pContext);
   }
}

/* SET OF MobilityTriggers Ber decoder */
static void AsnDecode_SS2_MobilityTriggers( SS2_MobilityTriggers *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_MM_Code( &pType->element[i], pContext);
   }
}

/* SEQUENCE GPRSMSClass Ber decoder */
static void AsnDecode_SS2_GPRSMSClass( SS2_GPRSMSClass *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_MSNetworkCapability( &pType->mSNetworkCapability, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_MSRadioAccessCapability( &pType->mSRadioAccessCapability, pContext);
            pType->validity |= SS2_GPRSMSClass_mSRadioAccessCapability_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* CHOICE SubscriberState Ber decoder */
static void AsnDecode_SS2_SubscriberState( SS2_SubscriberState *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV		seq_tlv;
      pre_get_t(pContext, &seq_tlv.t);
      if(ContextSpecific == seq_tlv.t.cl && tag.is_tagged == TRUE)
         get_tl(pContext, &seq_tlv);
   }
   
   {
      BER_TAG   pdu_tag;
      
      pre_get_t(pContext, &pdu_tag);
      
      if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 0) )
      {
         {
            BER_TLV tlv; 
            get_tl( pContext, &tlv ); 
            /* without value */ 
         }
         
         pType->selection = SS2_SubscriberState_assumedIdle_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 1) )
      {
         {
            BER_TLV tlv; 
            get_tl( pContext, &tlv ); 
            /* without value */ 
         }
         
         pType->selection = SS2_SubscriberState_camelBusy_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 3) )
      {
         AsnDecode_SS2_NotReachableReason( &pType->choice.netDetNotReachable, pContext);
         
         pType->selection = SS2_SubscriberState_netDetNotReachable_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 2) )
      {
         {
            BER_TLV tlv; 
            get_tl( pContext, &tlv ); 
            /* without value */ 
         }
         
         pType->selection = SS2_SubscriberState_notProvidedFromVLR_selected;
      }
   }
   
}

/* SEQUENCE TraceDepthList Ber decoder */
static void AsnDecode_SS2_TraceDepthList( SS2_TraceDepthList *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_TraceDepth( &pType->msc_s_TraceDepth, pContext);
            pType->validity |= SS2_TraceDepthList_msc_s_TraceDepth_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_TraceDepth( &pType->mgw_TraceDepth, pContext);
            pType->validity |= SS2_TraceDepthList_mgw_TraceDepth_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_TraceDepth( &pType->sgsn_TraceDepth, pContext);
            pType->validity |= SS2_TraceDepthList_sgsn_TraceDepth_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_TraceDepth( &pType->ggsn_TraceDepth, pContext);
            pType->validity |= SS2_TraceDepthList_ggsn_TraceDepth_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_TraceDepth( &pType->rnc_TraceDepth, pContext);
            pType->validity |= SS2_TraceDepthList_rnc_TraceDepth_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_TraceDepth( &pType->bmsc_TraceDepth, pContext);
            pType->validity |= SS2_TraceDepthList_bmsc_TraceDepth_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE TraceInterfaceList Ber decoder */
static void AsnDecode_SS2_TraceInterfaceList( SS2_TraceInterfaceList *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_MSC_S_InterfaceList( &pType->msc_s_List, pContext);
            pType->validity |= SS2_TraceInterfaceList_msc_s_List_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_MGW_InterfaceList( &pType->mgw_List, pContext);
            pType->validity |= SS2_TraceInterfaceList_mgw_List_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SGSN_InterfaceList( &pType->sgsn_List, pContext);
            pType->validity |= SS2_TraceInterfaceList_sgsn_List_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GGSN_InterfaceList( &pType->ggsn_List, pContext);
            pType->validity |= SS2_TraceInterfaceList_ggsn_List_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_RNC_InterfaceList( &pType->rnc_List, pContext);
            pType->validity |= SS2_TraceInterfaceList_rnc_List_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_BMSC_InterfaceList( &pType->bmsc_List, pContext);
            pType->validity |= SS2_TraceInterfaceList_bmsc_List_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE TraceEventList Ber decoder */
static void AsnDecode_SS2_TraceEventList( SS2_TraceEventList *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_MSC_S_EventList( &pType->msc_s_List, pContext);
            pType->validity |= SS2_TraceEventList_msc_s_List_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_MGW_EventList( &pType->mgw_List, pContext);
            pType->validity |= SS2_TraceEventList_mgw_List_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SGSN_EventList( &pType->sgsn_List, pContext);
            pType->validity |= SS2_TraceEventList_sgsn_List_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GGSN_EventList( &pType->ggsn_List, pContext);
            pType->validity |= SS2_TraceEventList_ggsn_List_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_BMSC_EventList( &pType->bmsc_List, pContext);
            pType->validity |= SS2_TraceEventList_bmsc_List_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE RegisterSS-Arg Ber decoder */
extern U32 AsnDecode_SS2_RegisterSS_Arg( SS2_RegisterSS_Arg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_RegisterSS_Arg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_RegisterSS_Arg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_SS_Code( &pType->ss_Code, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 0;
      {
         unsigned int sub_choice_tag_pre_list[]={2,3}, counter=0;
         pre_get_t(pContext, &pdu_tag);
         std_tag.tag=-1;
         for(counter=0;counter<2;counter++)
         {
            if(pdu_tag.tag==sub_choice_tag_pre_list[counter])
            {
               std_tag.tag=0;
               break;
            }
         }
      }
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_BasicServiceCode( &pType->basicService, pContext, tag);
            pType->validity |= SS2_RegisterSS_Arg_basicService_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_AddressString( &pType->forwardedToNumber, pContext);
            pType->validity |= SS2_RegisterSS_Arg_forwardedToNumber_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_SubaddressString( &pType->forwardedToSubaddress, pContext);
            pType->validity |= SS2_RegisterSS_Arg_forwardedToSubaddress_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->noReplyConditionTime = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_RegisterSS_Arg_noReplyConditionTime_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 7;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->defaultPriority = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_RegisterSS_Arg_defaultPriority_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 8;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->nbrUser = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_RegisterSS_Arg_nbrUser_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 9;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_RegisterSS_Arg_longFTN_Supported_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE ForwardingFeature Ber decoder */
static void AsnDecode_SS2_ForwardingFeature( SS2_ForwardingFeature *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 0;
      {
         unsigned int sub_choice_tag_pre_list[]={2,3}, counter=0;
         pre_get_t(pContext, &pdu_tag);
         std_tag.tag=-1;
         for(counter=0;counter<2;counter++)
         {
            if(pdu_tag.tag==sub_choice_tag_pre_list[counter])
            {
               std_tag.tag=0;
               break;
            }
         }
      }
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_BasicServiceCode( &pType->basicService, pContext, tag);
            pType->validity |= SS2_ForwardingFeature_basicService_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SS_Status( &pType->ss_Status, pContext);
            pType->validity |= SS2_ForwardingFeature_ss_Status_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->forwardedToNumber, pContext);
            pType->validity |= SS2_ForwardingFeature_forwardedToNumber_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 8;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_SubaddressString( &pType->forwardedToSubaddress, pContext);
            pType->validity |= SS2_ForwardingFeature_forwardedToSubaddress_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ForwardingOptions( &pType->forwardingOptions, pContext);
            pType->validity |= SS2_ForwardingFeature_forwardingOptions_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 7;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->noReplyConditionTime = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_ForwardingFeature_noReplyConditionTime_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 9;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_FTN_AddressString( &pType->longForwardedToNumber, pContext);
            pType->validity |= SS2_ForwardingFeature_longForwardedToNumber_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE CallBarringFeature Ber decoder */
static void AsnDecode_SS2_CallBarringFeature( SS2_CallBarringFeature *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 0;
      {
         unsigned int sub_choice_tag_pre_list[]={2,3}, counter=0;
         pre_get_t(pContext, &pdu_tag);
         std_tag.tag=-1;
         for(counter=0;counter<2;counter++)
         {
            if(pdu_tag.tag==sub_choice_tag_pre_list[counter])
            {
               std_tag.tag=0;
               break;
            }
         }
      }
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_BasicServiceCode( &pType->basicService, pContext, tag);
            pType->validity |= SS2_CallBarringFeature_basicService_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SS_Status( &pType->ss_Status, pContext);
            pType->validity |= SS2_CallBarringFeature_ss_Status_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* CHOICE SS-SubscriptionOption Ber decoder */
static void AsnDecode_SS2_SS_SubscriptionOption( SS2_SS_SubscriptionOption *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV		seq_tlv;
      pre_get_t(pContext, &seq_tlv.t);
      if(ContextSpecific == seq_tlv.t.cl && tag.is_tagged == TRUE)
         get_tl(pContext, &seq_tlv);
   }
   
   {
      BER_TAG   pdu_tag;
      
      pre_get_t(pContext, &pdu_tag);
      
      if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 2) )
      {
         AsnDecode_SS2_CliRestrictionOption( &pType->choice.cliRestrictionOption, pContext);
         
         pType->selection = SS2_SS_SubscriptionOption_cliRestrictionOption_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 1) )
      {
         AsnDecode_SS2_OverrideCategory( &pType->choice.overrideCategory, pContext);
         
         pType->selection = SS2_SS_SubscriptionOption_overrideCategory_selected;
      }
   }
   
}

/* SEQUENCE SS-ForBS-Code Ber decoder */
static void AsnDecode_SS2_SS_ForBS_Code( SS2_SS_ForBS_Code *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_SS_Code( &pType->ss_Code, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 0;
      {
         unsigned int sub_choice_tag_pre_list[]={2,3}, counter=0;
         pre_get_t(pContext, &pdu_tag);
         std_tag.tag=-1;
         for(counter=0;counter<2;counter++)
         {
            if(pdu_tag.tag==sub_choice_tag_pre_list[counter])
            {
               std_tag.tag=0;
               break;
            }
         }
      }
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_BasicServiceCode( &pType->basicService, pContext, tag);
            pType->validity |= SS2_SS_ForBS_Code_basicService_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_SS_ForBS_Code_longFTN_Supported_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE CCBS-Feature Ber decoder */
static void AsnDecode_SS2_CCBS_Feature( SS2_CCBS_Feature *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->ccbs_Index = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_CCBS_Feature_ccbs_Index_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->b_subscriberNumber, pContext);
            pType->validity |= SS2_CCBS_Feature_b_subscriberNumber_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_SubaddressString( &pType->b_subscriberSubaddress, pContext);
            pType->validity |= SS2_CCBS_Feature_b_subscriberSubaddress_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_BasicServiceCode( &pType->basicServiceGroup, pContext, tag);
            pType->validity |= SS2_CCBS_Feature_basicServiceGroup_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE USSD-Arg Ber decoder */
extern U32 AsnDecode_SS2_USSD_Arg( SS2_USSD_Arg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_USSD_Arg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_USSD_Arg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_USSD_DataCodingScheme( &pType->ussd_DataCodingScheme, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_USSD_String( &pType->ussd_String, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_AlertingPattern( &pType->alertingPattern, pContext);
            pType->validity |= SS2_USSD_Arg_alertingPattern_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->msisdn, pContext);
            pType->validity |= SS2_USSD_Arg_msisdn_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE USSD-Res Ber decoder */
extern U32 AsnDecode_SS2_USSD_Res( SS2_USSD_Res **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_USSD_Res *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_USSD_Res ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_USSD_DataCodingScheme( &pType->ussd_DataCodingScheme, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_USSD_String( &pType->ussd_String, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SET OF BasicServiceGroupList Ber decoder */
static void AsnDecode_SS2_BasicServiceGroupList( SS2_BasicServiceGroupList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_BasicServiceCode( &pType->element[i], pContext, tag);
   }
}

/* SEQUENCE RegisterCC-EntryRes Ber decoder */
extern U32 AsnDecode_SS2_RegisterCC_EntryRes( SS2_RegisterCC_EntryRes **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_RegisterCC_EntryRes *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_RegisterCC_EntryRes ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_CCBS_Feature( &pType->ccbs_Feature, pContext);
            pType->validity |= SS2_RegisterCC_EntryRes_ccbs_Feature_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* CHOICE InvokeId Ber decoder */
static void AsnDecode_SS2_InvokeId( SS2_InvokeId *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV		seq_tlv;
      pre_get_t(pContext, &seq_tlv.t);
      if(ContextSpecific == seq_tlv.t.cl && tag.is_tagged == TRUE)
         get_tl(pContext, &seq_tlv);
   }
   
   {
      BER_TAG   pdu_tag;
      
      pre_get_t(pContext, &pdu_tag);
      
      if( (pdu_tag.cl == Universal) && (pdu_tag.tag == 2) )
      {
         pType->choice.present = (S32)ber_get_integer( pContext ); 
         
         pType->selection = SS2_InvokeId_present_selected;
      }
      else if( (pdu_tag.cl == Universal) && (pdu_tag.tag == 5) )
      {
         {
            BER_TLV tlv; 
            get_tl( pContext, &tlv ); 
            /* without value */ 
         }
         
         pType->selection = SS2_InvokeId_absent_selected;
      }
   }
   
}

/* DEFINED NoInvokeId Ber decoder */
extern U32 AsnDecode_SS2_NoInvokeId( SS2_NoInvokeId **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_NoInvokeId *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_NoInvokeId ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   { 
      BER_TAG tag;
      tag.is_tagged = FALSE;
      ((void)tag); 

      AsnDecode_SS2_InvokeId( pType, pContext, tag);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE ChargingInformation Ber decoder */
static void AsnDecode_SS2_ChargingInformation( SS2_ChargingInformation *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->e1 = (U16)ber_get_integer( pContext ); 
            pType->validity |= SS2_ChargingInformation_e1_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->e2 = (U16)ber_get_integer( pContext ); 
            pType->validity |= SS2_ChargingInformation_e2_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->e3 = (U16)ber_get_integer( pContext ); 
            pType->validity |= SS2_ChargingInformation_e3_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->e4 = (U16)ber_get_integer( pContext ); 
            pType->validity |= SS2_ChargingInformation_e4_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->e5 = (U16)ber_get_integer( pContext ); 
            pType->validity |= SS2_ChargingInformation_e5_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->e6 = (U16)ber_get_integer( pContext ); 
            pType->validity |= SS2_ChargingInformation_e6_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 7;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->e7 = (U16)ber_get_integer( pContext ); 
            pType->validity |= SS2_ChargingInformation_e7_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* CHOICE Name Ber decoder */
static void AsnDecode_SS2_Name( SS2_Name *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV		seq_tlv;
      pre_get_t(pContext, &seq_tlv.t);
      if(ContextSpecific == seq_tlv.t.cl && tag.is_tagged == TRUE)
         get_tl(pContext, &seq_tlv);
   }
   
   {
      BER_TAG   pdu_tag;
      
      pre_get_t(pContext, &pdu_tag);
      
      if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 0) )
      {
         AsnDecode_SS2_NameSet( &pType->choice.namePresentationAllowed, pContext);
         
         pType->selection = SS2_Name_namePresentationAllowed_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 1) )
      {
         {
            BER_TLV tlv; 
            get_tl( pContext, &tlv ); 
            /* without value */ 
         }
         
         pType->selection = SS2_Name_presentationRestricted_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 2) )
      {
         {
            BER_TLV tlv; 
            get_tl( pContext, &tlv ); 
            /* without value */ 
         }
         
         pType->selection = SS2_Name_nameUnavailable_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 3) )
      {
         AsnDecode_SS2_NameSet( &pType->choice.namePresentationRestricted, pContext);
         
         pType->selection = SS2_Name_namePresentationRestricted_selected;
      }
   }
   
}

/* CHOICE RDN Ber decoder */
static void AsnDecode_SS2_RDN( SS2_RDN *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV		seq_tlv;
      pre_get_t(pContext, &seq_tlv.t);
      if(ContextSpecific == seq_tlv.t.cl && tag.is_tagged == TRUE)
         get_tl(pContext, &seq_tlv);
   }
   
   {
      BER_TAG   pdu_tag;
      
      pre_get_t(pContext, &pdu_tag);
      
      if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 0) )
      {
         AsnDecode_SS2_RemotePartyNumber( &pType->choice.presentationAllowedAddress, pContext);
         
         pType->selection = SS2_RDN_presentationAllowedAddress_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 1) )
      {
         {
            BER_TLV tlv; 
            get_tl( pContext, &tlv ); 
            /* without value */ 
         }
         
         pType->selection = SS2_RDN_presentationRestricted_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 2) )
      {
         {
            BER_TLV tlv; 
            get_tl( pContext, &tlv ); 
            /* without value */ 
         }
         
         pType->selection = SS2_RDN_numberNotAvailableDueToInterworking_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 3) )
      {
         AsnDecode_SS2_RemotePartyNumber( &pType->choice.presentationRestrictedAddress, pContext);
         
         pType->selection = SS2_RDN_presentationRestrictedAddress_selected;
      }
   }
   
}

/* SEQUENCE UserUserServiceArg Ber decoder */
extern U32 AsnDecode_SS2_UserUserServiceArg( SS2_UserUserServiceArg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_UserUserServiceArg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_UserUserServiceArg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_UUS_Service( &pType->uUS_Service, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            applib2_getShortBits(pContext, 16);
            pType->uUS_Required = applib2_getShortBits(pContext, 8) == 0 ? FALSE : TRUE ;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE LocationNotificationRes Ber decoder */
extern U32 AsnDecode_SS2_LocationNotificationRes( SS2_LocationNotificationRes **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_LocationNotificationRes *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_LocationNotificationRes ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_VerificationResponse( &pType->verificationResponse, pContext);
            pType->validity |= SS2_LocationNotificationRes_verificationResponse_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE LCS-MOLRRes Ber decoder */
extern U32 AsnDecode_SS2_LCS_MOLRRes( SS2_LCS_MOLRRes **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_LCS_MOLRRes *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_LCS_MOLRRes ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Ext_GeographicalInformation( &pType->locationEstimate, pContext);
            pType->validity |= SS2_LCS_MOLRRes_locationEstimate_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_DecipheringKeys( &pType->decipheringKeys, pContext);
            pType->validity |= SS2_LCS_MOLRRes_decipheringKeys_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Add_GeographicalInformation( &pType->add_LocationEstimate, pContext);
            pType->validity |= SS2_LCS_MOLRRes_add_LocationEstimate_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* CHOICE Identity Ber decoder */
static void AsnDecode_SS2_Identity( SS2_Identity *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV		seq_tlv;
      pre_get_t(pContext, &seq_tlv.t);
      if(ContextSpecific == seq_tlv.t.cl && tag.is_tagged == TRUE)
         get_tl(pContext, &seq_tlv);
   }
   
   {
      BER_TAG   pdu_tag;
      
      pre_get_t(pContext, &pdu_tag);
      
      if( (pdu_tag.cl == Universal) && (pdu_tag.tag == 4) )
      {
         AsnDecode_SS2_IMSI( &pType->choice.imsi, pContext);
         
         pType->selection = SS2_Identity_imsi_selected;
      }
      else if( (pdu_tag.cl == Universal) && (pdu_tag.tag == 16) )
      {
         AsnDecode_SS2_IMSI_WithLMSI( &pType->choice.imsi_WithLMSI, pContext);
         
         pType->selection = SS2_Identity_imsi_WithLMSI_selected;
      }
   }
   
}

/* SEQUENCE ExtensionContainer Ber decoder */
static void AsnDecode_SS2_ExtensionContainer( SS2_ExtensionContainer *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_PrivateExtensionList( &pType->privateExtensionList, pContext);
            pType->validity |= SS2_ExtensionContainer_privateExtensionList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_PCS_Extensions( &pType->pcs_Extensions, pContext);
            pType->validity |= SS2_ExtensionContainer_pcs_Extensions_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE SLR-ArgExtensionContainer Ber decoder */
static void AsnDecode_SS2_SLR_ArgExtensionContainer( SS2_SLR_ArgExtensionContainer *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_PrivateExtensionList( &pType->privateExtensionList, pContext);
            pType->validity |= SS2_SLR_ArgExtensionContainer_privateExtensionList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SLR_Arg_PCS_Extensions( &pType->slr_Arg_PCS_Extensions, pContext);
            pType->validity |= SS2_SLR_ArgExtensionContainer_slr_Arg_PCS_Extensions_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE RoutingInfoForLCS-Arg Ber decoder */
extern U32 AsnDecode_SS2_RoutingInfoForLCS_Arg( SS2_RoutingInfoForLCS_Arg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_RoutingInfoForLCS_Arg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_RoutingInfoForLCS_Arg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->mlcNumber, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SubscriberIdentity( &pType->targetMS, pContext, tag);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_RoutingInfoForLCS_Arg_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE LCSLocationInfo Ber decoder */
static void AsnDecode_SS2_LCSLocationInfo( SS2_LCSLocationInfo *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->networkNode_Number, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LMSI( &pType->lmsi, pContext);
            pType->validity |= SS2_LCSLocationInfo_lmsi_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_LCSLocationInfo_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_LCSLocationInfo_gprsNodeIndicator_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Additional_Number( &pType->additional_Number, pContext, tag);
            pType->validity |= SS2_LCSLocationInfo_additional_Number_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SupportedLCS_CapabilitySets( &pType->supportedLCS_CapabilitySets, pContext);
            pType->validity |= SS2_LCSLocationInfo_supportedLCS_CapabilitySets_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SupportedLCS_CapabilitySets( &pType->additional_LCS_CapabilitySets, pContext);
            pType->validity |= SS2_LCSLocationInfo_additional_LCS_CapabilitySets_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE LCSClientName Ber decoder */
static void AsnDecode_SS2_LCSClientName( SS2_LCSClientName *pType, applib2_AsnContext *pContext)
{
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_USSD_DataCodingScheme( &pType->dataCodingScheme, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_NameString( &pType->nameString, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LCS_FormatIndicator( &pType->lcs_FormatIndicator, pContext);
            pType->validity |= SS2_LCSClientName_lcs_FormatIndicator_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE LCSRequestorID Ber decoder */
static void AsnDecode_SS2_LCSRequestorID( SS2_LCSRequestorID *pType, applib2_AsnContext *pContext)
{
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_USSD_DataCodingScheme( &pType->dataCodingScheme, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_RequestorIDString( &pType->requestorIDString, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LCS_FormatIndicator( &pType->lcs_FormatIndicator, pContext);
            pType->validity |= SS2_LCSRequestorID_lcs_FormatIndicator_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE LCS-QoS Ber decoder */
static void AsnDecode_SS2_LCS_QoS( SS2_LCS_QoS *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Horizontal_Accuracy( &pType->horizontal_accuracy, pContext);
            pType->validity |= SS2_LCS_QoS_horizontal_accuracy_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_LCS_QoS_verticalCoordinateRequest_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Vertical_Accuracy( &pType->vertical_accuracy, pContext);
            pType->validity |= SS2_LCS_QoS_vertical_accuracy_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ResponseTime( &pType->responseTime, pContext);
            pType->validity |= SS2_LCS_QoS_responseTime_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_LCS_QoS_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE LCSCodeword Ber decoder */
static void AsnDecode_SS2_LCSCodeword( SS2_LCSCodeword *pType, applib2_AsnContext *pContext)
{
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_USSD_DataCodingScheme( &pType->dataCodingScheme, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LCSCodewordString( &pType->lcsCodewordString, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SET OF AreaList Ber decoder */
static void AsnDecode_SS2_AreaList( SS2_AreaList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_Area( &pType->element[i], pContext);
   }
}

/* SEQUENCE ProvideSubscriberLocation-Res Ber decoder */
extern U32 AsnDecode_SS2_ProvideSubscriberLocation_Res( SS2_ProvideSubscriberLocation_Res **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_ProvideSubscriberLocation_Res *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_ProvideSubscriberLocation_Res ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_Ext_GeographicalInformation( &pType->locationEstimate, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->ageOfLocationEstimate = (U16)ber_get_integer( pContext ); 
            pType->validity |= SS2_ProvideSubscriberLocation_Res_ageOfLocationEstimate_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_ProvideSubscriberLocation_Res_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Add_GeographicalInformation( &pType->add_LocationEstimate, pContext);
            pType->validity |= SS2_ProvideSubscriberLocation_Res_add_LocationEstimate_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_ProvideSubscriberLocation_Res_deferredmt_lrResponseIndicator_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_PositioningDataInformation( &pType->geranPositioningData, pContext);
            pType->validity |= SS2_ProvideSubscriberLocation_Res_geranPositioningData_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_UtranPositioningDataInfo( &pType->utranPositioningData, pContext);
            pType->validity |= SS2_ProvideSubscriberLocation_Res_utranPositioningData_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_CellGlobalIdOrServiceAreaIdOrLAI( &pType->cellIdOrSai, pContext, tag);
            pType->validity |= SS2_ProvideSubscriberLocation_Res_cellIdOrSai_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 7;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_ProvideSubscriberLocation_Res_sai_Present_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 8;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_AccuracyFulfilmentIndicator( &pType->accuracyFulfilmentIndicator, pContext);
            pType->validity |= SS2_ProvideSubscriberLocation_Res_accuracyFulfilmentIndicator_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE Deferredmt-lrData Ber decoder */
static void AsnDecode_SS2_Deferredmt_lrData( SS2_Deferredmt_lrData *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_DeferredLocationEventType( &pType->deferredLocationEventType, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_TerminationCause( &pType->terminationCause, pContext);
            pType->validity |= SS2_Deferredmt_lrData_terminationCause_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LCSLocationInfo( &pType->lcsLocationInfo, pContext);
            pType->validity |= SS2_Deferredmt_lrData_lcsLocationInfo_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE SubscriberLocationReport-Res Ber decoder */
extern U32 AsnDecode_SS2_SubscriberLocationReport_Res( SS2_SubscriberLocationReport_Res **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_SubscriberLocationReport_Res *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_SubscriberLocationReport_Res ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_SubscriberLocationReport_Res_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->na_ESRK, pContext);
            pType->validity |= SS2_SubscriberLocationReport_Res_na_ESRK_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->na_ESRD, pContext);
            pType->validity |= SS2_SubscriberLocationReport_Res_na_ESRD_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE VLR-Capability Ber decoder */
static void AsnDecode_SS2_VLR_Capability( SS2_VLR_Capability *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SupportedCamelPhases( &pType->supportedCamelPhases, pContext);
            pType->validity |= SS2_VLR_Capability_supportedCamelPhases_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_VLR_Capability_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_VLR_Capability_solsaSupportIndicator_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_IST_SupportIndicator( &pType->istSupportIndicator, pContext);
            pType->validity |= SS2_VLR_Capability_istSupportIndicator_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SuperChargerInfo( &pType->superChargerSupportedInServingNetworkEntity, pContext, tag);
            pType->validity |= SS2_VLR_Capability_superChargerSupportedInServingNetworkEntity_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_VLR_Capability_longFTN_Supported_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SupportedLCS_CapabilitySets( &pType->supportedLCS_CapabilitySets, pContext);
            pType->validity |= SS2_VLR_Capability_supportedLCS_CapabilitySets_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_OfferedCamel4CSIs( &pType->offeredCamel4CSIs, pContext);
            pType->validity |= SS2_VLR_Capability_offeredCamel4CSIs_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE UpdateLocationRes Ber decoder */
extern U32 AsnDecode_SS2_UpdateLocationRes( SS2_UpdateLocationRes **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_UpdateLocationRes *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_UpdateLocationRes ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->hlr_Number, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_UpdateLocationRes_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_UpdateLocationRes_add_Capability_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE CancelLocationArg Ber decoder */
extern U32 AsnDecode_SS2_CancelLocationArg( SS2_CancelLocationArg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_CancelLocationArg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_CancelLocationArg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_Identity( &pType->identity, pContext, tag);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_CancellationType( &pType->cancellationType, pContext);
            pType->validity |= SS2_CancelLocationArg_cancellationType_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_CancelLocationArg_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE CancelLocationRes Ber decoder */
extern U32 AsnDecode_SS2_CancelLocationRes( SS2_CancelLocationRes **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_CancelLocationRes *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_CancelLocationRes ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_CancelLocationRes_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE PurgeMS-Arg Ber decoder */
extern U32 AsnDecode_SS2_PurgeMS_Arg( SS2_PurgeMS_Arg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_PurgeMS_Arg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_PurgeMS_Arg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_IMSI( &pType->imsi, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->vlr_Number, pContext);
            pType->validity |= SS2_PurgeMS_Arg_vlr_Number_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->sgsn_Number, pContext);
            pType->validity |= SS2_PurgeMS_Arg_sgsn_Number_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_PurgeMS_Arg_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE PurgeMS-Res Ber decoder */
extern U32 AsnDecode_SS2_PurgeMS_Res( SS2_PurgeMS_Res **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_PurgeMS_Res *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_PurgeMS_Res ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_PurgeMS_Res_freezeTMSI_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_PurgeMS_Res_freezeP_TMSI_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_PurgeMS_Res_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE SendIdentificationArg Ber decoder */
extern U32 AsnDecode_SS2_SendIdentificationArg( SS2_SendIdentificationArg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_SendIdentificationArg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_SendIdentificationArg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_TMSI( &pType->tmsi, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            pType->numberOfRequestedVectors = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_SendIdentificationArg_numberOfRequestedVectors_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_SendIdentificationArg_segmentationProhibited_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_SendIdentificationArg_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->msc_Number, pContext);
            pType->validity |= SS2_SendIdentificationArg_msc_Number_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LAIFixedLength( &pType->previous_LAI, pContext);
            pType->validity |= SS2_SendIdentificationArg_previous_LAI_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->hopCounter = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_SendIdentificationArg_hopCounter_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SET OF TripletList Ber decoder */
static void AsnDecode_SS2_TripletList( SS2_TripletList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_AuthenticationTriplet( &pType->element[i], pContext);
   }
}

/* SET OF QuintupletList Ber decoder */
static void AsnDecode_SS2_QuintupletList( SS2_QuintupletList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_AuthenticationQuintuplet( &pType->element[i], pContext);
   }
}

/* CHOICE CurrentSecurityContext Ber decoder */
static void AsnDecode_SS2_CurrentSecurityContext( SS2_CurrentSecurityContext *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV		seq_tlv;
      pre_get_t(pContext, &seq_tlv.t);
      if(ContextSpecific == seq_tlv.t.cl && tag.is_tagged == TRUE)
         get_tl(pContext, &seq_tlv);
   }
   
   {
      BER_TAG   pdu_tag;
      
      pre_get_t(pContext, &pdu_tag);
      
      if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 0) )
      {
         AsnDecode_SS2_GSM_SecurityContextData( &pType->choice.gsm_SecurityContextData, pContext);
         
         pType->selection = SS2_CurrentSecurityContext_gsm_SecurityContextData_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 1) )
      {
         AsnDecode_SS2_UMTS_SecurityContextData( &pType->choice.umts_SecurityContextData, pContext);
         
         pType->selection = SS2_CurrentSecurityContext_umts_SecurityContextData_selected;
      }
   }
   
}

/* SEQUENCE AuthenticationFailureReportArg Ber decoder */
extern U32 AsnDecode_SS2_AuthenticationFailureReportArg( SS2_AuthenticationFailureReportArg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_AuthenticationFailureReportArg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_AuthenticationFailureReportArg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_IMSI( &pType->imsi, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_FailureCause( &pType->failureCause, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_AuthenticationFailureReportArg_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            applib2_getShortBits(pContext, 16);
            pType->re_attempt = applib2_getShortBits(pContext, 8) == 0 ? FALSE : TRUE ;
            pType->validity |= SS2_AuthenticationFailureReportArg_re_attempt_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_AccessType( &pType->accessType, pContext);
            pType->validity |= SS2_AuthenticationFailureReportArg_accessType_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_RAND( &pType->rand, pContext);
            pType->validity |= SS2_AuthenticationFailureReportArg_rand_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->vlr_Number, pContext);
            pType->validity |= SS2_AuthenticationFailureReportArg_vlr_Number_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->sgsn_Number, pContext);
            pType->validity |= SS2_AuthenticationFailureReportArg_sgsn_Number_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE AuthenticationFailureReportRes Ber decoder */
extern U32 AsnDecode_SS2_AuthenticationFailureReportRes( SS2_AuthenticationFailureReportRes **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_AuthenticationFailureReportRes *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_AuthenticationFailureReportRes ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_AuthenticationFailureReportRes_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE SGSN-Capability Ber decoder */
static void AsnDecode_SS2_SGSN_Capability( SS2_SGSN_Capability *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_SGSN_Capability_solsaSupportIndicator_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_SGSN_Capability_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SuperChargerInfo( &pType->superChargerSupportedInServingNetworkEntity, pContext, tag);
            pType->validity |= SS2_SGSN_Capability_superChargerSupportedInServingNetworkEntity_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_SGSN_Capability_gprsEnhancementsSupportIndicator_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SupportedCamelPhases( &pType->supportedCamelPhases, pContext);
            pType->validity |= SS2_SGSN_Capability_supportedCamelPhases_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SupportedLCS_CapabilitySets( &pType->supportedLCS_CapabilitySets, pContext);
            pType->validity |= SS2_SGSN_Capability_supportedLCS_CapabilitySets_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_OfferedCamel4CSIs( &pType->offeredCamel4CSIs, pContext);
            pType->validity |= SS2_SGSN_Capability_offeredCamel4CSIs_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 7;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_SGSN_Capability_smsCallBarringSupportIndicator_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE UpdateGprsLocationRes Ber decoder */
extern U32 AsnDecode_SS2_UpdateGprsLocationRes( SS2_UpdateGprsLocationRes **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_UpdateGprsLocationRes *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_UpdateGprsLocationRes ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->hlr_Number, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_UpdateGprsLocationRes_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_UpdateGprsLocationRes_add_Capability_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE AllowedUMTS-Algorithms Ber decoder */
static void AsnDecode_SS2_AllowedUMTS_Algorithms( SS2_AllowedUMTS_Algorithms *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_PermittedIntegrityProtectionAlgorithms( &pType->integrityProtectionAlgorithms, pContext);
            pType->validity |= SS2_AllowedUMTS_Algorithms_integrityProtectionAlgorithms_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_PermittedEncryptionAlgorithms( &pType->encryptionAlgorithms, pContext);
            pType->validity |= SS2_AllowedUMTS_Algorithms_encryptionAlgorithms_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_AllowedUMTS_Algorithms_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SET OF BSSMAP-ServiceHandoverList Ber decoder */
static void AsnDecode_SS2_BSSMAP_ServiceHandoverList( SS2_BSSMAP_ServiceHandoverList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_BSSMAP_ServiceHandoverInfo( &pType->element[i], pContext);
   }
}

/* SET OF RadioResourceList Ber decoder */
static void AsnDecode_SS2_RadioResourceList( SS2_RadioResourceList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_RadioResource( &pType->element[i], pContext);
   }
}

/* SEQUENCE SelectedUMTS-Algorithms Ber decoder */
static void AsnDecode_SS2_SelectedUMTS_Algorithms( SS2_SelectedUMTS_Algorithms *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ChosenIntegrityProtectionAlgorithm( &pType->integrityProtectionAlgorithm, pContext);
            pType->validity |= SS2_SelectedUMTS_Algorithms_integrityProtectionAlgorithm_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ChosenEncryptionAlgorithm( &pType->encryptionAlgorithm, pContext);
            pType->validity |= SS2_SelectedUMTS_Algorithms_encryptionAlgorithm_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_SelectedUMTS_Algorithms_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE CodecList Ber decoder */
static void AsnDecode_SS2_CodecList( SS2_CodecList *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Codec( &pType->codec1, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Codec( &pType->codec2, pContext);
            pType->validity |= SS2_CodecList_codec2_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Codec( &pType->codec3, pContext);
            pType->validity |= SS2_CodecList_codec3_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Codec( &pType->codec4, pContext);
            pType->validity |= SS2_CodecList_codec4_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Codec( &pType->codec5, pContext);
            pType->validity |= SS2_CodecList_codec5_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Codec( &pType->codec6, pContext);
            pType->validity |= SS2_CodecList_codec6_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 7;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Codec( &pType->codec7, pContext);
            pType->validity |= SS2_CodecList_codec7_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 8;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Codec( &pType->codec8, pContext);
            pType->validity |= SS2_CodecList_codec8_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 9;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_CodecList_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE SendEndSignal-Res Ber decoder */
extern U32 AsnDecode_SS2_SendEndSignal_Res( SS2_SendEndSignal_Res **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_SendEndSignal_Res *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_SendEndSignal_Res ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_SendEndSignal_Res_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SET OF RelocationNumberList Ber decoder */
static void AsnDecode_SS2_RelocationNumberList( SS2_RelocationNumberList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_RelocationNumber( &pType->element[i], pContext);
   }
}

/* SEQUENCE SendAuthenticationInfoArg Ber decoder */
extern U32 AsnDecode_SS2_SendAuthenticationInfoArg( SS2_SendAuthenticationInfoArg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_SendAuthenticationInfoArg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_SendAuthenticationInfoArg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_IMSI( &pType->imsi, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            pType->numberOfRequestedVectors = (U8)ber_get_integer( pContext ); 
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_SendAuthenticationInfoArg_segmentationProhibited_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_SendAuthenticationInfoArg_immediateResponsePreferred_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_Re_synchronisationInfo( &pType->re_synchronisationInfo, pContext);
            pType->validity |= SS2_SendAuthenticationInfoArg_re_synchronisationInfo_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_SendAuthenticationInfoArg_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_RequestingNodeType( &pType->requestingNodeType, pContext);
            pType->validity |= SS2_SendAuthenticationInfoArg_requestingNodeType_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_PLMN_Id( &pType->requestingPLMN_Id, pContext);
            pType->validity |= SS2_SendAuthenticationInfoArg_requestingPLMN_Id_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE CheckIMEI-Arg Ber decoder */
extern U32 AsnDecode_SS2_CheckIMEI_Arg( SS2_CheckIMEI_Arg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_CheckIMEI_Arg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_CheckIMEI_Arg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_IMEI( &pType->imei, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_RequestedEquipmentInfo( &pType->requestedEquipmentInfo, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_CheckIMEI_Arg_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE CheckIMEI-Res Ber decoder */
extern U32 AsnDecode_SS2_CheckIMEI_Res( SS2_CheckIMEI_Res **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_CheckIMEI_Res *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_CheckIMEI_Res ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_EquipmentStatus( &pType->equipmentStatus, pContext);
            pType->validity |= SS2_CheckIMEI_Res_equipmentStatus_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_UESBI_Iu( &pType->bmuef, pContext);
            pType->validity |= SS2_CheckIMEI_Res_bmuef_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_CheckIMEI_Res_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE PDP-Context Ber decoder */
static void AsnDecode_SS2_PDP_Context( SS2_PDP_Context *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            pType->pdp_ContextId = (U8)ber_get_integer( pContext ); 
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_PDP_Type( &pType->pdp_Type, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 17;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_PDP_Address( &pType->pdp_Address, pContext);
            pType->validity |= SS2_PDP_Context_pdp_Address_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 18;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_QoS_Subscribed( &pType->qos_Subscribed, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 19;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_PDP_Context_vplmnAddressAllowed_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 20;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_APN( &pType->apn, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 21;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_PDP_Context_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Ext_QoS_Subscribed( &pType->ext_QoS_Subscribed, pContext);
            pType->validity |= SS2_PDP_Context_ext_QoS_Subscribed_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ChargingCharacteristics( &pType->pdp_ChargingCharacteristics, pContext);
            pType->validity |= SS2_PDP_Context_pdp_ChargingCharacteristics_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Ext2_QoS_Subscribed( &pType->ext2_QoS_Subscribed, pContext);
            pType->validity |= SS2_PDP_Context_ext2_QoS_Subscribed_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE GPRS-CamelTDPData Ber decoder */
static void AsnDecode_SS2_GPRS_CamelTDPData( SS2_GPRS_CamelTDPData *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GPRS_TriggerDetectionPoint( &pType->gprs_TriggerDetectionPoint, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->serviceKey = (U32)ber_get_integer( pContext ); 
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->gsmSCF_Address, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_DefaultGPRS_Handling( &pType->defaultSessionHandling, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_GPRS_CamelTDPData_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE LSAData Ber decoder */
static void AsnDecode_SS2_LSAData( SS2_LSAData *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LSAIdentity( &pType->lsaIdentity, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LSAAttributes( &pType->lsaAttributes, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_LSAData_lsaActiveModeIndicator_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_LSAData_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE ODB-Data Ber decoder */
static void AsnDecode_SS2_ODB_Data( SS2_ODB_Data *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ODB_GeneralData( &pType->odb_GeneralData, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ODB_HPLMN_Data( &pType->odb_HPLMN_Data, pContext);
            pType->validity |= SS2_ODB_Data_odb_HPLMN_Data_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_ODB_Data_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE Ext-ForwFeature Ber decoder */
static void AsnDecode_SS2_Ext_ForwFeature( SS2_Ext_ForwFeature *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 0;
      {
         unsigned int sub_choice_tag_pre_list[]={2,3}, counter=0;
         pre_get_t(pContext, &pdu_tag);
         std_tag.tag=-1;
         for(counter=0;counter<2;counter++)
         {
            if(pdu_tag.tag==sub_choice_tag_pre_list[counter])
            {
               std_tag.tag=0;
               break;
            }
         }
      }
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_Ext_BasicServiceCode( &pType->basicService, pContext, tag);
            pType->validity |= SS2_Ext_ForwFeature_basicService_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Ext_SS_Status( &pType->ss_Status, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->forwardedToNumber, pContext);
            pType->validity |= SS2_Ext_ForwFeature_forwardedToNumber_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 8;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_SubaddressString( &pType->forwardedToSubaddress, pContext);
            pType->validity |= SS2_Ext_ForwFeature_forwardedToSubaddress_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Ext_ForwOptions( &pType->forwardingOptions, pContext);
            pType->validity |= SS2_Ext_ForwFeature_forwardingOptions_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 7;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->noReplyConditionTime = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_Ext_ForwFeature_noReplyConditionTime_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 9;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_Ext_ForwFeature_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_FTN_AddressString( &pType->longForwardedToNumber, pContext);
            pType->validity |= SS2_Ext_ForwFeature_longForwardedToNumber_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE Ext-CallBarringFeature Ber decoder */
static void AsnDecode_SS2_Ext_CallBarringFeature( SS2_Ext_CallBarringFeature *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 0;
      {
         unsigned int sub_choice_tag_pre_list[]={2,3}, counter=0;
         pre_get_t(pContext, &pdu_tag);
         std_tag.tag=-1;
         for(counter=0;counter<2;counter++)
         {
            if(pdu_tag.tag==sub_choice_tag_pre_list[counter])
            {
               std_tag.tag=0;
               break;
            }
         }
      }
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_Ext_BasicServiceCode( &pType->basicService, pContext, tag);
            pType->validity |= SS2_Ext_CallBarringFeature_basicService_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Ext_SS_Status( &pType->ss_Status, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_Ext_CallBarringFeature_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE CUG-Subscription Ber decoder */
static void AsnDecode_SS2_CUG_Subscription( SS2_CUG_Subscription *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            pType->cug_Index = (U16)ber_get_integer( pContext ); 
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_CUG_Interlock( &pType->cug_Interlock, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_IntraCUG_Options( &pType->intraCUG_Options, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_Ext_BasicServiceGroupList( &pType->basicServiceGroupList, pContext);
            pType->validity |= SS2_CUG_Subscription_basicServiceGroupList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_CUG_Subscription_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE CUG-Feature Ber decoder */
static void AsnDecode_SS2_CUG_Feature( SS2_CUG_Feature *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_Ext_BasicServiceCode( &pType->basicService, pContext, tag);
            pType->validity |= SS2_CUG_Feature_basicService_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            pType->preferentialCUG_Indicator = (U16)ber_get_integer( pContext ); 
            pType->validity |= SS2_CUG_Feature_preferentialCUG_Indicator_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_InterCUG_Restrictions( &pType->interCUG_Restrictions, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_CUG_Feature_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE Ext-SS-Data Ber decoder */
static void AsnDecode_SS2_Ext_SS_Data( SS2_Ext_SS_Data *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_SS_Code( &pType->ss_Code, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Ext_SS_Status( &pType->ss_Status, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 0;
      {
         unsigned int sub_choice_tag_pre_list[]={2,1}, counter=0;
         pre_get_t(pContext, &pdu_tag);
         std_tag.tag=-1;
         for(counter=0;counter<2;counter++)
         {
            if(pdu_tag.tag==sub_choice_tag_pre_list[counter])
            {
               std_tag.tag=0;
               break;
            }
         }
      }
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_SS_SubscriptionOption( &pType->ss_SubscriptionOption, pContext, tag);
            pType->validity |= SS2_Ext_SS_Data_ss_SubscriptionOption_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_Ext_BasicServiceGroupList( &pType->basicServiceGroupList, pContext);
            pType->validity |= SS2_Ext_SS_Data_basicServiceGroupList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_Ext_SS_Data_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE ServiceType Ber decoder */
static void AsnDecode_SS2_ServiceType( SS2_ServiceType *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            pType->serviceTypeIdentity = (U8)ber_get_integer( pContext ); 
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GMLC_Restriction( &pType->gmlc_Restriction, pContext);
            pType->validity |= SS2_ServiceType_gmlc_Restriction_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_NotificationToMSUser( &pType->notificationToMSUser, pContext);
            pType->validity |= SS2_ServiceType_notificationToMSUser_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_ServiceType_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE MOLR-Class Ber decoder */
static void AsnDecode_SS2_MOLR_Class( SS2_MOLR_Class *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_SS_Code( &pType->ss_Code, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_Ext_SS_Status( &pType->ss_Status, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_MOLR_Class_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE InsertSubscriberDataRes Ber decoder */
extern U32 AsnDecode_SS2_InsertSubscriberDataRes( SS2_InsertSubscriberDataRes **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_InsertSubscriberDataRes *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_InsertSubscriberDataRes ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_TeleserviceList( &pType->teleserviceList, pContext);
            pType->validity |= SS2_InsertSubscriberDataRes_teleserviceList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_BearerServiceList( &pType->bearerServiceList, pContext);
            pType->validity |= SS2_InsertSubscriberDataRes_bearerServiceList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SS_List( &pType->ss_List, pContext);
            pType->validity |= SS2_InsertSubscriberDataRes_ss_List_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ODB_GeneralData( &pType->odb_GeneralData, pContext);
            pType->validity |= SS2_InsertSubscriberDataRes_odb_GeneralData_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_RegionalSubscriptionResponse( &pType->regionalSubscriptionResponse, pContext);
            pType->validity |= SS2_InsertSubscriberDataRes_regionalSubscriptionResponse_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SupportedCamelPhases( &pType->supportedCamelPhases, pContext);
            pType->validity |= SS2_InsertSubscriberDataRes_supportedCamelPhases_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 7;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_InsertSubscriberDataRes_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 8;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_OfferedCamel4CSIs( &pType->offeredCamel4CSIs, pContext);
            pType->validity |= SS2_InsertSubscriberDataRes_offeredCamel4CSIs_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE DeleteSubscriberDataArg Ber decoder */
extern U32 AsnDecode_SS2_DeleteSubscriberDataArg( SS2_DeleteSubscriberDataArg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_DeleteSubscriberDataArg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_DeleteSubscriberDataArg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_IMSI( &pType->imsi, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_BasicServiceList( &pType->basicServiceList, pContext);
            pType->validity |= SS2_DeleteSubscriberDataArg_basicServiceList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SS_List( &pType->ss_List, pContext);
            pType->validity |= SS2_DeleteSubscriberDataArg_ss_List_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_DeleteSubscriberDataArg_roamingRestrictionDueToUnsupportedFeature_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ZoneCode( &pType->regionalSubscriptionIdentifier, pContext);
            pType->validity |= SS2_DeleteSubscriberDataArg_regionalSubscriptionIdentifier_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 7;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_DeleteSubscriberDataArg_vbsGroupIndication_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 8;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_DeleteSubscriberDataArg_vgcsGroupIndication_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 9;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_DeleteSubscriberDataArg_camelSubscriptionInfoWithdraw_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_DeleteSubscriberDataArg_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GPRSSubscriptionDataWithdraw( &pType->gprsSubscriptionDataWithdraw, pContext, tag);
            pType->validity |= SS2_DeleteSubscriberDataArg_gprsSubscriptionDataWithdraw_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 11;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_DeleteSubscriberDataArg_roamingRestrictedInSgsnDueToUnsuppportedFeature_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 12;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LSAInformationWithdraw( &pType->lsaInformationWithdraw, pContext, tag);
            pType->validity |= SS2_DeleteSubscriberDataArg_lsaInformationWithdraw_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 13;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_DeleteSubscriberDataArg_gmlc_ListWithdraw_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 14;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_DeleteSubscriberDataArg_istInformationWithdraw_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 15;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SpecificCSI_Withdraw( &pType->specificCSI_Withdraw, pContext);
            pType->validity |= SS2_DeleteSubscriberDataArg_specificCSI_Withdraw_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_DeleteSubscriberDataArg_chargingCharacteristicsWithdraw_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE DeleteSubscriberDataRes Ber decoder */
extern U32 AsnDecode_SS2_DeleteSubscriberDataRes( SS2_DeleteSubscriberDataRes **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_DeleteSubscriberDataRes *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_DeleteSubscriberDataRes ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_RegionalSubscriptionResponse( &pType->regionalSubscriptionResponse, pContext);
            pType->validity |= SS2_DeleteSubscriberDataRes_regionalSubscriptionResponse_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_DeleteSubscriberDataRes_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE MT-smsCAMELTDP-Criteria Ber decoder */
static void AsnDecode_SS2_MT_smsCAMELTDP_Criteria( SS2_MT_smsCAMELTDP_Criteria *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_SMS_TriggerDetectionPoint( &pType->sms_TriggerDetectionPoint, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_TPDU_TypeCriterion( &pType->tpdu_TypeCriterion, pContext);
            pType->validity |= SS2_MT_smsCAMELTDP_Criteria_tpdu_TypeCriterion_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE DP-AnalysedInfoCriterium Ber decoder */
static void AsnDecode_SS2_DP_AnalysedInfoCriterium( SS2_DP_AnalysedInfoCriterium *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->dialledNumber, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            pType->serviceKey = (U32)ber_get_integer( pContext ); 
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->gsmSCF_Address, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_DefaultCallHandling( &pType->defaultCallHandling, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_DP_AnalysedInfoCriterium_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE SS-CamelData Ber decoder */
static void AsnDecode_SS2_SS_CamelData( SS2_SS_CamelData *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_SS_EventList( &pType->ss_EventList, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->gsmSCF_Address, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_SS_CamelData_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE O-BcsmCamelTDPData Ber decoder */
static void AsnDecode_SS2_O_BcsmCamelTDPData( SS2_O_BcsmCamelTDPData *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_O_BcsmTriggerDetectionPoint( &pType->o_BcsmTriggerDetectionPoint, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            pType->serviceKey = (U32)ber_get_integer( pContext ); 
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->gsmSCF_Address, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_DefaultCallHandling( &pType->defaultCallHandling, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_O_BcsmCamelTDPData_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE O-BcsmCamelTDP-Criteria Ber decoder */
static void AsnDecode_SS2_O_BcsmCamelTDP_Criteria( SS2_O_BcsmCamelTDP_Criteria *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_O_BcsmTriggerDetectionPoint( &pType->o_BcsmTriggerDetectionPoint, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_DestinationNumberCriteria( &pType->destinationNumberCriteria, pContext);
            pType->validity |= SS2_O_BcsmCamelTDP_Criteria_destinationNumberCriteria_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_BasicServiceCriteria( &pType->basicServiceCriteria, pContext);
            pType->validity |= SS2_O_BcsmCamelTDP_Criteria_basicServiceCriteria_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_CallTypeCriteria( &pType->callTypeCriteria, pContext);
            pType->validity |= SS2_O_BcsmCamelTDP_Criteria_callTypeCriteria_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_O_CauseValueCriteria( &pType->o_CauseValueCriteria, pContext);
            pType->validity |= SS2_O_BcsmCamelTDP_Criteria_o_CauseValueCriteria_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_O_BcsmCamelTDP_Criteria_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE T-BCSM-CAMEL-TDP-Criteria Ber decoder */
static void AsnDecode_SS2_T_BCSM_CAMEL_TDP_Criteria( SS2_T_BCSM_CAMEL_TDP_Criteria *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_T_BcsmTriggerDetectionPoint( &pType->t_BCSM_TriggerDetectionPoint, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_BasicServiceCriteria( &pType->basicServiceCriteria, pContext);
            pType->validity |= SS2_T_BCSM_CAMEL_TDP_Criteria_basicServiceCriteria_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_T_CauseValueCriteria( &pType->t_CauseValueCriteria, pContext);
            pType->validity |= SS2_T_BCSM_CAMEL_TDP_Criteria_t_CauseValueCriteria_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE SMS-CAMEL-TDP-Data Ber decoder */
static void AsnDecode_SS2_SMS_CAMEL_TDP_Data( SS2_SMS_CAMEL_TDP_Data *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SMS_TriggerDetectionPoint( &pType->sms_TriggerDetectionPoint, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->serviceKey = (U32)ber_get_integer( pContext ); 
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->gsmSCF_Address, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_DefaultSMS_Handling( &pType->defaultSMS_Handling, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_SMS_CAMEL_TDP_Data_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE M-CSI Ber decoder */
static void AsnDecode_SS2_M_CSI( SS2_M_CSI *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_MobilityTriggers( &pType->mobilityTriggers, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            pType->serviceKey = (U32)ber_get_integer( pContext ); 
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->gsmSCF_Address, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_M_CSI_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_M_CSI_notificationToCSE_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_M_CSI_csi_Active_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE MG-CSI Ber decoder */
static void AsnDecode_SS2_MG_CSI( SS2_MG_CSI *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_MobilityTriggers( &pType->mobilityTriggers, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            pType->serviceKey = (U32)ber_get_integer( pContext ); 
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->gsmSCF_Address, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_MG_CSI_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_MG_CSI_notificationToCSE_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_MG_CSI_csi_Active_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE T-BcsmCamelTDPData Ber decoder */
static void AsnDecode_SS2_T_BcsmCamelTDPData( SS2_T_BcsmCamelTDPData *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_T_BcsmTriggerDetectionPoint( &pType->t_BcsmTriggerDetectionPoint, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            pType->serviceKey = (U32)ber_get_integer( pContext ); 
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->gsmSCF_Address, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_DefaultCallHandling( &pType->defaultCallHandling, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_T_BcsmCamelTDPData_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE SendRoutingInfoForGprsArg Ber decoder */
extern U32 AsnDecode_SS2_SendRoutingInfoForGprsArg( SS2_SendRoutingInfoForGprsArg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_SendRoutingInfoForGprsArg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_SendRoutingInfoForGprsArg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_IMSI( &pType->imsi, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GSN_Address( &pType->ggsn_Address, pContext);
            pType->validity |= SS2_SendRoutingInfoForGprsArg_ggsn_Address_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->ggsn_Number, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_SendRoutingInfoForGprsArg_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE SendRoutingInfoForGprsRes Ber decoder */
extern U32 AsnDecode_SS2_SendRoutingInfoForGprsRes( SS2_SendRoutingInfoForGprsRes **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_SendRoutingInfoForGprsRes *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_SendRoutingInfoForGprsRes ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GSN_Address( &pType->sgsn_Address, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GSN_Address( &pType->ggsn_Address, pContext);
            pType->validity |= SS2_SendRoutingInfoForGprsRes_ggsn_Address_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->mobileNotReachableReason = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_SendRoutingInfoForGprsRes_mobileNotReachableReason_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_SendRoutingInfoForGprsRes_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE FailureReportArg Ber decoder */
extern U32 AsnDecode_SS2_FailureReportArg( SS2_FailureReportArg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_FailureReportArg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_FailureReportArg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_IMSI( &pType->imsi, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->ggsn_Number, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GSN_Address( &pType->ggsn_Address, pContext);
            pType->validity |= SS2_FailureReportArg_ggsn_Address_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_FailureReportArg_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE FailureReportRes Ber decoder */
extern U32 AsnDecode_SS2_FailureReportRes( SS2_FailureReportRes **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_FailureReportRes *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_FailureReportRes ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GSN_Address( &pType->ggsn_Address, pContext);
            pType->validity |= SS2_FailureReportRes_ggsn_Address_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_FailureReportRes_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE NoteMsPresentForGprsArg Ber decoder */
extern U32 AsnDecode_SS2_NoteMsPresentForGprsArg( SS2_NoteMsPresentForGprsArg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_NoteMsPresentForGprsArg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_NoteMsPresentForGprsArg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_IMSI( &pType->imsi, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GSN_Address( &pType->sgsn_Address, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GSN_Address( &pType->ggsn_Address, pContext);
            pType->validity |= SS2_NoteMsPresentForGprsArg_ggsn_Address_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_NoteMsPresentForGprsArg_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE NoteMsPresentForGprsRes Ber decoder */
extern U32 AsnDecode_SS2_NoteMsPresentForGprsRes( SS2_NoteMsPresentForGprsRes **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_NoteMsPresentForGprsRes *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_NoteMsPresentForGprsRes ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_NoteMsPresentForGprsRes_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE RestoreDataArg Ber decoder */
extern U32 AsnDecode_SS2_RestoreDataArg( SS2_RestoreDataArg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_RestoreDataArg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_RestoreDataArg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_IMSI( &pType->imsi, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_LMSI( &pType->lmsi, pContext);
            pType->validity |= SS2_RestoreDataArg_lmsi_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_RestoreDataArg_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_VLR_Capability( &pType->vlr_Capability, pContext);
            pType->validity |= SS2_RestoreDataArg_vlr_Capability_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE RestoreDataRes Ber decoder */
extern U32 AsnDecode_SS2_RestoreDataRes( SS2_RestoreDataRes **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_RestoreDataRes *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_RestoreDataRes ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->hlr_Number, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_RestoreDataRes_msNotReachable_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_RestoreDataRes_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE VoiceGroupCallData Ber decoder */
static void AsnDecode_SS2_VoiceGroupCallData( SS2_VoiceGroupCallData *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_GroupId( &pType->groupId, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_VoiceGroupCallData_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE VoiceBroadcastData Ber decoder */
static void AsnDecode_SS2_VoiceBroadcastData( SS2_VoiceBroadcastData *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_GroupId( &pType->groupid, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_VoiceBroadcastData_broadcastInitEntitlement_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_VoiceBroadcastData_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE MNPInfoRes Ber decoder */
static void AsnDecode_SS2_MNPInfoRes( SS2_MNPInfoRes *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_RouteingNumber( &pType->routeingNumber, pContext);
            pType->validity |= SS2_MNPInfoRes_routeingNumber_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_IMSI( &pType->imsi, pContext);
            pType->validity |= SS2_MNPInfoRes_imsi_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->msisdn, pContext);
            pType->validity |= SS2_MNPInfoRes_msisdn_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_NumberPortabilityStatus( &pType->numberPortabilityStatus, pContext);
            pType->validity |= SS2_MNPInfoRes_numberPortabilityStatus_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_MNPInfoRes_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE RequestedInfo Ber decoder */
static void AsnDecode_SS2_RequestedInfo( SS2_RequestedInfo *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_RequestedInfo_locationInformation_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_RequestedInfo_subscriberState_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_RequestedInfo_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_RequestedInfo_currentLocation_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_DomainType( &pType->requestedDomain, pContext);
            pType->validity |= SS2_RequestedInfo_requestedDomain_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_RequestedInfo_imei_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_RequestedInfo_ms_classmark_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 7;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_RequestedInfo_mnpRequestedInfo_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE LocationInformation Ber decoder */
static void AsnDecode_SS2_LocationInformation( SS2_LocationInformation *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            pType->ageOfLocationInformation = (U16)ber_get_integer( pContext ); 
            pType->validity |= SS2_LocationInformation_ageOfLocationInformation_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GeographicalInformation( &pType->geographicalInformation, pContext);
            pType->validity |= SS2_LocationInformation_geographicalInformation_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->vlr_number, pContext);
            pType->validity |= SS2_LocationInformation_vlr_number_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LocationNumber( &pType->locationNumber, pContext);
            pType->validity |= SS2_LocationInformation_locationNumber_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_CellGlobalIdOrServiceAreaIdOrLAI( &pType->cellGlobalIdOrServiceAreaIdOrLAI, pContext, tag);
            pType->validity |= SS2_LocationInformation_cellGlobalIdOrServiceAreaIdOrLAI_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_LocationInformation_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LSAIdentity( &pType->selectedLSA_Id, pContext);
            pType->validity |= SS2_LocationInformation_selectedLSA_Id_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->msc_Number, pContext);
            pType->validity |= SS2_LocationInformation_msc_Number_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 7;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GeodeticInformation( &pType->geodeticInformation, pContext);
            pType->validity |= SS2_LocationInformation_geodeticInformation_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 8;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_LocationInformation_currentLocationRetrieved_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 9;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_LocationInformation_sai_Present_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE LocationInformationGPRS Ber decoder */
static void AsnDecode_SS2_LocationInformationGPRS( SS2_LocationInformationGPRS *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_CellGlobalIdOrServiceAreaIdOrLAI( &pType->cellGlobalIdOrServiceAreaIdOrLAI, pContext, tag);
            pType->validity |= SS2_LocationInformationGPRS_cellGlobalIdOrServiceAreaIdOrLAI_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_RAIdentity( &pType->routeingAreaIdentity, pContext);
            pType->validity |= SS2_LocationInformationGPRS_routeingAreaIdentity_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GeographicalInformation( &pType->geographicalInformation, pContext);
            pType->validity |= SS2_LocationInformationGPRS_geographicalInformation_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->sgsn_Number, pContext);
            pType->validity |= SS2_LocationInformationGPRS_sgsn_Number_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LSAIdentity( &pType->selectedLSAIdentity, pContext);
            pType->validity |= SS2_LocationInformationGPRS_selectedLSAIdentity_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_LocationInformationGPRS_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_LocationInformationGPRS_sai_Present_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 7;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GeodeticInformation( &pType->geodeticInformation, pContext);
            pType->validity |= SS2_LocationInformationGPRS_geodeticInformation_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 8;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_LocationInformationGPRS_currentLocationRetrieved_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 9;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->ageOfLocationInformation = (U16)ber_get_integer( pContext ); 
            pType->validity |= SS2_LocationInformationGPRS_ageOfLocationInformation_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE PDP-ContextInfo Ber decoder */
static void AsnDecode_SS2_PDP_ContextInfo( SS2_PDP_ContextInfo *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->pdp_ContextIdentifier = (U8)ber_get_integer( pContext ); 
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_PDP_ContextInfo_pdp_ContextActive_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_PDP_Type( &pType->pdp_Type, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_PDP_Address( &pType->pdp_Address, pContext);
            pType->validity |= SS2_PDP_ContextInfo_pdp_Address_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_APN( &pType->apn_Subscribed, pContext);
            pType->validity |= SS2_PDP_ContextInfo_apn_Subscribed_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_APN( &pType->apn_InUse, pContext);
            pType->validity |= SS2_PDP_ContextInfo_apn_InUse_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->nsapi = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_PDP_ContextInfo_nsapi_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 7;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_TransactionId( &pType->transactionId, pContext);
            pType->validity |= SS2_PDP_ContextInfo_transactionId_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 8;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_TEID( &pType->teid_ForGnAndGp, pContext);
            pType->validity |= SS2_PDP_ContextInfo_teid_ForGnAndGp_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 9;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_TEID( &pType->teid_ForIu, pContext);
            pType->validity |= SS2_PDP_ContextInfo_teid_ForIu_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GSN_Address( &pType->ggsn_Address, pContext);
            pType->validity |= SS2_PDP_ContextInfo_ggsn_Address_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 11;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Ext_QoS_Subscribed( &pType->qos_Subscribed, pContext);
            pType->validity |= SS2_PDP_ContextInfo_qos_Subscribed_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 12;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Ext_QoS_Subscribed( &pType->qos_Requested, pContext);
            pType->validity |= SS2_PDP_ContextInfo_qos_Requested_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 13;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Ext_QoS_Subscribed( &pType->qos_Negotiated, pContext);
            pType->validity |= SS2_PDP_ContextInfo_qos_Negotiated_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 14;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GPRSChargingID( &pType->chargingId, pContext);
            pType->validity |= SS2_PDP_ContextInfo_chargingId_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 15;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ChargingCharacteristics( &pType->chargingCharacteristics, pContext);
            pType->validity |= SS2_PDP_ContextInfo_chargingCharacteristics_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GSN_Address( &pType->rnc_Address, pContext);
            pType->validity |= SS2_PDP_ContextInfo_rnc_Address_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 17;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_PDP_ContextInfo_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 18;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Ext2_QoS_Subscribed( &pType->qos2_Subscribed, pContext);
            pType->validity |= SS2_PDP_ContextInfo_qos2_Subscribed_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 19;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Ext2_QoS_Subscribed( &pType->qos2_Requested, pContext);
            pType->validity |= SS2_PDP_ContextInfo_qos2_Requested_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 20;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Ext2_QoS_Subscribed( &pType->qos2_Negotiated, pContext);
            pType->validity |= SS2_PDP_ContextInfo_qos2_Negotiated_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE AnyTimeInterrogationArg Ber decoder */
extern U32 AsnDecode_SS2_AnyTimeInterrogationArg( SS2_AnyTimeInterrogationArg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_AnyTimeInterrogationArg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_AnyTimeInterrogationArg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SubscriberIdentity( &pType->subscriberIdentity, pContext, tag);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_RequestedInfo( &pType->requestedInfo, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->gsmSCF_Address, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_AnyTimeInterrogationArg_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE RequestedSubscriptionInfo Ber decoder */
static void AsnDecode_SS2_RequestedSubscriptionInfo( SS2_RequestedSubscriptionInfo *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SS_ForBS_Code( &pType->requestedSS_Info, pContext);
            pType->validity |= SS2_RequestedSubscriptionInfo_requestedSS_Info_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_RequestedSubscriptionInfo_odb_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_RequestedCAMEL_SubscriptionInfo( &pType->requestedCAMEL_SubscriptionInfo, pContext);
            pType->validity |= SS2_RequestedSubscriptionInfo_requestedCAMEL_SubscriptionInfo_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_RequestedSubscriptionInfo_supportedVLR_CAMEL_Phases_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_RequestedSubscriptionInfo_supportedSGSN_CAMEL_Phases_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_RequestedSubscriptionInfo_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 7;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_AdditionalRequestedCAMEL_SubscriptionInfo( &pType->additionalRequestedCAMEL_SubscriptionInfo, pContext);
            pType->validity |= SS2_RequestedSubscriptionInfo_additionalRequestedCAMEL_SubscriptionInfo_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE ODB-Info Ber decoder */
static void AsnDecode_SS2_ODB_Info( SS2_ODB_Info *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ODB_Data( &pType->odb_Data, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_ODB_Info_notificationToCSE_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_ODB_Info_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE ModificationRequestFor-CF-Info Ber decoder */
static void AsnDecode_SS2_ModificationRequestFor_CF_Info( SS2_ModificationRequestFor_CF_Info *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SS_Code( &pType->ss_Code, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Ext_BasicServiceCode( &pType->basicService, pContext, tag);
            pType->validity |= SS2_ModificationRequestFor_CF_Info_basicService_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Ext_SS_Status( &pType->ss_Status, pContext);
            pType->validity |= SS2_ModificationRequestFor_CF_Info_ss_Status_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_AddressString( &pType->forwardedToNumber, pContext);
            pType->validity |= SS2_ModificationRequestFor_CF_Info_forwardedToNumber_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_SubaddressString( &pType->forwardedToSubaddress, pContext);
            pType->validity |= SS2_ModificationRequestFor_CF_Info_forwardedToSubaddress_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->noReplyConditionTime = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_ModificationRequestFor_CF_Info_noReplyConditionTime_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ModificationInstruction( &pType->modifyNotificationToCSE, pContext);
            pType->validity |= SS2_ModificationRequestFor_CF_Info_modifyNotificationToCSE_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 7;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_ModificationRequestFor_CF_Info_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE ModificationRequestFor-CB-Info Ber decoder */
static void AsnDecode_SS2_ModificationRequestFor_CB_Info( SS2_ModificationRequestFor_CB_Info *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SS_Code( &pType->ss_Code, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Ext_BasicServiceCode( &pType->basicService, pContext, tag);
            pType->validity |= SS2_ModificationRequestFor_CB_Info_basicService_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Ext_SS_Status( &pType->ss_Status, pContext);
            pType->validity |= SS2_ModificationRequestFor_CB_Info_ss_Status_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Password( &pType->password, pContext);
            pType->validity |= SS2_ModificationRequestFor_CB_Info_password_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->wrongPasswordAttemptsCounter = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_ModificationRequestFor_CB_Info_wrongPasswordAttemptsCounter_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ModificationInstruction( &pType->modifyNotificationToCSE, pContext);
            pType->validity |= SS2_ModificationRequestFor_CB_Info_modifyNotificationToCSE_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_ModificationRequestFor_CB_Info_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE ModificationRequestFor-ODB-data Ber decoder */
static void AsnDecode_SS2_ModificationRequestFor_ODB_data( SS2_ModificationRequestFor_ODB_data *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ODB_Data( &pType->odb_data, pContext);
            pType->validity |= SS2_ModificationRequestFor_ODB_data_odb_data_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ModificationInstruction( &pType->modifyNotificationToCSE, pContext);
            pType->validity |= SS2_ModificationRequestFor_ODB_data_modifyNotificationToCSE_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_ModificationRequestFor_ODB_data_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE ModificationRequestFor-CSI Ber decoder */
static void AsnDecode_SS2_ModificationRequestFor_CSI( SS2_ModificationRequestFor_CSI *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_RequestedCAMEL_SubscriptionInfo( &pType->requestedCamel_SubscriptionInfo, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ModificationInstruction( &pType->modifyNotificationToCSE, pContext);
            pType->validity |= SS2_ModificationRequestFor_CSI_modifyNotificationToCSE_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ModificationInstruction( &pType->modifyCSI_State, pContext);
            pType->validity |= SS2_ModificationRequestFor_CSI_modifyCSI_State_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_ModificationRequestFor_CSI_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_AdditionalRequestedCAMEL_SubscriptionInfo( &pType->additionalRequestedCAMEL_SubscriptionInfo, pContext);
            pType->validity |= SS2_ModificationRequestFor_CSI_additionalRequestedCAMEL_SubscriptionInfo_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE NoteSubscriberDataModifiedRes Ber decoder */
extern U32 AsnDecode_SS2_NoteSubscriberDataModifiedRes( SS2_NoteSubscriberDataModifiedRes **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_NoteSubscriberDataModifiedRes *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_NoteSubscriberDataModifiedRes ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_NoteSubscriberDataModifiedRes_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE NoteMM-EventArg Ber decoder */
extern U32 AsnDecode_SS2_NoteMM_EventArg( SS2_NoteMM_EventArg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_NoteMM_EventArg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_NoteMM_EventArg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            pType->serviceKey = (U32)ber_get_integer( pContext ); 
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_MM_Code( &pType->eventMet, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_IMSI( &pType->imsi, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->msisdn, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LocationInformation( &pType->locationInformation, pContext);
            pType->validity |= SS2_NoteMM_EventArg_locationInformation_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SupportedCamelPhases( &pType->supportedCAMELPhases, pContext);
            pType->validity |= SS2_NoteMM_EventArg_supportedCAMELPhases_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_NoteMM_EventArg_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 7;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LocationInformationGPRS( &pType->locationInformationGPRS, pContext);
            pType->validity |= SS2_NoteMM_EventArg_locationInformationGPRS_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 8;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_OfferedCamel4Functionalities( &pType->offeredCamel4Functionalities, pContext);
            pType->validity |= SS2_NoteMM_EventArg_offeredCamel4Functionalities_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE NoteMM-EventRes Ber decoder */
extern U32 AsnDecode_SS2_NoteMM_EventRes( SS2_NoteMM_EventRes **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_NoteMM_EventRes *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_NoteMM_EventRes ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_NoteMM_EventRes_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE ActivateTraceModeArg Ber decoder */
extern U32 AsnDecode_SS2_ActivateTraceModeArg( SS2_ActivateTraceModeArg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_ActivateTraceModeArg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_ActivateTraceModeArg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_IMSI( &pType->imsi, pContext);
            pType->validity |= SS2_ActivateTraceModeArg_imsi_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_TraceReference( &pType->traceReference, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->traceType = (U8)ber_get_integer( pContext ); 
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_AddressString( &pType->omc_Id, pContext);
            pType->validity |= SS2_ActivateTraceModeArg_omc_Id_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_ActivateTraceModeArg_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_TraceReference2( &pType->traceReference2, pContext);
            pType->validity |= SS2_ActivateTraceModeArg_traceReference2_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_TraceDepthList( &pType->traceDepthList, pContext);
            pType->validity |= SS2_ActivateTraceModeArg_traceDepthList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 7;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_TraceNE_TypeList( &pType->traceNE_TypeList, pContext);
            pType->validity |= SS2_ActivateTraceModeArg_traceNE_TypeList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 8;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_TraceInterfaceList( &pType->traceInterfaceList, pContext);
            pType->validity |= SS2_ActivateTraceModeArg_traceInterfaceList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 9;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_TraceEventList( &pType->traceEventList, pContext);
            pType->validity |= SS2_ActivateTraceModeArg_traceEventList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE ActivateTraceModeRes Ber decoder */
extern U32 AsnDecode_SS2_ActivateTraceModeRes( SS2_ActivateTraceModeRes **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_ActivateTraceModeRes *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_ActivateTraceModeRes ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_ActivateTraceModeRes_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_ActivateTraceModeRes_traceSupportIndicator_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE DeactivateTraceModeArg Ber decoder */
extern U32 AsnDecode_SS2_DeactivateTraceModeArg( SS2_DeactivateTraceModeArg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_DeactivateTraceModeArg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_DeactivateTraceModeArg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_IMSI( &pType->imsi, pContext);
            pType->validity |= SS2_DeactivateTraceModeArg_imsi_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_TraceReference( &pType->traceReference, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_DeactivateTraceModeArg_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_TraceReference2( &pType->traceReference2, pContext);
            pType->validity |= SS2_DeactivateTraceModeArg_traceReference2_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE DeactivateTraceModeRes Ber decoder */
extern U32 AsnDecode_SS2_DeactivateTraceModeRes( SS2_DeactivateTraceModeRes **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_DeactivateTraceModeRes *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_DeactivateTraceModeRes ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_DeactivateTraceModeRes_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE RoutingInfoForSM-Arg Ber decoder */
extern U32 AsnDecode_SS2_RoutingInfoForSM_Arg( SS2_RoutingInfoForSM_Arg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_RoutingInfoForSM_Arg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_RoutingInfoForSM_Arg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->msisdn, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            applib2_getShortBits(pContext, 16);
            pType->sm_RP_PRI = applib2_getShortBits(pContext, 8) == 0 ? FALSE : TRUE ;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_AddressString( &pType->serviceCentreAddress, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_RoutingInfoForSM_Arg_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 7;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_RoutingInfoForSM_Arg_gprsSupportIndicator_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 8;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->sm_RP_MTI = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_RoutingInfoForSM_Arg_sm_RP_MTI_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 9;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SM_RP_SMEA( &pType->sm_RP_SMEA, pContext);
            pType->validity |= SS2_RoutingInfoForSM_Arg_sm_RP_SMEA_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE LocationInfoWithLMSI Ber decoder */
static void AsnDecode_SS2_LocationInfoWithLMSI( SS2_LocationInfoWithLMSI *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->networkNode_Number, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_LMSI( &pType->lmsi, pContext);
            pType->validity |= SS2_LocationInfoWithLMSI_lmsi_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_LocationInfoWithLMSI_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_LocationInfoWithLMSI_gprsNodeIndicator_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Additional_Number( &pType->additional_Number, pContext, tag);
            pType->validity |= SS2_LocationInfoWithLMSI_additional_Number_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE MO-ForwardSM-Arg Ber decoder */
extern U32 AsnDecode_SS2_MO_ForwardSM_Arg( SS2_MO_ForwardSM_Arg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_MO_ForwardSM_Arg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_MO_ForwardSM_Arg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_SM_RP_DA( &pType->sm_RP_DA, pContext, tag);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_SM_RP_OA( &pType->sm_RP_OA, pContext, tag);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_SignalInfo( &pType->sm_RP_UI, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_MO_ForwardSM_Arg_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_IMSI( &pType->imsi, pContext);
            pType->validity |= SS2_MO_ForwardSM_Arg_imsi_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE MO-ForwardSM-Res Ber decoder */
extern U32 AsnDecode_SS2_MO_ForwardSM_Res( SS2_MO_ForwardSM_Res **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_MO_ForwardSM_Res *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_MO_ForwardSM_Res ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_SignalInfo( &pType->sm_RP_UI, pContext);
            pType->validity |= SS2_MO_ForwardSM_Res_sm_RP_UI_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_MO_ForwardSM_Res_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE MT-ForwardSM-Arg Ber decoder */
extern U32 AsnDecode_SS2_MT_ForwardSM_Arg( SS2_MT_ForwardSM_Arg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_MT_ForwardSM_Arg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_MT_ForwardSM_Arg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_SM_RP_DA( &pType->sm_RP_DA, pContext, tag);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_SM_RP_OA( &pType->sm_RP_OA, pContext, tag);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_SignalInfo( &pType->sm_RP_UI, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_MT_ForwardSM_Arg_moreMessagesToSend_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_MT_ForwardSM_Arg_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE MT-ForwardSM-Res Ber decoder */
extern U32 AsnDecode_SS2_MT_ForwardSM_Res( SS2_MT_ForwardSM_Res **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_MT_ForwardSM_Res *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_MT_ForwardSM_Res ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_SignalInfo( &pType->sm_RP_UI, pContext);
            pType->validity |= SS2_MT_ForwardSM_Res_sm_RP_UI_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_MT_ForwardSM_Res_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE ReportSM-DeliveryStatusArg Ber decoder */
extern U32 AsnDecode_SS2_ReportSM_DeliveryStatusArg( SS2_ReportSM_DeliveryStatusArg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_ReportSM_DeliveryStatusArg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_ReportSM_DeliveryStatusArg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->msisdn, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_AddressString( &pType->serviceCentreAddress, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_SM_DeliveryOutcome( &pType->sm_DeliveryOutcome, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->absentSubscriberDiagnosticSM = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_ReportSM_DeliveryStatusArg_absentSubscriberDiagnosticSM_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_ReportSM_DeliveryStatusArg_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_ReportSM_DeliveryStatusArg_gprsSupportIndicator_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_ReportSM_DeliveryStatusArg_deliveryOutcomeIndicator_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SM_DeliveryOutcome( &pType->additionalSM_DeliveryOutcome, pContext);
            pType->validity |= SS2_ReportSM_DeliveryStatusArg_additionalSM_DeliveryOutcome_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->additionalAbsentSubscriberDiagnosticSM = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_ReportSM_DeliveryStatusArg_additionalAbsentSubscriberDiagnosticSM_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE ReportSM-DeliveryStatusRes Ber decoder */
extern U32 AsnDecode_SS2_ReportSM_DeliveryStatusRes( SS2_ReportSM_DeliveryStatusRes **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_ReportSM_DeliveryStatusRes *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_ReportSM_DeliveryStatusRes ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->storedMSISDN, pContext);
            pType->validity |= SS2_ReportSM_DeliveryStatusRes_storedMSISDN_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_ReportSM_DeliveryStatusRes_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE InformServiceCentreArg Ber decoder */
extern U32 AsnDecode_SS2_InformServiceCentreArg( SS2_InformServiceCentreArg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_InformServiceCentreArg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_InformServiceCentreArg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->storedMSISDN, pContext);
            pType->validity |= SS2_InformServiceCentreArg_storedMSISDN_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_MW_Status( &pType->mw_Status, pContext);
            pType->validity |= SS2_InformServiceCentreArg_mw_Status_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_InformServiceCentreArg_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            pType->absentSubscriberDiagnosticSM = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_InformServiceCentreArg_absentSubscriberDiagnosticSM_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->additionalAbsentSubscriberDiagnosticSM = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_InformServiceCentreArg_additionalAbsentSubscriberDiagnosticSM_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE ReadyForSM-Arg Ber decoder */
extern U32 AsnDecode_SS2_ReadyForSM_Arg( SS2_ReadyForSM_Arg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_ReadyForSM_Arg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_ReadyForSM_Arg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_IMSI( &pType->imsi, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_AlertReason( &pType->alertReason, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_ReadyForSM_Arg_alertReasonIndicator_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_ReadyForSM_Arg_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE ReadyForSM-Res Ber decoder */
extern U32 AsnDecode_SS2_ReadyForSM_Res( SS2_ReadyForSM_Res **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_ReadyForSM_Res *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_ReadyForSM_Res ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_ReadyForSM_Res_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SET OF ForwardingFeatureList Ber decoder */
static void AsnDecode_SS2_ForwardingFeatureList( SS2_ForwardingFeatureList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_ForwardingFeature( &pType->element[i], pContext);
   }
}

/* SET OF CallBarringFeatureList Ber decoder */
static void AsnDecode_SS2_CallBarringFeatureList( SS2_CallBarringFeatureList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_CallBarringFeature( &pType->element[i], pContext);
   }
}

/* SEQUENCE SS-Data Ber decoder */
static void AsnDecode_SS2_SS_Data( SS2_SS_Data *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_SS_Code( &pType->ss_Code, pContext);
            pType->validity |= SS2_SS_Data_ss_Code_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SS_Status( &pType->ss_Status, pContext);
            pType->validity |= SS2_SS_Data_ss_Status_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 0;
      {
         unsigned int sub_choice_tag_pre_list[]={2,1}, counter=0;
         pre_get_t(pContext, &pdu_tag);
         std_tag.tag=-1;
         for(counter=0;counter<2;counter++)
         {
            if(pdu_tag.tag==sub_choice_tag_pre_list[counter])
            {
               std_tag.tag=0;
               break;
            }
         }
      }
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_SS_SubscriptionOption( &pType->ss_SubscriptionOption, pContext, tag);
            pType->validity |= SS2_SS_Data_ss_SubscriptionOption_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_BasicServiceGroupList( &pType->basicServiceGroupList, pContext);
            pType->validity |= SS2_SS_Data_basicServiceGroupList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            pType->defaultPriority = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_SS_Data_defaultPriority_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->nbrUser = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_SS_Data_nbrUser_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SET OF CCBS-FeatureList Ber decoder */
static void AsnDecode_SS2_CCBS_FeatureList( SS2_CCBS_FeatureList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_CCBS_Feature( &pType->element[i], pContext);
   }
}

/* SEQUENCE SS-InvocationNotificationArg Ber decoder */
extern U32 AsnDecode_SS2_SS_InvocationNotificationArg( SS2_SS_InvocationNotificationArg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_SS_InvocationNotificationArg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_SS_InvocationNotificationArg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_IMSI( &pType->imsi, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->msisdn, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SS_Code( &pType->ss_Event, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SS_EventSpecification( &pType->ss_EventSpecification, pContext);
            pType->validity |= SS2_SS_InvocationNotificationArg_ss_EventSpecification_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_SS_InvocationNotificationArg_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->b_subscriberNumber, pContext);
            pType->validity |= SS2_SS_InvocationNotificationArg_b_subscriberNumber_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_CCBS_RequestState( &pType->ccbs_RequestState, pContext);
            pType->validity |= SS2_SS_InvocationNotificationArg_ccbs_RequestState_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE SS-InvocationNotificationRes Ber decoder */
extern U32 AsnDecode_SS2_SS_InvocationNotificationRes( SS2_SS_InvocationNotificationRes **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_SS_InvocationNotificationRes *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_SS_InvocationNotificationRes ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_SS_InvocationNotificationRes_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* CHOICE Reject-problem Ber decoder */
static void AsnDecode_SS2_Reject_problem( SS2_Reject_problem *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV		seq_tlv;
      pre_get_t(pContext, &seq_tlv.t);
      if(ContextSpecific == seq_tlv.t.cl && tag.is_tagged == TRUE)
         get_tl(pContext, &seq_tlv);
   }
   
   {
      BER_TAG   pdu_tag;
      
      pre_get_t(pContext, &pdu_tag);
      
      if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 0) )
      {
         pType->choice.general = (S32)ber_get_integer( pContext ); 
         
         pType->selection = SS2_Reject_problem_general_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 1) )
      {
         pType->choice.invoke = (S32)ber_get_integer( pContext ); 
         
         pType->selection = SS2_Reject_problem_invoke_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 2) )
      {
         pType->choice.returnResult = (S32)ber_get_integer( pContext ); 
         
         pType->selection = SS2_Reject_problem_returnResult_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 3) )
      {
         pType->choice.returnError = (S32)ber_get_integer( pContext ); 
         
         pType->selection = SS2_Reject_problem_returnError_selected;
      }
   }
   
}

/* SEQUENCE Reject Ber decoder */
extern U32 AsnDecode_SS2_Reject( SS2_Reject **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_Reject *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_Reject ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_InvokeId( &pType->invokeId, pContext, tag);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_Reject_problem( &pType->problem, pContext, tag);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE ForwardChargeAdviceArg Ber decoder */
extern U32 AsnDecode_SS2_ForwardChargeAdviceArg( SS2_ForwardChargeAdviceArg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_ForwardChargeAdviceArg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_ForwardChargeAdviceArg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SS_Code( &pType->ss_Code, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ChargingInformation( &pType->chargingInformation, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE ECT-Indicator Ber decoder */
extern U32 AsnDecode_SS2_ECT_Indicator( SS2_ECT_Indicator **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_ECT_Indicator *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_ECT_Indicator ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ECT_CallState( &pType->ect_CallState, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_RDN( &pType->rdn, pContext, tag);
            pType->validity |= SS2_ECT_Indicator_rdn_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE NameIndicator Ber decoder */
extern U32 AsnDecode_SS2_NameIndicator( SS2_NameIndicator **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_NameIndicator *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_NameIndicator ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Name( &pType->callingName, pContext, tag);
            pType->validity |= SS2_NameIndicator_callingName_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE ExternalSignalInfo Ber decoder */
static void AsnDecode_SS2_ExternalSignalInfo( SS2_ExternalSignalInfo *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ProtocolId( &pType->protocolId, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_SignalInfo( &pType->signalInfo, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_ExternalSignalInfo_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE Ext-ExternalSignalInfo Ber decoder */
extern U32 AsnDecode_SS2_Ext_ExternalSignalInfo( SS2_Ext_ExternalSignalInfo **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_Ext_ExternalSignalInfo *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_Ext_ExternalSignalInfo ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_Ext_ProtocolId( &pType->ext_ProtocolId, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_SignalInfo( &pType->signalInfo, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_Ext_ExternalSignalInfo_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE AccessNetworkSignalInfo Ber decoder */
static void AsnDecode_SS2_AccessNetworkSignalInfo( SS2_AccessNetworkSignalInfo *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_AccessNetworkProtocolId( &pType->accessNetworkProtocolId, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_LongSignalInfo( &pType->signalInfo, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_AccessNetworkSignalInfo_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE NAEA-PreferredCI Ber decoder */
static void AsnDecode_SS2_NAEA_PreferredCI( SS2_NAEA_PreferredCI *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_NAEA_CIC( &pType->naea_PreferredCIC, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_NAEA_PreferredCI_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE LCSClientExternalID Ber decoder */
static void AsnDecode_SS2_LCSClientExternalID( SS2_LCSClientExternalID *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->externalAddress, pContext);
            pType->validity |= SS2_LCSClientExternalID_externalAddress_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_LCSClientExternalID_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE EMLPP-Info Ber decoder */
static void AsnDecode_SS2_EMLPP_Info( SS2_EMLPP_Info *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            pType->maximumentitledPriority = (U8)ber_get_integer( pContext ); 
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            pType->defaultPriority = (U8)ber_get_integer( pContext ); 
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_EMLPP_Info_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE MC-SS-Info Ber decoder */
static void AsnDecode_SS2_MC_SS_Info( SS2_MC_SS_Info *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SS_Code( &pType->ss_Code, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Ext_SS_Status( &pType->ss_Status, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->nbrSB = (U8)ber_get_integer( pContext ); 
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->nbrUser = (U8)ber_get_integer( pContext ); 
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_MC_SS_Info_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE RoamingNotAllowedParam Ber decoder */
extern U32 AsnDecode_SS2_RoamingNotAllowedParam( SS2_RoamingNotAllowedParam **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_RoamingNotAllowedParam *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_RoamingNotAllowedParam ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_RoamingNotAllowedCause( &pType->roamingNotAllowedCause, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_RoamingNotAllowedParam_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE ExtensibleCallBarredParam Ber decoder */
static void AsnDecode_SS2_ExtensibleCallBarredParam( SS2_ExtensibleCallBarredParam *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_CallBarringCause( &pType->callBarringCause, pContext);
            pType->validity |= SS2_ExtensibleCallBarredParam_callBarringCause_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_ExtensibleCallBarredParam_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_ExtensibleCallBarredParam_unauthorisedMessageOriginator_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE CUG-RejectParam Ber decoder */
extern U32 AsnDecode_SS2_CUG_RejectParam( SS2_CUG_RejectParam **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_CUG_RejectParam *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_CUG_RejectParam ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_CUG_RejectCause( &pType->cug_RejectCause, pContext);
            pType->validity |= SS2_CUG_RejectParam_cug_RejectCause_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_CUG_RejectParam_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE SM-DeliveryFailureCause Ber decoder */
extern U32 AsnDecode_SS2_SM_DeliveryFailureCause( SS2_SM_DeliveryFailureCause **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_SM_DeliveryFailureCause *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_SM_DeliveryFailureCause ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_SM_EnumeratedDeliveryFailureCause( &pType->sm_EnumeratedDeliveryFailureCause, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_SignalInfo( &pType->diagnosticInfo, pContext);
            pType->validity |= SS2_SM_DeliveryFailureCause_diagnosticInfo_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_SM_DeliveryFailureCause_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE AbsentSubscriberSM-Param Ber decoder */
extern U32 AsnDecode_SS2_AbsentSubscriberSM_Param( SS2_AbsentSubscriberSM_Param **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_AbsentSubscriberSM_Param *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_AbsentSubscriberSM_Param ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            pType->absentSubscriberDiagnosticSM = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_AbsentSubscriberSM_Param_absentSubscriberDiagnosticSM_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_AbsentSubscriberSM_Param_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->additionalAbsentSubscriberDiagnosticSM = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_AbsentSubscriberSM_Param_additionalAbsentSubscriberDiagnosticSM_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE ExtensibleSystemFailureParam Ber decoder */
static void AsnDecode_SS2_ExtensibleSystemFailureParam( SS2_ExtensibleSystemFailureParam *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_NetworkResource( &pType->networkResource, pContext);
            pType->validity |= SS2_ExtensibleSystemFailureParam_networkResource_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_ExtensibleSystemFailureParam_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_AdditionalNetworkResource( &pType->additionalNetworkResource, pContext);
            pType->validity |= SS2_ExtensibleSystemFailureParam_additionalNetworkResource_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE DataMissingParam Ber decoder */
extern U32 AsnDecode_SS2_DataMissingParam( SS2_DataMissingParam **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_DataMissingParam *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_DataMissingParam ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_DataMissingParam_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE UnexpectedDataParam Ber decoder */
extern U32 AsnDecode_SS2_UnexpectedDataParam( SS2_UnexpectedDataParam **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_UnexpectedDataParam *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_UnexpectedDataParam ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_UnexpectedDataParam_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE FacilityNotSupParam Ber decoder */
extern U32 AsnDecode_SS2_FacilityNotSupParam( SS2_FacilityNotSupParam **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_FacilityNotSupParam *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_FacilityNotSupParam ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_FacilityNotSupParam_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_FacilityNotSupParam_shapeOfLocationEstimateNotSupported_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_FacilityNotSupParam_neededLcsCapabilityNotSupportedInServingNode_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE OR-NotAllowedParam Ber decoder */
extern U32 AsnDecode_SS2_OR_NotAllowedParam( SS2_OR_NotAllowedParam **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_OR_NotAllowedParam *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_OR_NotAllowedParam ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_OR_NotAllowedParam_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE UnknownSubscriberParam Ber decoder */
extern U32 AsnDecode_SS2_UnknownSubscriberParam( SS2_UnknownSubscriberParam **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_UnknownSubscriberParam *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_UnknownSubscriberParam ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_UnknownSubscriberParam_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_UnknownSubscriberDiagnostic( &pType->unknownSubscriberDiagnostic, pContext);
            pType->validity |= SS2_UnknownSubscriberParam_unknownSubscriberDiagnostic_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE NumberChangedParam Ber decoder */
extern U32 AsnDecode_SS2_NumberChangedParam( SS2_NumberChangedParam **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_NumberChangedParam *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_NumberChangedParam ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_NumberChangedParam_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE UnidentifiedSubParam Ber decoder */
extern U32 AsnDecode_SS2_UnidentifiedSubParam( SS2_UnidentifiedSubParam **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_UnidentifiedSubParam *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_UnidentifiedSubParam ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_UnidentifiedSubParam_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE IllegalSubscriberParam Ber decoder */
extern U32 AsnDecode_SS2_IllegalSubscriberParam( SS2_IllegalSubscriberParam **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_IllegalSubscriberParam *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_IllegalSubscriberParam ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_IllegalSubscriberParam_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE IllegalEquipmentParam Ber decoder */
extern U32 AsnDecode_SS2_IllegalEquipmentParam( SS2_IllegalEquipmentParam **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_IllegalEquipmentParam *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_IllegalEquipmentParam ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_IllegalEquipmentParam_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE BearerServNotProvParam Ber decoder */
extern U32 AsnDecode_SS2_BearerServNotProvParam( SS2_BearerServNotProvParam **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_BearerServNotProvParam *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_BearerServNotProvParam ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_BearerServNotProvParam_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE TeleservNotProvParam Ber decoder */
extern U32 AsnDecode_SS2_TeleservNotProvParam( SS2_TeleservNotProvParam **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_TeleservNotProvParam *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_TeleservNotProvParam ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_TeleservNotProvParam_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE TracingBufferFullParam Ber decoder */
extern U32 AsnDecode_SS2_TracingBufferFullParam( SS2_TracingBufferFullParam **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_TracingBufferFullParam *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_TracingBufferFullParam ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_TracingBufferFullParam_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE NoRoamingNbParam Ber decoder */
extern U32 AsnDecode_SS2_NoRoamingNbParam( SS2_NoRoamingNbParam **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_NoRoamingNbParam *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_NoRoamingNbParam ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_NoRoamingNbParam_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE AbsentSubscriberParam Ber decoder */
extern U32 AsnDecode_SS2_AbsentSubscriberParam( SS2_AbsentSubscriberParam **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_AbsentSubscriberParam *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_AbsentSubscriberParam ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_AbsentSubscriberParam_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_AbsentSubscriberReason( &pType->absentSubscriberReason, pContext);
            pType->validity |= SS2_AbsentSubscriberParam_absentSubscriberReason_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE BusySubscriberParam Ber decoder */
extern U32 AsnDecode_SS2_BusySubscriberParam( SS2_BusySubscriberParam **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_BusySubscriberParam *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_BusySubscriberParam ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_BusySubscriberParam_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_BusySubscriberParam_ccbs_Possible_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_BusySubscriberParam_ccbs_Busy_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE NoSubscriberReplyParam Ber decoder */
extern U32 AsnDecode_SS2_NoSubscriberReplyParam( SS2_NoSubscriberReplyParam **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_NoSubscriberReplyParam *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_NoSubscriberReplyParam ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_NoSubscriberReplyParam_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE ForwardingViolationParam Ber decoder */
extern U32 AsnDecode_SS2_ForwardingViolationParam( SS2_ForwardingViolationParam **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_ForwardingViolationParam *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_ForwardingViolationParam ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_ForwardingViolationParam_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE ForwardingFailedParam Ber decoder */
extern U32 AsnDecode_SS2_ForwardingFailedParam( SS2_ForwardingFailedParam **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_ForwardingFailedParam *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_ForwardingFailedParam ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_ForwardingFailedParam_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE ATI-NotAllowedParam Ber decoder */
extern U32 AsnDecode_SS2_ATI_NotAllowedParam( SS2_ATI_NotAllowedParam **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_ATI_NotAllowedParam *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_ATI_NotAllowedParam ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_ATI_NotAllowedParam_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE ATSI-NotAllowedParam Ber decoder */
extern U32 AsnDecode_SS2_ATSI_NotAllowedParam( SS2_ATSI_NotAllowedParam **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_ATSI_NotAllowedParam *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_ATSI_NotAllowedParam ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_ATSI_NotAllowedParam_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE ATM-NotAllowedParam Ber decoder */
extern U32 AsnDecode_SS2_ATM_NotAllowedParam( SS2_ATM_NotAllowedParam **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_ATM_NotAllowedParam *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_ATM_NotAllowedParam ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_ATM_NotAllowedParam_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE IllegalSS-OperationParam Ber decoder */
extern U32 AsnDecode_SS2_IllegalSS_OperationParam( SS2_IllegalSS_OperationParam **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_IllegalSS_OperationParam *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_IllegalSS_OperationParam ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_IllegalSS_OperationParam_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE SS-NotAvailableParam Ber decoder */
extern U32 AsnDecode_SS2_SS_NotAvailableParam( SS2_SS_NotAvailableParam **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_SS_NotAvailableParam *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_SS_NotAvailableParam ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_SS_NotAvailableParam_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE SS-SubscriptionViolationParam Ber decoder */
extern U32 AsnDecode_SS2_SS_SubscriptionViolationParam( SS2_SS_SubscriptionViolationParam **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_SS_SubscriptionViolationParam *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_SS_SubscriptionViolationParam ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_SS_SubscriptionViolationParam_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE InformationNotAvailableParam Ber decoder */
extern U32 AsnDecode_SS2_InformationNotAvailableParam( SS2_InformationNotAvailableParam **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_InformationNotAvailableParam *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_InformationNotAvailableParam ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_InformationNotAvailableParam_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE SubBusyForMT-SMS-Param Ber decoder */
extern U32 AsnDecode_SS2_SubBusyForMT_SMS_Param( SS2_SubBusyForMT_SMS_Param **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_SubBusyForMT_SMS_Param *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_SubBusyForMT_SMS_Param ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_SubBusyForMT_SMS_Param_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_SubBusyForMT_SMS_Param_gprsConnectionSuspended_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE MessageWaitListFullParam Ber decoder */
extern U32 AsnDecode_SS2_MessageWaitListFullParam( SS2_MessageWaitListFullParam **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_MessageWaitListFullParam *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_MessageWaitListFullParam ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_MessageWaitListFullParam_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE ResourceLimitationParam Ber decoder */
extern U32 AsnDecode_SS2_ResourceLimitationParam( SS2_ResourceLimitationParam **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_ResourceLimitationParam *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_ResourceLimitationParam ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_ResourceLimitationParam_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE NoGroupCallNbParam Ber decoder */
extern U32 AsnDecode_SS2_NoGroupCallNbParam( SS2_NoGroupCallNbParam **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_NoGroupCallNbParam *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_NoGroupCallNbParam ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_NoGroupCallNbParam_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE IncompatibleTerminalParam Ber decoder */
extern U32 AsnDecode_SS2_IncompatibleTerminalParam( SS2_IncompatibleTerminalParam **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_IncompatibleTerminalParam *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_IncompatibleTerminalParam ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_IncompatibleTerminalParam_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE UnauthorizedRequestingNetwork-Param Ber decoder */
extern U32 AsnDecode_SS2_UnauthorizedRequestingNetwork_Param( SS2_UnauthorizedRequestingNetwork_Param **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_UnauthorizedRequestingNetwork_Param *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_UnauthorizedRequestingNetwork_Param ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_UnauthorizedRequestingNetwork_Param_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE UnauthorizedLCSClient-Param Ber decoder */
extern U32 AsnDecode_SS2_UnauthorizedLCSClient_Param( SS2_UnauthorizedLCSClient_Param **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_UnauthorizedLCSClient_Param *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_UnauthorizedLCSClient_Param ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_UnauthorizedLCSClient_Diagnostic( &pType->unauthorizedLCSClient_Diagnostic, pContext);
            pType->validity |= SS2_UnauthorizedLCSClient_Param_unauthorizedLCSClient_Diagnostic_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_UnauthorizedLCSClient_Param_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE PositionMethodFailure-Param Ber decoder */
extern U32 AsnDecode_SS2_PositionMethodFailure_Param( SS2_PositionMethodFailure_Param **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_PositionMethodFailure_Param *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_PositionMethodFailure_Param ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_PositionMethodFailure_Diagnostic( &pType->positionMethodFailure_Diagnostic, pContext);
            pType->validity |= SS2_PositionMethodFailure_Param_positionMethodFailure_Diagnostic_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_PositionMethodFailure_Param_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE UnknownOrUnreachableLCSClient-Param Ber decoder */
extern U32 AsnDecode_SS2_UnknownOrUnreachableLCSClient_Param( SS2_UnknownOrUnreachableLCSClient_Param **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_UnknownOrUnreachableLCSClient_Param *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_UnknownOrUnreachableLCSClient_Param ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_UnknownOrUnreachableLCSClient_Param_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE MM-EventNotSupported-Param Ber decoder */
extern U32 AsnDecode_SS2_MM_EventNotSupported_Param( SS2_MM_EventNotSupported_Param **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_MM_EventNotSupported_Param *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_MM_EventNotSupported_Param ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_MM_EventNotSupported_Param_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE TargetCellOutsideGCA-Param Ber decoder */
extern U32 AsnDecode_SS2_TargetCellOutsideGCA_Param( SS2_TargetCellOutsideGCA_Param **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_TargetCellOutsideGCA_Param *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_TargetCellOutsideGCA_Param ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_TargetCellOutsideGCA_Param_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE RoutingInfoForLCS-Res Ber decoder */
extern U32 AsnDecode_SS2_RoutingInfoForLCS_Res( SS2_RoutingInfoForLCS_Res **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_RoutingInfoForLCS_Res *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_RoutingInfoForLCS_Res ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SubscriberIdentity( &pType->targetMS, pContext, tag);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LCSLocationInfo( &pType->lcsLocationInfo, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_RoutingInfoForLCS_Res_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GSN_Address( &pType->v_gmlc_Address, pContext);
            pType->validity |= SS2_RoutingInfoForLCS_Res_v_gmlc_Address_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GSN_Address( &pType->h_gmlc_Address, pContext);
            pType->validity |= SS2_RoutingInfoForLCS_Res_h_gmlc_Address_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GSN_Address( &pType->ppr_Address, pContext);
            pType->validity |= SS2_RoutingInfoForLCS_Res_ppr_Address_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GSN_Address( &pType->additional_v_gmlc_Address, pContext);
            pType->validity |= SS2_RoutingInfoForLCS_Res_additional_v_gmlc_Address_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE LCS-ClientID Ber decoder */
static void AsnDecode_SS2_LCS_ClientID( SS2_LCS_ClientID *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LCSClientType( &pType->lcsClientType, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LCSClientExternalID( &pType->lcsClientExternalID, pContext);
            pType->validity |= SS2_LCS_ClientID_lcsClientExternalID_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_AddressString( &pType->lcsClientDialedByMS, pContext);
            pType->validity |= SS2_LCS_ClientID_lcsClientDialedByMS_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LCSClientInternalID( &pType->lcsClientInternalID, pContext);
            pType->validity |= SS2_LCS_ClientID_lcsClientInternalID_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LCSClientName( &pType->lcsClientName, pContext);
            pType->validity |= SS2_LCS_ClientID_lcsClientName_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_APN( &pType->lcsAPN, pContext);
            pType->validity |= SS2_LCS_ClientID_lcsAPN_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LCSRequestorID( &pType->lcsRequestorID, pContext);
            pType->validity |= SS2_LCS_ClientID_lcsRequestorID_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE AreaDefinition Ber decoder */
static void AsnDecode_SS2_AreaDefinition( SS2_AreaDefinition *pType, applib2_AsnContext *pContext)
{
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_AreaList( &pType->areaList, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE SubscriberLocationReport-Arg Ber decoder */
extern U32 AsnDecode_SS2_SubscriberLocationReport_Arg( SS2_SubscriberLocationReport_Arg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_SubscriberLocationReport_Arg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_SubscriberLocationReport_Arg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_LCS_Event( &pType->lcs_Event, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_LCS_ClientID( &pType->lcs_ClientID, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_LCSLocationInfo( &pType->lcsLocationInfo, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->msisdn, pContext);
            pType->validity |= SS2_SubscriberLocationReport_Arg_msisdn_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_IMSI( &pType->imsi, pContext);
            pType->validity |= SS2_SubscriberLocationReport_Arg_imsi_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_IMEI( &pType->imei, pContext);
            pType->validity |= SS2_SubscriberLocationReport_Arg_imei_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->na_ESRD, pContext);
            pType->validity |= SS2_SubscriberLocationReport_Arg_na_ESRD_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->na_ESRK, pContext);
            pType->validity |= SS2_SubscriberLocationReport_Arg_na_ESRK_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Ext_GeographicalInformation( &pType->locationEstimate, pContext);
            pType->validity |= SS2_SubscriberLocationReport_Arg_locationEstimate_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->ageOfLocationEstimate = (U16)ber_get_integer( pContext ); 
            pType->validity |= SS2_SubscriberLocationReport_Arg_ageOfLocationEstimate_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 7;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SLR_ArgExtensionContainer( &pType->slr_ArgExtensionContainer, pContext);
            pType->validity |= SS2_SubscriberLocationReport_Arg_slr_ArgExtensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 8;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Add_GeographicalInformation( &pType->add_LocationEstimate, pContext);
            pType->validity |= SS2_SubscriberLocationReport_Arg_add_LocationEstimate_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 9;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Deferredmt_lrData( &pType->deferredmt_lrData, pContext);
            pType->validity |= SS2_SubscriberLocationReport_Arg_deferredmt_lrData_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LCS_ReferenceNumber( &pType->lcs_ReferenceNumber, pContext);
            pType->validity |= SS2_SubscriberLocationReport_Arg_lcs_ReferenceNumber_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 11;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_PositioningDataInformation( &pType->geranPositioningData, pContext);
            pType->validity |= SS2_SubscriberLocationReport_Arg_geranPositioningData_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 12;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_UtranPositioningDataInfo( &pType->utranPositioningData, pContext);
            pType->validity |= SS2_SubscriberLocationReport_Arg_utranPositioningData_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 13;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_CellGlobalIdOrServiceAreaIdOrLAI( &pType->cellIdOrSai, pContext, tag);
            pType->validity |= SS2_SubscriberLocationReport_Arg_cellIdOrSai_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 14;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GSN_Address( &pType->h_gmlc_Address, pContext);
            pType->validity |= SS2_SubscriberLocationReport_Arg_h_gmlc_Address_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 15;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->lcsServiceTypeID = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_SubscriberLocationReport_Arg_lcsServiceTypeID_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 17;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_SubscriberLocationReport_Arg_sai_Present_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 18;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_SubscriberLocationReport_Arg_pseudonymIndicator_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 19;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_AccuracyFulfilmentIndicator( &pType->accuracyFulfilmentIndicator, pContext);
            pType->validity |= SS2_SubscriberLocationReport_Arg_accuracyFulfilmentIndicator_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE UpdateLocationArg Ber decoder */
extern U32 AsnDecode_SS2_UpdateLocationArg( SS2_UpdateLocationArg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_UpdateLocationArg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_UpdateLocationArg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_IMSI( &pType->imsi, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->msc_Number, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->vlr_Number, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LMSI( &pType->lmsi, pContext);
            pType->validity |= SS2_UpdateLocationArg_lmsi_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_UpdateLocationArg_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_VLR_Capability( &pType->vlr_Capability, pContext);
            pType->validity |= SS2_UpdateLocationArg_vlr_Capability_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 11;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_UpdateLocationArg_informPreviousNetworkEntity_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 12;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_UpdateLocationArg_cs_LCS_NotSupportedByUE_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GSN_Address( &pType->v_gmlc_Address, pContext);
            pType->validity |= SS2_UpdateLocationArg_v_gmlc_Address_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 13;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ADD_Info( &pType->add_info, pContext);
            pType->validity |= SS2_UpdateLocationArg_add_info_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* CHOICE AuthenticationSetList Ber decoder */
static void AsnDecode_SS2_AuthenticationSetList( SS2_AuthenticationSetList *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV		seq_tlv;
      pre_get_t(pContext, &seq_tlv.t);
      if(ContextSpecific == seq_tlv.t.cl && tag.is_tagged == TRUE)
         get_tl(pContext, &seq_tlv);
   }
   
   {
      BER_TAG   pdu_tag;
      
      pre_get_t(pContext, &pdu_tag);
      
      if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 0) )
      {
         AsnDecode_SS2_TripletList( &pType->choice.tripletList, pContext);
         
         pType->selection = SS2_AuthenticationSetList_tripletList_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 1) )
      {
         AsnDecode_SS2_QuintupletList( &pType->choice.quintupletList, pContext);
         
         pType->selection = SS2_AuthenticationSetList_quintupletList_selected;
      }
   }
   
}

/* SEQUENCE UpdateGprsLocationArg Ber decoder */
extern U32 AsnDecode_SS2_UpdateGprsLocationArg( SS2_UpdateGprsLocationArg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_UpdateGprsLocationArg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_UpdateGprsLocationArg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_IMSI( &pType->imsi, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->sgsn_Number, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_GSN_Address( &pType->sgsn_Address, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_UpdateGprsLocationArg_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SGSN_Capability( &pType->sgsn_Capability, pContext);
            pType->validity |= SS2_UpdateGprsLocationArg_sgsn_Capability_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_UpdateGprsLocationArg_informPreviousNetworkEntity_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_UpdateGprsLocationArg_ps_LCS_NotSupportedByUE_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GSN_Address( &pType->v_gmlc_Address, pContext);
            pType->validity |= SS2_UpdateGprsLocationArg_v_gmlc_Address_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ADD_Info( &pType->add_info, pContext);
            pType->validity |= SS2_UpdateGprsLocationArg_add_info_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE PrepareHO-Res Ber decoder */
extern U32 AsnDecode_SS2_PrepareHO_Res( SS2_PrepareHO_Res **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_PrepareHO_Res *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_PrepareHO_Res ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->handoverNumber, pContext);
            pType->validity |= SS2_PrepareHO_Res_handoverNumber_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_RelocationNumberList( &pType->relocationNumberList, pContext);
            pType->validity |= SS2_PrepareHO_Res_relocationNumberList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_AccessNetworkSignalInfo( &pType->an_APDU, pContext);
            pType->validity |= SS2_PrepareHO_Res_an_APDU_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->multicallBearerInfo = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_PrepareHO_Res_multicallBearerInfo_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_PrepareHO_Res_multipleBearerNotSupported_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SelectedUMTS_Algorithms( &pType->selectedUMTS_Algorithms, pContext);
            pType->validity |= SS2_PrepareHO_Res_selectedUMTS_Algorithms_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ChosenRadioResourceInformation( &pType->chosenRadioResourceInformation, pContext);
            pType->validity |= SS2_PrepareHO_Res_chosenRadioResourceInformation_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_PrepareHO_Res_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 7;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Codec( &pType->iuSelectedCodec, pContext);
            pType->validity |= SS2_PrepareHO_Res_iuSelectedCodec_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 8;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_CodecList( &pType->iuAvailableCodecsList, pContext);
            pType->validity |= SS2_PrepareHO_Res_iuAvailableCodecsList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE PrepareSubsequentHO-Arg Ber decoder */
extern U32 AsnDecode_SS2_PrepareSubsequentHO_Arg( SS2_PrepareSubsequentHO_Arg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_PrepareSubsequentHO_Arg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_PrepareSubsequentHO_Arg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GlobalCellId( &pType->targetCellId, pContext);
            pType->validity |= SS2_PrepareSubsequentHO_Arg_targetCellId_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->targetMSC_Number, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_RNCId( &pType->targetRNCId, pContext);
            pType->validity |= SS2_PrepareSubsequentHO_Arg_targetRNCId_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_AccessNetworkSignalInfo( &pType->an_APDU, pContext);
            pType->validity |= SS2_PrepareSubsequentHO_Arg_an_APDU_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->selectedRab_Id = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_PrepareSubsequentHO_Arg_selectedRab_Id_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_PrepareSubsequentHO_Arg_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GERAN_Classmark( &pType->geran_classmark, pContext);
            pType->validity |= SS2_PrepareSubsequentHO_Arg_geran_classmark_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 7;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_PrepareSubsequentHO_Arg_rab_ConfigurationIndicator_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE PrepareSubsequentHO-Res Ber decoder */
extern U32 AsnDecode_SS2_PrepareSubsequentHO_Res( SS2_PrepareSubsequentHO_Res **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_PrepareSubsequentHO_Res *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_PrepareSubsequentHO_Res ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_AccessNetworkSignalInfo( &pType->an_APDU, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_PrepareSubsequentHO_Res_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE ProcessAccessSignalling-Arg Ber decoder */
extern U32 AsnDecode_SS2_ProcessAccessSignalling_Arg( SS2_ProcessAccessSignalling_Arg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_ProcessAccessSignalling_Arg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_ProcessAccessSignalling_Arg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_AccessNetworkSignalInfo( &pType->an_APDU, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SelectedUMTS_Algorithms( &pType->selectedUMTS_Algorithms, pContext);
            pType->validity |= SS2_ProcessAccessSignalling_Arg_selectedUMTS_Algorithms_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SelectedGSM_Algorithm( &pType->selectedGSM_Algorithm, pContext);
            pType->validity |= SS2_ProcessAccessSignalling_Arg_selectedGSM_Algorithm_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ChosenRadioResourceInformation( &pType->chosenRadioResourceInformation, pContext);
            pType->validity |= SS2_ProcessAccessSignalling_Arg_chosenRadioResourceInformation_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->selectedRab_Id = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_ProcessAccessSignalling_Arg_selectedRab_Id_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_ProcessAccessSignalling_Arg_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Codec( &pType->iUSelectedCodec, pContext);
            pType->validity |= SS2_ProcessAccessSignalling_Arg_iUSelectedCodec_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_CodecList( &pType->iuAvailableCodecsList, pContext);
            pType->validity |= SS2_ProcessAccessSignalling_Arg_iuAvailableCodecsList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE SupportedCodecsList Ber decoder */
static void AsnDecode_SS2_SupportedCodecsList( SS2_SupportedCodecsList *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_CodecList( &pType->utranCodecList, pContext);
            pType->validity |= SS2_SupportedCodecsList_utranCodecList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_CodecList( &pType->geranCodecList, pContext);
            pType->validity |= SS2_SupportedCodecsList_geranCodecList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_SupportedCodecsList_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE SendEndSignal-Arg Ber decoder */
extern U32 AsnDecode_SS2_SendEndSignal_Arg( SS2_SendEndSignal_Arg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_SendEndSignal_Arg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_SendEndSignal_Arg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_AccessNetworkSignalInfo( &pType->an_APDU, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_SendEndSignal_Arg_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE SendAuthenticationInfoRes Ber decoder */
extern U32 AsnDecode_SS2_SendAuthenticationInfoRes( SS2_SendAuthenticationInfoRes **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_SendAuthenticationInfoRes *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_SendAuthenticationInfoRes ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_AuthenticationSetList( &pType->authenticationSetList, pContext, tag);
            pType->validity |= SS2_SendAuthenticationInfoRes_authenticationSetList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_SendAuthenticationInfoRes_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SET OF GPRSDataList Ber decoder */
static void AsnDecode_SS2_GPRSDataList( SS2_GPRSDataList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_PDP_Context( &pType->element[i], pContext);
   }
}

/* SEQUENCE GPRSSubscriptionData Ber decoder */
static void AsnDecode_SS2_GPRSSubscriptionData( SS2_GPRSSubscriptionData *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_GPRSSubscriptionData_completeDataListIncluded_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GPRSDataList( &pType->gprsDataList, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_GPRSSubscriptionData_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SET OF GPRS-CamelTDPDataList Ber decoder */
static void AsnDecode_SS2_GPRS_CamelTDPDataList( SS2_GPRS_CamelTDPDataList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_GPRS_CamelTDPData( &pType->element[i], pContext);
   }
}

/* SET OF LSADataList Ber decoder */
static void AsnDecode_SS2_LSADataList( SS2_LSADataList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_LSAData( &pType->element[i], pContext);
   }
}

/* SEQUENCE LSAInformation Ber decoder */
static void AsnDecode_SS2_LSAInformation( SS2_LSAInformation *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_LSAInformation_completeDataListIncluded_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LSAOnlyAccessIndicator( &pType->lsaOnlyAccessIndicator, pContext);
            pType->validity |= SS2_LSAInformation_lsaOnlyAccessIndicator_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LSADataList( &pType->lsaDataList, pContext);
            pType->validity |= SS2_LSAInformation_lsaDataList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_LSAInformation_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SET OF Ext-ForwFeatureList Ber decoder */
static void AsnDecode_SS2_Ext_ForwFeatureList( SS2_Ext_ForwFeatureList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_Ext_ForwFeature( &pType->element[i], pContext);
   }
}

/* SET OF Ext-CallBarFeatureList Ber decoder */
static void AsnDecode_SS2_Ext_CallBarFeatureList( SS2_Ext_CallBarFeatureList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_Ext_CallBarringFeature( &pType->element[i], pContext);
   }
}

/* SET OF CUG-SubscriptionList Ber decoder */
static void AsnDecode_SS2_CUG_SubscriptionList( SS2_CUG_SubscriptionList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_CUG_Subscription( &pType->element[i], pContext);
   }
}

/* SET OF CUG-FeatureList Ber decoder */
static void AsnDecode_SS2_CUG_FeatureList( SS2_CUG_FeatureList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_CUG_Feature( &pType->element[i], pContext);
   }
}

/* SEQUENCE ExternalClient Ber decoder */
static void AsnDecode_SS2_ExternalClient( SS2_ExternalClient *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_LCSClientExternalID( &pType->clientIdentity, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GMLC_Restriction( &pType->gmlc_Restriction, pContext);
            pType->validity |= SS2_ExternalClient_gmlc_Restriction_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_NotificationToMSUser( &pType->notificationToMSUser, pContext);
            pType->validity |= SS2_ExternalClient_notificationToMSUser_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_ExternalClient_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SET OF ServiceTypeList Ber decoder */
static void AsnDecode_SS2_ServiceTypeList( SS2_ServiceTypeList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_ServiceType( &pType->element[i], pContext);
   }
}

/* SET OF MOLR-List Ber decoder */
static void AsnDecode_SS2_MOLR_List( SS2_MOLR_List *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_MOLR_Class( &pType->element[i], pContext);
   }
}

/* SET OF MT-smsCAMELTDP-CriteriaList Ber decoder */
static void AsnDecode_SS2_MT_smsCAMELTDP_CriteriaList( SS2_MT_smsCAMELTDP_CriteriaList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_MT_smsCAMELTDP_Criteria( &pType->element[i], pContext);
   }
}

/* SET OF DP-AnalysedInfoCriteriaList Ber decoder */
static void AsnDecode_SS2_DP_AnalysedInfoCriteriaList( SS2_DP_AnalysedInfoCriteriaList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_DP_AnalysedInfoCriterium( &pType->element[i], pContext);
   }
}

/* SEQUENCE SS-CSI Ber decoder */
static void AsnDecode_SS2_SS_CSI( SS2_SS_CSI *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_SS_CamelData( &pType->ss_CamelData, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_SS_CSI_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_SS_CSI_notificationToCSE_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_SS_CSI_csi_Active_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SET OF O-BcsmCamelTDPDataList Ber decoder */
static void AsnDecode_SS2_O_BcsmCamelTDPDataList( SS2_O_BcsmCamelTDPDataList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_O_BcsmCamelTDPData( &pType->element[i], pContext);
   }
}

/* SET OF O-BcsmCamelTDPCriteriaList Ber decoder */
static void AsnDecode_SS2_O_BcsmCamelTDPCriteriaList( SS2_O_BcsmCamelTDPCriteriaList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_O_BcsmCamelTDP_Criteria( &pType->element[i], pContext);
   }
}

/* SET OF T-BCSM-CAMEL-TDP-CriteriaList Ber decoder */
static void AsnDecode_SS2_T_BCSM_CAMEL_TDP_CriteriaList( SS2_T_BCSM_CAMEL_TDP_CriteriaList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_T_BCSM_CAMEL_TDP_Criteria( &pType->element[i], pContext);
   }
}

/* SET OF SMS-CAMEL-TDP-DataList Ber decoder */
static void AsnDecode_SS2_SMS_CAMEL_TDP_DataList( SS2_SMS_CAMEL_TDP_DataList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_SMS_CAMEL_TDP_Data( &pType->element[i], pContext);
   }
}

/* SET OF T-BcsmCamelTDPDataList Ber decoder */
static void AsnDecode_SS2_T_BcsmCamelTDPDataList( SS2_T_BcsmCamelTDPDataList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_T_BcsmCamelTDPData( &pType->element[i], pContext);
   }
}

/* SET OF VBSDataList Ber decoder */
static void AsnDecode_SS2_VBSDataList( SS2_VBSDataList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_VoiceBroadcastData( &pType->element[i], pContext);
   }
}

/* SET OF VGCSDataList Ber decoder */
static void AsnDecode_SS2_VGCSDataList( SS2_VGCSDataList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_VoiceGroupCallData( &pType->element[i], pContext);
   }
}

/* SEQUENCE ProvideSubscriberInfoArg Ber decoder */
extern U32 AsnDecode_SS2_ProvideSubscriberInfoArg( SS2_ProvideSubscriberInfoArg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_ProvideSubscriberInfoArg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_ProvideSubscriberInfoArg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_IMSI( &pType->imsi, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LMSI( &pType->lmsi, pContext);
            pType->validity |= SS2_ProvideSubscriberInfoArg_lmsi_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_RequestedInfo( &pType->requestedInfo, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_ProvideSubscriberInfoArg_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SET OF PDP-ContextInfoList Ber decoder */
static void AsnDecode_SS2_PDP_ContextInfoList( SS2_PDP_ContextInfoList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_PDP_ContextInfo( &pType->element[i], pContext);
   }
}

/* SEQUENCE AnyTimeSubscriptionInterrogationArg Ber decoder */
extern U32 AsnDecode_SS2_AnyTimeSubscriptionInterrogationArg( SS2_AnyTimeSubscriptionInterrogationArg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_AnyTimeSubscriptionInterrogationArg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_AnyTimeSubscriptionInterrogationArg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SubscriberIdentity( &pType->subscriberIdentity, pContext, tag);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_RequestedSubscriptionInfo( &pType->requestedSubscriptionInfo, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->gsmSCF_Address, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_AnyTimeSubscriptionInterrogationArg_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_AnyTimeSubscriptionInterrogationArg_longFTN_Supported_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE CallForwardingData Ber decoder */
static void AsnDecode_SS2_CallForwardingData( SS2_CallForwardingData *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_Ext_ForwFeatureList( &pType->forwardingFeatureList, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_CallForwardingData_notificationToCSE_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_CallForwardingData_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE CallBarringData Ber decoder */
static void AsnDecode_SS2_CallBarringData( SS2_CallBarringData *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_Ext_CallBarFeatureList( &pType->callBarringFeatureList, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  18;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_Password( &pType->password, pContext);
            pType->validity |= SS2_CallBarringData_password_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            pType->wrongPasswordAttemptsCounter = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_CallBarringData_wrongPasswordAttemptsCounter_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_CallBarringData_notificationToCSE_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_CallBarringData_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE AnyTimeModificationArg Ber decoder */
extern U32 AsnDecode_SS2_AnyTimeModificationArg( SS2_AnyTimeModificationArg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_AnyTimeModificationArg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_AnyTimeModificationArg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SubscriberIdentity( &pType->subscriberIdentity, pContext, tag);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->gsmSCF_Address, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ModificationRequestFor_CF_Info( &pType->modificationRequestFor_CF_Info, pContext);
            pType->validity |= SS2_AnyTimeModificationArg_modificationRequestFor_CF_Info_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ModificationRequestFor_CB_Info( &pType->modificationRequestFor_CB_Info, pContext);
            pType->validity |= SS2_AnyTimeModificationArg_modificationRequestFor_CB_Info_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ModificationRequestFor_CSI( &pType->modificationRequestFor_CSI, pContext);
            pType->validity |= SS2_AnyTimeModificationArg_modificationRequestFor_CSI_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_AnyTimeModificationArg_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_AnyTimeModificationArg_longFTN_Supported_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 7;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ModificationRequestFor_ODB_data( &pType->modificationRequestFor_ODB_data, pContext);
            pType->validity |= SS2_AnyTimeModificationArg_modificationRequestFor_ODB_data_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE Ext-ForwardingInfoFor-CSE Ber decoder */
static void AsnDecode_SS2_Ext_ForwardingInfoFor_CSE( SS2_Ext_ForwardingInfoFor_CSE *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SS_Code( &pType->ss_Code, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Ext_ForwFeatureList( &pType->forwardingFeatureList, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_Ext_ForwardingInfoFor_CSE_notificationToCSE_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_Ext_ForwardingInfoFor_CSE_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE Ext-CallBarringInfoFor-CSE Ber decoder */
static void AsnDecode_SS2_Ext_CallBarringInfoFor_CSE( SS2_Ext_CallBarringInfoFor_CSE *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SS_Code( &pType->ss_Code, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Ext_CallBarFeatureList( &pType->callBarringFeatureList, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Password( &pType->password, pContext);
            pType->validity |= SS2_Ext_CallBarringInfoFor_CSE_password_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->wrongPasswordAttemptsCounter = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_Ext_CallBarringInfoFor_CSE_wrongPasswordAttemptsCounter_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_Ext_CallBarringInfoFor_CSE_notificationToCSE_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_Ext_CallBarringInfoFor_CSE_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE RoutingInfoForSM-Res Ber decoder */
extern U32 AsnDecode_SS2_RoutingInfoForSM_Res( SS2_RoutingInfoForSM_Res **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_RoutingInfoForSM_Res *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_RoutingInfoForSM_Res ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_IMSI( &pType->imsi, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LocationInfoWithLMSI( &pType->locationInfoWithLMSI, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_RoutingInfoForSM_Res_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE ForwardingInfo Ber decoder */
static void AsnDecode_SS2_ForwardingInfo( SS2_ForwardingInfo *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_SS_Code( &pType->ss_Code, pContext);
            pType->validity |= SS2_ForwardingInfo_ss_Code_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ForwardingFeatureList( &pType->forwardingFeatureList, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE CallBarringInfo Ber decoder */
static void AsnDecode_SS2_CallBarringInfo( SS2_CallBarringInfo *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_SS_Code( &pType->ss_Code, pContext);
            pType->validity |= SS2_CallBarringInfo_ss_Code_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_CallBarringFeatureList( &pType->callBarringFeatureList, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE GenericServiceInfo Ber decoder */
static void AsnDecode_SS2_GenericServiceInfo( SS2_GenericServiceInfo *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_SS_Status( &pType->ss_Status, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_CliRestrictionOption( &pType->cliRestrictionOption, pContext);
            pType->validity |= SS2_GenericServiceInfo_cliRestrictionOption_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->maximumEntitledPriority = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_GenericServiceInfo_maximumEntitledPriority_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->defaultPriority = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_GenericServiceInfo_defaultPriority_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_CCBS_FeatureList( &pType->ccbs_FeatureList, pContext);
            pType->validity |= SS2_GenericServiceInfo_ccbs_FeatureList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->nbrSB = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_GenericServiceInfo_nbrSB_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->nbrUser = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_GenericServiceInfo_nbrUser_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->nbrSN = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_GenericServiceInfo_nbrSN_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* CHOICE InterrogateSS-Res Ber decoder */
extern U32 AsnDecode_SS2_InterrogateSS_Res( SS2_InterrogateSS_Res **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_InterrogateSS_Res *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_InterrogateSS_Res ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   {
      BER_TAG   pdu_tag;
      
      pre_get_t(pContext, &pdu_tag);
      
      if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 0) )
      {
         AsnDecode_SS2_SS_Status( &pType->choice.ss_Status, pContext);
         
         pType->selection = SS2_InterrogateSS_Res_ss_Status_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 2) )
      {
         AsnDecode_SS2_BasicServiceGroupList( &pType->choice.basicServiceGroupList, pContext);
         
         pType->selection = SS2_InterrogateSS_Res_basicServiceGroupList_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 3) )
      {
         AsnDecode_SS2_ForwardingFeatureList( &pType->choice.forwardingFeatureList, pContext);
         
         pType->selection = SS2_InterrogateSS_Res_forwardingFeatureList_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 4) )
      {
         AsnDecode_SS2_GenericServiceInfo( &pType->choice.genericServiceInfo, pContext);
         
         pType->selection = SS2_InterrogateSS_Res_genericServiceInfo_selected;
      }
   }
   

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE CCBS-Data Ber decoder */
static void AsnDecode_SS2_CCBS_Data( SS2_CCBS_Data *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_CCBS_Feature( &pType->ccbs_Feature, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->translatedB_Number, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ServiceIndicator( &pType->serviceIndicator, pContext);
            pType->validity |= SS2_CCBS_Data_serviceIndicator_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExternalSignalInfo( &pType->callInfo, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExternalSignalInfo( &pType->networkSignalInfo, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE LocationNotificationArg Ber decoder */
extern U32 AsnDecode_SS2_LocationNotificationArg( SS2_LocationNotificationArg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_LocationNotificationArg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_LocationNotificationArg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_NotificationToMSUser( &pType->notificationType, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LocationType( &pType->locationType, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LCSClientExternalID( &pType->lcsClientExternalID, pContext);
            pType->validity |= SS2_LocationNotificationArg_lcsClientExternalID_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LCSClientName( &pType->lcsClientName, pContext);
            pType->validity |= SS2_LocationNotificationArg_lcsClientName_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LCSRequestorID( &pType->lcsRequestorID, pContext);
            pType->validity |= SS2_LocationNotificationArg_lcsRequestorID_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LCSCodeword( &pType->lcsCodeword, pContext);
            pType->validity |= SS2_LocationNotificationArg_lcsCodeword_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->lcsServiceTypeID = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_LocationNotificationArg_lcsServiceTypeID_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE LCS-MOLRArg Ber decoder */
extern U32 AsnDecode_SS2_LCS_MOLRArg( SS2_LCS_MOLRArg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_LCS_MOLRArg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_LCS_MOLRArg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_MOLR_Type( &pType->molr_Type, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LocationMethod( &pType->locationMethod, pContext);
            pType->validity |= SS2_LCS_MOLRArg_locationMethod_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LCS_QoS( &pType->lcs_QoS, pContext);
            pType->validity |= SS2_LCS_MOLRArg_lcs_QoS_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LCSClientExternalID( &pType->lcsClientExternalID, pContext);
            pType->validity |= SS2_LCS_MOLRArg_lcsClientExternalID_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->mlc_Number, pContext);
            pType->validity |= SS2_LCS_MOLRArg_mlc_Number_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GPSAssistanceData( &pType->gpsAssistanceData, pContext);
            pType->validity |= SS2_LCS_MOLRArg_gpsAssistanceData_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SupportedGADShapes( &pType->supportedGADShapes, pContext);
            pType->validity |= SS2_LCS_MOLRArg_supportedGADShapes_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 7;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->lcsServiceTypeID = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_LCS_MOLRArg_lcsServiceTypeID_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 8;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->ageOfLocationInfo = (U16)ber_get_integer( pContext ); 
            pType->validity |= SS2_LCS_MOLRArg_ageOfLocationInfo_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 9;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LocationType( &pType->locationType, pContext);
            pType->validity |= SS2_LCS_MOLRArg_locationType_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_LCS_MOLRArg_pseudonymIndicator_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* CHOICE CallBarredParam Ber decoder */
extern U32 AsnDecode_SS2_CallBarredParam( SS2_CallBarredParam **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_CallBarredParam *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_CallBarredParam ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   {
      BER_TAG   pdu_tag;
      
      pre_get_t(pContext, &pdu_tag);
      
      if( (pdu_tag.cl == Universal) && (pdu_tag.tag == 10) )
      {
         AsnDecode_SS2_CallBarringCause( &pType->choice.callBarringCause, pContext);
         
         pType->selection = SS2_CallBarredParam_callBarringCause_selected;
      }
      else if( (pdu_tag.cl == Universal) && (pdu_tag.tag == 16) )
      {
         AsnDecode_SS2_ExtensibleCallBarredParam( &pType->choice.extensibleCallBarredParam, pContext);
         
         pType->selection = SS2_CallBarredParam_extensibleCallBarredParam_selected;
      }
   }
   

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* CHOICE SystemFailureParam Ber decoder */
extern U32 AsnDecode_SS2_SystemFailureParam( SS2_SystemFailureParam **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_SystemFailureParam *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_SystemFailureParam ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   {
      BER_TAG   pdu_tag;
      
      pre_get_t(pContext, &pdu_tag);
      
      if( (pdu_tag.cl == Universal) && (pdu_tag.tag == 10) )
      {
         AsnDecode_SS2_NetworkResource( &pType->choice.networkResource, pContext);
         
         pType->selection = SS2_SystemFailureParam_networkResource_selected;
      }
      else if( (pdu_tag.cl == Universal) && (pdu_tag.tag == 16) )
      {
         AsnDecode_SS2_ExtensibleSystemFailureParam( &pType->choice.extensibleSystemFailureParam, pContext);
         
         pType->selection = SS2_SystemFailureParam_extensibleSystemFailureParam_selected;
      }
   }
   

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE AreaEventInfo Ber decoder */
static void AsnDecode_SS2_AreaEventInfo( SS2_AreaEventInfo *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_AreaDefinition( &pType->areaDefinition, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_OccurrenceInfo( &pType->occurrenceInfo, pContext);
            pType->validity |= SS2_AreaEventInfo_occurrenceInfo_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->intervalTime = (U16)ber_get_integer( pContext ); 
            pType->validity |= SS2_AreaEventInfo_intervalTime_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE SendIdentificationRes Ber decoder */
extern U32 AsnDecode_SS2_SendIdentificationRes( SS2_SendIdentificationRes **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_SendIdentificationRes *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_SendIdentificationRes ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_IMSI( &pType->imsi, pContext);
            pType->validity |= SS2_SendIdentificationRes_imsi_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 0;
      {
         unsigned int sub_choice_tag_pre_list[]={0,1}, counter=0;
         pre_get_t(pContext, &pdu_tag);
         std_tag.tag=-1;
         for(counter=0;counter<2;counter++)
         {
            if(pdu_tag.tag==sub_choice_tag_pre_list[counter])
            {
               std_tag.tag=0;
               break;
            }
         }
      }
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_AuthenticationSetList( &pType->authenticationSetList, pContext, tag);
            pType->validity |= SS2_SendIdentificationRes_authenticationSetList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_CurrentSecurityContext( &pType->currentSecurityContext, pContext, tag);
            pType->validity |= SS2_SendIdentificationRes_currentSecurityContext_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_SendIdentificationRes_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE ForwardAccessSignalling-Arg Ber decoder */
extern U32 AsnDecode_SS2_ForwardAccessSignalling_Arg( SS2_ForwardAccessSignalling_Arg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_ForwardAccessSignalling_Arg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_ForwardAccessSignalling_Arg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_AccessNetworkSignalInfo( &pType->an_APDU, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_IntegrityProtectionInformation( &pType->integrityProtectionInfo, pContext);
            pType->validity |= SS2_ForwardAccessSignalling_Arg_integrityProtectionInfo_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_EncryptionInformation( &pType->encryptionInfo, pContext);
            pType->validity |= SS2_ForwardAccessSignalling_Arg_encryptionInfo_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_KeyStatus( &pType->keyStatus, pContext);
            pType->validity |= SS2_ForwardAccessSignalling_Arg_keyStatus_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_AllowedGSM_Algorithms( &pType->allowedGSM_Algorithms, pContext);
            pType->validity |= SS2_ForwardAccessSignalling_Arg_allowedGSM_Algorithms_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_AllowedUMTS_Algorithms( &pType->allowedUMTS_Algorithms, pContext);
            pType->validity |= SS2_ForwardAccessSignalling_Arg_allowedUMTS_Algorithms_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_RadioResourceInformation( &pType->radioResourceInformation, pContext);
            pType->validity |= SS2_ForwardAccessSignalling_Arg_radioResourceInformation_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_ForwardAccessSignalling_Arg_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 7;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_RadioResourceList( &pType->radioResourceList, pContext);
            pType->validity |= SS2_ForwardAccessSignalling_Arg_radioResourceList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 9;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_BSSMAP_ServiceHandover( &pType->bssmap_ServiceHandover, pContext);
            pType->validity |= SS2_ForwardAccessSignalling_Arg_bssmap_ServiceHandover_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 8;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_RANAP_ServiceHandover( &pType->ranap_ServiceHandover, pContext);
            pType->validity |= SS2_ForwardAccessSignalling_Arg_ranap_ServiceHandover_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_BSSMAP_ServiceHandoverList( &pType->bssmap_ServiceHandoverList, pContext);
            pType->validity |= SS2_ForwardAccessSignalling_Arg_bssmap_ServiceHandoverList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 11;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Codec( &pType->currentlyUsedCodec, pContext);
            pType->validity |= SS2_ForwardAccessSignalling_Arg_currentlyUsedCodec_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 12;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SupportedCodecsList( &pType->iuSupportedCodecsList, pContext);
            pType->validity |= SS2_ForwardAccessSignalling_Arg_iuSupportedCodecsList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 13;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_ForwardAccessSignalling_Arg_rab_ConfigurationIndicator_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 14;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Codec( &pType->iuSelectedCodec, pContext);
            pType->validity |= SS2_ForwardAccessSignalling_Arg_iuSelectedCodec_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 15;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_RadioResourceInformation( &pType->alternativeChannelType, pContext);
            pType->validity |= SS2_ForwardAccessSignalling_Arg_alternativeChannelType_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 17;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_TracePropagationList( &pType->tracePropagationList, pContext);
            pType->validity |= SS2_ForwardAccessSignalling_Arg_tracePropagationList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE PrepareHO-Arg Ber decoder */
extern U32 AsnDecode_SS2_PrepareHO_Arg( SS2_PrepareHO_Arg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_PrepareHO_Arg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_PrepareHO_Arg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GlobalCellId( &pType->targetCellId, pContext);
            pType->validity |= SS2_PrepareHO_Arg_targetCellId_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_PrepareHO_Arg_ho_NumberNotRequired_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_RNCId( &pType->targetRNCId, pContext);
            pType->validity |= SS2_PrepareHO_Arg_targetRNCId_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_AccessNetworkSignalInfo( &pType->an_APDU, pContext);
            pType->validity |= SS2_PrepareHO_Arg_an_APDU_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_PrepareHO_Arg_multipleBearerRequested_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_IMSI( &pType->imsi, pContext);
            pType->validity |= SS2_PrepareHO_Arg_imsi_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_IntegrityProtectionInformation( &pType->integrityProtectionInfo, pContext);
            pType->validity |= SS2_PrepareHO_Arg_integrityProtectionInfo_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_EncryptionInformation( &pType->encryptionInfo, pContext);
            pType->validity |= SS2_PrepareHO_Arg_encryptionInfo_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 7;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_RadioResourceInformation( &pType->radioResourceInformation, pContext);
            pType->validity |= SS2_PrepareHO_Arg_radioResourceInformation_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 9;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_AllowedGSM_Algorithms( &pType->allowedGSM_Algorithms, pContext);
            pType->validity |= SS2_PrepareHO_Arg_allowedGSM_Algorithms_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_AllowedUMTS_Algorithms( &pType->allowedUMTS_Algorithms, pContext);
            pType->validity |= SS2_PrepareHO_Arg_allowedUMTS_Algorithms_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 11;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_RadioResourceList( &pType->radioResourceList, pContext);
            pType->validity |= SS2_PrepareHO_Arg_radioResourceList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 8;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_PrepareHO_Arg_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 12;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->rab_Id = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_PrepareHO_Arg_rab_Id_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 13;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_BSSMAP_ServiceHandover( &pType->bssmap_ServiceHandover, pContext);
            pType->validity |= SS2_PrepareHO_Arg_bssmap_ServiceHandover_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 14;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_RANAP_ServiceHandover( &pType->ranap_ServiceHandover, pContext);
            pType->validity |= SS2_PrepareHO_Arg_ranap_ServiceHandover_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 15;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_BSSMAP_ServiceHandoverList( &pType->bssmap_ServiceHandoverList, pContext);
            pType->validity |= SS2_PrepareHO_Arg_bssmap_ServiceHandoverList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 20;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ASCI_CallReference( &pType->asciCallReference, pContext);
            pType->validity |= SS2_PrepareHO_Arg_asciCallReference_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GERAN_Classmark( &pType->geran_classmark, pContext);
            pType->validity |= SS2_PrepareHO_Arg_geran_classmark_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 17;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Codec( &pType->iuCurrentlyUsedCodec, pContext);
            pType->validity |= SS2_PrepareHO_Arg_iuCurrentlyUsedCodec_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 18;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SupportedCodecsList( &pType->iuSupportedCodecsList, pContext);
            pType->validity |= SS2_PrepareHO_Arg_iuSupportedCodecsList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 19;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_PrepareHO_Arg_rab_ConfigurationIndicator_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 21;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_UESBI_Iu( &pType->uesbi_Iu, pContext);
            pType->validity |= SS2_PrepareHO_Arg_uesbi_Iu_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 22;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_IMEI( &pType->imeisv, pContext);
            pType->validity |= SS2_PrepareHO_Arg_imeisv_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 23;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_RadioResourceInformation( &pType->alternativeChannelType, pContext);
            pType->validity |= SS2_PrepareHO_Arg_alternativeChannelType_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 25;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_TracePropagationList( &pType->tracePropagationList, pContext);
            pType->validity |= SS2_PrepareHO_Arg_tracePropagationList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE GPRS-CSI Ber decoder */
static void AsnDecode_SS2_GPRS_CSI( SS2_GPRS_CSI *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GPRS_CamelTDPDataList( &pType->gprs_CamelTDPDataList, pContext);
            pType->validity |= SS2_GPRS_CSI_gprs_CamelTDPDataList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->camelCapabilityHandling = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_GPRS_CSI_camelCapabilityHandling_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_GPRS_CSI_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_GPRS_CSI_notificationToCSE_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_GPRS_CSI_csi_Active_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE Ext-ForwInfo Ber decoder */
static void AsnDecode_SS2_Ext_ForwInfo( SS2_Ext_ForwInfo *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_SS_Code( &pType->ss_Code, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_Ext_ForwFeatureList( &pType->forwardingFeatureList, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_Ext_ForwInfo_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE Ext-CallBarInfo Ber decoder */
static void AsnDecode_SS2_Ext_CallBarInfo( SS2_Ext_CallBarInfo *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_SS_Code( &pType->ss_Code, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_Ext_CallBarFeatureList( &pType->callBarringFeatureList, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_Ext_CallBarInfo_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE CUG-Info Ber decoder */
static void AsnDecode_SS2_CUG_Info( SS2_CUG_Info *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_CUG_SubscriptionList( &pType->cug_SubscriptionList, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_CUG_FeatureList( &pType->cug_FeatureList, pContext);
            pType->validity |= SS2_CUG_Info_cug_FeatureList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_CUG_Info_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SET OF ExternalClientList Ber decoder */
static void AsnDecode_SS2_ExternalClientList( SS2_ExternalClientList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_ExternalClient( &pType->element[i], pContext);
   }
}

/* SET OF Ext-ExternalClientList Ber decoder */
static void AsnDecode_SS2_Ext_ExternalClientList( SS2_Ext_ExternalClientList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_ExternalClient( &pType->element[i], pContext);
   }
}

/* SEQUENCE D-CSI Ber decoder */
static void AsnDecode_SS2_D_CSI( SS2_D_CSI *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_DP_AnalysedInfoCriteriaList( &pType->dp_AnalysedInfoCriteriaList, pContext);
            pType->validity |= SS2_D_CSI_dp_AnalysedInfoCriteriaList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->camelCapabilityHandling = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_D_CSI_camelCapabilityHandling_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_D_CSI_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_D_CSI_notificationToCSE_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_D_CSI_csi_Active_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE O-CSI Ber decoder */
static void AsnDecode_SS2_O_CSI( SS2_O_CSI *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_O_BcsmCamelTDPDataList( &pType->o_BcsmCamelTDPDataList, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_O_CSI_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->camelCapabilityHandling = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_O_CSI_camelCapabilityHandling_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_O_CSI_notificationToCSE_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_O_CSI_csiActive_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE SMS-CSI Ber decoder */
static void AsnDecode_SS2_SMS_CSI( SS2_SMS_CSI *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SMS_CAMEL_TDP_DataList( &pType->sms_CAMEL_TDP_DataList, pContext);
            pType->validity |= SS2_SMS_CSI_sms_CAMEL_TDP_DataList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->camelCapabilityHandling = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_SMS_CSI_camelCapabilityHandling_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_SMS_CSI_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_SMS_CSI_notificationToCSE_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_SMS_CSI_csi_Active_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE T-CSI Ber decoder */
static void AsnDecode_SS2_T_CSI( SS2_T_CSI *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_T_BcsmCamelTDPDataList( &pType->t_BcsmCamelTDPDataList, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_T_CSI_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->camelCapabilityHandling = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_T_CSI_camelCapabilityHandling_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_T_CSI_notificationToCSE_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_T_CSI_csi_Active_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* CHOICE PS-SubscriberState Ber decoder */
static void AsnDecode_SS2_PS_SubscriberState( SS2_PS_SubscriberState *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV		seq_tlv;
      pre_get_t(pContext, &seq_tlv.t);
      if(ContextSpecific == seq_tlv.t.cl && tag.is_tagged == TRUE)
         get_tl(pContext, &seq_tlv);
   }
   
   {
      BER_TAG   pdu_tag;
      
      pre_get_t(pContext, &pdu_tag);
      
      if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 0) )
      {
         {
            BER_TLV tlv; 
            get_tl( pContext, &tlv ); 
            /* without value */ 
         }
         
         pType->selection = SS2_PS_SubscriberState_notProvidedFromSGSN_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 1) )
      {
         {
            BER_TLV tlv; 
            get_tl( pContext, &tlv ); 
            /* without value */ 
         }
         
         pType->selection = SS2_PS_SubscriberState_ps_Detached_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 2) )
      {
         {
            BER_TLV tlv; 
            get_tl( pContext, &tlv ); 
            /* without value */ 
         }
         
         pType->selection = SS2_PS_SubscriberState_ps_AttachedNotReachableForPaging_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 3) )
      {
         {
            BER_TLV tlv; 
            get_tl( pContext, &tlv ); 
            /* without value */ 
         }
         
         pType->selection = SS2_PS_SubscriberState_ps_AttachedReachableForPaging_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 4) )
      {
         AsnDecode_SS2_PDP_ContextInfoList( &pType->choice.ps_PDP_ActiveNotReachableForPaging, pContext);
         
         pType->selection = SS2_PS_SubscriberState_ps_PDP_ActiveNotReachableForPaging_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 5) )
      {
         AsnDecode_SS2_PDP_ContextInfoList( &pType->choice.ps_PDP_ActiveReachableForPaging, pContext);
         
         pType->selection = SS2_PS_SubscriberState_ps_PDP_ActiveReachableForPaging_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 6) )
      {
         AsnDecode_SS2_NotReachableReason( &pType->choice.netDetNotReachable, pContext);
         
         pType->selection = SS2_PS_SubscriberState_netDetNotReachable_selected;
      }
   }
   
}

/* SEQUENCE CAMEL-SubscriptionInfo Ber decoder */
static void AsnDecode_SS2_CAMEL_SubscriptionInfo( SS2_CAMEL_SubscriptionInfo *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_O_CSI( &pType->o_CSI, pContext);
            pType->validity |= SS2_CAMEL_SubscriptionInfo_o_CSI_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_O_BcsmCamelTDPCriteriaList( &pType->o_BcsmCamelTDP_CriteriaList, pContext);
            pType->validity |= SS2_CAMEL_SubscriptionInfo_o_BcsmCamelTDP_CriteriaList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_D_CSI( &pType->d_CSI, pContext);
            pType->validity |= SS2_CAMEL_SubscriptionInfo_d_CSI_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_T_CSI( &pType->t_CSI, pContext);
            pType->validity |= SS2_CAMEL_SubscriptionInfo_t_CSI_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_T_BCSM_CAMEL_TDP_CriteriaList( &pType->t_BCSM_CAMEL_TDP_CriteriaList, pContext);
            pType->validity |= SS2_CAMEL_SubscriptionInfo_t_BCSM_CAMEL_TDP_CriteriaList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_T_CSI( &pType->vt_CSI, pContext);
            pType->validity |= SS2_CAMEL_SubscriptionInfo_vt_CSI_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_T_BCSM_CAMEL_TDP_CriteriaList( &pType->vt_BCSM_CAMEL_TDP_CriteriaList, pContext);
            pType->validity |= SS2_CAMEL_SubscriptionInfo_vt_BCSM_CAMEL_TDP_CriteriaList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 7;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_CAMEL_SubscriptionInfo_tif_CSI_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 8;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_CAMEL_SubscriptionInfo_tif_CSI_NotificationToCSE_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 9;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GPRS_CSI( &pType->gprs_CSI, pContext);
            pType->validity |= SS2_CAMEL_SubscriptionInfo_gprs_CSI_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SMS_CSI( &pType->mo_sms_CSI, pContext);
            pType->validity |= SS2_CAMEL_SubscriptionInfo_mo_sms_CSI_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 11;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SS_CSI( &pType->ss_CSI, pContext);
            pType->validity |= SS2_CAMEL_SubscriptionInfo_ss_CSI_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 12;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_M_CSI( &pType->m_CSI, pContext);
            pType->validity |= SS2_CAMEL_SubscriptionInfo_m_CSI_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 13;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_CAMEL_SubscriptionInfo_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 14;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SpecificCSI_Withdraw( &pType->specificCSIDeletedList, pContext);
            pType->validity |= SS2_CAMEL_SubscriptionInfo_specificCSIDeletedList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 15;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SMS_CSI( &pType->mt_sms_CSI, pContext);
            pType->validity |= SS2_CAMEL_SubscriptionInfo_mt_sms_CSI_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_MT_smsCAMELTDP_CriteriaList( &pType->mt_smsCAMELTDP_CriteriaList, pContext);
            pType->validity |= SS2_CAMEL_SubscriptionInfo_mt_smsCAMELTDP_CriteriaList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 17;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_MG_CSI( &pType->mg_csi, pContext);
            pType->validity |= SS2_CAMEL_SubscriptionInfo_mg_csi_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 18;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_O_CSI( &pType->o_IM_CSI, pContext);
            pType->validity |= SS2_CAMEL_SubscriptionInfo_o_IM_CSI_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 19;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_O_BcsmCamelTDPCriteriaList( &pType->o_IM_BcsmCamelTDP_CriteriaList, pContext);
            pType->validity |= SS2_CAMEL_SubscriptionInfo_o_IM_BcsmCamelTDP_CriteriaList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 20;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_D_CSI( &pType->d_IM_CSI, pContext);
            pType->validity |= SS2_CAMEL_SubscriptionInfo_d_IM_CSI_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 21;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_T_CSI( &pType->vt_IM_CSI, pContext);
            pType->validity |= SS2_CAMEL_SubscriptionInfo_vt_IM_CSI_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 22;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_T_BCSM_CAMEL_TDP_CriteriaList( &pType->vt_IM_BCSM_CAMEL_TDP_CriteriaList, pContext);
            pType->validity |= SS2_CAMEL_SubscriptionInfo_vt_IM_BCSM_CAMEL_TDP_CriteriaList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE NoteSubscriberDataModifiedArg Ber decoder */
extern U32 AsnDecode_SS2_NoteSubscriberDataModifiedArg( SS2_NoteSubscriberDataModifiedArg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_NoteSubscriberDataModifiedArg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_NoteSubscriberDataModifiedArg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_IMSI( &pType->imsi, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->msisdn, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Ext_ForwardingInfoFor_CSE( &pType->forwardingInfoFor_CSE, pContext);
            pType->validity |= SS2_NoteSubscriberDataModifiedArg_forwardingInfoFor_CSE_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Ext_CallBarringInfoFor_CSE( &pType->callBarringInfoFor_CSE, pContext);
            pType->validity |= SS2_NoteSubscriberDataModifiedArg_callBarringInfoFor_CSE_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ODB_Info( &pType->odb_Info, pContext);
            pType->validity |= SS2_NoteSubscriberDataModifiedArg_odb_Info_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_CAMEL_SubscriptionInfo( &pType->camel_SubscriptionInfo, pContext);
            pType->validity |= SS2_NoteSubscriberDataModifiedArg_camel_SubscriptionInfo_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_NoteSubscriberDataModifiedArg_allInformationSent_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_NoteSubscriberDataModifiedArg_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* CHOICE Ext-SS-InfoFor-CSE Ber decoder */
static void AsnDecode_SS2_Ext_SS_InfoFor_CSE( SS2_Ext_SS_InfoFor_CSE *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV		seq_tlv;
      pre_get_t(pContext, &seq_tlv.t);
      if(ContextSpecific == seq_tlv.t.cl && tag.is_tagged == TRUE)
         get_tl(pContext, &seq_tlv);
   }
   
   {
      BER_TAG   pdu_tag;
      
      pre_get_t(pContext, &pdu_tag);
      
      if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 0) )
      {
         AsnDecode_SS2_Ext_ForwardingInfoFor_CSE( &pType->choice.forwardingInfoFor_CSE, pContext);
         
         pType->selection = SS2_Ext_SS_InfoFor_CSE_forwardingInfoFor_CSE_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 1) )
      {
         AsnDecode_SS2_Ext_CallBarringInfoFor_CSE( &pType->choice.callBarringInfoFor_CSE, pContext);
         
         pType->selection = SS2_Ext_SS_InfoFor_CSE_callBarringInfoFor_CSE_selected;
      }
   }
   
}

/* CHOICE SS-Info Ber decoder */
static void AsnDecode_SS2_SS_Info( SS2_SS_Info *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV		seq_tlv;
      pre_get_t(pContext, &seq_tlv.t);
      if(ContextSpecific == seq_tlv.t.cl && tag.is_tagged == TRUE)
         get_tl(pContext, &seq_tlv);
   }
   
   {
      BER_TAG   pdu_tag;
      
      pre_get_t(pContext, &pdu_tag);
      
      if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 0) )
      {
         AsnDecode_SS2_ForwardingInfo( &pType->choice.forwardingInfo, pContext);
         
         pType->selection = SS2_SS_Info_forwardingInfo_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 1) )
      {
         AsnDecode_SS2_CallBarringInfo( &pType->choice.callBarringInfo, pContext);
         
         pType->selection = SS2_SS_Info_callBarringInfo_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 3) )
      {
         AsnDecode_SS2_SS_Data( &pType->choice.ss_Data, pContext);
         
         pType->selection = SS2_SS_Info_ss_Data_selected;
      }
   }
   
}

/* SET OF SS-InfoList Ber decoder */
extern U32 AsnDecode_SS2_SS_InfoList( SS2_SS_InfoList **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_SS_InfoList *pType;
unsigned int i;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_SS_InfoList ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_SS_Info( &pType->element[i], pContext, tag);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE RegisterCC-EntryArg Ber decoder */
extern U32 AsnDecode_SS2_RegisterCC_EntryArg( SS2_RegisterCC_EntryArg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_RegisterCC_EntryArg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_RegisterCC_EntryArg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SS_Code( &pType->ss_Code, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_CCBS_Data( &pType->ccbs_Data, pContext);
            pType->validity |= SS2_RegisterCC_EntryArg_ccbs_Data_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE LCS-AreaEventRequestArg Ber decoder */
extern U32 AsnDecode_SS2_LCS_AreaEventRequestArg( SS2_LCS_AreaEventRequestArg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_LCS_AreaEventRequestArg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_LCS_AreaEventRequestArg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LCS_ReferenceNumber( &pType->referenceNumber, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GSN_Address( &pType->h_gmlc_address, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GSN_Address( &pType->r_gmlc_address, pContext);
            pType->validity |= SS2_LCS_AreaEventRequestArg_r_gmlc_address_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_DeferredLocationEventType( &pType->deferredLocationEventType, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_AreaEventInfo( &pType->areaEventInfo, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE ProvideSubscriberLocation-Arg Ber decoder */
extern U32 AsnDecode_SS2_ProvideSubscriberLocation_Arg( SS2_ProvideSubscriberLocation_Arg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_ProvideSubscriberLocation_Arg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_ProvideSubscriberLocation_Arg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_LocationType( &pType->locationType, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->mlc_Number, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LCS_ClientID( &pType->lcs_ClientID, pContext);
            pType->validity |= SS2_ProvideSubscriberLocation_Arg_lcs_ClientID_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_ProvideSubscriberLocation_Arg_privacyOverride_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_IMSI( &pType->imsi, pContext);
            pType->validity |= SS2_ProvideSubscriberLocation_Arg_imsi_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->msisdn, pContext);
            pType->validity |= SS2_ProvideSubscriberLocation_Arg_msisdn_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LMSI( &pType->lmsi, pContext);
            pType->validity |= SS2_ProvideSubscriberLocation_Arg_lmsi_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_IMEI( &pType->imei, pContext);
            pType->validity |= SS2_ProvideSubscriberLocation_Arg_imei_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LCS_Priority( &pType->lcs_Priority, pContext);
            pType->validity |= SS2_ProvideSubscriberLocation_Arg_lcs_Priority_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 7;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LCS_QoS( &pType->lcs_QoS, pContext);
            pType->validity |= SS2_ProvideSubscriberLocation_Arg_lcs_QoS_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 8;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_ProvideSubscriberLocation_Arg_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 9;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SupportedGADShapes( &pType->supportedGADShapes, pContext);
            pType->validity |= SS2_ProvideSubscriberLocation_Arg_supportedGADShapes_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LCS_ReferenceNumber( &pType->lcs_ReferenceNumber, pContext);
            pType->validity |= SS2_ProvideSubscriberLocation_Arg_lcs_ReferenceNumber_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 11;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->lcsServiceTypeID = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_ProvideSubscriberLocation_Arg_lcsServiceTypeID_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 12;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LCSCodeword( &pType->lcsCodeword, pContext);
            pType->validity |= SS2_ProvideSubscriberLocation_Arg_lcsCodeword_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 13;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LCS_PrivacyCheck( &pType->lcs_PrivacyCheck, pContext);
            pType->validity |= SS2_ProvideSubscriberLocation_Arg_lcs_PrivacyCheck_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 14;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_AreaEventInfo( &pType->areaEventInfo, pContext);
            pType->validity |= SS2_ProvideSubscriberLocation_Arg_areaEventInfo_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 15;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GSN_Address( &pType->h_gmlc_Address, pContext);
            pType->validity |= SS2_ProvideSubscriberLocation_Arg_h_gmlc_Address_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE SGSN-CAMEL-SubscriptionInfo Ber decoder */
static void AsnDecode_SS2_SGSN_CAMEL_SubscriptionInfo( SS2_SGSN_CAMEL_SubscriptionInfo *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GPRS_CSI( &pType->gprs_CSI, pContext);
            pType->validity |= SS2_SGSN_CAMEL_SubscriptionInfo_gprs_CSI_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SMS_CSI( &pType->mo_sms_CSI, pContext);
            pType->validity |= SS2_SGSN_CAMEL_SubscriptionInfo_mo_sms_CSI_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_SGSN_CAMEL_SubscriptionInfo_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SMS_CSI( &pType->mt_sms_CSI, pContext);
            pType->validity |= SS2_SGSN_CAMEL_SubscriptionInfo_mt_sms_CSI_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_MT_smsCAMELTDP_CriteriaList( &pType->mt_smsCAMELTDP_CriteriaList, pContext);
            pType->validity |= SS2_SGSN_CAMEL_SubscriptionInfo_mt_smsCAMELTDP_CriteriaList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_MG_CSI( &pType->mg_csi, pContext);
            pType->validity |= SS2_SGSN_CAMEL_SubscriptionInfo_mg_csi_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* CHOICE Ext-SS-Info Ber decoder */
static void AsnDecode_SS2_Ext_SS_Info( SS2_Ext_SS_Info *pType, applib2_AsnContext *pContext, BER_TAG tag)
{
   
   {
      BER_TLV		seq_tlv;
      pre_get_t(pContext, &seq_tlv.t);
      if(ContextSpecific == seq_tlv.t.cl && tag.is_tagged == TRUE)
         get_tl(pContext, &seq_tlv);
   }
   
   {
      BER_TAG   pdu_tag;
      
      pre_get_t(pContext, &pdu_tag);
      
      if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 0) )
      {
         AsnDecode_SS2_Ext_ForwInfo( &pType->choice.forwardingInfo, pContext);
         
         pType->selection = SS2_Ext_SS_Info_forwardingInfo_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 1) )
      {
         AsnDecode_SS2_Ext_CallBarInfo( &pType->choice.callBarringInfo, pContext);
         
         pType->selection = SS2_Ext_SS_Info_callBarringInfo_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 2) )
      {
         AsnDecode_SS2_CUG_Info( &pType->choice.cug_Info, pContext);
         
         pType->selection = SS2_Ext_SS_Info_cug_Info_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 3) )
      {
         AsnDecode_SS2_Ext_SS_Data( &pType->choice.ss_Data, pContext);
         
         pType->selection = SS2_Ext_SS_Info_ss_Data_selected;
      }
      else if( (pdu_tag.cl == ContextSpecific) && (pdu_tag.tag == 4) )
      {
         AsnDecode_SS2_EMLPP_Info( &pType->choice.emlpp_Info, pContext);
         
         pType->selection = SS2_Ext_SS_Info_emlpp_Info_selected;
      }
   }
   
}

/* SEQUENCE LCS-PrivacyClass Ber decoder */
static void AsnDecode_SS2_LCS_PrivacyClass( SS2_LCS_PrivacyClass *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_SS_Code( &pType->ss_Code, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_Ext_SS_Status( &pType->ss_Status, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_NotificationToMSUser( &pType->notificationToMSUser, pContext);
            pType->validity |= SS2_LCS_PrivacyClass_notificationToMSUser_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExternalClientList( &pType->externalClientList, pContext);
            pType->validity |= SS2_LCS_PrivacyClass_externalClientList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_PLMNClientList( &pType->plmnClientList, pContext);
            pType->validity |= SS2_LCS_PrivacyClass_plmnClientList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_LCS_PrivacyClass_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Ext_ExternalClientList( &pType->ext_externalClientList, pContext);
            pType->validity |= SS2_LCS_PrivacyClass_ext_externalClientList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ServiceTypeList( &pType->serviceTypeList, pContext);
            pType->validity |= SS2_LCS_PrivacyClass_serviceTypeList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE VlrCamelSubscriptionInfo Ber decoder */
static void AsnDecode_SS2_VlrCamelSubscriptionInfo( SS2_VlrCamelSubscriptionInfo *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_O_CSI( &pType->o_CSI, pContext);
            pType->validity |= SS2_VlrCamelSubscriptionInfo_o_CSI_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_VlrCamelSubscriptionInfo_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SS_CSI( &pType->ss_CSI, pContext);
            pType->validity |= SS2_VlrCamelSubscriptionInfo_ss_CSI_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_O_BcsmCamelTDPCriteriaList( &pType->o_BcsmCamelTDP_CriteriaList, pContext);
            pType->validity |= SS2_VlrCamelSubscriptionInfo_o_BcsmCamelTDP_CriteriaList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_VlrCamelSubscriptionInfo_tif_CSI_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_M_CSI( &pType->m_CSI, pContext);
            pType->validity |= SS2_VlrCamelSubscriptionInfo_m_CSI_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SMS_CSI( &pType->mo_sms_CSI, pContext);
            pType->validity |= SS2_VlrCamelSubscriptionInfo_mo_sms_CSI_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 7;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_T_CSI( &pType->vt_CSI, pContext);
            pType->validity |= SS2_VlrCamelSubscriptionInfo_vt_CSI_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 8;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_T_BCSM_CAMEL_TDP_CriteriaList( &pType->t_BCSM_CAMEL_TDP_CriteriaList, pContext);
            pType->validity |= SS2_VlrCamelSubscriptionInfo_t_BCSM_CAMEL_TDP_CriteriaList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 9;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_D_CSI( &pType->d_CSI, pContext);
            pType->validity |= SS2_VlrCamelSubscriptionInfo_d_CSI_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SMS_CSI( &pType->mt_sms_CSI, pContext);
            pType->validity |= SS2_VlrCamelSubscriptionInfo_mt_sms_CSI_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 11;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_MT_smsCAMELTDP_CriteriaList( &pType->mt_smsCAMELTDP_CriteriaList, pContext);
            pType->validity |= SS2_VlrCamelSubscriptionInfo_mt_smsCAMELTDP_CriteriaList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE SubscriberInfo Ber decoder */
static void AsnDecode_SS2_SubscriberInfo( SS2_SubscriberInfo *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LocationInformation( &pType->locationInformation, pContext);
            pType->validity |= SS2_SubscriberInfo_locationInformation_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SubscriberState( &pType->subscriberState, pContext, tag);
            pType->validity |= SS2_SubscriberInfo_subscriberState_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_SubscriberInfo_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LocationInformationGPRS( &pType->locationInformationGPRS, pContext);
            pType->validity |= SS2_SubscriberInfo_locationInformationGPRS_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_PS_SubscriberState( &pType->ps_SubscriberState, pContext, tag);
            pType->validity |= SS2_SubscriberInfo_ps_SubscriberState_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_IMEI( &pType->imei, pContext);
            pType->validity |= SS2_SubscriberInfo_imei_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_MS_Classmark2( &pType->ms_Classmark2, pContext);
            pType->validity |= SS2_SubscriberInfo_ms_Classmark2_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 7;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GPRSMSClass( &pType->gprs_MS_Class, pContext);
            pType->validity |= SS2_SubscriberInfo_gprs_MS_Class_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 8;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_MNPInfoRes( &pType->mnpInfoRes, pContext);
            pType->validity |= SS2_SubscriberInfo_mnpInfoRes_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE AnyTimeInterrogationRes Ber decoder */
extern U32 AsnDecode_SS2_AnyTimeInterrogationRes( SS2_AnyTimeInterrogationRes **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_AnyTimeInterrogationRes *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_AnyTimeInterrogationRes ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_SubscriberInfo( &pType->subscriberInfo, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_AnyTimeInterrogationRes_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE AnyTimeSubscriptionInterrogationRes Ber decoder */
extern U32 AsnDecode_SS2_AnyTimeSubscriptionInterrogationRes( SS2_AnyTimeSubscriptionInterrogationRes **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_AnyTimeSubscriptionInterrogationRes *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_AnyTimeSubscriptionInterrogationRes ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_CallForwardingData( &pType->callForwardingData, pContext);
            pType->validity |= SS2_AnyTimeSubscriptionInterrogationRes_callForwardingData_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_CallBarringData( &pType->callBarringData, pContext);
            pType->validity |= SS2_AnyTimeSubscriptionInterrogationRes_callBarringData_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ODB_Info( &pType->odb_Info, pContext);
            pType->validity |= SS2_AnyTimeSubscriptionInterrogationRes_odb_Info_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_CAMEL_SubscriptionInfo( &pType->camel_SubscriptionInfo, pContext);
            pType->validity |= SS2_AnyTimeSubscriptionInterrogationRes_camel_SubscriptionInfo_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 5;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SupportedCamelPhases( &pType->supportedVLR_CAMEL_Phases, pContext);
            pType->validity |= SS2_AnyTimeSubscriptionInterrogationRes_supportedVLR_CAMEL_Phases_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SupportedCamelPhases( &pType->supportedSGSN_CAMEL_Phases, pContext);
            pType->validity |= SS2_AnyTimeSubscriptionInterrogationRes_supportedSGSN_CAMEL_Phases_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 7;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_AnyTimeSubscriptionInterrogationRes_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 8;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_OfferedCamel4CSIs( &pType->offeredCamel4CSIsInVLR, pContext);
            pType->validity |= SS2_AnyTimeSubscriptionInterrogationRes_offeredCamel4CSIsInVLR_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 9;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_OfferedCamel4CSIs( &pType->offeredCamel4CSIsInSGSN, pContext);
            pType->validity |= SS2_AnyTimeSubscriptionInterrogationRes_offeredCamel4CSIsInSGSN_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE AnyTimeModificationRes Ber decoder */
extern U32 AsnDecode_SS2_AnyTimeModificationRes( SS2_AnyTimeModificationRes **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_AnyTimeModificationRes *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_AnyTimeModificationRes ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Ext_SS_InfoFor_CSE( &pType->ss_InfoFor_CSE, pContext, tag);
            pType->validity |= SS2_AnyTimeModificationRes_ss_InfoFor_CSE_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_CAMEL_SubscriptionInfo( &pType->camel_SubscriptionInfo, pContext);
            pType->validity |= SS2_AnyTimeModificationRes_camel_SubscriptionInfo_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_AnyTimeModificationRes_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ODB_Info( &pType->odb_Info, pContext);
            pType->validity |= SS2_AnyTimeModificationRes_odb_Info_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SET OF Ext-SS-InfoList Ber decoder */
static void AsnDecode_SS2_Ext_SS_InfoList( SS2_Ext_SS_InfoList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_Ext_SS_Info( &pType->element[i], pContext, tag);
   }
}

/* SET OF LCS-PrivacyExceptionList Ber decoder */
static void AsnDecode_SS2_LCS_PrivacyExceptionList( SS2_LCS_PrivacyExceptionList *pType, applib2_AsnContext *pContext)
{
unsigned int i;

   
   {
      BER_TLV		seq_tlv;
      U8				*p_pud_end;
      applib2_AsnContext	temp;
   
      get_tl(pContext, &seq_tlv);
   
      temp = *pContext;
   
      pType->numElements = 0;
   
      p_pud_end = pContext->pEncoded + seq_tlv.l.length;
   
      do
      {
         get_tl(pContext, &seq_tlv);
         pContext->pEncoded += seq_tlv.l.length;
         pType->numElements++;
      } while(pContext->pEncoded < p_pud_end);
   
      *pContext = temp;
   }

   for( i = 0; i < pType->numElements; i++ )
   {
      BER_TAG   tag;
      tag.is_tagged = FALSE;
      ((void)tag);
      tag.mode = IMPLICIT ;
      AsnDecode_SS2_LCS_PrivacyClass( &pType->element[i], pContext);
   }
}

/* SEQUENCE ProvideSubscriberInfoRes Ber decoder */
extern U32 AsnDecode_SS2_ProvideSubscriberInfoRes( SS2_ProvideSubscriberInfoRes **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_ProvideSubscriberInfoRes *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_ProvideSubscriberInfoRes ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_SubscriberInfo( &pType->subscriberInfo, pContext);
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = Universal;
      std_tag.tag =  16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = FALSE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_ProvideSubscriberInfoRes_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE LCSInformation Ber decoder */
static void AsnDecode_SS2_LCSInformation( SS2_LCSInformation *pType, applib2_AsnContext *pContext)
{
   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GMLC_List( &pType->gmlc_List, pContext);
            pType->validity |= SS2_LCSInformation_gmlc_List_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LCS_PrivacyExceptionList( &pType->lcs_PrivacyExceptionList, pContext);
            pType->validity |= SS2_LCSInformation_lcs_PrivacyExceptionList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_MOLR_List( &pType->molr_List, pContext);
            pType->validity |= SS2_LCSInformation_molr_List_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LCS_PrivacyExceptionList( &pType->add_lcs_PrivacyExceptionList, pContext);
            pType->validity |= SS2_LCSInformation_add_lcs_PrivacyExceptionList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }
}

/* SEQUENCE SubscriberData Ber decoder */
extern U32 AsnDecode_SS2_SubscriberData( SS2_SubscriberData **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_SubscriberData *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_SubscriberData ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->msisdn, pContext);
            pType->validity |= SS2_SubscriberData_msisdn_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Category( &pType->category, pContext);
            pType->validity |= SS2_SubscriberData_category_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SubscriberStatus( &pType->subscriberStatus, pContext);
            pType->validity |= SS2_SubscriberData_subscriberStatus_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_BearerServiceList( &pType->bearerServiceList, pContext);
            pType->validity |= SS2_SubscriberData_bearerServiceList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_TeleserviceList( &pType->teleserviceList, pContext);
            pType->validity |= SS2_SubscriberData_teleserviceList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 7;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Ext_SS_InfoList( &pType->provisionedSS, pContext);
            pType->validity |= SS2_SubscriberData_provisionedSS_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 8;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ODB_Data( &pType->odb_Data, pContext);
            pType->validity |= SS2_SubscriberData_odb_Data_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 9;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_SubscriberData_roamingRestrictionDueToUnsupportedFeature_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ZoneCodeList( &pType->regionalSubscriptionData, pContext);
            pType->validity |= SS2_SubscriberData_regionalSubscriptionData_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 11;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_VBSDataList( &pType->vbsSubscriptionData, pContext);
            pType->validity |= SS2_SubscriberData_vbsSubscriptionData_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 12;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_VGCSDataList( &pType->vgcsSubscriptionData, pContext);
            pType->validity |= SS2_SubscriberData_vgcsSubscriptionData_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 13;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_VlrCamelSubscriptionInfo( &pType->vlrCamelSubscriptionInfo, pContext);
            pType->validity |= SS2_SubscriberData_vlrCamelSubscriptionInfo_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

/* SEQUENCE InsertSubscriberDataArg Ber decoder */
extern U32 AsnDecode_SS2_InsertSubscriberDataArg( SS2_InsertSubscriberDataArg **ppType, U8 *pEncoded, U32 *pEncodedLength, void *pAppContext, applib2_AsnCustomMemFunctions *pMemFuncs )
{
applib2_AsnContext decodeAsnContext, *pContext = &decodeAsnContext;
SS2_InsertSubscriberDataArg *pType;

   pContext->decodeAlloc = NULL;

   pContext->pAppContext = pAppContext;
   if (pMemFuncs != NULL)
   {
      pContext->pMemAllocFunc = pMemFuncs->pMemAllocFunc;
      pContext->pMemFreeFunc = pMemFuncs->pMemFreeFunc;
   }
   else
   {
      pContext->pMemAllocFunc = NULL;
      pContext->pMemFreeFunc = NULL;
   };

   if( setjmp( pContext->env ) )
   {
      /* A decode exception has occurred - free any allocated memory */
      applib2_AsnDecodeFree( pContext->decodeAlloc,  pContext->pMemFreeFunc );

      return pContext->result? pContext->result : 1;
   }

   applib2_AsnRootDecodeAlloc( pContext, (void **)ppType, sizeof( SS2_InsertSubscriberDataArg ) );

   if(0==*pEncodedLength){
      return 0;
   }

   pType = *ppType;

   applib2_initFifo( pContext, pEncoded, ( ( *pEncodedLength + 7 ) / 8 ) );

   
   pType->validity = 0;
   
   
   {
      BER_TLV		seq_tlv;
      int length = 0 , templen=0;
      get_tl(pContext, &seq_tlv);
      length = seq_tlv.l.length;
      templen = length;
      ((void)templen);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 0;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_IMSI( &pType->imsi, pContext);
            pType->validity |= SS2_InsertSubscriberDataArg_imsi_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 1;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ISDN_AddressString( &pType->msisdn, pContext);
            pType->validity |= SS2_InsertSubscriberDataArg_msisdn_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 2;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Category( &pType->category, pContext);
            pType->validity |= SS2_InsertSubscriberDataArg_category_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 3;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SubscriberStatus( &pType->subscriberStatus, pContext);
            pType->validity |= SS2_InsertSubscriberDataArg_subscriberStatus_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 4;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_BearerServiceList( &pType->bearerServiceList, pContext);
            pType->validity |= SS2_InsertSubscriberDataArg_bearerServiceList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 6;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_TeleserviceList( &pType->teleserviceList, pContext);
            pType->validity |= SS2_InsertSubscriberDataArg_teleserviceList_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 7;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_Ext_SS_InfoList( &pType->provisionedSS, pContext);
            pType->validity |= SS2_InsertSubscriberDataArg_provisionedSS_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 8;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ODB_Data( &pType->odb_Data, pContext);
            pType->validity |= SS2_InsertSubscriberDataArg_odb_Data_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 9;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_InsertSubscriberDataArg_roamingRestrictionDueToUnsupportedFeature_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 10;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ZoneCodeList( &pType->regionalSubscriptionData, pContext);
            pType->validity |= SS2_InsertSubscriberDataArg_regionalSubscriptionData_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 11;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_VBSDataList( &pType->vbsSubscriptionData, pContext);
            pType->validity |= SS2_InsertSubscriberDataArg_vbsSubscriptionData_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 12;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_VGCSDataList( &pType->vgcsSubscriptionData, pContext);
            pType->validity |= SS2_InsertSubscriberDataArg_vgcsSubscriptionData_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 13;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_VlrCamelSubscriptionInfo( &pType->vlrCamelSubscriptionInfo, pContext);
            pType->validity |= SS2_InsertSubscriberDataArg_vlrCamelSubscriptionInfo_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 14;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ExtensionContainer( &pType->extensionContainer, pContext);
            pType->validity |= SS2_InsertSubscriberDataArg_extensionContainer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 15;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_NAEA_PreferredCI( &pType->naea_PreferredCI, pContext);
            pType->validity |= SS2_InsertSubscriberDataArg_naea_PreferredCI_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 16;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_GPRSSubscriptionData( &pType->gprsSubscriptionData, pContext);
            pType->validity |= SS2_InsertSubscriberDataArg_gprsSubscriptionData_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 23;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_InsertSubscriberDataArg_roamingRestrictedInSgsnDueToUnsupportedFeature_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 24;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_NetworkAccessMode( &pType->networkAccessMode, pContext);
            pType->validity |= SS2_InsertSubscriberDataArg_networkAccessMode_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 25;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LSAInformation( &pType->lsaInformation, pContext);
            pType->validity |= SS2_InsertSubscriberDataArg_lsaInformation_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 21;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            {
               BER_TLV tlv; 
               get_tl( pContext, &tlv ); 
               /* without value */ 
            }
            pType->validity |= SS2_InsertSubscriberDataArg_lmu_Indicator_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 22;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_LCSInformation( &pType->lcsInformation, pContext);
            pType->validity |= SS2_InsertSubscriberDataArg_lcsInformation_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 26;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            pType->istAlertTimer = (U8)ber_get_integer( pContext ); 
            pType->validity |= SS2_InsertSubscriberDataArg_istAlertTimer_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 27;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_AgeIndicator( &pType->superChargerSupportedInHLR, pContext);
            pType->validity |= SS2_InsertSubscriberDataArg_superChargerSupportedInHLR_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 28;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_MC_SS_Info( &pType->mc_SS_Info, pContext);
            pType->validity |= SS2_InsertSubscriberDataArg_mc_SS_Info_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 29;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_CS_AllocationRetentionPriority( &pType->cs_AllocationRetentionPriority, pContext);
            pType->validity |= SS2_InsertSubscriberDataArg_cs_AllocationRetentionPriority_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 17;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_SGSN_CAMEL_SubscriptionInfo( &pType->sgsn_CAMEL_SubscriptionInfo, pContext);
            pType->validity |= SS2_InsertSubscriberDataArg_sgsn_CAMEL_SubscriptionInfo_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 18;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_ChargingCharacteristics( &pType->chargingCharacteristics, pContext);
            pType->validity |= SS2_InsertSubscriberDataArg_chargingCharacteristics_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   
   do{
      BER_TAG   std_tag, pdu_tag;
      templen = (U32)pContext->pEncoded;
      
      if(seq_tlv.l.is_defined == TRUE && length <=0)
      {
         break;
      }
      std_tag.cl = ContextSpecific;
      std_tag.tag = 19;
      pre_get_t(pContext, &pdu_tag);
      
      if(ber_tag_cmp(std_tag, pdu_tag))
      {
         {
            BER_TAG tag;
            tag.is_tagged = TRUE;
            ((void)tag);

            AsnDecode_SS2_AccessRestrictionData( &pType->accessRestrictionData, pContext);
            pType->validity |= SS2_InsertSubscriberDataArg_accessRestrictionData_valid;
            templen =  (U32)pContext->pEncoded - templen;
            length  -= templen >0 ? templen : -templen;
         }
      }
   }while(0);
   }

   *pEncodedLength = ( ( pContext->pEncoded - pEncoded ) * 8 ) - pContext->shiftRegisterLength;

   ((void)pType);
   return 0;
}

#endif //__AGPS_CONTROL_PLANE__
